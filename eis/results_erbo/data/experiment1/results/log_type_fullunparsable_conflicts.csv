/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java;<<<<<<< MINE
                    +" or make serializer extend 'com.fasterxml.jackson.databind.ser.std.SerializerBase'"); 
=======
                    +" or make serializer extend 'com.fasterxml.jackson.databind.ser.std.StdSerializer'"); 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
                if (t.isArrayType()) {
=======
                while (t.isArrayType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
                if (t.isArrayType()) {
=======
                while (t.isArrayType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE

            JavaType propType = prop.getSerializationType();
            BeanSerializerBase.depositSchemaProperty(prop, objectVisitor);
=======
            if (filter != null) {
            	filter.depositSchemaProperty(prop, propertiesNode, provider);
            	 continue;
            }
            depositSchemaProperty(prop, propertiesNode, provider);

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
    	if (visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {
    		visitor.expectIntegerFormat(typeHint);
    	} else {
    		JsonStringFormatVisitor stringVisitor = visitor.expectStringFormat(typeHint);
    		if (typeHint != null) {
    			if (typeHint.isEnumType()) {
    				Set<String> enums = new HashSet<String>();
    				for (SerializedString value : _values.values()) {
    					enums.add(value.getValue());
    				}
    				stringVisitor.enumTypes(enums);
    			}
    		}
    	}
=======
        if (_serializeAsIndex(provider)) {
            return createSchemaNode("integer", true);
        }
        ObjectNode objectNode = createSchemaNode("string", true);
        if (typeHint != null) {
            JavaType type = provider.constructType(typeHint);
            if (type.isEnumType()) {
                ArrayNode enumNode = objectNode.putArray("enum");
                for (SerializedString value : _values.values()) {
                    enumNode.add(value.getValue());
                }
            }
        }
        return objectNode;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            jgen.writeBinary(value);
=======
            jgen.writeBinary(provider.getConfig().getBase64Variant(),
                    value, 0, value.length);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            jgen.writeBinary(value);
=======
            jgen.writeBinary(provider.getConfig().getBase64Variant(),
                    value, 0, value.length);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java;<<<<<<< MINE
        jg.writeBinary(_data);
=======
        jg.writeBinary(provider.getConfig().getBase64Variant(),
                _data, 0, _data.length);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
    /* Extended ObjectNode API, mutators, generic
=======
    /* Extended ObjectNode API, mutators, since 2.1
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * Method that will set specified field, replacing old value,
     * if any.
=======
     * Method that will set specified field, replacing old value, if any.
     * Note that this is identical to {@link #replace(String, JsonNode)},
     * except for return value.
     *<p>
     * NOTE: added to replace those uses of {@link #put(String, JsonNode)}
     * where chaining with 'this' is desired.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This ObjectNode after removing entries
=======
     * @return This node after removing entries
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This ObjectNode after removing all entries
=======
     * @return This node after removing all entries
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This node (to allow chaining)
=======
     * @return This node after adding/replacing property values (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
    public JsonNode putAll(Map<String,JsonNode> properties)
    {
        if (_children == null) {
            _children = new LinkedHashMap<String, JsonNode>(properties);
        } else {
            for (Map.Entry<String, JsonNode> en : properties.entrySet()) {
                JsonNode n = en.getValue();
                if (n == null) {
                    n = nullNode();
                }
                _children.put(en.getKey(), n);
            }
        }
        return this;
=======
    public JsonNode putAll(Map<String,JsonNode> properties) {
        return setAll(properties);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
    public JsonNode putAll(ObjectNode other)
    {
        int len = other.size();
        if (len > 0) {
            if (_children == null) {
                _children = new LinkedHashMap<String, JsonNode>(len);
            }
            other.putContentsTo(_children);
        }
        return this;
=======
    public JsonNode putAll(ObjectNode other) {
        return setAll(other);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This ObjectNode (to allow call chaining)
=======
     * @return This node (to allow call chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This ObjectNode (to allow call chaining)
=======
     * @return This node (to allow call chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
            Locale locale, TimeZone tz)
=======
            Locale locale, TimeZone tz, Base64Variant defaultBase64)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                typer, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                typer, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, df, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, hi, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, hi, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, df, _handlerInstantiator, _locale, tz);
=======
                _typeResolverBuilder, df, _handlerInstantiator, _locale,
                tz, _defaultBase64);
    }

    /**
     * @since 2.1
     */
    public BaseSettings with(Base64Variant base64) {
        if (base64 == _defaultBase64) {
            return this;
        }
        return new BaseSettings(_classIntrospector, _annotationIntrospector,
                _visibilityChecker, _propertyNamingStrategy, _typeFactory,
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, base64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java;<<<<<<< MINE
     * Explicitly definite root name to use, if any; if empty
=======
     * Explicitly defined root name to use, if any; if empty
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
            TimeZone.getTimeZone("GMT")
=======
            TimeZone.getTimeZone("GMT"),
            Base64Variants.getDefaultVariant() // 2.1
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader with(DeserializationFeature feature) 
    {
        DeserializationConfig newConfig = _config.with(feature);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
    public ObjectReader with(DeserializationFeature feature) {
        return _with(_config.with(feature));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.with(first, other);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
        return _with(_config.with(first, other));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader withFeatures(DeserializationFeature... features)
    {
        DeserializationConfig newConfig = _config.withFeatures(features);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
    public ObjectReader withFeatures(DeserializationFeature... features) {
        return _with(_config.withFeatures(features));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader without(DeserializationFeature feature) 
    {
        DeserializationConfig newConfig = _config.without(feature);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
    public ObjectReader without(DeserializationFeature feature) {
        return _with(_config.without(feature)); 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.without(first, other);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
        return _with(_config.without(first, other));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader withoutFeatures(DeserializationFeature... features)
    {
        DeserializationConfig newConfig = _config.withoutFeatures(features);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
    public ObjectReader withoutFeatures(DeserializationFeature... features) {
        return _with(_config.withoutFeatures(features));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader with(JsonNodeFactory f)
    {
        DeserializationConfig newConfig = _config.with(f);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
    public ObjectReader with(JsonNodeFactory f) {
        return _with(_config.with(f));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader withRootName(String rootName)
    {
        DeserializationConfig newConfig = _config.withRootName(rootName);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
    public ObjectReader withRootName(String rootName) {
        return _with(_config.withRootName(rootName));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.withView(activeView);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
        return _with(_config.withView(activeView));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.with(l);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
        return _with(_config.with(l));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.with(tz);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
        return _with(_config.with(tz));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.withHandler(h);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
        return _with(_config.withHandler(h));
    }

    public ObjectReader with(Base64Variant defaultBase64) {
        return _with(_config.with(defaultBase64));
    }

    protected ObjectReader _with(DeserializationConfig newConfig) {
        if (newConfig == _config) return this;
        return new ObjectReader(this, newConfig);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        n.put("a", text);
=======
        n.set("a", text);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        n.putAll(n2);
=======
        n.setAll(n2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        n.put("null", (JsonNode)null);
=======
        n.set("null", (JsonNode)null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        n.putAll(nodes);
=======
        n.setAll(nodes);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        o1.putAll(o2);
=======
        o1.setAll(o2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        o1.put("x", (ObjectNode) null);
=======
        o1.set("x", null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        dest.putAll(src);
=======
        dest.setAll(src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        assertSame(ob, ob.remove(Arrays.asList("a", "c")));
=======
        assertSame(ob, ob.without(Arrays.asList("a", "c")));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java;<<<<<<< MINE
        n1.put("x", TextNode.valueOf("Test"));
=======
        n1.set("x", TextNode.valueOf("Test"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java;<<<<<<< MINE
        n2.put("x", TextNode.valueOf("Test"));
=======
        n2.set("x", TextNode.valueOf("Test"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java;<<<<<<< MINE
        n.put("pojo", mapper.getNodeFactory().POJONode("abc"));
=======
        n.set("pojo", mapper.getNodeFactory().POJONode("abc"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java;<<<<<<< MINE
        n.put("pojo", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));
=======
        n.set("pojo", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java;<<<<<<< MINE
        n.put("pojo", mapper.getNodeFactory().POJONode(new Bean()));
=======
        n.set("pojo", mapper.getNodeFactory().POJONode(new Bean()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("true", serializeAsString(mapper, Boolean.TRUE));
        assertEquals("false", serializeAsString(mapper, Boolean.FALSE));
=======
        assertEquals("true", serializeAsString(MAPPER, Boolean.TRUE));
        assertEquals("false", serializeAsString(MAPPER, Boolean.FALSE));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("[true,false]", serializeAsString(mapper, new boolean[] { true, false} ));
        assertEquals("[true,false]", serializeAsString(mapper, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));
=======
        assertEquals("[true,false]", serializeAsString(MAPPER, new boolean[] { true, false} ));
        assertEquals("[true,false]", serializeAsString(MAPPER, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        String str1 = serializeAsString(mapper, data);
        String str2 = serializeAsString(mapper, data2);
        assertArrayEquals(data, mapper.readValue(str1, byte[].class));
        assertArrayEquals(data2, mapper.readValue(str2, Byte[].class));
=======
        String str1 = serializeAsString(MAPPER, data);
        String str2 = serializeAsString(MAPPER, data2);
        assertArrayEquals(data, MAPPER.readValue(str1, byte[].class));
        assertArrayEquals(data2, MAPPER.readValue(str2, Byte[].class));
    }

    // as per [Issue#42], allow Base64 variant use as well
    public void testBase64Variants() throws Exception
    {
        final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8");
        
        // default encoding is "MIME, no linefeeds", so:
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), MAPPER.writeValueAsString(INPUT));
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="),
                MAPPER.writer(Base64Variants.MIME_NO_LINEFEEDS).writeValueAsString(INPUT));

        // but others should be slightly different
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="),
                MAPPER.writer(Base64Variants.MIME).writeValueAsString(INPUT));
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"), // no padding or LF
                MAPPER.writer(Base64Variants.MODIFIED_FOR_URL).writeValueAsString(INPUT));
        // PEM mandates 64 char lines:
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="),
                MAPPER.writer(Base64Variants.PEM).writeValueAsString(INPUT));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("[0,1]", serializeAsString(mapper, new short[] { 0, 1 }));
        assertEquals("[2,3]", serializeAsString(mapper, new Short[] { 2, 3 }));
=======
        assertEquals("[0,1]", serializeAsString(MAPPER, new short[] { 0, 1 }));
        assertEquals("[2,3]", serializeAsString(MAPPER, new Short[] { 2, 3 }));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("[0,-3]", serializeAsString(mapper, new int[] { 0, -3 }));
        assertEquals("[13,9]", serializeAsString(mapper, new Integer[] { 13, 9 }));
=======
        assertEquals("[0,-3]", serializeAsString(MAPPER, new int[] { 0, -3 }));
        assertEquals("[13,9]", serializeAsString(MAPPER, new Integer[] { 13, 9 }));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
           assertEquals(expected,serializeAsString(mapper, Float.valueOf(f)));
=======
           assertEquals(expected,serializeAsString(MAPPER, Float.valueOf(f)));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
            assertEquals(expected,serializeAsString(mapper, Double.valueOf(d)));
=======
            assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
            assertEquals(expected,serializeAsString(mapper, value));
=======
            assertEquals(expected, MAPPER.writeValueAsString(value));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
    private static final long serialVersionUID = 612196544186875755L;

    /*
=======
    /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
	 */
=======
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
    /*
=======
    /*
    /**********************************************************
    /* Methods for sub-classes
    /**********************************************************
     */

    /**
     * Method called to determine whether property will be included
     * (if 'true' returned) or filtered out (if 'false' returned)
     */
    protected abstract boolean include(BeanPropertyWriter writer);

    public void serializeAsField(Object bean, JsonGenerator jgen,
            SerializerProvider provider, BeanPropertyWriter writer) throws Exception
    {
        if (include(writer)) {
            writer.serializeAsField(bean, jgen, provider);
        }
    }

    
    public void depositSchemaProperty(BeanPropertyWriter writer,
            ObjectNode propertiesNode, SerializerProvider provider)
        throws JsonMappingException
    {
        if (include(writer)) {
            writer.depositSchemaProperty(propertiesNode, provider);
        }
    }

    public void depositSchemaProperty(BeanPropertyWriter writer,
            JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)
        throws JsonMappingException
    {
        if (include(writer)) {
            writer.depositSchemaProperty(objectVisitor);
        }
    }
    
    /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f7ef407_8221fe1/rev_f7ef407-8221fe1/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java;<<<<<<< MINE
     * 
     * Feature is disabled by default
     * @since 2.4
=======
     * Feature is disabled by default.
     * 
     * @since 2.4
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
            TypeFactory tf = visitor.getProvider().getTypeFactory();
            JavaType contentType = tf.moreSpecificType(_elementType, typeHint.getContentType());
            if (contentType == null) {
                throw new JsonMappingException("Could not resolve type");
            }
=======
            /* 01-Sep-2014, tatu: Earlier was trying to make use of 'typeHint' for some
             *   reason, causing NPE (as per https://github.com/FasterXML/jackson-module-jsonSchema/issues/34)
             *   if coupled with `@JsonValue`. But I can't see much benefit of trying to rely
             *   on TypeHint here so code is simplified like so:
             */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
                valueSer = visitor.getProvider().findValueSerializer(contentType, _property);
=======
                valueSer = visitor.getProvider().findValueSerializer(_elementType, _property);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
            arrayVisitor.itemsFormat(valueSer, contentType);
=======
            arrayVisitor.itemsFormat(valueSer, _elementType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
            Class<?> serType = getRawSerializationType();
            if (serType == null) {
                serType = getPropertyType();
            }
            ser = provider.findValueSerializer(serType, this);
=======
            ser = provider.findValueSerializer(getType(), this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
                /* As per [Issue#305], need to provide contextual info. But for
=======
                /* As per [Databind#305], need to provide contextual info. But for
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
                    if (_defaultImpl == null) {
=======
                    deser = _findDefaultImplDeserializer(ctxt);
                    if (deser == null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
            if (_defaultImpl == null) {
=======
            deser = _findDefaultImplDeserializer(ctxt);
            if (deser == null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
 * Basic serializer that can take Json "Object" structure and
=======
 * Basic serializer that can take JSON "Object" structure and
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
            } catch(UnresolvedForwardReference reference) {
=======
            } catch (UnresolvedForwardReference reference) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
                        wrapAndThrow(e, _mapType.getRawClass());
=======
                        wrapAndThrow(e, _mapType.getRawClass(), propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
            Object value;            
            if (t == JsonToken.VALUE_NULL) {
                value = valueDes.getNullValue();
            } else if (typeDeser == null) {
                value = valueDes.deserialize(jp, ctxt);
            } else {
                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);
=======
            Object value; 

            try {
                if (t == JsonToken.VALUE_NULL) {
                    value = valueDes.getNullValue();
                } else if (typeDeser == null) {
                    value = valueDes.deserialize(jp, ctxt);
                } else {
                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);
                }
            } catch (Exception e) {
                wrapAndThrow(e, _mapType.getRawClass(), propName);
                return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
            wrapAndThrow(e, _mapType.getRawClass());
=======
            wrapAndThrow(e, _mapType.getRawClass(), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
    @Deprecated // since 2.5
    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {
        wrapAndThrow(t, ref, null);
=======
    @Deprecated // since 2.5
    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {
        wrapAndThrow(t, ref, null);
    }
    
    // note: copied from BeanDeserializer; should try to share somehow...
    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException
    {
        // to handle StackOverflow:
        while (t instanceof InvocationTargetException && t.getCause() != null) {
            t = t.getCause();
        }
        // Errors and "plain" IOExceptions to be passed as is
        if (t instanceof Error) {
            throw (Error) t;
        }
        // ... except for mapping exceptions
        if (t instanceof IOException && !(t instanceof JsonMappingException)) {
            throw (IOException) t;
        }
        throw JsonMappingException.wrapWithPath(t, ref, key);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                // [JACKSON-334]: may be missing milliseconds... if so, add
=======
                // Milliseconds partial or missing; and even seconds are optional
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                // '+0000' (5 chars); should come after '.000' (4 chars) of milliseconds, so:
                c = dateStr.charAt(len-9);
                if (Character.isDigit(c)) {
=======
                // remove 'T', '+'/'-' and 4-digit timezone-offset
                int timeLen = len - dateStr.lastIndexOf('T') - 6;
                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss
                    int offset = len - 5; // insertion offset, before tz-offset
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                    sb.insert(len-5, ".000");
=======
                    switch (timeLen) {
                    case 11:
                        sb.insert(offset, '0'); break;
                    case 10:
                        sb.insert(offset, "00"); break;
                    case 9: // is this legal? (just second fraction marker)
                        sb.insert(offset, "000"); break;
                    case 8:
                        sb.insert(offset, ".000"); break;
                    case 7: // not legal to have single-digit second
                        break;
                    case 6: // probably not legal, but let's allow
                        sb.insert(offset, "00.000");
                    case 5: // is legal to omit seconds
                        sb.insert(offset, ":00.000");
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                if (timeLen <= 8) {
                    sb.append(".000");
=======
                if (timeLen < 12) { // missing, or partial
                    switch (timeLen) {
                    case 11: sb.append('0');
                    case 10: sb.append('0');
                    case 9: sb.append('0');
                        break;
                    default:
                        sb.append(".000");
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java;<<<<<<< MINE
        return new ObjectIdInfo(_propertyName, _scope, _generator, state);
=======
        return new ObjectIdInfo(_propertyName, _scope, _generator, state, _resolver);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
            if ("true".equals(_value.trim())) {
=======
            String v = _value.trim();
            if ("true".equals(v)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                        if (typeParams != null) {
=======
                        if (typeParams != null && typeParams.length > i) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java;<<<<<<< MINE
     * Feature is enabled by default.
=======
     * Feature is disabled by default.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java;<<<<<<< MINE
        //    for #338 I thinl
=======
        //    for #338 I think
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java;<<<<<<< MINE
 * Unit tests related to [JACKSON-712]; specialized handling of
=======
 * Unit tests related to specialized handling of
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java;<<<<<<< MINE
    // [Issue#148]
=======
    // [Databind#148]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java;<<<<<<< MINE
    // [Issue#148]
=======
    // [Databind#148]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_655d2a1_edf8674/rev_655d2a1-edf8674/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2a2ae59_d7a94ed/rev_2a2ae59-d7a94ed/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
            throw new IllegalStateException("Could not resolve Object Id ["+id+"] -- unresolved forward-reference?");
=======
            throw new UnresolvedForwardReference("Could not resolve Object Id ["+id+"] -- unresolved forward-reference?", jp.getCurrentLocation(), roid);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
 * Unit tests for verifying "old" data binding from JSON to JDK objects;
=======
 * Unit tests for verifying "raw" (or "untyped") data binding from JSON to JDK objects;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
        public String deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException
        {
=======
        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
        public Number deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException
        {
=======
        public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
    @SuppressWarnings("serial")
=======
    // Let's make this Contextual, to tease out cyclic resolution issues, if any
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java;<<<<<<< MINE
        if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) {
=======
        Class<?> rawValueType = valueType.getRawClass();
        if ((rawBuildType != rawValueType)
                && !rawBuildType.isAssignableFrom(rawValueType)
                && !rawValueType.isAssignableFrom(rawBuildType)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java;<<<<<<< MINE
    	String json = "{\"x\":1,\"y\":2}";
    	Object o = mapper.readValue(json, ValueClassXY.class);
    	assertNotNull(o);
    	assertSame(ValueClassXY.class, o.getClass());
    	ValueClassXY value = (ValueClassXY) o;
    	// note: ctor adds one to both values
    	assertEquals(value._x, 2);
    	assertEquals(value._y, 3);
=======
        String json = "{\"x\":1,\"y\":2}";
        Object o = mapper.readValue(json, ValueClassXY.class);
        assertNotNull(o);
    	    assertSame(ValueClassXY.class, o.getClass());
    	    ValueClassXY value = (ValueClassXY) o;
    	    // note: ctor adds one to both values
    	    assertEquals(value._x, 2);
    	    assertEquals(value._y, 3);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java;<<<<<<< MINE
    	String json = "{\"c\":3,\"a\":2,\"b\":-9}";
    	ValueClassABC value = mapper.readValue(json, ValueClassABC.class);
    	assertNotNull(value);
    	// note: ctor adds one to both values
    	assertEquals(value.a, 2);
    	assertEquals(value.b, -9);
    	assertEquals(value.c, 3);
=======
        String json = "{\"c\":3,\"a\":2,\"b\":-9}";
        ValueClassABC value = mapper.readValue(json, ValueClassABC.class);
        assertNotNull(value);
    	    // note: ctor adds one to both values
        assertEquals(value.a, 2);
        assertEquals(value.b, -9);
        assertEquals(value.c, 3);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_54b2a5f_7d5c50b/rev_54b2a5f-7d5c50b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
        if (typeHint != null && stringVisitor != null) {
=======
        if (stringVisitor != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
     * values for creator method need to be buffered, first; and 
=======
     * values for creator method need to be buffered, first; and
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            handleUnknownProperty(p, ctxt, bean, propName);         
=======
            handleUnknownProperty(p, ctxt, bean, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6172d75_726b6e0/rev_6172d75-726b6e0/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    protected Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt,
            SettableBeanProperty prop)
        throws IOException
    {
=======
    protected Object deserializeWithErrorWrapping(SettableBeanProperty prop,
            JsonParser p, DeserializationContext ctxt, String propName) throws IOException
    {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6172d75_726b6e0/rev_6172d75-726b6e0/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            return prop.deserialize(p, ctxt);
        } catch (Exception e) {
            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);
            // never gets here, unless caller returns
            return null;
=======
            return prop.deserialize(p, ctxt);
        } catch (IOException e) {
            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
            // exception below will be throw only if someone overwrite default implementation of wrapAndThrow method
            throw e;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e5b8ff1_5183922/rev_e5b8ff1-5183922/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
        return new MappingJsonFactory(null);
=======
        return new MappingJsonFactory(this, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);
        }
        Class<?> enumClass = type.getRawClass();
        // 23-Nov-2010, tatu: Custom deserializer?
        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);
        if (custom != null) {
            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);
=======
            return des;
        } else {
            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.
            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);
            if (custom != null) {
                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);
            }
            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());
            if (valueDesForKey != null) {
                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6c1badb_795dd01/rev_6c1badb-795dd01/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
                throw new NumberFormatException("Invalid number: " + value);
=======
                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6c1badb_795dd01/rev_6c1badb-795dd01/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
                throw new NumberFormatException("Invalid number: " + value);
=======
                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f75f2bf_660ec8f/rev_f75f2bf-660ec8f/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
            return PropertyName.construct(jg.value());
        }
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            return PropertyName.construct(pann.value());
        }
        PropertyName ctorName = _findConstructorName(a);
        if (ctorName != null) {
            return ctorName;
        }
        if (_hasAnnotation(a, JsonSerialize.class)
                || _hasAnnotation(a, JsonView.class)
                || _hasAnnotation(a, JsonRawValue.class)) {
            return PropertyName.USE_DEFAULT;
=======
            name = jg.value();
        } else {
            JsonProperty pann = _findAnnotation(a, JsonProperty.class);
            if (pann != null) {
                name = pann.value();
                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but
                 *   it's actually bit tricky to do it more efficiently (meta-annotations
                 *   add more lookups; AnnotationMap costs etc)
                 */
            } else if (_hasAnnotation(a, JsonSerialize.class)
                    || _hasAnnotation(a, JsonView.class)
                    || _hasAnnotation(a, JsonRawValue.class)
                    || _hasAnnotation(a, JsonUnwrapped.class)
                    || _hasAnnotation(a, JsonBackReference.class)
                    || _hasAnnotation(a, JsonManagedReference.class)) {
                name = "";
            } else {
                return null;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    // [JACKSON-799]
    public void testSerializeAsInClass() throws IOException
    {
=======
    public void testSerializeAsInClass() throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    public void testSerializeAsForArrayProp() throws IOException
    {
        assertEquals("{\"foos\":[{\"foo\":42}]}", WRITER.writeValueAsString(new Fooables()));
=======
    public void testSerializeAsForArrayProp() throws IOException {
        assertEquals("{\"foos\":[{\"foo\":42}]}",
                WRITER.writeValueAsString(new Fooables()));
    }

    public void testSerializeAsForSimpleProp() throws IOException {
        assertEquals("{\"foo\":{\"foo\":42}}",
                WRITER.writeValueAsString(new FooableWrapper()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    public void testSerializeAsForSimpleProp() throws IOException
    {
        assertEquals("{\"foo\":{\"foo\":42}}", WRITER.writeValueAsString(new FooableWrapper()));
=======
    public void testSerializeWithFieldAnno() throws IOException {
        assertEquals("{\"foo\":{\"foo\":42}}",
                WRITER.writeValueAsString(new FooableWithFieldWrapper()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);
=======
                _addClassMixIns(ca, _class, _primaryMixIn);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            _addAnnotationsIfNotPresent(ca,
                    ClassUtil.findClassAnnotations(_class));
=======
            _addAnnotationsIfNotPresent(ca, _class.getDeclaredAnnotations());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                _addClassMixIns(ca, type);
                _addAnnotationsIfNotPresent(ca,
                        ClassUtil.findClassAnnotations(type.getRawClass()));
=======
                _addClassMixIns(ca, cls);
                _addAnnotationsIfNotPresent(ca, cls.getDeclaredAnnotations());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            _addClassMixIns(_classAnnotations, Object.class);
=======
            _addClassMixIns(ca, Object.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return ca;
=======
        _classAnnotations = ca;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_290f9a6_386e9f7/rev_290f9a6-386e9f7/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
    public void serialize(java.sql.Time value, JsonGenerator jgen, SerializerProvider provider) throws IOException
=======
    public void serialize(java.sql.Time value, JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_290f9a6_386e9f7/rev_290f9a6-386e9f7/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
        jgen.writeString(value.toString());
=======
        g.writeString(value.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_290f9a6_386e9f7/rev_290f9a6-386e9f7/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
        DateSerializer dateSer = DateSerializer.instance;
        concrete.put(java.util.Date.class.getName(), dateSer);
        // note: timestamps are very similar to java.util.Date, thus serialized as such
        concrete.put(java.sql.Timestamp.class.getName(), dateSer);
        
        // leave some of less commonly used ones as lazy, no point in proactive construction
        concLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);
        concLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);
=======
        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
        _concrete.put(java.util.Date.class.getName(), DateSerializer.instance);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_db9584c_89559a2/rev_db9584c-89559a2/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
            if ((v2 == null) || comparator.compare(entry.getValue(), v2) != 0) {
=======
            if ((v2 == null) || !entry.getValue().equals(comparator, v2)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_db9584c_89559a2/rev_db9584c-89559a2/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java;<<<<<<< MINE
            if (comparator.compare(l1.get(i), l2.get(i)) != 0) {
=======
            if (!l1.get(i).equals(comparator, l2.get(i))) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java;<<<<<<< MINE
        // [Issue#124]: May have a content converter
=======
        // [databind#124]: May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java;<<<<<<< MINE
            if ((_valueTypeIsStatic && _valueType.getRawClass() != Object.class)
                    || hasContentTypeAnnotation(provider, property)) {
=======
            if (_valueTypeIsStatic && !_valueType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java;<<<<<<< MINE
    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException
=======
    public void serialize(Object value, JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java;<<<<<<< MINE
        throw new JsonGenerationException(_msg);
=======
        throw new JsonGenerationException(_msg, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java;<<<<<<< MINE
            throw new JsonMappingException("Unwrapped property requires use of type information: can not serialize without disabling `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS`");
=======
            throw JsonMappingException.from(gen,
                    "Unwrapped property requires use of type information: can not serialize without disabling `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS`");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/AttributePropertyWriter.java;<<<<<<< MINE
            JsonInclude.Include inclusion)
=======
            JsonInclude.Value inclusion)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
            writer.depositSchemaProperty(objectVisitor);
=======
            writer.depositSchemaProperty(objectVisitor, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
            writer.depositSchemaProperty(objectVisitor);
=======
            writer.depositSchemaProperty(objectVisitor, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java;<<<<<<< MINE
            failForEmpty(value);
=======
            failForEmpty(gen, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java;<<<<<<< MINE
            failForEmpty(value);
=======
            failForEmpty(gen, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java;<<<<<<< MINE
    protected void failForEmpty(Object value) throws JsonMappingException
    {
        throw new JsonMappingException("No serializer found for class "+value.getClass().getName()+" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )");
=======
    protected void failForEmpty(JsonGenerator gen, Object value) throws JsonMappingException {
        throw JsonMappingException.from(gen,
                "No serializer found for class "+value.getClass().getName()+" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java;<<<<<<< MINE
        if (visitor != null) {
            JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
            if (v2 != null) {
                v2.itemsFormat(JsonFormatTypes.STRING);
            }
        }
=======
        visitArrayFormat(visitor, typeHint, JsonFormatTypes.STRING);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java;<<<<<<< MINE
    public void depositSchemaProperty(final JsonObjectFormatVisitor visitor)
            throws JsonMappingException {
        SerializerProvider provider = visitor.getProvider();
=======
    public void depositSchemaProperty(final JsonObjectFormatVisitor visitor,
            SerializerProvider provider) throws JsonMappingException
    {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java;<<<<<<< MINE
            super.depositSchemaProperty(visitor);
=======
            super.depositSchemaProperty(visitor, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
                // 20-Aug-2013, tatu: Need to avoid trying to access serializer for java.lang.Object tho
                if ((_staticTyping && _elementType.getRawClass() != Object.class)
                        || hasContentTypeAnnotation(provider, property)) {
=======
                if (_staticTyping && !_elementType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
        JsonArrayFormatVisitor arrayVisitor = (visitor == null) ? null : visitor.expectArrayFormat(typeHint);
        if (arrayVisitor != null) {
            /* 01-Sep-2014, tatu: Earlier was trying to make use of 'typeHint' for some
             *   reason, causing NPE (as per https://github.com/FasterXML/jackson-module-jsonSchema/issues/34)
             *   if coupled with `@JsonValue`. But I can't see much benefit of trying to rely
             *   on TypeHint here so code is simplified like so:
             */
            JsonSerializer<?> valueSer = _elementSerializer;
            if (valueSer == null) {
                valueSer = visitor.getProvider().findValueSerializer(_elementType, _property);
            }
            arrayVisitor.itemsFormat(valueSer, _elementType);
=======
        JsonSerializer<?> valueSer = _elementSerializer;
        if (valueSer == null) {
            valueSer = visitor.getProvider().findValueSerializer(_elementType, _property);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java;<<<<<<< MINE
                if (_staticTyping || hasContentTypeAnnotation(provider, property)) {
=======
                if (_staticTyping && !_elementType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java;<<<<<<< MINE
                throw new JsonMappingException("Could not resolve type");
=======
                throw JsonMappingException.from(visitor.getProvider(), "Could not resolve type");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
 * Container class for serializers used for handling standard JDK-provided types.
=======
 * Container class for serializers used for handling standard JDK-provided
 * types.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers)
    {
=======
    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        implements ContextualSerializer
    {
        protected final static Integer EMPTY_INTEGER = Integer.valueOf(0);

=======
            implements ContextualSerializer {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        protected Base(Class<?> cls, JsonParser.NumberType numberType, String schemaType) {
=======
        protected Base(Class<?> cls, JsonParser.NumberType numberType,
                String schemaType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                    || (numberType == JsonParser.NumberType.BIG_INTEGER)
                    ;
=======
                    || (numberType == JsonParser.NumberType.BIG_INTEGER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
=======
        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor,
                JavaType typeHint) throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
                if (v2 != null) {
                    v2.numberType(_numberType);
                }
=======
                visitIntFormat(visitor, typeHint, _numberType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);
                if (v2 != null) {
                    v2.numberType(_numberType);
                }
=======
                visitFloatFormat(visitor, typeHint, _numberType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                BeanProperty property) throws JsonMappingException
        {
=======
                BeanProperty property) throws JsonMappingException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    /**********************************************************
    /* Concrete serializers, numerics
    /**********************************************************
=======
     * /********************************************************** /* Concrete
     * serializers, numerics
     * /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, "number"); }

        @Override
        public boolean isEmpty(SerializerProvider prov, Short value) {
            return EMPTY.equals(value);
=======
        public ShortSerializer() {
            super(Short.class, JsonParser.NumberType.INT, "number");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {
            gen.writeNumber(value.shortValue());
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
            gen.writeNumber(((Short) value).shortValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
     *<p>
     * Since this is one of "native" types, no type information is ever
     * included on serialization (unlike for most scalar types)
     *<p>
=======
     * <p>
     * Since this is one of "native" types, no type information is ever included
     * on serialization (unlike for most scalar types)
     * <p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                SerializerProvider provider, TypeSerializer typeSer) throws IOException {
=======
                SerializerProvider provider, TypeSerializer typeSer)
                throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
            serialize(value, gen, provider);            
        }

        @Override
        public boolean isEmpty(SerializerProvider prov, Object value) {
            return EMPTY_INTEGER.equals(value);
=======
            serialize(value, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
     * instead, cast is to {@link java.lang.Number}, and conversion is
     * by calling {@link java.lang.Number#intValue}.
=======
     * instead, cast is to {@link java.lang.Number}, and conversion is by
     * calling {@link java.lang.Number#intValue}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public boolean isEmpty(SerializerProvider prov, Number value) {
            return value.intValue() == 0;
        }

        @Override
        public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {
            gen.writeNumber(value.intValue());
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
            gen.writeNumber(((Number) value).intValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        @Override
        public boolean isEmpty(SerializerProvider prov, Object value) {
            return EMPTY.equals(value);
=======
        public LongSerializer() {
            super(Long.class, JsonParser.NumberType.LONG, "number");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, "number"); }

        @Override
        public boolean isEmpty(SerializerProvider prov, Object value) {
            return EMPTY.equals(value);
=======
        public FloatSerializer() {
            super(Float.class, JsonParser.NumberType.FLOAT, "number");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
     * This is the special serializer for regular {@link java.lang.Double}s
     * (and primitive doubles)
     *<p>
     * Since this is one of "native" types, no type information is ever
     * included on serialization (unlike for most scalar types as of 1.5)
=======
     * This is the special serializer for regular {@link java.lang.Double}s (and
     * primitive doubles)
     * <p>
     * Since this is one of "native" types, no type information is ever included
     * on serialization (unlike for most scalar types as of 1.5)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        @Override
        public boolean isEmpty(SerializerProvider prov, Object value) {
            return EMPTY.equals(value);
=======
        public DoubleSerializer() {
            super(Double.class, JsonParser.NumberType.DOUBLE, "number");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                SerializerProvider provider, TypeSerializer typeSer) throws IOException {
=======
                SerializerProvider provider, TypeSerializer typeSer)
                throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
            serialize(value, gen, provider);            
=======
            serialize(value, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
        		Boolean asNumber = (format.getShape() == JsonFormat.Shape.STRING) ? Boolean.FALSE : null;
                // If not, do we have a pattern?
                TimeZone tz = format.getTimeZone();
                if (format.hasPattern()) {
                    String pattern = format.getPattern();
                    final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();
=======
                if (format.getShape() == JsonFormat.Shape.STRING) {
                    TimeZone tz = format.getTimeZone();
                    final String pattern = format.hasPattern()
                                           ? format.getPattern()
                                           : StdDateFormat.DATE_FORMAT_STR_ISO8601;
                    final Locale loc = format.hasLocale()
                                       ? format.getLocale()
                                       : serializers.getLocale();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
                    return withFormat(asNumber, df);
                }
                // If not, do we at least have a custom timezone?
                if (tz != null) {
                    DateFormat df = serializers.getConfig().getDateFormat();
                    // one shortcut: with our custom format, can simplify handling a bit
                    if (df.getClass() == StdDateFormat.class) {
                        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();
                        df = StdDateFormat.getISO8601Format(tz, loc);
                    } else {
                        // otherwise need to clone, re-set timezone:
                        df = (DateFormat) df.clone();
                        df.setTimeZone(tz);
                    }
                    return withFormat(asNumber, df);
=======
                    return withFormat(Boolean.FALSE, df);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                v2.numberType(JsonParser.NumberType.LONG);
                v2.format(JsonValueFormat.UTC_MILLISEC);
            }
=======
            visitIntFormat(visitor, typeHint,
                    JsonParser.NumberType.LONG, JsonValueFormat.UTC_MILLISEC);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
            JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);
            if (v2 != null) {
                v2.format(JsonValueFormat.DATE_TIME);
            }
=======
            visitStringFormat(visitor, typeHint, JsonValueFormat.DATE_TIME);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    /* Helper methods for JSON Schema generation
=======
    /* Type introspection API, partial/default implementation
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    public JsonNode getSchema(SerializerProvider provider, Type typeHint)
        throws JsonMappingException
=======
    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    	ObjectNode schema = (ObjectNode) getSchema(provider, typeHint);
    	if (!isOptional) {
    		schema.put("required", !isOptional);
    	}
=======
        ObjectNode schema = (ObjectNode) getSchema(provider, typeHint);
        if (!isOptional) {
    		    schema.put("required", !isOptional);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
     * Default implementation specifies no format. This behavior is usually
     * overriden by custom serializers.
=======
     * Helper method that calls necessary visit method(s) to indicate that the
     * underlying JSON type is a floating-point JSON number.
     *
     * @since 2.7
     */
    protected void visitFloatFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            NumberType numberType)
        throws JsonMappingException
    {
        if (visitor != null) {
            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);
            if (v2 != null) {
                v2.numberType(numberType);
            }
        }
    }

    /**
     * @since 2.7
     */
    protected void visitArrayFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            JsonSerializer<?> itemSerializer, JavaType itemType)
        throws JsonMappingException
    {
        if (visitor != null) {
            JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
            if (v2 != null) {
                if (itemSerializer != null) {
                    v2.itemsFormat(itemSerializer, itemType);
                }
            }
        }
    }

    /**
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    @Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
=======
    protected void visitArrayFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            JsonFormatTypes itemType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
        visitor.expectAnyFormat(typeHint);
=======
        if (visitor != null) {
            JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
            if (v2 != null) {
                v2.itemsFormat(itemType);
            }
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
        // [JACKSON-55] Need to add reference information
=======
        // Need to add reference information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
        // [JACKSON-55] Need to add reference information
=======
        // Need to add reference information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
                    if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) {
=======
                    if ((existingSerializer == null) && !delegateType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
            throw new JsonMappingException("Can not resolve PropertyFilter with id '"+filterId+"'; no FilterProvider configured");
=======
            throw JsonMappingException.from(provider,
                    "Can not resolve PropertyFilter with id '"+filterId+"'; no FilterProvider configured");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
    public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException
=======
    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber((BigDecimal) value);
=======
            g.writeNumber((BigDecimal) value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber((BigInteger) value);
=======
            g.writeNumber((BigInteger) value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
        /* These shouldn't match (as there are more specific ones),
         * but just to be sure:
         */
        } else if (value instanceof Integer) {
            jgen.writeNumber(value.intValue());
=======
        // These should not occur, as more specific methods should have been called; but
        // just in case let's cover all bases:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber(value.longValue());
=======
            g.writeNumber(value.longValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber(value.doubleValue());
=======
            g.writeNumber(value.doubleValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber(value.floatValue());
        } else if ((value instanceof Byte) || (value instanceof Short)) {
            jgen.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers
=======
            g.writeNumber(value.floatValue());
        } else if (value instanceof Integer || value instanceof Byte || value instanceof Short) {
            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber(value.toString());
=======
            g.writeNumber(value.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                v2.numberType(JsonParser.NumberType.BIG_INTEGER);
            }
=======
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);
            if (v2 != null) {
                Class<?> h = handledType();
                if (h == BigDecimal.class) {
                    v2.numberType(JsonParser.NumberType.BIG_DECIMAL);
                } // otherwise it's for Number... anything we could do there?
=======
            Class<?> h = handledType();
            if (h == BigDecimal.class) {
                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);
            } else {
                // otherwise bit unclear what to call... but let's try:
                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
    public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider)
=======
    public void serialize(byte[] value, JsonGenerator g, SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
        jgen.writeBinary(provider.getConfig().getBase64Variant(),
=======
        g.writeBinary(provider.getConfig().getBase64Variant(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
    public void serializeWithType(byte[] value, JsonGenerator jgen, SerializerProvider provider,
=======
    public void serializeWithType(byte[] value, JsonGenerator g, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
        typeSer.writeTypePrefixForScalar(value, jgen);
        jgen.writeBinary(provider.getConfig().getBase64Variant(),
=======
        typeSer.writeTypePrefixForScalar(value, g);
        g.writeBinary(provider.getConfig().getBase64Variant(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
        typeSer.writeTypeSuffixForScalar(value, jgen);
=======
        typeSer.writeTypeSuffixForScalar(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
        if (visitor != null) {
            JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
            if (v2 != null) {
                v2.itemsFormat(JsonFormatTypes.STRING);
            }
        }
=======
        // while logically (and within JVM) binary, gets encoded as Base64 String
        visitArrayFormat(visitor, typeHint, JsonFormatTypes.STRING);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
        JsonStringFormatVisitor v2 = (visitor == null) ? null : visitor.expectStringFormat(typeHint);
        if (v2 != null) {
            v2.format(JsonValueFormat.DATE_TIME);
        }
=======
        visitStringFormat(visitor, typeHint, JsonValueFormat.DATE_TIME);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java;<<<<<<< MINE
        visitor.expectStringFormat(typeHint);
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java;<<<<<<< MINE
    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,
=======
    public void serializeWithType(T value, JsonGenerator g, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java;<<<<<<< MINE
        typeSer.writeTypePrefixForScalar(value, jgen);
        serialize(value, jgen, provider);
        typeSer.writeTypeSuffixForScalar(value, jgen);
=======
        typeSer.writeTypePrefixForScalar(value, g);
        serialize(value, g, provider);
        typeSer.writeTypeSuffixForScalar(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java;<<<<<<< MINE
        if (visitor != null) {
            // 13-Sep-2013, tatu: Let's assume it's usually a String, right?
//            visitor.expectAnyFormat(typeHint);
            visitor.expectStringFormat(typeHint);
        }
=======
        // 13-Sep-2013, tatu: Let's assume it's usually a String, right?
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java;<<<<<<< MINE
        visitor.expectStringFormat(typeHint);
=======
        // type not really known, but since it is a JSON string:
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
     * Value that indicates suppression mechanism to use; either one of
     * values of {@link com.fasterxml.jackson.annotation.JsonInclude.Include}, or actual object to compare
     * against ("default value")
=======
     * Value that indicates suppression mechanism to use for <b>values contained</b>;
     * either one of values of {@link com.fasterxml.jackson.annotation.JsonInclude.Include},
     * or actual object to compare against ("default value").
     * Note that inclusion value for Map instance itself is handled by caller (POJO
     * property that refers to the Map value).
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
        if (propertyAcc != null && intr != null) {
=======
        if ((propertyAcc != null) && (intr != null)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
            JsonInclude.Include incl = intr.findSerializationInclusionForContent(propertyAcc, null);
            if (incl != null) {
=======
        }
        if (property != null) {
            JsonInclude.Value inclV = property.findPropertyInclusion(provider.getConfig(), Map.class);
            JsonInclude.Include incl = inclV.getContentInclusion();
            if ((incl != null) && (incl != JsonInclude.Include.USE_DEFAULTS)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
            if ((_valueTypeIsStatic && _valueType.getRawClass() != Object.class)
                    || hasContentTypeAnnotation(provider, property)) {
=======
            if (_valueTypeIsStatic && !_valueType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
    public boolean isEmpty(SerializerProvider prov, Map<?,?> value) {
        return (value == null) || value.isEmpty();
=======
    public boolean isEmpty(SerializerProvider prov, Map<?,?> value)
    {
        if (value == null || value.isEmpty()) {
            return true;
        }
        // 05-Nove-2015, tatu: Simple cases are cheap, but for recursive
        //   emptiness checking we actually need to see if values are empty as well.
        Object supp = this._suppressableValue;

        if ((supp == null) || (supp == JsonInclude.Include.ALWAYS)) {
            return false;
        }
        JsonSerializer<Object> valueSer = _valueSerializer;
        if (valueSer != null) {
            for (Object elemValue : value.values()) {
                if ((elemValue != null) && !valueSer.isEmpty(prov, elemValue)) {
                    return false;
                }
            }
            return true;
        }
        // But if not statically known, try this:
        PropertySerializerMap serializers = _dynamicValueSerializers;
        for (Object elemValue : value.values()) {
            if (elemValue == null) {
                continue;
            }
            Class<?> cc = elemValue.getClass();
            // 05-Nov-2015, tatu: Let's not worry about generic types here, actually;
            //   unlikely to make any difference, but does add significant overhead
            valueSer = serializers.serializerFor(cc);
            if (valueSer == null) {
                try {
                    valueSer = _findAndAddDynamic(serializers, cc, prov);
                } catch (JsonMappingException e) { // Ugh... can not just throw as-is, so...
                    // 05-Nov-2015, tatu: For now, probably best not to assume empty then
                    return false;
                }
                serializers = _dynamicValueSerializers;
            }
            if (!valueSer.isEmpty(prov, elemValue)) {
                return false;
            }
        }
        return true;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void serializeAsField(Object value, JsonGenerator jgen,
=======
    public void serializeAsField(Object value, JsonGenerator gen,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        _keySerializer.serialize(_key, jgen, provider);
=======
        _keySerializer.serialize(_key, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
            _valueSerializer.serialize(value, jgen, provider);
=======
            _valueSerializer.serialize(value, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);
=======
            _valueSerializer.serializeWithType(value, gen, provider, _typeSerializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void serializeAsOmittedField(Object value, JsonGenerator jgen,
=======
    public void serializeAsOmittedField(Object value, JsonGenerator gen,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        if (!jgen.canOmitFields()) {
            jgen.writeOmittedField(getName());
=======
        if (!gen.canOmitFields()) {
            gen.writeOmittedField(getName());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void serializeAsElement(Object value, JsonGenerator jgen,
=======
    public void serializeAsElement(Object value, JsonGenerator gen,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
            _valueSerializer.serialize(value, jgen, provider);
=======
            _valueSerializer.serialize(value, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);
=======
            _valueSerializer.serializeWithType(value, gen, provider, _typeSerializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void serializeAsPlaceholder(Object value, JsonGenerator jgen,
=======
    public void serializeAsPlaceholder(Object value, JsonGenerator gen,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        jgen.writeNull();
=======
        gen.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)
=======
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        // !!! TODO
=======
        if (_property != null) {
            _property.depositSchemaProperty(objectVisitor, provider);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        // !!! TODO
=======
        // nothing to do here
   }

    @Override
    public JavaType getType() {
        return (_property == null) ? TypeFactory.unknownType() : _property.getType();
    }

    @Override
    public PropertyName getWrapperName() {
        return (_property == null) ? null : _property.getWrapperName();
    }

    @Override
    public AnnotatedMember getMember() {
        return (_property == null) ? null : _property.getMember();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
     * @deprecated Since 2.6
=======
     * Declared type parameter for Optional.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    public AtomicReferenceSerializer(ReferenceType type) {
        super(type);
=======
    protected final BeanProperty _property;

    /**
     * Type serializer used for values, if any.
     *
     * @since 2.7
     */
    protected final TypeSerializer _valueTypeSerializer;

    /**
     * @since 2.7
     */
    protected final JsonSerializer<Object> _valueSerializer;

    /**
     * To support unwrapped values of dynamic types, will need this:
     *
     * @since 2.7
     */
    protected final NameTransformer _unwrapper;

    /**
     * Further guidance on serialization-inclusion (or not), regarding
     * contained value (if any).
     *
     * @since 2.7
     */
    protected final JsonInclude.Include _contentInclusion;
    
    /**
     * If element type can not be statically determined, mapping from
     * runtime type to serializer is handled using this object
     *
     * @since 2.7
     */
    protected transient PropertySerializerMap _dynamicSerializers;

    /*
    /**********************************************************
    /* Constructors, factory methods
    /**********************************************************
     */

    public AtomicReferenceSerializer(ReferenceType fullType, boolean staticTyping, TypeSerializer vts,
            JsonSerializer<Object> ser)
    {
        super(fullType);
        _referredType = fullType.getReferencedType();
        _property = null;
        _valueTypeSerializer = vts;
        _valueSerializer = ser;
        _unwrapper = null;
        _contentInclusion = null;
        _dynamicSerializers = PropertySerializerMap.emptyForProperties();
    }

    @SuppressWarnings("unchecked")
    protected AtomicReferenceSerializer(AtomicReferenceSerializer base, BeanProperty property,
            TypeSerializer vts, JsonSerializer<?> valueSer,
            NameTransformer unwrapper,
            JsonInclude.Include contentIncl)
    {
        super(base);
        _referredType = base._referredType;
        _dynamicSerializers = base._dynamicSerializers;
        _property = property;
        _valueTypeSerializer = vts;
        _valueSerializer = (JsonSerializer<Object>) valueSer;
        _unwrapper = unwrapper;
        if ((contentIncl == JsonInclude.Include.USE_DEFAULTS)
                || (contentIncl == JsonInclude.Include.ALWAYS)) {
            _contentInclusion = null;
        } else {
            _contentInclusion = contentIncl;
        }
    }

    @Override
    public JsonSerializer<AtomicReference<?>> unwrappingSerializer(NameTransformer transformer) {
        JsonSerializer<Object> ser = _valueSerializer;
        if (ser != null) {
            ser = ser.unwrappingSerializer(transformer);
        }
        NameTransformer unwrapper = (_unwrapper == null) ? transformer
                : NameTransformer.chainedTransformer(transformer, _unwrapper);
        return withResolved(_property, _valueTypeSerializer, ser, unwrapper, _contentInclusion);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    public boolean isEmpty(SerializerProvider provider, AtomicReference<?> value) {
        return (value == null) || (value.get() == null);
=======
    public boolean isUnwrappingSerializer() {
        return (_unwrapper != null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    public void serialize(AtomicReference<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {
        provider.defaultSerializeValue(value.get(), jgen);
=======
    public void serialize(AtomicReference<?> ref, JsonGenerator g, SerializerProvider provider)
        throws IOException
    {
        Object value = ref.get();
        if (value == null) {
            if (_unwrapper == null) {
                provider.defaultSerializeNull(g);
            }
            return;
        }
        JsonSerializer<Object> ser = _valueSerializer;
        if (ser == null) {
            ser = _findCachedSerializer(provider, value.getClass());
        }
        if (_valueTypeSerializer != null) {
            ser.serializeWithType(value, g, provider, _valueTypeSerializer);
        } else {
            ser.serialize(value, g, provider);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {
        return createSchemaNode("any", true);
=======
    public void serializeWithType(AtomicReference<?> ref,
            JsonGenerator g, SerializerProvider provider,
            TypeSerializer typeSer) throws IOException
    {
        Object value = ref.get();
        if (value == null) {
            if (_unwrapper == null) {
                provider.defaultSerializeNull(g);
            }
            return;
        }

        // Otherwise apply type-prefix/suffix, then std serialize:
        typeSer.writeTypePrefixForScalar(ref, g);
        serialize(ref, g, provider);
        typeSer.writeTypeSuffixForScalar(ref, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
        visitor.expectAnyFormat(typeHint);
=======
        JsonSerializer<?> ser = _valueSerializer;
        if (ser == null) {
            ser = _findSerializer(visitor.getProvider(), _referredType, _property);
            if (_unwrapper != null) {
                ser = ser.unwrappingSerializer(_unwrapper);
            }
        }
        ser.acceptJsonFormatVisitor(visitor, _referredType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
            // [Issue#124]: allow use of converters
=======
            // [databind#124]: allow use of converters
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
                    type = provider.constructType(prop.getGenericPropertyType());
=======
                    // 30-Oct-2015, tatu: Not sure why this was used
//                    type = provider.constructType(prop.getGenericPropertyType());
                    // but this looks better
                    type = prop.getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
        throws IOException, JsonGenerationException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
            for (int i = 0; i < _props.length; i++) {
                filter.depositSchemaProperty(_props[i], objectVisitor, visitor.getProvider());
=======
            for (int i = 0, end = _props.length; i < end; ++i) {
                filter.depositSchemaProperty(_props[i], objectVisitor, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
            for (int i = 0; i < _props.length; i++) {
                _props[i].depositSchemaProperty(objectVisitor);
=======
            Class<?> view = ((_filteredProps == null) || (provider == null))
                    ? null : provider.getActiveView();
            final BeanPropertyWriter[] props;
            if (view != null) {
                props = _filteredProps;
            } else {
                props = _props;
            }

            for (int i = 0, end = props.length; i < end; ++i) {
                BeanPropertyWriter prop = props[i];
                if (prop != null) { // may be filtered out unconditionally
                    prop.depositSchemaProperty(objectVisitor, provider);
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                v2.numberType(JsonParser.NumberType.INT);
            }
=======
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                v2.numberType(JsonParser.NumberType.LONG);
            }
=======
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java;<<<<<<< MINE
    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
        jgen.writeString((String) value);
=======
    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
        gen.writeString((String) value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java;<<<<<<< MINE
        if (visitor != null) visitor.expectStringFormat(typeHint);
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java;<<<<<<< MINE
                throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value");
=======
                throw JsonMappingException.from(provider,
                        "Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java;<<<<<<< MINE
                throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaItemDefinition value");
=======
                throw JsonMappingException.from(provider,
                        "Failed to parse @JsonSerializableSchema.schemaItemDefinition value");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java;<<<<<<< MINE
    public void serialize(File value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
        jgen.writeString(value.getAbsolutePath());
=======
    public void serialize(File value, JsonGenerator g, SerializerProvider provider) throws IOException {
        g.writeString(value.getAbsolutePath());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java;<<<<<<< MINE
        visitor.expectStringFormat(typeHint);
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java;<<<<<<< MINE
        // #124: May have a content converter
=======
        // [databind#124]: May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java;<<<<<<< MINE
        if (visitor != null) {
            visitor.expectStringFormat(typeHint);
        }
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) { // typically serialized as a small number (byte or int)
                v2.numberType(JsonParser.NumberType.INT);
            }
=======
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java;<<<<<<< MINE
    public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,
=======
    public final void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java;<<<<<<< MINE
        serialize(value, jgen, provider);            
=======
        serialize(value, gen, provider);            
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.BOOLEAN);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.BOOLEAN);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.INTEGER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.INTEGER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.STRING);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.STRING);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.INTEGER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.INTEGER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.NUMBER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.NUMBER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.NUMBER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
    public void serialize(Class<?> value, JsonGenerator jgen, SerializerProvider provider)
        throws IOException, JsonGenerationException
=======
    public void serialize(Class<?> value, JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
        jgen.writeString(value.getName());
=======
        g.writeString(value.getName());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
        visitor.expectStringFormat(typeHint);
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
        throws IOException, JsonGenerationException
=======
            throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
            TypeSerializer typeSer)
        throws IOException, JsonGenerationException
=======
            TypeSerializer typeSer) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
        /* 01-Jan-2010, tatu: Not 100% sure what we should say here:
         *   type is basically not known. This seems closest
         *   approximation
         */
=======
        // Not 100% sure what we should say here: type is basically not known.
        // This seems like closest approximation
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
        /* 01-Jan-2010, tatu: Not 100% sure what we should say here:
         *   type is basically not known. This seems closest
         *   approximation
         */
=======
        // Not 100% sure what we should say here: type is basically not known.
        // This seems like closest approximation
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
            JsonInclude.Include inclusion)
=======
            JsonInclude.Value inclusion)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
    protected static boolean _suppressNulls(JsonInclude.Include inclusion) {
        return (inclusion != JsonInclude.Include.ALWAYS);
=======
    protected static boolean _suppressNulls(JsonInclude.Value inclusion) {
        if (inclusion == null) {
            return false;
        }
        JsonInclude.Include incl = inclusion.getValueInclusion();
        return (incl != JsonInclude.Include.ALWAYS) && (incl != JsonInclude.Include.USE_DEFAULTS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
    protected static Object _suppressableValue(JsonInclude.Include inclusion) {
        if ((inclusion == JsonInclude.Include.NON_EMPTY)
                || (inclusion == JsonInclude.Include.NON_EMPTY)) {
            return MARKER_FOR_EMPTY;
=======
    protected static Object _suppressableValue(JsonInclude.Value inclusion) {
        if (inclusion == null) {
            return false;
        }
        JsonInclude.Include incl = inclusion.getValueInclusion();
        if ((incl == JsonInclude.Include.ALWAYS)
                || (incl == JsonInclude.Include.NON_NULL)
                || (incl == JsonInclude.Include.USE_DEFAULTS)) {
            return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
        return null;
=======
        return MARKER_FOR_EMPTY;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw new JsonMappingException(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw JsonMappingException.from(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw JsonMappingException.from(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw JsonMappingException.from(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw JsonMappingException.from(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concrete.put(String.class.getName(), new StringSerializer());
=======
        concrete.put(String.class.getName(), new StringSerializer());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concrete.put(StringBuffer.class.getName(), sls);
        _concrete.put(StringBuilder.class.getName(), sls);
        _concrete.put(Character.class.getName(), sls);
        _concrete.put(Character.TYPE.getName(), sls);
=======
        concrete.put(StringBuffer.class.getName(), sls);
        concrete.put(StringBuilder.class.getName(), sls);
        concrete.put(Character.class.getName(), sls);
        concrete.put(Character.TYPE.getName(), sls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        NumberSerializers.addAll(_concrete);
        _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));
        _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));
=======
        NumberSerializers.addAll(concrete);
        concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));
        concrete.put(Boolean.class.getName(), new BooleanSerializer(false));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));
        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));
=======
        concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));
        concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
        _concrete.put(java.util.Date.class.getName(), DateSerializer.instance);
=======
        concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
        concrete.put(java.util.Date.class.getName(), DateSerializer.instance);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
                _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);
=======
                concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
                _concreteLazy.put(en.getKey().getName(), cls);
=======
                concLazy.put(en.getKey().getName(), cls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);
=======
        concLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);

        _concrete = concrete;
        _concreteLazy = concLazy;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
                            ClassUtil.checkAndFixAccess(m);
=======
                            ClassUtil.checkAndFixAccess(m, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(m);
=======
                ClassUtil.checkAndFixAccess(m, prov.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        // Then check for optional/external serializers [JACKSON-386]
=======
        // Then check for optional/external serializers 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        if (Iterator.class.isAssignableFrom(type)) {
=======
        if (Iterator.class.isAssignableFrom(rawType)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        if (Iterable.class.isAssignableFrom(type)) {
=======
        if (Iterable.class.isAssignableFrom(rawType)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        if (CharSequence.class.isAssignableFrom(type)) {
=======
        if (CharSequence.class.isAssignableFrom(rawType)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);

        if (incl != null) {
            switch (incl) {
            case NON_DEFAULT:
                // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean "NON_EMPTY"...
                incl = JsonInclude.Include.NON_EMPTY;
                break;
            default:
                // all other modes actually good as is, unless we'll find better ways
                break;
            }
            return incl;
=======
        JsonInclude.Value inclV = beanDesc.findPropertyInclusion(config.getDefaultPropertyInclusion());
        
        if (inclV == null) {
            return null;
        }
        JsonInclude.Include incl = inclV.getContentInclusion();
        switch (incl) {
        case USE_DEFAULTS: // means "dunno"
            return null;
        case NON_DEFAULT:
            // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean "NON_EMPTY"...
            // 11-Nov-2015, tatu: With 2.6, we did indeed revert to "NON_EMPTY", but that did
            //    not go well, so with 2.7, we'll do this instead...
            //   But not 100% sure if we ought to call new `JsonSerializer.findDefaultValue()`;
            //   to do that, would need to locate said serializer
//            incl = JsonInclude.Include.NON_EMPTY;
            break;
        default:
            // all other modes actually good as is, unless we'll find better ways
            break;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        return null;
=======
        return incl;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
     * If so, will try to instantiate key serializer and return it; otherwise returns null.
=======
     * If so, will try to instantiate value serializer and return it; otherwise returns null.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE
            /* Finally: some serializers want to do post-processing, after
             * getting registered (to handle cyclic deps).
             */
            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done
             *   in synchronized manner; this because while we do need to register
             *   instance first, we also must keep lock until resolution is complete
=======
            // Need resolution to handle cyclic POJO type dependencies
            /* 14-May-2011, tatu: Resolving needs to be done in synchronized manner;
             *   this because while we do need to register instance first, we also must
             *   keep lock until resolution is complete.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE
            /* Finally: some serializers want to do post-processing, after
             * getting registered (to handle cyclic deps).
             */
            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done
             *   in synchronized manner; this because while we do need to register
             *   instance first, we also must keep lock until resolution is complete
=======
            // Need resolution to handle cyclic POJO type dependencies
            /* 14-May-2011, tatu: Resolving needs to be done in synchronized manner;
             *   this because while we do need to register instance first, we also must
             *   keep lock until resolution is complete.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java;<<<<<<< MINE
     * specified type, which is not of a container type (for which other methods are
     * called).
=======
     * specified type, which is not of a container or reference type (for which
     * other methods are called).
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java;<<<<<<< MINE
            throw new JsonMappingException("Value returned by 'any-getter' ("
=======
            throw JsonMappingException.from(gen, "Value returned by 'any-getter' ("
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java;<<<<<<< MINE
            throw new JsonMappingException("Value returned by 'any-getter' ("
=======
            throw JsonMappingException.from(gen, "Value returned by 'any-getter' ("
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
        // One more twist, as per [Issue#288]; probably need to get new BeanDesc
=======
        // One more twist, as per [databind#288]; probably need to get new BeanDesc
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
=======
            // 03-Aug-2012, tatu: As per [databind#40], may require POJO serializer...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            // Modules may provide serializers of POJO types:
            for (Serializers serializers : customSerializers()) {
                ser = serializers.findSerializer(config, type, beanDesc);
                if (ser != null) {
                    break;
=======
            if (type.isReferenceType()) {
                ser = findReferenceSerializer(prov, (ReferenceType) type, beanDesc, staticTyping);
            } else {
                // Modules may provide serializers of POJO types:
                for (Serializers serializers : customSerializers()) {
                    ser = serializers.findSerializer(config, type, beanDesc);
                    if (ser != null) {
                        break;
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)
=======
    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type,
            BeanDescription beanDesc)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            //   as per [Issue#24]
=======
            //   as per [databind#24]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                anyGetter.fixAccess();
=======
                anyGetter.fixAccess(config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            // [JACKSON-762]: type id? Requires special handling:
=======
            // Type id? Requires special handling:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                    if (config.canOverrideAccessModifiers()) {
                        accessor.fixAccess();
=======
                    if (fixAccess) {
                        accessor.fixAccess(forceAccess);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            // [JACKSON-235]: suppress writing of back references
=======
            // suppress writing of back references
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));
=======
                result.add(_constructWriter(prov, property, pb, staticTyping, (AnnotatedMethod) accessor));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));
=======
                result.add(_constructWriter(prov, property, pb, staticTyping, (AnnotatedField) accessor));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            BeanPropertyDefinition propDef, TypeBindings typeContext,
=======
            BeanPropertyDefinition propDef,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            accessor.fixAccess();
=======
            accessor.fixAccess(prov.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
     * we need to know the default value of the bean, to know if property value
=======
     * we may need to know the default value of the bean, to know if property value
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        _defaultInclusion = beanDesc.findSerializationInclusion(config.getSerializationInclusion());
=======
        _defaultInclusion = beanDesc.findPropertyInclusion(config.getDefaultPropertyInclusion());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        JsonInclude.Include inclusion = propDef.findInclusion();
        if ((inclusion == null)
                || (inclusion == JsonInclude.Include.USE_DEFAULTS)) { // since 2.6
=======
        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());
        JsonInclude.Include inclusion = inclV.getValueInclusion();
        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...
            inclusion = JsonInclude.Include.ALWAYS;
        }

        /*
        JsonInclude.Include inclusion = propDef.findInclusion().getValueInclusion();
        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // since 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
            valueToSuppress = getDefaultValue(propDef.getName(), am);
=======
            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,
            //    so that if enclosing class has this, we may need to values of property,
            //    whereas for global defaults OR per-property overrides, we have more
            //    static definition. Sigh.
            // First: case of class specifying it; try to find POJO property defaults
            JavaType t = (serializationType == null) ? declaredType : serializationType;
            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {
                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, t);
            } else {
                valueToSuppress = getDefaultValue(t);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        // [JACKSON-120]: Check to see if serialization type is fixed
        Class<?> serClass = _annotationIntrospector.findSerializationType(a);
        if (serClass != null) {
=======
        JavaType secondary = _annotationIntrospector.refineSerializationType(_config, a, declaredType);
        // 11-Oct-2015, tatu: As of 2.7, not 100% sure following checks are needed. But keeping
        //    for now, just in case
        if (secondary != declaredType) {
            Class<?> serClass = secondary.getRawClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
                /* 03-Dec-2010, tatu: Actually, ugh, to resolve [JACKSON-415] may further relax this
=======
                /* 03-Dec-2010, tatu: Actually, ugh, we may need to further relax this
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        
        /* [JACKSON-114]: if using static typing, declared type is known
         * to be the type...
         */
=======
        // If using static typing, declared type is known to be the type...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        if (typing != null && typing != JsonSerialize.Typing.DEFAULT_TYPING) {
=======
        if ((typing != null) && (typing != JsonSerialize.Typing.DEFAULT_TYPING)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        return useStaticTyping ? declaredType : null;
=======
        if (useStaticTyping) {
            // 11-Oct-2015, tatu: Make sure JavaType also "knows" static-ness...
            return declaredType.withStaticTyping();
            
        }
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        if (_defaultBean == null) {
=======
        Object def = _defaultBean;
        if (def == null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
            _defaultBean = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());
            if (_defaultBean == null) {
=======
            def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());
            if (def == null) {
                // 06-Nov-2015, tatu: As per [databind#998], do not fail.
                /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        return _defaultBean;
=======
        return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
    protected Object getDefaultValue(String name, AnnotatedMember member)
=======
    /**
     * Accessor used to find out "default value" for given property, to use for
     * comparing values to serialize, to determine whether to exclude value from serialization with
     * inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_EMPTY}.
     * This method is called when we specifically want to know default value within context
     * of a POJO, when annotation is within containing class, and not for property or
     * defined as global baseline.
     *<p>
     * Note that returning of pseudo-type 
     *
     * @since 2.7
     */
    protected Object getPropertyDefaultValue(String name, AnnotatedMember member,
            JavaType type)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
    public abstract void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)
=======
    @Override
    public abstract void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        // one more thing: copy internal settings, if any (since 1.7)
=======
        // one more thing: copy internal settings, if any
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        return (_accessorMethod != null) ? _accessorMethod.getReturnType() : _field.getType();
=======
        if (_accessorMethod != null) {
            return _accessorMethod.getReturnType();
        }
        if (_field != null) {
            return _field.getType();
        }
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
    public void depositSchemaProperty(JsonObjectFormatVisitor v)
=======
    public void depositSchemaProperty(JsonObjectFormatVisitor v,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
                throw new JsonMappingException("Direct self-reference leading to cycle");
=======
                throw JsonMappingException.from(gen, "Direct self-reference leading to cycle");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	/**
=======
    /**
     * This is a CSS color (like "#FF0000" or "red"), based on CSS
         2.1 [W3C.CR-CSS21-20070719].
     */
    COLOR("color"),

    /**
     * This SHOULD be a date in the format of YYYY-MM-DD.  It is
     recommended that you use the "date-time" format instead of "date"
     unless you need to transfer only the date part.
     */
    DATE("date"),

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	/**
	 * This SHOULD be a date in the format of YYYY-MM-DD.  It is
      recommended that you use the "date-time" format instead of "date"
      unless you need to transfer only the date part.
	 */
	DATE("date"),

	/**
	 * This SHOULD be a time in the format of hh:mm:ss.  It is
      recommended that you use the "date-time" format instead of "time"
      unless you need to transfer only the time part.
	 */
	TIME("time"),
=======
     /**
      * This SHOULD be an email address.
      */
     EMAIL("email"),

     /**
      * This SHOULD be a host-name.
      */
     HOST_NAME("host-name"),
     
     /**
      * This SHOULD be an ip version 4 address.
      */
     IP_ADDRESS("ip-address"),

     /**
      * This SHOULD be an ip version 6 address.
      */
     IPV6("ipv6"),

     /**
      * This SHOULD be a phone number (format MAY follow E.123).
      */
     PHONE("phone"),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	/**
	 * This SHOULD be the difference, measured in
      milliseconds, between the specified time and midnight, 00:00 of
      January 1, 1970 UTC.  The value SHOULD be a number (integer or
      float).
	 */
	UTC_MILLISEC("utc-millisec"),

	/**
=======
     /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	 * This SHOULD be a phone number (format MAY follow E.123).
	 */
	PHONE("phone"),
=======
      * This SHOULD be a time in the format of hh:mm:ss.  It is
      recommended that you use the "date-time" format instead of "time"
      unless you need to transfer only the time part.
      */
     TIME("time"),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	/**
	 * This SHOULD be an email address.
	 */
	EMAIL("email"),

	/**
	 * This SHOULD be an ip version 4 address.
	 */
	IP_ADDRESS("ip-address"),
	
	/**
	 * This SHOULD be an ip version 6 address.
	 */
	IPV6("ipv6"),
	
	/**
	 * This SHOULD be a host-name.
	 */
	HOST_NAME("host-name")
=======
     /**
      * This SHOULD be the difference, measured in
      milliseconds, between the specified time and midnight, 00:00 of
      January 1, 1970 UTC.  The value SHOULD be a number (integer or
      float).
      */
     UTC_MILLISEC("utc-millisec"),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserializeTypedFromObject(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        if (jp.canReadTypeId()) {
            Object typeId = jp.getTypeId();
=======
        if (p.canReadTypeId()) {
            Object typeId = p.getTypeId();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                return _deserializeWithNativeTypeId(jp, ctxt, typeId);
=======
                return _deserializeWithNativeTypeId(p, ctxt, typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            t = jp.nextToken();
        } else if (t == JsonToken.START_ARRAY) {
=======
            t = p.nextToken();
        } else if (/*t == JsonToken.START_ARRAY ||*/ t != JsonToken.FIELD_NAME) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);
        } else if (t != JsonToken.FIELD_NAME) {
            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);
=======
            return _deserializeTypedUsingDefaultImpl(p, ctxt, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {
            String name = jp.getCurrentName();
            jp.nextToken(); // to point to the value
            if (_typePropertyName.equals(name)) { // gotcha!
                return _deserializeTypedForId(jp, ctxt, tb);
=======
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String name = p.getCurrentName();
            p.nextToken(); // to point to the value
            if (name.equals(_typePropertyName)) { // gotcha!
                return _deserializeTypedForId(p, ctxt, tb);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                tb = new TokenBuffer(jp, ctxt);
=======
                tb = new TokenBuffer(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            tb.copyCurrentStructure(jp);
=======
            tb.copyCurrentStructure(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb);
=======
        return _deserializeTypedUsingDefaultImpl(p, ctxt, tb);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    protected Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException
=======
    protected Object _deserializeTypedForId(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                tb = new TokenBuffer(jp, ctxt);
=======
                tb = new TokenBuffer(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            tb.writeFieldName(jp.getCurrentName());
=======
            tb.writeFieldName(p.getCurrentName());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);
=======
            p = JsonParserSequence.createFlattened(tb.asParser(p), p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        jp.nextToken(); // to skip past String value
=======
        p.nextToken(); // to skip past String value
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        return deser.deserialize(jp, ctxt);
=======
        return deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException
=======
    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                jp = tb.asParser(jp);
=======
                p = tb.asParser(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                jp.nextToken();
=======
                p.nextToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            return deser.deserialize(jp, ctxt);
=======
            return deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromAny(jp, ctxt);
=======
        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromAny(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,
=======
        throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    /* As per [JACKSON-352], also need to re-route "unknown" version. Need to think
=======
    /* Also need to re-route "unknown" version. Need to think
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromArray(jp, ctxt);
=======
        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        return deserializeTypedFromObject(jp, ctxt);
=======
        return deserializeTypedFromObject(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config);
=======
                ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java;<<<<<<< MINE
        return typeFromId(id);
=======
        // 22-Dec-2015, tatu: Must be overridden by sub-classes, so let's throw
        //    an exception if not
        throw new IllegalStateException("Sub-class "+getClass().getName()+" MUST implement "
                +"`typeFromId(DatabindContext,String)");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeObjectFieldStart(_validTypeId(typeId));
=======
            g.writeObjectFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g, Class<?> type) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeObjectFieldStart(_validTypeId(typeId));
=======
            g.writeObjectFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
=======
            g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeArrayFieldStart(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeArrayFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type) throws IOException
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g, Class<?> type) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
=======
            g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeArrayFieldStart(_validTypeId(typeId));
=======
            g.writeArrayFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeFieldName(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeFieldName(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g, Class<?> type) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeFieldName(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeFieldName(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException
=======
    public void writeTypeSuffixForObject(Object value, JsonGenerator g) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        jgen.writeEndObject();
        if (!jgen.canWriteTypeId()) {
=======
        g.writeEndObject();
        if (!g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeEndObject();
=======
            g.writeEndObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException
=======
    public void writeTypeSuffixForArray(Object value, JsonGenerator g) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        jgen.writeEndArray();
        if (!jgen.canWriteTypeId()) {
=======
        g.writeEndArray();
        if (!g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeEndObject();
=======
            g.writeEndObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException {
        if (!jgen.canWriteTypeId()) {
=======
    public void writeTypeSuffixForScalar(Object value, JsonGenerator g) throws IOException {
        if (!g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeEndObject();
=======
            g.writeEndObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForObject(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeObjectFieldStart(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeObjectFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForArray(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
=======
            g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeArrayFieldStart(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeArrayFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForScalar(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeFieldName(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeFieldName(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForObject(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForObject(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForArray(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForArray(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForScalar(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForScalar(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
     * @since 2.6.0
=======
     * Helper method used to ensure that intended type id is output as something that is valid:
     * currently only used to ensure that `null` output is converted to an empty String.
     *
     * @since 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
        _typePropertyName = typePropertyName;
=======
        // 22-Dec-2015, tatu: as per [databind#1055], avoid NPE
        _typePropertyName = (typePropertyName == null) ? "" : typePropertyName;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
        // defaults are fine, although concurrency of 4 bit more frugal than 16:
        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 4);
=======
        // defaults are fine, although shouldn't need much concurrency
        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java;<<<<<<< MINE
    @Deprecated // since 2.4
=======
    @Deprecated // since 2.5
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
        return typeDeserializer.deserializeTypedFromArray(p, ctxt);
    }
    
    protected T handleNonArray(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        // [JACKSON-620] Empty String can become null...
        if (p.hasToken(JsonToken.VALUE_STRING)
                && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
            if (p.getText().length() == 0) {
                return null;
            }
        }
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (canWrap) {
            return handleSingleElementUnwrapped(p, ctxt);
        }
        throw ctxt.mappingException(_valueClass);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
    */
=======
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            // 11-Dec-2015, tatu: Not sure how re-wrapping would work; omit
            return this;
        }
        
        @Override
        public char[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (jp.isExpectedStartArrayToken()) {
=======
            if (p.isExpectedStartArrayToken()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
=======
                while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                        throw JsonMappingException.from(jp, "Can not convert a JSON String of length "+str.length()+" into a char element of char array");
=======
                        throw JsonMappingException.from(p, "Can not convert a JSON String of length "+str.length()+" into a char element of char array");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt)
=======
        public boolean[] deserialize(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new boolean[] { _parseBooleanPrimitive(jp, ctxt) };
=======
        @Override
        protected boolean[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new boolean[] { _parseBooleanPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        public byte[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                return jp.getBinaryValue(ctxt.getBase64Variant());
=======
                return p.getBinaryValue(ctxt.getBase64Variant());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
=======
                while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                        value = jp.getByteValue();
=======
                        value = p.getByteValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        @Override
        protected byte[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                value = jp.getByteValue();
=======
                value = p.getByteValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                // [JACKSON-79]: should probably accept nulls as 'false'
=======
                // should probably accept nulls as 'false'
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new ShortDeser(this, unwrapSingle);
        }
        
        @Override
        public short[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
                    short value = _parseShortPrimitive(jp, ctxt);
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
                    short value = _parseShortPrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new short[] { _parseShortPrimitive(jp, ctxt) };
=======
        @Override
        protected short[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new short[] { _parseShortPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        public int[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new int[] { _parseIntPrimitive(jp, ctxt) };
=======
        @Override
        protected int[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new int[] { _parseIntPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        public long[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
                    long value = _parseLongPrimitive(jp, ctxt);
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
                    long value = _parseLongPrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new long[] { _parseLongPrimitive(jp, ctxt) };
=======
        @Override
        protected long[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new long[] { _parseLongPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public float[] deserialize(JsonParser jp, DeserializationContext ctxt)
=======
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new FloatDeser(this, unwrapSingle);
        }

        @Override
        public float[] deserialize(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final float[] handleNonArray(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new float[] { _parseFloatPrimitive(jp, ctxt) };
=======
        @Override
        protected float[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new float[] { _parseFloatPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        public double[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
                    double value = _parseDoublePrimitive(jp, ctxt);
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
                    double value = _parseDoublePrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new double[] { _parseDoublePrimitive(jp, ctxt) };
=======
        @Override
        protected double[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new double[] { _parseDoublePrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(ctor);
=======
                ClassUtil.checkAndFixAccess(ctor, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(m);
=======
                ClassUtil.checkAndFixAccess(m, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
    public ArrayBlockingQueueDeserializer(JavaType collectionType,
=======
     protected ArrayBlockingQueueDeserializer(JavaType collectionType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
            JsonDeserializer<Object> delegateDeser)
=======
            JsonDeserializer<Object> delegateDeser, Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
        super(collectionType, valueDeser, valueTypeDeser, valueInstantiator, delegateDeser);
=======
        super(collectionType, valueDeser, valueTypeDeser, valueInstantiator,
                delegateDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
            JsonDeserializer<?> vd, TypeDeserializer vtd)
=======
            JsonDeserializer<?> vd, TypeDeserializer vtd, Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) {
=======
        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)
                && (_unwrapSingle == unwrapSingle)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
                _valueInstantiator, (JsonDeserializer<Object>) dd);
=======
                _valueInstantiator, (JsonDeserializer<Object>) dd, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
            ClassUtil.checkAndFixAccess(factory.getMember());
=======
            ClassUtil.checkAndFixAccess(factory.getMember(),
                    config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
            // ... unless told not to do that. :-) (as per [JACKSON-412])
            _checkFailOnNumber(ctxt);
            
=======
            // ... unless told not to do that
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
                throw ctxt.weirdNumberException(Integer.valueOf(index), _enumClass(),
=======
                throw ctxt.weirdNumberException(index, _enumClass(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
            // [#149]: Allow use of 'String' indexes as well
=======
            // [databind#149]: Allow use of 'String' indexes as well
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
                    _checkFailOnNumber(ctxt);
=======
                    if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {
                        _failOnNumber(ctxt, p, ix);
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
    protected void _checkFailOnNumber(DeserializationContext ctxt) throws IOException
=======
    protected void _failOnNumber(DeserializationContext ctxt, JsonParser p, int index)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {
            throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)");
        }
=======
        throw InvalidFormatException.from(p,
                String.format("Not allowed to deserialize Enum value out of JSON number (%d): disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow",
                        index),
                        index, _enumClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
    public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public String deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
        JsonToken curr = jp.getCurrentToken();
        if (curr == JsonToken.VALUE_STRING) {
            return jp.getText();
=======
        if (p.hasToken(JsonToken.VALUE_STRING)) {
            return p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE

        // Issue#381
        if (curr == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
            jp.nextToken();
            final String parsed = _parseString(jp, ctxt);
            if (jp.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
=======
        JsonToken t = p.getCurrentToken();
        // [databind#381]
        if ((t == JsonToken.START_ARRAY) && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
            p.nextToken();
            final String parsed = _parseString(p, ctxt);
            if (p.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
        // [JACKSON-330]: need to gracefully handle byte[] data, as base64
        if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {
            Object ob = jp.getEmbeddedObject();
=======
        // need to gracefully handle byte[] data, as base64
        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {
            Object ob = p.getEmbeddedObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
                return Base64Variants.getDefaultVariant().encode((byte[]) ob, false);
=======
                return ctxt.getBase64Variant().encode((byte[]) ob, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
        throw ctxt.mappingException(_valueClass, curr);
=======
        throw ctxt.mappingException(_valueClass, p.getCurrentToken());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
    // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
=======
    // Since we can never have type info ("natural type"; String, Boolean, Integer, Double):
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
    public String deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return deserialize(jp, ctxt);
=======
    public String deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
        return new EnumSetDeserializer(_enumType, deser);
=======
        return new EnumSetDeserializer(this, deser, _unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
        return withDeserializer(deser);
=======
        return withResolved(deser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
    public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public EnumSet<?> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
        if (!jp.isExpectedStartArrayToken()) {
            throw ctxt.mappingException(EnumSet.class);
=======
        if (!p.isExpectedStartArrayToken()) {
            return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
=======
            while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
        return typeDeserializer.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return _parseBooleanFromNumber(jp, ctxt);
=======
            return _parseBooleanFromOther(jp, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return Boolean.valueOf(_parseBooleanFromNumber(p, ctxt));
=======
            return Boolean.valueOf(_parseBooleanFromOther(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
    protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt)
=======
    protected final boolean _parseBooleanFromOther(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        if (jp.getNumberType() == NumberType.LONG) {
            return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE;
=======
        if (p.getNumberType() == NumberType.LONG) {
            return (p.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?
        // for now, MIN_VALUE, since MIN_NORMAL is JDK 1.6
=======
        // avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return Double.MIN_VALUE;
=======
            return Double.MIN_NORMAL; // since 2.7; was MIN_VALUE prior
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
    protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected final String _parseString(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return jp.getText();
=======
            return p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        
        // Issue#381
=======
        // [databind#381]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            jp.nextToken();
            final String parsed = _parseString(jp, ctxt);
            if (jp.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
=======
            p.nextToken();
            final String parsed = _parseString(p, ctxt);
            if (p.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        throw ctxt.mappingException(String.class, jp.getCurrentToken());
=======
        throw ctxt.mappingException(String.class, p.getCurrentToken());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
     *     for passing deserialized values; provided so deserializer can be contextualized if necessary (since 1.7)
=======
     *     for passing deserialized values; provided so deserializer can be contextualized if necessary
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
            _badFormat(id);
=======
            _badFormat(id, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
            _badFormat(id);
=======
            _badFormat(id, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
        long l2 = ((long) shortFromChars(id, 9)) << 16;
        l2 |= shortFromChars(id, 14);
=======
        long l2 = ((long) shortFromChars(id, 9, ctxt)) << 16;
        l2 |= shortFromChars(id, 14, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
        l2 = intFromChars(id, 28);
=======
        l2 = intFromChars(id, 28, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    private void _badFormat(String uuidStr) {
        throw new NumberFormatException("UUID has to be represented by the standard 36-char representation");
=======
    private void _badFormat(String uuidStr, DeserializationContext ctxt)
        throws JsonMappingException
    {
        throw InvalidFormatException.from(ctxt.getParser(),
                String.format("UUID has to be represented by standard 36-char representation: input String '%s'",
                        uuidStr),
                uuidStr, handledType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    static int intFromChars(String str, int index) {
        return (byteFromChars(str, index) << 24) + (byteFromChars(str, index+2) << 16) + (byteFromChars(str, index+4) << 8) + byteFromChars(str, index+6);
=======
    static int intFromChars(String str, int index, DeserializationContext ctxt) throws JsonMappingException {
        return (byteFromChars(str, index, ctxt) << 24)
                + (byteFromChars(str, index+2, ctxt) << 16)
                + (byteFromChars(str, index+4, ctxt) << 8)
                + byteFromChars(str, index+6, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    static int shortFromChars(String str, int index) {
        return (byteFromChars(str, index) << 8) + byteFromChars(str, index+2);
=======
    static int shortFromChars(String str, int index, DeserializationContext ctxt) throws JsonMappingException {
        return (byteFromChars(str, index, ctxt) << 8) + byteFromChars(str, index+2, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    static int byteFromChars(String str, int index)
=======
    static int byteFromChars(String str, int index, DeserializationContext ctxt) throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
            return _badChar(str, index, c1);
=======
            return _badChar(str, index, ctxt, c1);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
        return _badChar(str, index+1, c2);
=======
        return _badChar(str, index+1, ctxt, c2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    static int _badChar(String uuidStr, int index, char c) {
        throw new NumberFormatException("Non-hex character '"+c+"', not valid character for a UUID String"
                +"' (value 0x"+Integer.toHexString(c)+") for UUID String \""+uuidStr+"\"");
=======
    static int _badChar(String uuidStr, int index, DeserializationContext ctxt, char c) throws JsonMappingException {
        String msg = String.format(
"Non-hex character '%c' (value 0x%s), not valid for UUID String: input String '%s'",
        c, Integer.toHexString(c), uuidStr);
        throw InvalidFormatException.from(ctxt.getParser(), msg, uuidStr, UUID.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    private UUID _fromBytes(byte[] bytes, DeserializationContext ctxt) throws IOException {
=======
    private UUID _fromBytes(byte[] bytes, DeserializationContext ctxt) throws JsonMappingException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
            ctxt.mappingException("Can only construct UUIDs from byte[16]; got %d bytes",
                    bytes.length);
=======
            throw InvalidFormatException.from(ctxt.getParser(),
                    "Can only construct UUIDs from byte[16]; got "+bytes.length+" bytes",
                    bytes, handledType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        this(collectionType, valueInstantiator, null, valueDeser);
=======
        this(collectionType, valueInstantiator, null, valueDeser, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            JsonDeserializer<?> valueDeser)
=======
            JsonDeserializer<?> valueDeser, Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            JsonDeserializer<?> valueDeser)
=======
            JsonDeserializer<?> valueDeser, Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        if ((_valueDeserializer == valueDeser) && (_delegateDeserializer == delegateDeser)) {
=======
        if ((_unwrapSingle == unwrapSingle)
                && (_valueDeserializer == valueDeser) && (_delegateDeserializer == delegateDeser)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                _valueInstantiator, delegateDeser, valueDeser);
=======
                _valueInstantiator, delegateDeser, valueDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            // #125: May have a content converter
=======
            // [databind#125]: May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        } 
=======
        }
        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
        //   comes down to "List vs Collection" I suppose... for now, pass Collection
        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        return withResolved(delegate, valueDeser);
=======
        return withResolved(delegate, valueDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt)
=======
    public Collection<String> deserialize(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                    _delegateDeserializer.deserialize(jp, ctxt));
=======
                    _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        return deserialize(jp, ctxt, result);
=======
        return deserialize(p, ctxt, result);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt,
=======
    public Collection<String> deserialize(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt, result);
=======
        if (!p.isExpectedStartArrayToken()) {
            return handleNonArray(p, ctxt, result);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer);
=======
            return deserializeUsingCustom(p, ctxt, result, _valueDeserializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                    value = _parseString(jp, ctxt);
=======
                    value = _parseString(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt,
=======
    private Collection<String> deserializeUsingCustom(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            if (jp.nextTextValue() == null) {
                JsonToken t = jp.getCurrentToken();
=======
            if (p.nextTextValue() == null) {
                JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt);
=======
                value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                value = deser.deserialize(jp, ctxt);
=======
                value = deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
        return typeDeserializer.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException
=======
    private final Collection<String> handleNonArray(JsonParser p, DeserializationContext ctxt, Collection<String> result) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        // [JACKSON-526]: implicit arrays from single values?
        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
=======
        // implicit arrays from single values?
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (!canWrap) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            value = (valueDes == null) ? _parseString(jp, ctxt) : valueDes.deserialize(jp, ctxt);
=======
            value = (valueDes == null) ? _parseString(p, ctxt) : valueDes.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            return _deserializeUsingPropertyBased(jp, ctxt);
=======
            return _deserializeUsingPropertyBased(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                    _delegateDeserializer.deserialize(jp, ctxt));
=======
                    _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            throw JsonMappingException.from(jp, "Can not instantiate abstract type "+_beanType
=======
            throw JsonMappingException.from(p, "Can not instantiate abstract type "+_beanType
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            throw new JsonMappingException("Can not deserialize Throwable of type "+_beanType
=======
            throw JsonMappingException.from(p,"Can not deserialize Throwable of type "+_beanType
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {
            String propName = jp.getCurrentName();
=======
        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {
            String propName = p.getCurrentName();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            jp.nextToken(); // to point to field value
=======
            p.nextToken(); // to point to field value
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                    prop.deserializeAndSet(jp, ctxt, throwable);
=======
                    prop.deserializeAndSet(p, ctxt, throwable);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                pending[pendingIx++] = prop.deserialize(jp, ctxt);
=======
                pending[pendingIx++] = prop.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());
=======
                    throwable = _valueInstantiator.createFromString(ctxt, p.getText());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                jp.skipChildren();
=======
                p.skipChildren();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);
=======
                _anySetter.deserializeAndSet(p, ctxt, throwable, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            handleUnknownProperty(jp, ctxt, throwable, propName);
=======
            handleUnknownProperty(p, ctxt, throwable, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
    public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
        /* 06-Nov-2013, tatu: Looks like the only way to make polymorphic deser to work
         *   correctly is to add support here; problem being that handler is not available
         *   for nominal type of AtomicReference but only "contained" type...
         */
        if (_valueTypeDeserializer != null) {
            return new AtomicReference<Object>(_valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer));
        }
        return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt));
=======
    public AtomicReference<?> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
        Object contents = (_valueTypeDeserializer == null)
                ? _valueDeserializer.deserialize(p, ctxt)
                : _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
        return new AtomicReference<Object>(contents);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
    public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt,
            TypeDeserializer typeDeserializer) throws IOException {
        return (Object[]) typeDeserializer.deserializeTypedFromAny(jp, ctxt);
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
            TypeDeserializer typeDeserializer) throws IOException
    {
        final JsonToken t = p.getCurrentToken();
        if (t == JsonToken.VALUE_NULL) { // can this actually happen?
            return getNullValue(ctxt);
        }
        // 22-Oct-2015, tatu: This handling is probably not needed (or is wrong), but
        //   could be result of older (pre-2.7) Jackson trying to serialize natural types.
        //  Because of this, let's allow for now, unless proven problematic
        if ((t != null) && t.isScalarValue()) {
            return deserialize(p, ctxt);
        }
        // andn this is what should really happen
        return typeDeserializer.deserializeTypedFromAny(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java;<<<<<<< MINE
            if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
=======
            if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
        // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
=======
        // Since we can never have type info ("natural type"; String, Boolean, Integer, Double):
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
            throws IOException, JsonProcessingException
=======
            throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
            throws IOException, JsonProcessingException
=======
            throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
        // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
=======
        // Since we can never have type info ("natural type"; String, Boolean, Integer, Double):
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
        // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
=======
        // Since we can never have type info ("natural type"; String, Boolean, Integer, Double):
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
     * Since 1.5, there is one additional complication: some numeric
=======
     * There is one additional complication: some numeric
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        if ((elemDeser == _elementDeserializer) && (elemTypeDeser == _elementTypeDeserializer)) {
=======
        return withResolved(elemTypeDeser, elemDeser, _unwrapSingle);
    }

    /**
     * @since 2.7
     */
    @SuppressWarnings("unchecked")
    public ObjectArrayDeserializer withResolved(TypeDeserializer elemTypeDeser,
            JsonDeserializer<?> elemDeser, Boolean unwrapSingle)
    {
        if ((unwrapSingle == _unwrapSingle)
                && (elemDeser == _elementDeserializer)
                && (elemTypeDeser == _elementTypeDeserializer)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        return new ObjectArrayDeserializer(_arrayType,
                (JsonDeserializer<Object>) elemDeser, elemTypeDeser);
=======
        return new ObjectArrayDeserializer(this,
                (JsonDeserializer<Object>) elemDeser, elemTypeDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        return withDeserializer(elemTypeDeser, deser);
=======
        return withResolved(elemTypeDeser, deser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    public Object[] deserialize(JsonParser jp, DeserializationContext ctxt)
        throws IOException, JsonProcessingException
=======
    public Object[] deserialize(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt);
=======
        if (!p.isExpectedStartArrayToken()) {
            return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
=======
            while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
                    value = _elementDeserializer.deserialize(jp, ctxt);
=======
                    value = _elementDeserializer.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
                    value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser);
=======
                    value = _elementDeserializer.deserializeWithType(p, ctxt, typeDeser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt,
=======
    public Object[] deserializeWithType(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        return (Object[]) typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
        return (Object[]) typeDeserializer.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    protected Byte[] deserializeFromBase64(JsonParser jp, DeserializationContext ctxt)
        throws IOException, JsonProcessingException
=======
    protected Byte[] deserializeFromBase64(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt)
        throws IOException, JsonProcessingException
=======
    protected Object[] handleNonArray(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        // [JACKSON-620] Empty String can become null...
        if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
=======
        // Empty String can become null...
        if (p.hasToken(JsonToken.VALUE_STRING)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
            /* 04-Oct-2009, tatu: One exception; byte arrays are generally
             *   serialized as base64, so that should be handled
             */
            if (jp.getCurrentToken() == JsonToken.VALUE_STRING
                && _elementClass == Byte.class) {
                return deserializeFromBase64(jp, ctxt);
=======
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (!canWrap) {
            // One exception; byte arrays are generally serialized as base64, so that should be handled
            if (p.getCurrentToken() == JsonToken.VALUE_STRING
                    // note: not `byte[]`, but `Byte[]` -- former is primitive array
                    && _elementClass == Byte.class) {
                return deserializeFromBase64(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
            value = _elementDeserializer.deserialize(jp, ctxt);
=======
            value = _elementDeserializer.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
            value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer);
=======
            value = _elementDeserializer.deserializeWithType(p, ctxt, _elementTypeDeserializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
        super(String[].class);
        _elementDeserializer = null;
=======
        this(null, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    protected StringArrayDeserializer(JsonDeserializer<?> deser) {
=======
    protected StringArrayDeserializer(JsonDeserializer<?> deser, Boolean unwrapSingle) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public String[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt);
=======
        if (!p.isExpectedStartArrayToken()) {
            return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
            return _deserializeCustom(jp, ctxt);
=======
            return _deserializeCustom(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                        value = _parseString(jp, ctxt);
=======
                        value = _parseString(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected final String[] _deserializeCustom(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                if (jp.nextTextValue() == null) {
                    JsonToken t = jp.getCurrentToken();
=======
                if (p.nextTextValue() == null) {
                    JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                    value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt);
=======
                    value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                    value = deser.deserialize(jp, ctxt);
=======
                    value = deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return typeDeserializer.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    private final String[] handleNonArray(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
        // [JACKSON-526]: implicit arrays from single values?
        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
=======
        // implicit arrays from single values?
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (canWrap) {
            return new String[] { p.hasToken(JsonToken.VALUE_NULL) ? null : _parseString(p, ctxt) };
        } else if (p.hasToken(JsonToken.VALUE_STRING)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                String str = jp.getText();
                if (str.length() == 0) {
                    return null;
                }
=======
            String str = p.getText();
            if (str.length() == 0) {
                return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
        return this;
=======
        throw ctxt.mappingException(_valueClass);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
        } catch (Exception e) {
            throw wrapException(e);
=======
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
        } catch (Exception e) {
            throw wrapException(e);
=======
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        if (_delegateCreator == null) { // sanity-check; caller should check
            throw new IllegalStateException("No delegate constructor for "+getValueTypeDesc());
        }
        try {
            // First simple case: just delegate, no injectables
            if (_delegateArguments == null) {
                return _delegateCreator.call1(delegate);
            }
            // And then the case with at least one injectable...
            final int len = _delegateArguments.length;
            Object[] args = new Object[len];
            for (int i = 0; i < len; ++i) {
                SettableBeanProperty prop = _delegateArguments[i];
                if (prop == null) { // delegate
                    args[i] = delegate;
                } else { // nope, injectable:
                    args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null);
                }
            }
            // and then try calling with full set of arguments
            return _delegateCreator.call(args);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
        } catch (Exception e) {
            throw wrapException(e);
=======
        return _createUsingDelegate(_delegateCreator, _delegateArguments, ctxt, delegate);
    }

    @Override
    public Object createUsingArrayDelegate(DeserializationContext ctxt, Object delegate) throws IOException
    {
        if (_arrayDelegateCreator == null) { // sanity-check; caller should check
            // fallback to the classic delegate creator
            return createUsingDelegate(ctxt, delegate);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        if (_fromStringCreator != null) {
            try {
                return _fromStringCreator.call1(value);
            } catch (Exception e) {
                throw wrapException(e);
            } catch (ExceptionInInitializerError e) {
                throw wrapException(e);
            }
=======
        if (_fromStringCreator == null) {
            return _createFromStringFallbacks(ctxt, value);
        }
        try {
            return _fromStringCreator.call1(value);
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        } catch (Exception e) {
            throw wrapException(e);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
=======
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
            if (_fromLongCreator != null) {
                return _fromLongCreator.call1(Long.valueOf(value));
            }
        } catch (Exception e) {
            throw wrapException(e);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
=======
            return _fromLongCreator.call1(Long.valueOf(value));
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
            if (_fromDoubleCreator != null) {
                return _fromDoubleCreator.call1(Double.valueOf(value));
            }
        } catch (Exception e) {
            throw wrapException(e);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
=======
            return _fromDoubleCreator.call1(Double.valueOf(value));
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
            if (_fromBooleanCreator != null) {
                return _fromBooleanCreator.call1(Boolean.valueOf(value));
            }
        } catch (Exception e) {
            throw wrapException(e);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
=======
            return _fromBooleanCreator.call1(Boolean.valueOf(value));
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        while (t.getCause() != null) {
            t = t.getCause();
=======
        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only
        //   does so if and until `JsonMappingException` is found.
        for (Throwable curr = t; curr != null; curr = curr.getCause()) {
            if (curr instanceof JsonMappingException) {
                return (JsonMappingException) curr;
            }
        }
        return new JsonMappingException(null,
                "Instantiation of "+getValueTypeDesc()+" value failed: "+t.getMessage(), t);
    }

    /**
     * @since 2.7
     */
    protected JsonMappingException unwrapAndWrapException(DeserializationContext ctxt, Throwable t)
    {
        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only
        //   does so if and until `JsonMappingException` is found.
        for (Throwable curr = t; curr != null; curr = curr.getCause()) {
            if (curr instanceof JsonMappingException) {
                return (JsonMappingException) curr;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        return new JsonMappingException("Instantiation of "+getValueTypeDesc()+" value failed: "+t.getMessage(), t);
=======
        String msg = String.format("Instantiation of %s value failed (%s): %s",
                getValueTypeDesc(), t.getClass().getName(), t.getMessage());
        return JsonMappingException.from(ctxt.getParser(), msg, t);
    }

    /**
     * @since 2.7
     */
    protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt,
            Throwable t)
    {
        // 05-Nov-2015, tatu: Seems like there are really only 2 useless wrapper errors/exceptions,
        //    so just peel those, and nothing else
        if ((t instanceof ExceptionInInitializerError) // from static initialization block
                || (t instanceof InvocationTargetException) // from constructor/method
                ) {
            Throwable cause = t.getCause();
            if (cause != null) {
                t = cause;
            }
        }
        return wrapAsJsonMappingException(ctxt, t);
    }

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    private Object _createUsingDelegate(
            AnnotatedWithParams delegateCreator,
            SettableBeanProperty[] delegateArguments,
            DeserializationContext ctxt,
            Object delegate)
            throws IOException
    {
        if (delegateCreator == null) { // sanity-check; caller should check
            throw new IllegalStateException("No delegate constructor for "+getValueTypeDesc());
        }
        try {
            // First simple case: just delegate, no injectables
            if (delegateArguments == null) {
                return delegateCreator.call1(delegate);
            }
            // And then the case with at least one injectable...
            final int len = delegateArguments.length;
            Object[] args = new Object[len];
            for (int i = 0; i < len; ++i) {
                SettableBeanProperty prop = delegateArguments[i];
                if (prop == null) { // delegate
                    args[i] = delegate;
                } else { // nope, injectable:
                    args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null);
                }
            }
            // and then try calling with full set of arguments
            return delegateCreator.call(args);
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
        throw new JsonMappingException(msg, p.getTokenLocation());
=======
        throw JsonMappingException.from(p, msg);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
		break;
=======
                break;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null);
=======
        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
            JsonDeserializer<Object> delegateDeser)
=======
            JsonDeserializer<Object> delegateDeser,
            Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
            JsonDeserializer<?> vd, TypeDeserializer vtd)
=======
            JsonDeserializer<?> vd, TypeDeserializer vtd,
            Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) {
=======
        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)
                && (_unwrapSingle == unwrapSingle)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
                _valueInstantiator, (JsonDeserializer<Object>) dd);
=======
                _valueInstantiator, (JsonDeserializer<Object>) dd, unwrapSingle);
    }

    /**
     * @deprecated Since 2.7 as it does not pass `unwrapSingle`
     */
    @Deprecated // since 2.7 -- will not retain "unwrapSingle" setting
    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd,
            JsonDeserializer<?> vd, TypeDeserializer vtd)
    {
        return withResolved(dd, vd, vtd, _unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        // #125: May have a content converter
=======
        // May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        return withResolved(delegateDeser, valueDeser, valueTypeDeser);
=======
        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        if (p.getCurrentToken() == JsonToken.VALUE_STRING) {
=======
        if (p.hasToken(JsonToken.VALUE_STRING)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        // [JACKSON-526]: implicit arrays from single values?
        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
=======
        // Implicit arrays from single values?
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (!canWrap) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java;<<<<<<< MINE
 * so that other classes can access information about contained (value)
 * types
=======
 * so that other classes can access information about contained (value) types
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
            jp.nextToken();
            final T value = deserialize(jp, ctxt);
            if (jp.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
=======
        if (p.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
            p.nextToken();
            final T value = deserialize(p, ctxt);
            if (p.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {
=======
        if (p.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
                        throw new InvalidFormatException("Bracketed IPv6 address must contain closing bracket",
=======
                        throw new InvalidFormatException(ctxt.getParser(),
                                "Bracketed IPv6 address must contain closing bracket",
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,
=======
    public void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
            _throwAsIOE(e, value);
=======
            _throwAsIOE(p, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
    public Object deserializeSetAndReturn(JsonParser jp,
=======
    public Object deserializeSetAndReturn(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
            _throwAsIOE(e, value);
=======
            _throwAsIOE(p, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
    public void deserializeAndSet(JsonParser jp,
=======
    public void deserializeAndSet(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
            _throwAsIOE(e, value);
=======
            _throwAsIOE(p, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
    public Object deserializeSetAndReturn(JsonParser jp,
=======
    public Object deserializeSetAndReturn(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
            _throwAsIOE(e, value);
=======
            _throwAsIOE(p, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
    public CreatorCollector(BeanDescription beanDesc, boolean canFixAccess)
=======
    public CreatorCollector(BeanDescription beanDesc, MapperConfig<?> config)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        _canFixAccess = canFixAccess;
=======
        _canFixAccess = config.canOverrideAccessModifiers();
        _forceAccess = config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        maybeVanilla &= !_hasNonDefaultCreator;

        if (maybeVanilla) {
=======
        if (!_hasNonDefaultCreator) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        verifyNonDup(creator, C_DELEGATE, explicit);
        _delegateArgs = injectables;
=======
        if (creator.getParameterType(0).isCollectionLikeType()) {
            verifyNonDup(creator, C_ARRAY_DELEGATE, explicit);
            _arrayDelegateArgs = injectables;
        } else {
            verifyNonDup(creator, C_DELEGATE, explicit);
            _delegateArgs = injectables;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        // [JACKSON-470] Better ensure we have no duplicate names either...
=======
        // Better ensure we have no duplicate names either...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
            ClassUtil.checkAndFixAccess((Member) member.getAnnotated());
=======
            ClassUtil.checkAndFixAccess((Member) member.getAnnotated(), _forceAccess);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
    public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,
            Object instance)
        throws IOException, JsonProcessingException
=======
    public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
            Object instance) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
            throw new JsonMappingException("Problem deserializing 'setterless' property (\""+getName()+"\"): no way to handle typed deser with setterless yet");
=======
            throw JsonMappingException.from(p,
                    "Problem deserializing 'setterless' property (\""+getName()+"\"): no way to handle typed deser with setterless yet");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
            _throwAsIOE(e);
=======
            _throwAsIOE(p, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
            throw new JsonMappingException("Problem deserializing 'setterless' property '"+getName()+"': get method returned null");
=======
            throw JsonMappingException.from(p,
                    "Problem deserializing 'setterless' property '"+getName()+"': get method returned null");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
        _valueDeserializer.deserialize(jp, ctxt, toModify);
=======
        _valueDeserializer.deserialize(p, ctxt, toModify);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
    public Object deserializeSetAndReturn(JsonParser jp,
    		DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException
=======
    public Object deserializeSetAndReturn(JsonParser p,
    		DeserializationContext ctxt, Object instance) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
        deserializeAndSet(jp, ctxt, instance);
=======
        deserializeAndSet(p, ctxt, instance);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java;<<<<<<< MINE
                exception = new UnresolvedForwardReference("Unresolved forward references for: ");
=======
                exception = new UnresolvedForwardReference(getParser(), "Unresolved forward references for: ");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
    public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,
=======
    public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
            set(instance, propName, deserialize(jp, ctxt));
=======
            set(instance, propName, deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
                throw JsonMappingException.from(jp, "Unresolved forward reference but no identity info.", reference);
=======
                throw JsonMappingException.from(p, "Unresolved forward reference but no identity info.", reference);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
            return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);
=======
            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
        return _valueDeserializer.deserialize(jp, ctxt);
=======
        return _valueDeserializer.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
            throw new JsonMappingException(msg.toString(), null, e);
=======
            throw new JsonMappingException(null, msg.toString(), e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
        throw new JsonMappingException(t.getMessage(), null, t);
=======
        throw new JsonMappingException(null, t.getMessage(), t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // then 1.6 types:
        /* 17-May-2013, tatu: [Issue#216] Should be fine to use straight Class references EXCEPT
         *   that some godforsaken platforms (... looking at you, Android) do not
=======
        // then JDK 1.6 types:
        /* 17-May-2013, tatu: [databind#216] Should be fine to use straight Class references EXCEPT
         *   that some god-forsaken platforms (... looking at you, Android) do not
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                    throw new JsonMappingException("Broken registered ValueInstantiators (of type "
                            +insts.getClass().getName()+"): returned null ValueInstantiator");
=======
                    throw JsonMappingException.from(ctxt.getParser(),
                            "Broken registered ValueInstantiators (of type "+insts.getClass().getName()+"): returned null ValueInstantiator");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:
=======
        // Then optional type info: if type has been resolved, we may already know type deserializer:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                    // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled
=======
                    // [databind#292]: Actually, may be fine, but only if polymorphich deser enabled
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                    // [Issue#161]: No default constructor for ArrayBlockingQueue...
=======
                    // [databind#161]: No default constructor for ArrayBlockingQueue...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);
=======
                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:
=======
                // Can use more optimal deserializer if content type is String, so:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // and then new with 2.2: ability to post-process it too (Issue#120)
=======
        // allow post-processing it too
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    /* JsonDeserializerFactory impl: Enum deserializers
=======
    /* JsonDeserializerFactory impl: other types
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            // [JACKSON-193] May have @JsonCreator for static factory method:
=======
            // May have @JsonCreator for static factory method:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            // [JACKSON-749] Also, need to consider @JsonValue, if one found
=======
            // Need to consider @JsonValue if one found
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // and then new with 2.2: ability to post-process it too (Issue#120)
=======
        // and then post-process it too
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-505]: May need to figure out default implementation, if none found yet
=======
        // May need to figure out default implementation, if none found yet
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {
=======
            if (ai.hasCreatorAnnotation(factory)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                        if (factory.getGenericParameterType(0) != String.class) {
=======
                        if (factory.getRawParameterType(0) != String.class) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                            ClassUtil.checkAndFixAccess(factory.getMember());
=======
                            ClassUtil.checkAndFixAccess(factory.getMember(),
                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,
=======
    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException
    {
        for (Deserializers d  : _factoryConfig.deserializers()) {
            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);
            if (deser != null) {
                return deser;
            }
        }
        return null;
    }

    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
=======
            TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        Class<?> subclass = intr.findDeserializationType(a, type);
        if (subclass != null) {
            try {
                type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method '"+a.getName()+"': "+iae.getMessage(), null, iae);
            }
=======
        if (intr == null) {
            return type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapLikeType)) {
                    throw new JsonMappingException("Illegal key-type annotation: type "+type+" is not a Map(-like) type");
                }
                try {
                    type = (T) ((MapLikeType) type).narrowKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException("Failed to narrow key type "+type+" with key-type annotation ("+keyClass.getName()+"): "+iae.getMessage(), null, iae);
                }
            }
=======
        // First, deserializers for key/value types?
        if (type.isMapLikeType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
             *   (not 100% why or how, but this does seem to get called more than once, which
             *   is not good: for now, let's just avoid errors)
             */
=======
            // 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
            //  (not 100% why or how, but this does seem to get called more than once, which
            //   is not good: for now, let's just avoid errors)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
           
           // and finally content class; only applicable to structured types
           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
           if (cc != null) {
               try {
                   type = (T) type.narrowContentsBy(cc);
               } catch (IllegalArgumentException iae) {
                   throw new JsonMappingException("Failed to narrow content type "+type+" with content-type annotation ("+cc.getName()+"): "+iae.getMessage(), null, iae);
               }
           }
=======
        }
        JavaType contentType = type.getContentType();
        if (contentType != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-154]: Also need to handle keyUsing, contentUsing
        if (type.isContainerType()) {
            AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
=======
        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
        if (intr == null) {
            return type;
        }
        
        // Also need to handle keyUsing, contentUsing

        if (type.isMapLikeType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            // and all container types have content types...
=======
        }

        if (type.getContentType() != null) { // container type or reference type
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(accessor);
=======
                ClassUtil.checkAndFixAccess(accessor, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-212]: may need to use Enum.toString()
=======
        // May need to use Enum.toString()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
                deser = _handleUnknownValueDeserializer(propertyType);
=======
                deser = _handleUnknownValueDeserializer(ctxt, propertyType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            return _handleUnknownKeyDeserializer(type);
=======
            return _handleUnknownKeyDeserializer(ctxt, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            throw new JsonMappingException(iae.getMessage(), null, iae);
=======
            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        Class<?> subclass = intr.findDeserializationType(a, type);
        if (subclass != null) {
            try {
                type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method '"+a.getName()+"': "+iae.getMessage(), null, iae);
            }
=======
        if (intr == null) {
            return type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapLikeType)) {
                    throw new JsonMappingException("Illegal key-type annotation: type "+type+" is not a Map(-like) type");
                }
                try {
                    type = ((MapLikeType) type).narrowKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException("Failed to narrow key type "+type+" with key-type annotation ("+keyClass.getName()+"): "+iae.getMessage(), null, iae);
                }
            }
=======
        // First things first: find explicitly annotated deserializer(s)

        // then key/value handlers  (annotated deserializers)?
        if (type.isMapLikeType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
             *   (not 100% why or how, but this does seem to get called more than once, which
             *   is not good: for now, let's just avoid errors)
             */
=======
            // 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
            //   (not 100% why or how, but this does seem to get called more than once, which
            //   is not good: for now, let's just avoid errors)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            
            // and finally content class; only applicable to structured types
            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
            if (cc != null) {
                try {
                    type = type.narrowContentsBy(cc);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException("Failed to narrow content type "+type+" with content-type annotation ("+cc.getName()+"): "+iae.getMessage(), null, iae);
                }
            }
            // ... as well as deserializer for contents:
            JavaType contentType = type.getContentType();
=======
        }
        JavaType contentType = type.getContentType();
        if (contentType != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)
        throws JsonMappingException
=======
    // NOTE: changed 2.6 -> 2.7 to pass context; no way to make backwards compatible
    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type)
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            throw new JsonMappingException("Can not find a Value deserializer for abstract type "+type);
=======
            throw JsonMappingException.from(ctxt, "Can not find a Value deserializer for abstract type "+type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        throw new JsonMappingException("Can not find a Value deserializer for type "+type);
=======
        throw JsonMappingException.from(ctxt, "Can not find a Value deserializer for type "+type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)
=======
    protected KeyDeserializer _handleUnknownKeyDeserializer(DeserializationContext ctxt, JavaType type)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        throw new JsonMappingException("Can not find a (Map) Key deserializer for type "+type);
=======
        throw JsonMappingException.from(ctxt, "Can not find a (Map) Key deserializer for type "+type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
     * For 2.7?
=======
     * For 2.8?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
        JsonToken t = p.getCurrentToken();
        return _deserializeOther(p, ctxt, t);
=======
        return _deserializeOther(p, ctxt, p.getCurrentToken());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            // ignorable things should be ignored
=======
            // Things marked as ignorable should not be passed to any setter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE

            /* As per [JACKSON-313], things marked as ignorable should not be
             * passed to any setter
             */
=======
            // Things marked as ignorable should not be passed to any setter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            /* As per [JACKSON-313], things marked as ignorable should not be
             * passed to any setter
             */
=======
            // Things marked as ignorable should not be passed to any setter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                // [Issue#125]: allow use of converters
=======
                // [databind#125]: allow use of converters
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();
            // Need to create a temporary property to allow contextual deserializers:
            BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME,
                    delegateType, null, _classAnnotations, delegateCreator,
                    PropertyMetadata.STD_OPTIONAL);

            TypeDeserializer td = delegateType.getTypeHandler();
            if (td == null) {
                td = ctxt.getConfig().findTypeDeserializer(delegateType);
            }
            JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);
            if (td != null) {
                td = td.forProperty(property);
                dd = new TypeWrappedDeserializer(td, dd);
=======
            _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,
                    _valueInstantiator.getDelegateCreator());
        }

        // and array-delegate-based constructor:
        if (_valueInstantiator.canCreateUsingArrayDelegate()) {
            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());
            if (delegateType == null) {
                throw new IllegalArgumentException("Invalid array-delegate-creator definition for "+_beanType
                        +": value instantiator ("+_valueInstantiator.getClass().getName()
                        +") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            _delegateDeserializer = dd;
=======
            _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,
                    _valueInstantiator.getArrayDelegateCreator());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                            if (ctxt.getConfig().canOverrideAccessModifiers()) {
                                ClassUtil.checkAndFixAccess(ctor);
=======
                            if (ctxt.canOverrideAccessModifiers()) {
                                ClassUtil.checkAndFixAccess(ctor, ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                if (t == JsonToken.FIELD_NAME && _objectIdReader.maySerializeAsObject()
=======
                if ((t == JsonToken.FIELD_NAME) && _objectIdReader.maySerializeAsObject()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object _handleTypedObjectId(JsonParser jp, DeserializationContext ctxt,
=======
    protected Object _handleTypedObjectId(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        /* 07-Aug-2013, tatu: One more challenge: type of id may not be type
         *   of property we are expecting later on; specifically, numeric ids
         *   vs Strings.
         */
=======
        // One more challenge: type of id may not be type of property we are expecting
        // later on; specifically, numeric ids vs Strings.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            id = _convertObjectId(jp, ctxt, rawId, idDeser);
=======
            id = _convertObjectId(p, ctxt, rawId, idDeser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {
        return deserializeFromObject(jp, ctxt);
=======
    protected Object deserializeWithObjectId(JsonParser p, DeserializationContext ctxt) throws IOException {
        return deserializeFromObject(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected Object deserializeFromObjectId(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            throw new UnresolvedForwardReference("Could not resolve Object Id ["+id+"] (for "
                    +_beanType+").", jp.getCurrentLocation(), roid);
=======
            throw new UnresolvedForwardReference(p,
                    "Could not resolve Object Id ["+id+"] (for "+_beanType+").",
                    p.getCurrentLocation(), roid);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,
=======
    protected Object deserializeFromObjectUsingNonDefault(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                    _delegateDeserializer.deserialize(jp, ctxt));
=======
                    _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return _deserializeUsingPropertyBased(jp, ctxt);
=======
            return _deserializeUsingPropertyBased(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            throw JsonMappingException.from(jp, "Can not instantiate abstract type "+_beanType
=======
            throw JsonMappingException.from(p, "Can not instantiate abstract type "+_beanType
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throw JsonMappingException.from(jp, "No suitable constructor found for type "
=======
        throw JsonMappingException.from(p, "No suitable constructor found for type "
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected abstract Object _deserializeUsingPropertyBased(final JsonParser jp,
=======
    protected abstract Object _deserializeUsingPropertyBased(final JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return deserializeFromObjectId(jp, ctxt);
=======
            return deserializeFromObjectId(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        switch (jp.getNumberType()) {
=======
        switch (p.getNumberType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return _valueInstantiator.createFromInt(ctxt, jp.getIntValue());
=======
            return _valueInstantiator.createFromInt(ctxt, p.getIntValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return _valueInstantiator.createFromLong(ctxt, jp.getLongValue());
=======
            return _valueInstantiator.createFromLong(ctxt, p.getLongValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        switch (p.getNumberType()) {
        case FLOAT: // no separate methods for taking float...
        case DOUBLE:
=======
        NumberType t = p.getNumberType();
        // no separate methods for taking float...
        if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    public Object deserializeFromEmbedded(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserializeFromEmbedded(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return deserializeFromObjectId(jp, ctxt);
=======
            return deserializeFromObjectId(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        return jp.getEmbeddedObject();
=======
        return p.getEmbeddedObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected void handleUnknownVanilla(JsonParser jp, DeserializationContext ctxt,
=======
    protected void handleUnknownVanilla(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            handleIgnoredProperty(jp, ctxt, bean, propName);
=======
            handleIgnoredProperty(p, ctxt, bean, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);
=======
                _anySetter.deserializeAndSet(p, ctxt, bean, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            handleUnknownProperty(jp, ctxt, bean, propName);         
=======
            handleUnknownProperty(p, ctxt, bean, propName);         
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt,
=======
    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            jp.skipChildren();
=======
            p.skipChildren();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            handleIgnoredProperty(jp, ctxt, beanOrClass, propName);
=======
            handleIgnoredProperty(p, ctxt, beanOrClass, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        super.handleUnknownProperty(jp, ctxt, beanOrClass, propName);
=======
        super.handleUnknownProperty(p, ctxt, beanOrClass, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected void handleIgnoredProperty(JsonParser jp, DeserializationContext ctxt,
=======
    protected void handleIgnoredProperty(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            throw IgnoredPropertyException.from(jp, beanOrClass, propName, getKnownPropertyNames());
=======
            throw IgnoredPropertyException.from(p, beanOrClass, propName, getKnownPropertyNames());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        jp.skipChildren();
=======
        p.skipChildren();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
     * @param jp (optional) If not null, parser that has more properties to handle
=======
     * @param p (optional) If not null, parser that has more properties to handle
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt,                                          
=======
    protected Object handlePolymorphic(JsonParser p, DeserializationContext ctxt,                                          
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            if (jp != null) {
                bean = subDeser.deserialize(jp, ctxt, bean);
=======
            if (p != null) {
                bean = subDeser.deserialize(p, ctxt, bean);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        if (jp != null) {
            bean = deserialize(jp, ctxt, bean);
=======
        if (p != null) {
            bean = deserialize(p, ctxt, bean);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
 * Unlike with {@link com.fasterxml.jackson.databind.ser.Serializers},
 * multiple different methods are used since different kinds of types typically
 * require different kinds of inputs.
=======
 * It is <b>strongly recommended</b> that implementations always extend {@link Deserializers.Base}
 * and NOT just implement {@link Deserializers}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findArrayDeserializer(ArrayType type,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
=======
        public JsonDeserializer<?> findEnumDeserializer(Class<?> type,
                DeserializationConfig config, BeanDescription beanDesc)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findCollectionDeserializer(CollectionType type,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
=======
        public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
                DeserializationConfig config, BeanDescription beanDesc)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
=======
        public JsonDeserializer<?> findBeanDeserializer(JavaType type,
                DeserializationConfig config, BeanDescription beanDesc)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findMapDeserializer(MapType type,
=======
        public JsonDeserializer<?> findArrayDeserializer(ArrayType type,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type,
=======
        public JsonDeserializer<?> findCollectionDeserializer(CollectionType type,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findEnumDeserializer(Class<?> type,
                DeserializationConfig config, BeanDescription beanDesc)
=======
        public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
                DeserializationConfig config, BeanDescription beanDesc)
=======
        public JsonDeserializer<?> findMapDeserializer(MapType type,
                DeserializationConfig config, BeanDescription beanDesc,
                KeyDeserializer keyDeserializer,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findBeanDeserializer(JavaType type,
                DeserializationConfig config, BeanDescription beanDesc)
=======
        public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type,
                DeserializationConfig config, BeanDescription beanDesc,
                KeyDeserializer keyDeserializer,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        if (type.isAbstract()) {
            // [JACKSON-41] (v1.6): Let's make it possible to materialize abstract types.
=======
        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
        //    not something we could materialize anything for
        if (type.isAbstract() && !type.isPrimitive()) {
            // Let's make it possible to materialize abstract types.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            	ClassUtil.checkAndFixAccess(buildMethod.getMember());
=======
            	ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                    am.getGenericParameterType(0));
=======
                    am.getParameterType(0));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                 *   to set (with new 1.9 code)... but let's replace it just in case,
=======
                 *   to set... but let's replace it just in case,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-794]: JDK 7 also added "getSuppressed", skip if we have such data:
=======
        // Java 7 also added "getSuppressed", skip if we have such data:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-440]: update builder now that all information is in?
=======
        // update builder now that all information is in?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:
=======
        // may have modifier(s) that wants to modify or replace serializer we just built:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
             *   we need to do linkage (as per [Issue#318]), and so need to start with
=======
             *   we need to do linkage (as per [databind#318]), and so need to start with
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                /* As per [JACKSON-88], may also need to consider getters
=======
                /* May also need to consider getters
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                    genericType = ((AnnotatedMethod) m).getGenericParameterType(0);
=======
                    type = ((AnnotatedMethod) m).getParameterType(0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                    genericType = m.getRawType();
=======
                    type = m.getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                        ctxt, beanDesc, propDef, genericType));
=======
                        ctxt, beanDesc, propDef, type));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                    m.fixAccess(); // to ensure we can call it
=======
                    m.fixAccess(forceAccess); // to ensure we can call it
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                        beanDesc.resolveType(m.getGenericType()),
=======
                        m.getType(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            setter.fixAccess(); // to ensure we can call it
=======
            setter.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); // to ensure we can call it
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            Type jdkType)
=======
            JavaType propType0)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            mutator.fixAccess();
=======
            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                t0, propDef.getWrapperName(),
=======
                propType0, propDef.getWrapperName(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        if (type != t0) {
=======
        if (type != propType0) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            getter.fixAccess();
=======
            getter.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    implements BeanProperty,
        java.io.Serializable
=======
    extends ConcreteBeanPropertyBase
    implements java.io.Serializable
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    public JsonFormat.Value findFormatOverrides(AnnotationIntrospector intr) {
        if (intr != null) {
            AnnotatedMember m = getMember();
            if (m != null) {
                return intr.findFormat(m);
            }
        }
        return null;
    }

    @Override
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)
=======
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    protected void _throwAsIOE(Exception e, Object value) throws IOException
=======
    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
            throw new JsonMappingException(msg.toString(), null, e);
=======
            throw JsonMappingException.from(p, msg.toString(), e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _throwAsIOE(e);
=======
        _throwAsIOE(p, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE

    protected IOException _throwAsIOE(Exception e) throws IOException
=======
    
    /**
     * @since 2.7
     */
    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        throw new JsonMappingException(th.getMessage(), null, th);
=======
        throw JsonMappingException.from(p, th.getMessage(), th);
    }

    @Deprecated // since 2.7
    protected IOException _throwAsIOE(Exception e) throws IOException {
        return _throwAsIOE((JsonParser) null, e);
    }

    // 10-Oct-2015, tatu: _Should_ be deprecated, too, but its remaining
    //   callers can not actually provide a JsonParser
    protected void _throwAsIOE(Exception e, Object value) throws IOException {
        _throwAsIOE((JsonParser) null, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
            JsonToken t = jp.getCurrentToken();
            // should be good enough check; we only care about Strings, integral numbers:
            if (t != null && t.isScalarValue()) {
                return _deserializeFromObjectId(jp, ctxt);
=======
            JsonToken t = p.getCurrentToken();
            if (t != null) {
                // Most commonly, a scalar (int id, uuid String, ...)
                if (t.isScalarValue()) {
                    return _deserializeFromObjectId(p, ctxt);
                }
                // but, with 2.5+, a simple Object-wrapped value also legal:
                if (t == JsonToken.START_OBJECT) {
                    t = p.nextToken();
                }
                if ((t == JsonToken.FIELD_NAME) && _objectIdReader.maySerializeAsObject()
                        && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {
                    return _deserializeFromObjectId(p, ctxt);
                }
            
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);
=======
        return typeDeserializer.deserializeTypedFromObject(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
    public Object deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException
=======
    public Object deserialize(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected Object _deserializeIfNatural(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        /* As per [JACKSON-417], there is a chance we might be "natural" types
=======
        /* There is a chance we might be "natural" types
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        switch (jp.getCurrentTokenId()) {
=======
        switch (p.getCurrentTokenId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
                return jp.getText();
=======
                return p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
                return jp.getIntValue();
=======
                return p.getIntValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
                return Double.valueOf(jp.getDoubleValue());
=======
                return Double.valueOf(p.getDoubleValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected Object _deserializeFromObjectId(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
            throw new UnresolvedForwardReference("Could not resolve Object Id ["+id+"] -- unresolved forward-reference?", jp.getCurrentLocation(), roid);
=======
            throw new UnresolvedForwardReference(p,
                    "Could not resolve Object Id ["+id+"] -- unresolved forward-reference?", p.getCurrentLocation(), roid);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java;<<<<<<< MINE
    public UnresolvedForwardReference(String msg, JsonLocation loc, ReadableObjectId roid)
    {
=======
    /**
     * @since 2.7
     */
    public UnresolvedForwardReference(JsonParser p, String msg, JsonLocation loc, ReadableObjectId roid) {
        super(p, msg, loc);
        _roid = roid;
    }

    /**
     * @since 2.7
     */
    public UnresolvedForwardReference(JsonParser p, String msg) {
        super(p, msg);
        _unresolvedIds = new ArrayList<UnresolvedId>();
    }

    /**
     * @deprecated Since 2.7
     */
    @Deprecated // since 2.7
    public UnresolvedForwardReference(String msg, JsonLocation loc, ReadableObjectId roid) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java;<<<<<<< MINE
    public UnresolvedForwardReference(String msg)
    {
=======
    /**
     * @deprecated Since 2.7
     */
    @Deprecated // since 2.7
    public UnresolvedForwardReference(String msg) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java;<<<<<<< MINE
    // ******************************
    // ****** Accessor methods ******
    // ******************************
=======
    /*
    /**********************************************************
    /* Accessor methods
    /**********************************************************
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java;<<<<<<< MINE
        for (Enum<?> e : enumValues) {
            map.put(ai.findEnumValue(e), e);
=======
        for (int i = 0, len = enumValues.length; i < len; ++i) {
            String name = names[i];
            if (name == null) {
                name = enumValues[i].name();
            }
            map.put(name, enumValues[i]);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        Package pkg = compType.getPackage();
        if (pkg != null) {
            String pname = pkg.getName();
            if (pname.contains(".cglib")) {
                if (pname.startsWith("net.sf.cglib")
=======
        String pkgName = ClassUtil.getPackageName(compType);
        if (pkgName != null) {
            if (pkgName.contains(".cglib")) {
                if (pkgName.startsWith("net.sf.cglib")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
                    || pname.startsWith("org.hibernate.repackage.cglib")
=======
                    || pkgName.startsWith("org.hibernate.repackage.cglib")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
                    || pname.startsWith("org.springframework.cglib")
=======
                    || pkgName.startsWith("org.springframework.cglib")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        Package pkg = argType.getPackage();
        if (pkg != null && pkg.getName().startsWith("groovy.lang")) {
=======
        String pkgName = ClassUtil.getPackageName(argType);
        if (pkgName != null && pkgName.startsWith("groovy.lang")) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        Package pkg = rt.getPackage();
        if (pkg != null && pkg.getName().startsWith("groovy.lang")) {
=======
        String pkgName = ClassUtil.getPackageName(rt);
        if (pkgName != null && pkgName.startsWith("groovy.lang")) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        // otherwise, lower case initial chars
        StringBuilder sb = null;
        for (int i = offset; i < end; ++i) {
            char upper = basename.charAt(i);
            char lower = Character.toLowerCase(upper);
            if (upper == lower) {
=======
        // next check: is the first character upper case? If not, return as is
        char c = basename.charAt(offset);
        char d = Character.toLowerCase(c);
        
        if (c == d) {
            return basename.substring(offset);
        }
        // otherwise, lower case initial chars. Common case first, just one char
        StringBuilder sb = new StringBuilder(end - offset);
        sb.append(d);
        int i = offset+1;
        for (; i < end; ++i) {
            c = basename.charAt(i);
            d = Character.toLowerCase(c);
            if (c == d) {
                sb.append(basename, i, end);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
            if (sb == null) {
                int l = end-offset;
                sb = new StringBuilder(l);
                sb.append(basename, offset, end);
            }
            sb.setCharAt(i-offset, lower);
=======
            sb.append(d);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        return (sb == null) ? basename.substring(offset) : sb.toString();
=======
        return sb.toString();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        _addSuperTypes(cls, endBefore, result, false);
=======
        _addRawSuperTypes(cls, endBefore, result, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    
    private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) {
=======

    private static void _addSuperTypes(JavaType type, Class<?> endBefore, Collection<JavaType> result,
            boolean addClassItself)
    {
        if (type == null) {
            return;
        }
        final Class<?> cls = type.getRawClass();
        if (cls == endBefore || cls == Object.class) { return; }
        if (addClassItself) {
            if (result.contains(type)) { // already added, no need to check supers
                return;
            }
            result.add(type);
        }
        for (JavaType intCls : type.getInterfaces()) {
            _addSuperTypes(intCls, endBefore, result, true);
        }
        _addSuperTypes(type.getSuperClass(), endBefore, result, true);
    }

    private static void _addRawSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        for (Class<?> intCls : cls.getInterfaces()) {
            _addSuperTypes(intCls, endBefore, result, true);
=======
        for (Class<?> intCls : _interfaces(cls)) {
            _addRawSuperTypes(intCls, endBefore, result, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        _addSuperTypes(cls.getSuperclass(), endBefore, result, true);
=======
        _addRawSuperTypes(cls.getSuperclass(), endBefore, result, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
            if (type.getEnclosingMethod() != null) {
=======
            if (hasEnclosingMethod(type)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
                if (type.getEnclosingClass() != null) {
                    if (!Modifier.isStatic(type.getModifiers())) {
=======
                if (!Modifier.isStatic(type.getModifiers())) {
                    if (getEnclosingClass(type) != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
            if (type.getEnclosingMethod() != null) {
=======
            if (hasEnclosingMethod(type)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
                return type.getEnclosingClass();
=======
                return getEnclosingClass(type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        // As per [Issue#57], should NOT disqualify JDK proxy:
=======
        // As per [databind#57], should NOT disqualify JDK proxy:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
     * Method called to check if we can use the passed method or constructor
     * (wrt access restriction -- public methods can be called, others
     * usually not); and if not, if there is a work-around for
     * the problem.
=======
     * Equivalent to call:
     *<pre>
     *   checkAndFixAccess(member, false);
     *</pre>
     *
     * @deprecated Since 2.7 call variant that takes boolean flag.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    public static void checkAndFixAccess(Member member)
=======
    @Deprecated
    public static void checkAndFixAccess(Member member) {
        checkAndFixAccess(member, false);
    }

    /**
     * Method that is called if a {@link Member} may need forced access,
     * to force a field, method or constructor to be accessible: this
     * is done by calling {@link AccessibleObject#setAccessible(boolean)}.
     * 
     * @param member Accessor to call <code>setAccessible()</code> on.
     * @param force Whether to always try to make accessor accessible (true),
     *   or only if needed as per access rights (false)
     *
     * @since 2.7
     */
    public static void checkAndFixAccess(Member member, boolean force)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
            ao.setAccessible(true);
=======
            if (force || 
                    (!Modifier.isPublic(member.getModifiers())
                            || !Modifier.isPublic(member.getDeclaringClass().getModifiers()))) {
                ao.setAccessible(true);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
	public static Class<? extends Enum<?>> findEnumType(Enum<?> en)
=======
    public static Class<? extends Enum<?>> findEnumType(Enum<?> en)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        return (cls.getEnclosingClass() != null)
                && !Modifier.isStatic(cls.getModifiers());
=======
        return !Modifier.isStatic(cls.getModifiers())
                && (getEnclosingClass(cls) != null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
    /**
     * ID to represent the 'GMT' string
     */
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * @since 2.6
=======
     * ID to represent the 'UTC' string, default timezone since Jackson 2.7
     * 
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * @since 2.6
=======
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * Timezone we use for 'Z' in ISO-8601 date/time values.
=======
     * Timezone we use for 'Z' in ISO-8601 date/time values: since 2.7
     * {@link #TIMEZONE_UTC}; with earlier versions up to 2.7 was {@link #TIMEZONE_GMT}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)
=======
     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
        return format(date, false, TIMEZONE_GMT);
=======
        return format(date, false, TIMEZONE_UTC);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
        return format(date, millis, TIMEZONE_GMT);
=======
        return format(date, millis, TIMEZONE_UTC);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * @param tz timezone to use for the formatting (GMT will produce 'Z')
=======
     * @param tz timezone to use for the formatting (UTC will produce 'Z')
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
                            milliseconds = parseInt(date, offset += 1, offset += 3);
=======
                            offset += 1;
                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
                            int fraction = parseInt(date, offset, parseEndOffset);
                            // compensate for "missing" digits
                            switch (parseEndOffset - offset) { // number of digits parsed
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                            }
                            offset = endOffset;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
	/**
=======
    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
    /**
     * @since 2.2 Use {@link #construct} instead
     */
    @Deprecated
    public SimpleBeanPropertyDefinition(AnnotatedMember member) {
        this(member, member.getName(), null);
=======
    protected SimpleBeanPropertyDefinition(AnnotatedMember member, PropertyName fullName,
            AnnotationIntrospector intr, PropertyMetadata metadata,
            JsonInclude.Include inclusion)
    {
        this(member, fullName, intr, metadata,
                ((inclusion == null) || (inclusion == JsonInclude.Include.USE_DEFAULTS)
                        ? EMPTY_INCLUDE : JsonInclude.Value.construct(inclusion, null)));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
            JsonInclude.Include inclusion)
=======
            JsonInclude.Value inclusion)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
        this(member, new PropertyName(name), intr, null, null);
=======
        this(member, new PropertyName(name), intr, null, EMPTY_INCLUDE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
                        null, null);
=======
                        null, EMPTY_INCLUDE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
                        null, null);
=======
                        null, EMPTY_INCLUDE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
        return construct(config, member, name, null, null);
=======
        return construct(config, member, name, null, EMPTY_INCLUDE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
    public BeanPropertyDefinition withInclusion(JsonInclude.Include inclusion) {
=======
    public BeanPropertyDefinition withInclusion(JsonInclude.Value inclusion) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
    public JsonInclude.Include findInclusion() {
=======
    public JsonInclude.Value findInclusion() {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
            return EmptyIterator.instance();
=======
            return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java;<<<<<<< MINE
        Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass);
        Enum<?>[] values = cls.getEnumConstants();
        if (values != null) {
            SerializableString[] textual = new SerializableString[values.length];
            for (Enum<?> en : values) {
                String value = config.getAnnotationIntrospector().findEnumValue(en);
                textual[en.ordinal()] = config.compileString(value);
=======
        Class<? extends Enum<?>> enumCls = ClassUtil.findEnumType(enumClass);
        Enum<?>[] enumValues = enumCls.getEnumConstants();
        if (enumValues == null) {
            throw new IllegalArgumentException("Can not determine enum constants for Class "+enumClass.getName());
        }
        String[] names = config.getAnnotationIntrospector().findEnumValues(enumCls, enumValues, new String[enumValues.length]);
        SerializableString[] textual = new SerializableString[enumValues.length];
        for (int i = 0, len = enumValues.length; i < len; ++i) {
            Enum<?> en = enumValues[i];
            String name = names[i];
            if (name == null) {
                name = en.name();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java;<<<<<<< MINE
            return new EnumValues(enumClass, textual);
=======
            textual[en.ordinal()] = config.compileString(name);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java;<<<<<<< MINE
        throw new IllegalArgumentException("Can not determine enum constants for Class "+enumClass.getName());
=======
        return new EnumValues(enumClass, textual);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE
     * Do we currnetly have a native type or object id buffered?
=======
     * Do we currently have a native type or object id buffered?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE
                        throw new JsonGenerationException("Unrecognized value type for VALUE_NUMBER_FLOAT: "+n.getClass().getName()+", can not serialize");
=======
                        throw new JsonGenerationException(String.format(
                                "Unrecognized value type for VALUE_NUMBER_FLOAT: %s, can not serialize",
                                n.getClass().getName()), gen);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdConverter.java;<<<<<<< MINE
    public JavaType getInputType(TypeFactory typeFactory)
    {
        JavaType[] types = typeFactory.findTypeParameters(getClass(), Converter.class);
        if (types == null || types.length < 2) {
            throw new IllegalStateException("Can not find OUT type parameter for Converter of type "+getClass().getName());
        }
        return types[0];
=======
    public JavaType getInputType(TypeFactory typeFactory) {
        return _findConverterType(typeFactory).containedType(0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdConverter.java;<<<<<<< MINE
    public JavaType getOutputType(TypeFactory typeFactory)
    {
        JavaType[] types = typeFactory.findTypeParameters(getClass(), Converter.class);
        if (types == null || types.length < 2) {
=======
    public JavaType getOutputType(TypeFactory typeFactory) {
        return _findConverterType(typeFactory).containedType(1);
    }

    protected JavaType _findConverterType(TypeFactory tf) {
        JavaType thisType = tf.constructType(getClass());
        JavaType convType = thisType.findSuperType(Converter.class);
        if (convType == null || convType.containedTypeCount() < 2) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdConverter.java;<<<<<<< MINE
        return types[1];
=======
        return convType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
     * (or "GMT")
=======
     * (or "UTC")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
     * By default we use GMT for everything.
=======
     * By default we use UTC for everything, with Jackson 2.7 and later
     * (2.6 and earlier relied on GMT)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        DEFAULT_TIMEZONE = TimeZone.getTimeZone("GMT");
=======
        DEFAULT_TIMEZONE = TimeZone.getTimeZone("UTC"); // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        /* Another important thing: let's force use of GMT for
=======
        /* Another important thing: let's force use of default timezone for
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return new StdDateFormat(tz, _locale);
=======
        return new StdDateFormat(tz, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return new StdDateFormat(_timezone, loc);
=======
        return new StdDateFormat(_timezone, loc, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return new StdDateFormat(_timezone, _locale);
    }

    /**
     * Method for getting the globally shared DateFormat instance
     * that uses GMT timezone and can handle simple ISO-8601
     * compliant date format.
     * 
     * @deprecated Since 2.4 not to be used.
     */
    @Deprecated
    public static DateFormat getBlueprintISO8601Format() {
        return DATE_FORMAT_ISO8601;
=======
        return new StdDateFormat(_timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc);
    }
    
    /**
     * Method for getting the globally shared DateFormat instance
     * that uses GMT timezone and can handle RFC-1123
     * compliant date format.
     * 
     * @deprecated Since 2.4 not to be used.
     */
    @Deprecated
    public static DateFormat getBlueprintRFC1123Format() {
        return DATE_FORMAT_RFC1123;
=======
        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc);
=======
        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                tz, loc, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    /* Public API
=======
    /* Public API, configuration
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        Date result = parse(dateStr, pos);
        if (result != null) {
            return result;
=======

        Date dt;

        if (looksLikeISO8601(dateStr)) { // also includes "plain"
            dt = parseAsISO8601(dateStr, pos, true);
        } else {
            // Also consider "stringified" simple time stamp
            int i = dateStr.length();
            while (--i >= 0) {
                char ch = dateStr.charAt(i);
                if (ch < '0' || ch > '9') {
                    // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                    if (i > 0 || ch != '-') {
                        break;
                    }
                }
            }
            if ((i < 0)
                // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
                dt = new Date(Long.parseLong(dateStr));
            } else {
                // Otherwise, fall back to using RFC 1123
                dt = parseAsRFC1123(dateStr, pos);
            }
        }
        if (dt != null) {
            return dt;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            return parseAsISO8601(dateStr, pos);
=======
            try {
                return parseAsISO8601(dateStr, pos, false);
            } catch (ParseException e) { // will NOT be thrown due to false but is declared...
                return null;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also
         *   consider "stringified" simple time stamp
         */
=======
        // Also consider "stringified" simple time stamp
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                // 07-Aug-2013, tatu: And #267 points out that negative numbers should also work
=======
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
=======
            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,
                    _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    protected Date parseAsISO8601(String dateStr, ParsePosition pos)
=======
    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)
            throws ParseException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        /* First: do we have "zulu" format ('Z' == "GMT")? If yes, that's
=======
        /* First: do we have "zulu" format ('Z' == "UTC")? If yes, that's
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
         * GMT, and hence can just strip out 'Z' altogether
=======
         * UTC, and hence can just strip out 'Z' altogether
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        // [JACKSON-200]: need to support "plain" date...
=======
        // Need to support "plain" date...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
=======
                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,
                        _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
=======
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
                        _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            // [JACKSON-334]: may be missing milliseconds... if so, add
=======
            // may be missing milliseconds... if so, add
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
=======
                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,
                            _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,
                            _timezone, _locale);
=======
                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
                            _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return df.parse(dateStr, pos);
=======
        Date dt = df.parse(dateStr, pos);
        // 22-Dec-2015, tatu: With non-lenient, may get null
        if (dt == null) {
            throw new ParseException
            (String.format("Can not parse date \"%s\": while it seems to fit format '%s', parsing fails (leniency? %s)",
                           dateStr, formatStr, _lenient),
               pos.getErrorIndex());
        }
        return dt;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);
=======
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                    _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            TimeZone tz, Locale loc)
=======
            TimeZone tz, Locale loc, Boolean lenient)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
    public JavaType getType(TypeBindings context) {
        return context.resolveType(getGenericType());
=======
    @Deprecated
    public final JavaType getType(TypeBindings bogus) {
        return getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes,
            AnnotationIntrospector aintr, MixInResolver mir,
=======
    private AnnotatedClass(JavaType type, Class<?> rawType, TypeBindings bindings,
            List<JavaType> superTypes,
            AnnotationIntrospector aintr, MixInResolver mir, TypeFactory tf,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _class = cls;
=======
        _type = type;
        _class = rawType;
        _bindings = bindings;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedClass(_class, _superTypes,
                _annotationIntrospector, _mixInResolver, ann);
=======
        return new AnnotatedClass(_type, _class, _bindings, _superTypes,
                _annotationIntrospector, _mixInResolver, _typeFactory, ann);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    public static AnnotatedClass construct(Class<?> cls,
            AnnotationIntrospector aintr, MixInResolver mir)
=======
    public static AnnotatedClass construct(JavaType type, MapperConfig<?> config) {
        AnnotationIntrospector intr = config.isAnnotationProcessingEnabled()
                ? config.getAnnotationIntrospector() : null;
        Class<?> raw = type.getRawClass();
        return new AnnotatedClass(type, raw, type.getBindings(),
                ClassUtil.findSuperTypes(type, null, false), intr,
                (MixInResolver) config, config.getTypeFactory(), null);
    }

    /**
     * @since 2.7
     */
    public static AnnotatedClass construct(JavaType type, MapperConfig<?> config,
            MixInResolver mir)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedClass(cls,
                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);
=======
        AnnotationIntrospector intr = config.isAnnotationProcessingEnabled()
                ? config.getAnnotationIntrospector() : null;
        Class<?> raw = type.getRawClass();
        return new AnnotatedClass(type, raw, type.getBindings(),
                ClassUtil.findSuperTypes(type, null, false),
                intr, mir, config.getTypeFactory(), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls,
            AnnotationIntrospector aintr, MixInResolver mir)
=======
    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, MapperConfig<?> config)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedClass(cls,
                Collections.<Class<?>>emptyList(), aintr, mir, null);
=======
        if (config == null) {
            return new AnnotatedClass(null, cls, TypeBindings.emptyBindings(),
                    Collections.<JavaType>emptyList(), null, null, null, null);
        }
        AnnotationIntrospector intr = config.isAnnotationProcessingEnabled()
                ? config.getAnnotationIntrospector() : null;
        return new AnnotatedClass(null, cls, TypeBindings.emptyBindings(),
                Collections.<JavaType>emptyList(), intr, (MixInResolver) config, config.getTypeFactory(), null);
    }

    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, MapperConfig<?> config,
            MixInResolver mir)
    {
        if (config == null) {
            return new AnnotatedClass(null, cls, TypeBindings.emptyBindings(),
                    Collections.<JavaType>emptyList(), null, null, null, null);
        }
        AnnotationIntrospector intr = config.isAnnotationProcessingEnabled()
                ? config.getAnnotationIntrospector() : null;
        return new AnnotatedClass(null, cls, TypeBindings.emptyBindings(),
                Collections.<JavaType>emptyList(), intr, mir, config.getTypeFactory(), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    public <A extends Annotation> A getAnnotation(Class<A> acls)
    {
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations.get(acls);
=======
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _classAnnotations().get(acls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    public Type getGenericType() {
        return _class;
=======
    public boolean hasAnnotation(Class<?> acls) {
        return _classAnnotations().has(acls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations.annotations();
=======
        return _classAnnotations().annotations();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations;
=======
        return _classAnnotations();
    }

    @Override
    public JavaType getType() {
        return _type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations;
=======
        return _classAnnotations();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations.size() > 0;
=======
        return _classAnnotations().size() > 0;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    private void resolveClassAnnotations()
=======
    private AnnotationMap _resolveClassAnnotations()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        // [JACKSON-659] Should skip processing if annotation processing disabled
=======
        // Should skip processing if annotation processing disabled
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            _addAnnotationsIfNotPresent(ca, _class.getDeclaredAnnotations());
=======
            _addAnnotationsIfNotPresent(ca,
                    ClassUtil.findClassAnnotations(_class));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            for (Class<?> cls : _superTypes) {
=======
            for (JavaType type : _superTypes) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                _addClassMixIns(ca, cls);
                _addAnnotationsIfNotPresent(ca, cls.getDeclaredAnnotations());
=======
                _addClassMixIns(ca, type);
                _addAnnotationsIfNotPresent(ca,
                        ClassUtil.findClassAnnotations(type.getRawClass()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _classAnnotations = ca;
=======
        return ca;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();
        for (Constructor<?> ctor : declaredCtors) {
            if (_isIncludableConstructor(ctor)) {
                if (ctor.getParameterTypes().length == 0) {
                    _defaultConstructor = _constructConstructor(ctor, true);
=======
        ClassUtil.Ctor[] declaredCtors = ClassUtil.getConstructors(_class);
        // Constructor also always members of this class, so
        TypeResolutionContext typeContext = this;        
        for (ClassUtil.Ctor ctor : declaredCtors) {
            if (_isIncludableConstructor(ctor.getConstructor())) {
                if (ctor.getParamCount() == 0) {
                    _defaultConstructor = _constructDefaultConstructor(ctor, typeContext);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                    constructors.add(_constructConstructor(ctor, false));
=======
                    constructors.add(_constructNonDefaultConstructor(ctor, typeContext));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:
=======
        // AnnotationIntrospector is null if annotations not enabled; if so, can skip:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            // all factory methods are fine, as per [JACKSON-850]
=======
            // all factory methods are fine:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            creatorMethods.add(_constructCreatorMethod(m));
=======
            creatorMethods.add(_constructCreatorMethod(m, typeContext));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);
        
=======
        _addMemberMethods(_class, this, _memberMethods, _primaryMixIn, mixins);

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Class<?> cls : _superTypes) {
            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         
            _addMemberMethods(cls, _memberMethods, mixin, mixins);
=======
        for (JavaType type : _superTypes) {
            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(type.getRawClass());
            TypeResolutionContext typeContext = new TypeResolutionContext.Basic(_typeFactory,
                    type.getBindings());
            _addMemberMethods(type.getRawClass(), typeContext, _memberMethods, mixin, mixins);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)
=======
    protected void _addClassMixIns(AnnotationMap annotations, JavaType target)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                                   Class<?> mixin)
=======
            Class<?> mixin)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());
=======
        _addAnnotationsIfNotPresent(annotations, ClassUtil.findClassAnnotations(mixin));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {
            _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations());
=======
        for (Class<?> parent : ClassUtil.findSuperClasses(mixin, toMask, false)) {
            _addAnnotationsIfNotPresent(annotations, ClassUtil.findClassAnnotations(parent));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {
=======
        for (ClassUtil.Ctor ctor0 : ClassUtil.getConstructors(mixin)) {
            Constructor<?> ctor = ctor0.getConstructor();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Method m : mixin.getDeclaredMethods()) {
=======
        for (Method m : ClassUtil.getDeclaredMethods(mixin)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,
=======
    protected void _addMemberMethods(Class<?> cls, TypeResolutionContext typeContext,
            AnnotatedMethodMap methods,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            for (Method m : mixin.getDeclaredMethods()) {
=======
            for (Method m : ClassUtil.getDeclaredMethods(mixin)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                    // Well, or, as per [Issue#515], multi-level merge within mixins...
=======
                    // Well, or, as per [databind#515], multi-level merge within mixins...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                        mixIns.add(_constructMethod(m));
=======
                        // 03-Nov-2015, tatu: Mix-in method never called, should not need
                        //    to resolve generic types, so this class is fine as context
                        mixIns.add(_constructMethod(m, this));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)
=======
    protected Map<String,AnnotatedField> _findFields(JavaType type,
            TypeResolutionContext typeContext, Map<String,AnnotatedField> fields)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            fields = _findFields(parent, fields);
            for (Field f : c.getDeclaredFields()) {
=======
            fields = _findFields(parent,
                    new TypeResolutionContext.Basic(_typeFactory, parent.getBindings()),
                    fields);
            for (Field f : ClassUtil.getDeclaredFields(cls)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                fields.put(f.getName(), _constructField(f));
=======
                fields.put(f.getName(), _constructField(f, typeContext));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                    _addFieldMixIns(parent, mixin, fields);
=======
                    _addFieldMixIns(mixin, cls, fields);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,
=======
    protected void _addFieldMixIns(Class<?> mixInCls, Class<?> targetClass,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            for (Field mixinField : mixin.getDeclaredFields()) {
=======
            for (Field mixinField : ClassUtil.getDeclaredFields(mixin)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected AnnotatedMethod _constructMethod(Method m)
=======
    protected AnnotatedMethod _constructMethod(Method m, TypeResolutionContext typeContext)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return new AnnotatedMethod(this, m, _emptyAnnotationMap(), null);
=======
            return new AnnotatedMethod(typeContext, m, _emptyAnnotationMap(), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedMethod(this, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);
=======
        return new AnnotatedMethod(typeContext, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)
=======
    protected AnnotatedConstructor _constructDefaultConstructor(ClassUtil.Ctor ctor,
            TypeResolutionContext typeContext)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return new AnnotatedConstructor(this, ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));
=======
            return new AnnotatedConstructor(typeContext, ctor.getConstructor(), _emptyAnnotationMap(), NO_ANNOTATION_MAPS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (defaultCtor) {
            return new AnnotatedConstructor(this, ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);
=======
        return new AnnotatedConstructor(typeContext, ctor.getConstructor(),
                _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), NO_ANNOTATION_MAPS);
    }

    protected AnnotatedConstructor _constructNonDefaultConstructor(ClassUtil.Ctor ctor,
            TypeResolutionContext typeContext)
    {
        final int paramCount = ctor.getParamCount();
        if (_annotationIntrospector == null) { // when annotation processing is disabled
            return new AnnotatedConstructor(typeContext, ctor.getConstructor(),
                    _emptyAnnotationMap(), _emptyAnnotationMaps(paramCount));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedConstructor(this, ctor,
=======
        return new AnnotatedConstructor(typeContext, ctor.getConstructor(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected AnnotatedMethod _constructCreatorMethod(Method m)
=======
    protected AnnotatedMethod _constructCreatorMethod(Method m, TypeResolutionContext typeContext)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return new AnnotatedMethod(this, m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));
=======
            return new AnnotatedMethod(typeContext, m, _emptyAnnotationMap(), _emptyAnnotationMaps(paramCount));
        }
        if (paramCount == 0) { // common enough we can slightly optimize
            return new AnnotatedMethod(typeContext, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),
                    NO_ANNOTATION_MAPS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedMethod(this, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),
=======
        return new AnnotatedMethod(typeContext, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected AnnotatedField _constructField(Field f)
=======
    protected AnnotatedField _constructField(Field f, TypeResolutionContext typeContext)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return new AnnotatedField(this, f, _emptyAnnotationMap());
=======
            return new AnnotatedField(typeContext, f, _emptyAnnotationMap());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedField(this, f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));
=======
        return new AnnotatedField(typeContext, f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Annotation a : bundle.annotationType().getDeclaredAnnotations()) {
=======
        for (Annotation a : ClassUtil.findClassAnnotations(bundle.annotationType())) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return cls.getDeclaredMethods();
=======
            return ClassUtil.getDeclaredMethods(cls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            if(loader == null){
=======
            if (loader == null){
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                // !!! TODO: 08-May-2015, tatu: Chain appropriately once we have JDK7 as baseline
                //ex.addSuppressed(e); Not until 1.7
=======
                // !!! TODO: 08-May-2015, tatu: Chain appropriately once we have JDK 1.7/Java7 as baseline
                //ex.addSuppressed(e); Not until Jackson 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
    public AnnotatedParameter(AnnotatedWithParams owner, Type type,  AnnotationMap annotations,
=======
    public AnnotatedParameter(AnnotatedWithParams owner, JavaType type,  AnnotationMap annotations,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
        super((owner == null) ? null : owner.getContextClass(), annotations);
=======
        super((owner == null) ? null : owner.getTypeContext(), annotations);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
    public Type getGenericType() {
        return _type;
=======
    public Class<?> getRawType() {
        return _type.getRawClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
    public Class<?> getRawType()
    {
        if (_type instanceof Class<?>) {
            return (Class<?>) _type;
        }
        // 14-Mar-2011, tatu: Not optimal, but has to do for now...
        JavaType t = TypeFactory.defaultInstance().constructType(_type);
        return t.getRawClass();
=======
    public JavaType getType() {
        return _typeContext.resolveType(_type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
    protected AnnotatedWithParams(AnnotatedClass ctxt, AnnotationMap annotations, AnnotationMap[] paramAnnotations)
=======
    protected AnnotatedWithParams(TypeResolutionContext ctxt, AnnotationMap annotations, AnnotationMap[] paramAnnotations)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
    }    
=======
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
        return new AnnotatedParameter(this, getGenericParameterType(index),
=======
        return new AnnotatedParameter(this, getParameterType(index),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
     * Method called to fully resolve type of one of parameters, given
     * specified type variable bindings.
=======
     * @deprecated Since 2.7, remove in 2.8
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
    public final JavaType resolveParameterType(int index, TypeBindings bindings) {
        return bindings.resolveType(getGenericParameterType(index));
=======
    @Deprecated
    public final Type getGenericParameterType(int index) {
        return getRawParameterType(index);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
    public AnnotatedConstructor(AnnotatedClass ctxt, Constructor<?> constructor,
=======
    public AnnotatedConstructor(TypeResolutionContext ctxt, Constructor<?> constructor,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
        return new AnnotatedConstructor(_context, _constructor, ann, _paramAnnotations);
=======
        return new AnnotatedConstructor(_typeContext, _constructor, ann, _paramAnnotations);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
    public Type getGenericType() {
        return getRawType();
=======
    public JavaType getType() {
        return _typeContext.resolveType(getRawType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
    public Type getGenericParameterType(int index)
    {
=======
    public JavaType getParameterType(int index) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
        return (index >= types.length) ? null : types[index];
=======
        if (index >= types.length) {
            return null;
        }
        return _typeContext.resolveType(types[index]);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(ctor);
=======
                ClassUtil.checkAndFixAccess(ctor, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
    public AnnotatedField(AnnotatedClass contextClass, Field field, AnnotationMap annMap)
=======
    public AnnotatedField(TypeResolutionContext contextClass, Field field, AnnotationMap annMap)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
        return new AnnotatedField(_context, _field, ann);
=======
        return new AnnotatedField(_typeContext, _field, ann);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return (_annotations == null) ? null : _annotations.get(acls);
=======
    public Class<?> getRawType() {
        return _field.getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
    public Type getGenericType() {
        return _field.getGenericType();
=======
    public JavaType getType() {
        return _typeContext.resolveType(_field.getGenericType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(f);
=======
                ClassUtil.checkAndFixAccess(f, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;
=======
        // 22-Sep-2015, tatu: Caching here has modest effect on JavaSE, and only
        //   mostly in degenerate cases where introspection used more often than
        //   it should (like recreating ObjectMapper once per read/write).
        //   But it may be more beneficial on platforms like Android (should verify)
        Class<?> type = ann.annotationType();
        Boolean b = _annotationsInside.get(type);
        if (b == null) {
            b = type.getAnnotation(JacksonAnnotationsInside.class) != null;
            _annotationsInside.putIfAbsent(type, b);
        }
        return b.booleanValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    } 
=======
    }

    @Override
    public String findClassDescription(AnnotatedClass ac) {
        JsonClassDescription ann = _findAnnotation(ac, JsonClassDescription.class);
        return (ann == null) ? null : ann.value();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        if (!containerType.isContainerType()) {
            throw new IllegalArgumentException("Must call method with a container type (got "+containerType+")");
=======
        if (containerType.getContentType() == null) {
            throw new IllegalArgumentException("Must call method with a container or reference type (got "+containerType+")");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
            name = jg.value();
        } else {
            JsonProperty pann = _findAnnotation(a, JsonProperty.class);
            if (pann != null) {
                name = pann.value();
                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but
                 *   it's actually bit tricky to do it more efficiently (meta-annotations
                 *   add more lookups; AnnotationMap costs etc)
                 */
            } else if (_hasAnnotation(a, JsonSerialize.class)
                    || _hasAnnotation(a, JsonView.class)
                    || _hasAnnotation(a, JsonRawValue.class)
                    || _hasAnnotation(a, JsonUnwrapped.class)
                    || _hasAnnotation(a, JsonBackReference.class)
                    || _hasAnnotation(a, JsonManagedReference.class)) {
                name = "";
            } else {
                return null;
            }
=======
            return PropertyName.construct(jg.value());
        }
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            return PropertyName.construct(pann.value());
        }
        PropertyName ctorName = _findConstructorName(a);
        if (ctorName != null) {
            return ctorName;
        }
        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_SER)) {
            return PropertyName.USE_DEFAULT;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return PropertyName.construct(name);
=======
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {
        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.as());
=======
    public Object findDeserializationConverter(Annotated a)
    {
        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {
        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.keyAs());
=======
    public Object findDeserializationContentConverter(AnnotatedMember a)
    {
        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    public Object findDeserializationConverter(Annotated a)
    {
        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);
=======
    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {
        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.as());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    public Object findDeserializationContentConverter(AnnotatedMember a)
    {
        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);
=======
    @Deprecated
    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {
        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.keyAs());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
            name = js.value();
        } else {
            JsonProperty pann = _findAnnotation(a, JsonProperty.class);
            if (pann != null) {
                name = pann.value();
                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but
                 *   it's actually bit tricky to do it more efficiently (meta-annotations
                 *   add more lookups; AnnotationMap costs etc)
                 */
            } else if (_hasAnnotation(a, JsonDeserialize.class)
                    || _hasAnnotation(a, JsonView.class)
                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]
                    || _hasAnnotation(a, JsonBackReference.class)
                    || _hasAnnotation(a, JsonManagedReference.class)) {
                    name = "";
            } else {
                return null;
            }
=======
            return PropertyName.construct(js.value());
        }
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            return PropertyName.construct(pann.value());
        }
        PropertyName ctorName = _findConstructorName(a);
        if (ctorName != null) {
            return ctorName;
        }
        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_DESER)) {
            return PropertyName.USE_DEFAULT;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return PropertyName.construct(name);
=======
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);
=======
         if (ann != null) {
             return (ann.mode() != JsonCreator.Mode.DISABLED);
         }
         if (a instanceof AnnotatedConstructor) {
             if (_jdk7Helper != null) {
                 Boolean b = _jdk7Helper.hasCreatorAnnotation(a);
                 if (b != null) {
                     return b.booleanValue();
                 }
             }
         }
         return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return (ann != null && ann.value());
=======
        if (ann != null) {
            return ann.value();
        }
        if (_jdk7Helper != null) {
            Boolean b = _jdk7Helper.findTransient(a);
            if (b != null) {
                return b.booleanValue();
            }
        }
        return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
                 *   use serialization annotation (@JsonSerializer) when serializing
=======
                 *   use serialization annotation (@JsonSerialize) when serializing
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
            // As per [#428](https://github.com/FasterXML/jackson-databind/issues/428) need
            // to skip renaming if property has explicitly defined name
            if (!prop.isExplicitlyNamed()) {
=======
            // As per [databind#428] need to skip renaming if property has
            // explicitly defined name, unless feature  is enabled
            if (!prop.isExplicitlyNamed() || _config.isEnabled(MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
            /* As per [Issue#311], this is bit delicate; but if alphabetic ordering
=======
            /* As per [databind#311], this is bit delicate; but if alphabetic ordering
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
            prop = new POJOPropertyBuilder(PropertyName.construct(implName),
                    _annotationIntrospector, _forSerialization);
=======
            prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,
                    PropertyName.construct(implName));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
    /*
    @Deprecated // since 2.5
    protected AnnotatedMember(AnnotationMap annotations) {
        this(null, annotations);
    }
    */

    protected AnnotatedMember(AnnotatedClass ctxt, AnnotationMap annotations) {
=======
    protected AnnotatedMember(TypeResolutionContext ctxt, AnnotationMap annotations) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
        _context = ctxt;
=======
        _typeContext = ctxt;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
        _context = base._context;
=======
        _typeContext = base._typeContext;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
     * @since 2.5
=======
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
    public AnnotatedClass getContextClass() {
        return _context;
=======
    public TypeResolutionContext getTypeContext() {
        return _typeContext;
    }

    @Override
    public final <A extends Annotation> A getAnnotation(Class<A> acls) {
        if (_annotations == null) {
            return null;
        }
        return _annotations.get(acls);
    }

    @Override
    public final boolean hasAnnotation(Class<?> acls) {
        if (_annotations == null) {
            return false;
        }
        return _annotations.has(acls);
    }

    @Override
    public boolean hasOneOf(Class<? extends Annotation>[] annoClasses) {
        if (_annotations == null) {
            return false;
        }
        return _annotations.hasOneOf(annoClasses);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
        ClassUtil.checkAndFixAccess(getMember());
=======
//        fixAccess(false);
        fixAccess(true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
    public VirtualAnnotatedMember(AnnotatedClass contextClass, Class<?> declaringClass,
=======
    public VirtualAnnotatedMember(TypeResolutionContext typeContext, Class<?> declaringClass,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
        super(contextClass, /* AnnotationMap*/ null);
=======
        super(typeContext, /* AnnotationMap*/ null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return null;
=======
    public Class<?> getRawType() {
        return _rawType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
    public Type getGenericType() {
        return _rawType;
=======
    public JavaType getType() {
        return _typeContext.resolveType(_rawType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
        defValue = _secondary.findSerializationInclusion(a, defValue);
        defValue = _primary.findSerializationInclusion(a, defValue);
=======
        defValue = _secondary.findSerializationInclusionForContent(a, defValue);
        defValue = _primary.findSerializationInclusionForContent(a, defValue);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
    public JsonInclude.Value findPropertyInclusion(Annotated a) {
=======
    public JsonInclude.Value findPropertyInclusion(Annotated a)
    {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
        JsonFormat.Value r = _primary.findFormat(ann);
        return (r == null) ? _secondary.findFormat(ann) : r;
=======
        JsonFormat.Value v1 = _primary.findFormat(ann);
        JsonFormat.Value v2 = _secondary.findFormat(ann);
        if (v2 == null) { // shouldn't occur but just in case
            return v1;
        }
        return v2.withOverrides(v1);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java;<<<<<<< MINE
    public JsonInclude.Include findInclusion() {
        return null;
=======
    public JsonInclude.Value findInclusion() {
        return EMPTY_INCLUDE;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
    public TypeBindings bindingsForBeanType()
    {
        if (_bindings == null) {
            _bindings = new TypeBindings(_config.getTypeFactory(), _type);
        }
        return _bindings;
=======
    @Deprecated // since 2.7
    public TypeBindings bindingsForBeanType() {
        return _type.getBindings();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
        return bindingsForBeanType().resolveType(jdkType);
=======
        return _config.getTypeFactory().constructType(jdkType, _type.getBindings());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
    public Object instantiateBean(boolean fixAccess)
    {
=======
    public Object instantiateBean(boolean fixAccess) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
            ac.fixAccess();
=======
            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
    public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue) {
        if (_annotationIntrospector == null) {
            return defValue;
=======
    public JsonInclude.Value findPropertyInclusion(JsonInclude.Value defValue) {
        if (_annotationIntrospector != null) {
            JsonInclude.Value incl = _annotationIntrospector.findPropertyInclusion(_classInfo);
            if (incl != null) {
                return defValue.withOverrides(incl);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
        return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue);
=======
        return defValue;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai,
            boolean forSerialization) {
        this(internalName, internalName, ai, forSerialization);
=======
    public POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai,
            boolean forSerialization, PropertyName internalName) {
        this(config, ai, forSerialization, internalName, internalName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    protected POJOPropertyBuilder(PropertyName internalName, PropertyName name,
            AnnotationIntrospector annotationIntrospector, boolean forSerialization)
=======
    protected POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai,
            boolean forSerialization, PropertyName internalName, PropertyName name)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
            /* [JACKSON-255] Allow masking, i.e. do not report exception if one
             *   is in super-class from the other
             */
=======
            // Allow masking, i.e. do not fail if one is in super-class from the other
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
            return EmptyIterator.instance();
=======
            return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        // [#238]: Also, regular getters have precedence over "is-getters"
=======
        // [databind#238]: Also, regular getters have precedence over "is-getters"
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    public JsonInclude.Include findInclusion() {
        if (_annotationIntrospector == null) {
            return null;
=======
    public JsonInclude.Value findInclusion() {
        if (_annotationIntrospector != null) {
            AnnotatedMember a = getAccessor();
            JsonInclude.Value v =  _annotationIntrospector.findPropertyInclusion(a);
            if (v != null) {
                return v;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        AnnotatedMember am = getAccessor();
        return _annotationIntrospector.findSerializationInclusion(am, null);
=======
        return JsonInclude.Value.empty();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes)
=======
    private AnnotationMap _mergeAnnotations(int index,
            Linked<? extends AnnotatedMember>... nodes)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        ++index;
        for (; index < nodes.length; ++index) {
=======
        while (++index < nodes.length) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
                // [Issue#541] ... but only as long as it's visible
=======
                // [databind#541] ... but only as long as it's visible
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
                prop = new POJOPropertyBuilder(_internalName, name, _annotationIntrospector, _forSerialization);
=======
                prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,
                        _internalName, name);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java;<<<<<<< MINE
    private AnnotationMap(HashMap<Class<? extends Annotation>,Annotation> a) {
=======
    private AnnotationMap(HashMap<Class<?>,Annotation> a) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java;<<<<<<< MINE
            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();
=======
            _annotations = new HashMap<Class<?>,Annotation>();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            desc = _findStdJdkCollectionDesc(cfg, type, r);
=======
            desc = _findStdJdkCollectionDesc(cfg, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            desc = _findStdJdkCollectionDesc(cfg, type, r);
=======
            desc = _findStdJdkCollectionDesc(cfg, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            desc = _findStdJdkCollectionDesc(cfg, type, r);
=======
            desc = _findStdJdkCollectionDesc(cfg, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
    public BasicBeanDescription forClassAnnotations(MapperConfig<?> cfg,
=======
    public BasicBeanDescription forClassAnnotations(MapperConfig<?> config,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
                boolean useAnnotations = cfg.isAnnotationProcessingEnabled();
                AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),
                        (useAnnotations ? cfg.getAnnotationIntrospector() : null), r);
                desc = BasicBeanDescription.forOtherUse(cfg, type, ac);
=======
                AnnotatedClass ac = AnnotatedClass.construct(type, config, r);
                desc = BasicBeanDescription.forOtherUse(config, type, ac);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
    public BasicBeanDescription forDirectClassAnnotations(MapperConfig<?> cfg,
=======
    public BasicBeanDescription forDirectClassAnnotations(MapperConfig<?> config,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            boolean useAnnotations = cfg.isAnnotationProcessingEnabled();
            AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();
            AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),
                    (useAnnotations ? ai : null), r);
            desc = BasicBeanDescription.forOtherUse(cfg, type, ac);
=======
            AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(), config, r);
            desc = BasicBeanDescription.forOtherUse(config, type, ac);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
        Package pkg = raw.getPackage();
        if (pkg != null) {
            String pkgName = pkg.getName();
=======
        String pkgName = ClassUtil.getPackageName(raw);
        if (pkgName != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
    protected BasicBeanDescription _findStdJdkCollectionDesc(MapperConfig<?> cfg,
            JavaType type, MixInResolver r)
=======
    protected BasicBeanDescription _findStdJdkCollectionDesc(MapperConfig<?> cfg, JavaType type)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    public AnnotatedMethod(AnnotatedClass ctxt, Method method,
=======
    public AnnotatedMethod(TypeResolutionContext ctxt, Method method,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
        return new AnnotatedMethod(_context, m, _annotations, _paramAnnotations);
=======
        return new AnnotatedMethod(_typeContext, m, _annotations, _paramAnnotations);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
        return new AnnotatedMethod(_context, _method, ann, _paramAnnotations);
=======
        return new AnnotatedMethod(_typeContext, _method, ann, _paramAnnotations);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    public Type getGenericType() {
        return _method.getGenericReturnType();
=======
    public JavaType getType() {
        return _typeContext.resolveType(_method.getGenericReturnType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    public Type getGenericParameterType(int index)
    {
=======
    public JavaType getParameterType(int index) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
        return (index >= types.length) ? null : types[index];
=======
        if (index >= types.length) {
            return null;
        }
        return _typeContext.resolveType(types[index]);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(m);
=======
                ClassUtil.checkAndFixAccess(m, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java;<<<<<<< MINE
    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,
=======
    public void serializeWithType(JsonGenerator g, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java;<<<<<<< MINE
        jg.writeNull();
=======
        g.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
        throw new JsonParseException(base, JsonLocation.NA);
=======
        throw new JsonParseException(null, base, JsonLocation.NA);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
        throw new JsonParseException("Unexpected end-of-String when base64 content", JsonLocation.NA);
=======
        throw new JsonParseException(null, "Unexpected end-of-String when base64 content");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
     * @deprecated Since 2.2 use method that takes 'asStatic' argument
=======
     * Main constructor to use by extending classes.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    @Deprecated
    protected TypeBase(Class<?> raw, int hash,
            Object valueHandler, Object typeHandler)
=======
    protected TypeBase(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInts,
            int hash,
            Object valueHandler, Object typeHandler, boolean asStatic)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
        this(raw, hash, valueHandler, typeHandler, false);
=======
        super(raw, hash, valueHandler, typeHandler, asStatic);
        _bindings = (bindings == null) ? NO_BINDINGS : bindings;
        _superClass = superClass;
        _superInterfaces = superInts;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
     * Main constructor to use by extending classes.
=======
     * Copy-constructor used when refining/upgrading type instances.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    protected TypeBase(Class<?> raw, int hash,
            Object valueHandler, Object typeHandler, boolean asStatic)
    {
        super(raw, hash, valueHandler, typeHandler, asStatic);
=======
    protected TypeBase(TypeBase base) {
        super(base);
        _superClass = base._superClass;
        _superInterfaces = base._superInterfaces;
        _bindings = base._bindings;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    /* JsonSerializableWithType base implementation
=======
    /* JsonSerializable base implementation
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    public void serializeWithType(JsonGenerator jgen, SerializerProvider provider,
=======
    public void serializeWithType(JsonGenerator gen, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
        typeSer.writeTypePrefixForScalar(this, jgen);
        this.serialize(jgen, provider);
        typeSer.writeTypeSuffixForScalar(this, jgen);
=======
        typeSer.writeTypePrefixForScalar(this, gen);
        this.serialize(gen, provider);
        typeSer.writeTypeSuffixForScalar(this, gen);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    public void serialize(JsonGenerator jgen, SerializerProvider provider)
=======
    public void serialize(JsonGenerator gen, SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
        jgen.writeString(toCanonical());
=======
        gen.writeString(toCanonical());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
 * Type that represents Map-like types; things that consist of key/value pairs but that
 * do not necessarily implement {@link java.util.Map}, but that do not have enough
 * introspection functionality to allow for some level of generic handling.
 * This specifically allows framework to check for configuration and annotation
 * settings used for Map types, and pass these to custom handlers that may be more
 * familiar with actual type.
=======
 * Type that represents Map-like types; things that consist of key/value pairs
 * but that do not necessarily implement {@link java.util.Map}, but that do not
 * have enough introspection functionality to allow for some level of generic
 * handling. This specifically allows framework to check for configuration and
 * annotation settings used for Map types, and pass these to custom handlers
 * that may be more familiar with actual type.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**********************************************************
    /* Life-cycle
    /**********************************************************
=======
     * /********************************************************** /* Life-cycle
     * /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    protected MapLikeType(Class<?> mapType, JavaType keyT, JavaType valueT,
            Object valueHandler, Object typeHandler, boolean asStatic)
    {
        super(mapType, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);
=======
    protected MapLikeType(Class<?> mapType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType keyT,
            JavaType valueT, Object valueHandler, Object typeHandler,
            boolean asStatic) {
        super(mapType, bindings, superClass, superInts, keyT.hashCode()
                ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    
    public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT)
    {
        // nominally component types will be just Object.class
        return new MapLikeType(rawType, keyT, valueT, null, null, false);
=======

    /**
     * @since 2.7
     */
    protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT) {
        super(base);
        _keyType = keyT;
        _valueType = valueT;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return new MapLikeType(subclass, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
=======
    /**
     * Factory method that can be used to "upgrade" a basic type into
     * collection-like one; usually done via {@link TypeModifier}
     *
     * @since 2.7
     */
    public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT,
            JavaType valueT) {
        // 19-Oct-2015, tatu: Not sure if and how other types could be used as
        // base;
        // will cross that bridge if and when need be
        if (baseType instanceof TypeBase) {
            return new MapLikeType((TypeBase) baseType, keyT, valueT);
        }
        throw new IllegalArgumentException(
                "Can not upgrade from an instance of " + baseType.getClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    @Override
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _valueType.getRawClass()) {
            return this;
=======
    @Deprecated
    // since 2.7; remove from 2.8
    public static MapLikeType construct(Class<?> rawType, JavaType keyT,
            JavaType valueT) {
        // First: may need to fabricate TypeBindings (needed for refining into
        // concrete collection types, as per [databind#1102])
        TypeVariable<?>[] vars = rawType.getTypeParameters();
        TypeBindings bindings;
        if ((vars == null) || (vars.length != 2)) {
            bindings = TypeBindings.emptyBindings();
        } else {
            bindings = TypeBindings.create(rawType, keyT, valueT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType, _valueType.narrowBy(contentClass),
               _valueHandler, _typeHandler, _asStatic);
=======
        return new MapLikeType(rawType, bindings, _bogusSuperClass(rawType),
                null, keyT, valueT, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        if (contentClass == _valueType.getRawClass()) {
            return this;
        }
        return new MapLikeType(_class, _keyType, _valueType.widenBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
    protected JavaType _narrow(Class<?> subclass) {
        return new MapLikeType(subclass, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType, _valueHandler,
                _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    
    public JavaType narrowKey(Class<?> keySubclass)
    {
        // Can do a quick check first:
        if (keySubclass == _keyType.getRawClass()) {
=======

    /**
     * @since 2.7
     */
    public MapLikeType withKeyType(JavaType keyType) {
        if (keyType == _keyType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType.narrowBy(keySubclass), _valueType,
                _valueHandler, _typeHandler, _asStatic);
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, keyType, _valueType, _valueHandler,
                _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public JavaType widenKey(Class<?> keySubclass)
    {
        // Can do a quick check first:
        if (keySubclass == _keyType.getRawClass()) {
=======
    @Override
    public JavaType withContentType(JavaType contentType) {
        if (_valueType == contentType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType.widenBy(keySubclass), _valueType,
                _valueHandler, _typeHandler, _asStatic);
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, contentType, _valueHandler,
                _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public MapLikeType withTypeHandler(Object h)
    {
        return new MapLikeType(_class, _keyType, _valueType, _valueHandler, h, _asStatic);
=======
    public MapLikeType withTypeHandler(Object h) {
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType, _valueHandler, h,
                _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public MapLikeType withContentTypeHandler(Object h)
    {
        return new MapLikeType(_class, _keyType, _valueType.withTypeHandler(h),
=======
    public MapLikeType withContentTypeHandler(Object h) {
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType, _valueType, h, _typeHandler, _asStatic);
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType, h, _typeHandler,
                _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType, _valueType.withValueHandler(h),
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType, _valueType.withStaticTyping(),
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**********************************************************
    /* Public API
    /**********************************************************
=======
     * /********************************************************** /* Public API
     * /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public int containedTypeCount() { return 2; }
    
    @Override
    public JavaType containedType(int index) {
        if (index == 0) return _keyType;
        if (index == 1) return _valueType;
        return null;
=======
    public JavaType getContentType() {
        return _valueType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public String containedTypeName(int index) {
        if (index == 0) return "K";
        if (index == 1) return "V";
        return null;
=======
    public Object getContentValueHandler() {
        return _valueType.getValueHandler();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public Class<?> getParameterSource() {
        return null;
=======
    public Object getContentTypeHandler() {
        return _valueType.getTypeHandler();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public StringBuilder getGenericSignature(StringBuilder sb)
    {
=======
    public StringBuilder getGenericSignature(StringBuilder sb) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**********************************************************
    /* Extended API
    /**********************************************************
=======
     * /********************************************************** /* Extended
     * API /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public MapLikeType withKeyTypeHandler(Object h)
    {
        return new MapLikeType(_class, _keyType.withTypeHandler(h), _valueType,
=======
    public MapLikeType withKeyTypeHandler(Object h) {
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType.withTypeHandler(h), _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType.withValueHandler(h), _valueType,
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType.withValueHandler(h), _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
     * Method that can be used for checking whether this type is a
     * "real" Collection type; meaning whether it represents a parameterized
     * subtype of {@link java.util.Collection} or just something that acts
     * like one.
=======
     * Method that can be used for checking whether this type is a "real"
     * Collection type; meaning whether it represents a parameterized subtype of
     * {@link java.util.Collection} or just something that acts like one.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**********************************************************
    /* Standard methods
    /**********************************************************
=======
     * /********************************************************** /* Standard
     * methods /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public String toString()
    {
        return "[map-like type; class "+_class.getName()+", "+_keyType+" -> "+_valueType+"]";
=======
    public String toString() {
        return "[map-like type; class " + _class.getName() + ", " + _keyType
                + " -> " + _valueType + "]";
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public boolean equals(Object o)
    {
        if (o == this) return true;
        if (o == null) return false;
        if (o.getClass() != getClass()) return false;
=======
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (o == null)
            return false;
        if (o.getClass() != getClass())
            return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return (_class == other._class)
            && _keyType.equals(other._keyType)
            && _valueType.equals(other._valueType);
=======
        return (_class == other._class) && _keyType.equals(other._keyType)
                && _valueType.equals(other._valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    private MapType(Class<?> mapType, JavaType keyT, JavaType valueT,
=======
    private MapType(Class<?> mapType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        super(mapType, keyT, valueT, valueHandler, typeHandler, asStatic);
    }
    
    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {
        // nominally component types will be just Object.class
        return new MapType(rawType, keyT, valueT, null, null, false);
=======
        super(mapType, bindings, superClass, superInts,
                keyT, valueT, valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return new MapType(subclass, _keyType, _valueType,
                _valueHandler, _typeHandler, _asStatic);
=======
    /**
     * @since 2.7
     */
    protected MapType(TypeBase base, JavaType keyT, JavaType valueT) {
        super(base, keyT, valueT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    @Override
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _valueType.getRawClass()) {
            return this;
=======
    /**
     * @since 2.7
     */
    public static MapType construct(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts,
            JavaType keyT, JavaType valueT) {
        return new MapType(rawType, bindings, superClass, superInts, keyT, valueT, null, null, false);
    }
    
    @Deprecated // since 2.7
    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)
    {
        // First: may need to fabricate TypeBindings (needed for refining into
        // concrete collection types, as per [databind#1102])
        TypeVariable<?>[] vars = rawType.getTypeParameters();
        TypeBindings bindings;
        if ((vars == null) || (vars.length != 2)) {
            bindings = TypeBindings.emptyBindings();
        } else {
            bindings = TypeBindings.create(rawType, keyT, valueT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType.narrowBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
        // !!! TODO: Wrong, does have supertypes
        return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,
                keyT, valueT, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        if (contentClass == _valueType.getRawClass()) {
            return this;
        }
        return new MapType(_class, _keyType, _valueType.widenBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
    }
    
    @Override
    public JavaType narrowKey(Class<?> keySubclass)
    {
        // Can do a quick check first:
        if (keySubclass == _keyType.getRawClass()) {
            return this;
        }
        return new MapType(_class, _keyType.narrowBy(keySubclass), _valueType,
=======
    protected JavaType _narrow(Class<?> subclass) {
        return new MapType(subclass, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType, _valueHandler, h, _asStatic);
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType.withTypeHandler(h),
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType, h, _typeHandler, _asStatic);
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType.withValueHandler(h),
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType.withStaticTyping(), _valueType.withStaticTyping(),
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType.withStaticTyping(), _valueType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    public Class<?> getParameterSource() {
        return java.util.Map.class;
=======
    public MapType withKeyType(JavaType keyType) {
        if (keyType == _keyType) {
            return this;
        }
        return new MapType(_class, _bindings, _superClass, _superInterfaces,
                keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType.withTypeHandler(h), _valueType,
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType.withValueHandler(h), _valueType,
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
    public JavaType parse(String canonical)
        throws IllegalArgumentException
=======
    public JavaType parse(String canonical) throws IllegalArgumentException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
                return _factory._fromParameterizedClass(base, parseTypes(tokens));
=======
                List<JavaType> parameterTypes = parseTypes(tokens);
                TypeBindings b = TypeBindings.create(base, parameterTypes);
                return _factory._fromClass(null, base, b);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
        return _factory._fromClass(base, null);
=======
        return _factory._fromClass(null, base, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    protected ReferenceType(Class<?> cls, JavaType refType,
=======
    protected ReferenceType(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType refType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        super(cls, refType.hashCode(),
=======
        super(cls, bindings, superClass, superInts, refType.hashCode(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    public static ReferenceType construct(Class<?> cls, JavaType refType,
            Object valueHandler, Object typeHandler)
=======
    /**
     * @since 2.7
     */
    protected ReferenceType(TypeBase base, JavaType refType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(cls, refType, null, null, false);
    }                                   
    
=======
        super(base);
        _referencedType = refType;
    }

    /**
     * Factory method that can be used to "upgrade" a basic type into collection-like
     * one; usually done via {@link TypeModifier}
     *
     * @since 2.7
     */
    public static ReferenceType upgradeFrom(JavaType baseType, JavaType refType) {
        if (refType == null) {
            throw new IllegalArgumentException("Missing referencedType");
        }
        // 19-Oct-2015, tatu: Not sure if and how other types could be used as base;
        //    will cross that bridge if and when need be
        if (baseType instanceof TypeBase) {
            return new ReferenceType((TypeBase) baseType, refType);
        }
        throw new IllegalArgumentException("Can not upgrade from an instance of "+baseType.getClass());
    }

    /**
     * @since 2.7
     */
    public static ReferenceType construct(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType refType)
    {
        return new ReferenceType(cls, bindings, superClass, superInts,
                refType, null, null, false);
    }

    @Deprecated // since 2.7
    public static ReferenceType construct(Class<?> cls, JavaType refType) {
        return new ReferenceType(cls, TypeBindings.emptyBindings(),
                // !!! TODO: missing supertypes
                null, null, refType, null, null, false);
    }

    @Override
    public JavaType withContentType(JavaType contentType) {
        if (_referencedType == contentType) {
            return this;
        }
        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,
                contentType, _valueHandler, _typeHandler, _asStatic);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType, _valueHandler, h, _asStatic);
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType.withTypeHandler(h),
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType, h, _typeHandler,_asStatic);
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType, h, _typeHandler,_asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType.withValueHandler(h),
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType.withStaticTyping(),
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(subclass, _referencedType,
=======
        return new ReferenceType(subclass, _bindings,
                _superClass, _superInterfaces, _referencedType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    /* Extended API
=======
    /* Public API overrides
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    protected CollectionLikeType(Class<?> collT, JavaType elemT,
=======
    protected CollectionLikeType(Class<?> collT, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        super(collT, elemT.hashCode(), valueHandler, typeHandler, asStatic);
=======
        super(collT, bindings, superClass, superInts,
                elemT.hashCode(), valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return new CollectionLikeType(subclass, _elementType,
                _valueHandler, _typeHandler, _asStatic);
=======

    /**
     * @since 2.7
     */
    protected CollectionLikeType(TypeBase base, JavaType elemT)
    {
        super(base);
        _elementType = elemT;
    }

    /**
     * @since 2.7
     */
    public static CollectionLikeType construct(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT) {
        return new CollectionLikeType(rawType, bindings, superClass, superInts, elemT,
                null, null, false);
    }

    /**
     * @deprecated Since 2.7, use {@link #upgradeFrom} for constructing instances, given
     *    pre-resolved {@link SimpleType}.
     */
    @Deprecated // since 2.7
    public static CollectionLikeType construct(Class<?> rawType, JavaType elemT) {
        // First: may need to fabricate TypeBindings (needed for refining into
        // concrete collection types, as per [databind#1102])
        TypeVariable<?>[] vars = rawType.getTypeParameters();
        TypeBindings bindings;
        if ((vars == null) || (vars.length != 1)) {
            bindings = TypeBindings.emptyBindings();
        } else {
            bindings = TypeBindings.create(rawType, elemT);
        }
        return new CollectionLikeType(rawType, bindings,
                _bogusSuperClass(rawType), null,
                elemT, null, null, false);
    }

    /**
     * Factory method that can be used to "upgrade" a basic type into collection-like
     * one; usually done via {@link TypeModifier}
     *
     * @since 2.7
     */
    public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType) {
        // 19-Oct-2015, tatu: Not sure if and how other types could be used as base;
        //    will cross that bridge if and when need be
        if (baseType instanceof TypeBase) {
            return new CollectionLikeType((TypeBase) baseType, elementType);
        }
        throw new IllegalArgumentException("Can not upgrade from an instance of "+baseType.getClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _elementType.getRawClass()) {
            return this;
        }
        return new CollectionLikeType(_class, _elementType.narrowBy(contentClass),
=======
    @Deprecated // since 2.7
    protected JavaType _narrow(Class<?> subclass) {
        return new CollectionLikeType(subclass, _bindings,
                _superClass, _superInterfaces, _elementType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _elementType.getRawClass()) {
=======
    public JavaType withContentType(JavaType contentType) {
        if (_elementType == contentType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType.widenBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
        return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces,
                contentType, _valueHandler, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public CollectionLikeType withTypeHandler(Object h)
    {
        return new CollectionLikeType(_class, _elementType, _valueHandler, h, _asStatic);
=======
    public CollectionLikeType withTypeHandler(Object h) {
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType.withTypeHandler(h),
=======
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType, h, _typeHandler, _asStatic);
=======
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType.withValueHandler(h),
=======
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType.withStaticTyping(),
=======
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public int containedTypeCount() { return 1; }

    @Override
    public JavaType containedType(int index) {
            return (index == 0) ? _elementType : null;
=======
    public Object getContentValueHandler() {
        return _elementType.getValueHandler();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        this(cls, null, null, null, null, false, null);
=======
        this(cls, TypeBindings.emptyBindings(), null, null);
    }

    protected SimpleType(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts) {
        this(cls, bindings, superClass, superInts, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
     * @deprecated Since 2.5 use variant that takes one more argument
=======
     * Simple copy-constructor, usually used when upgrading/refining a simple type
     * into more specialized type.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    @Deprecated
    protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams,
            Object valueHandler, Object typeHandler, boolean asStatic)
    {
        this(cls, typeNames, typeParams, valueHandler, typeHandler, asStatic, null);
=======
    protected SimpleType(TypeBase base) {
        super(base);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    /**
     * 
     * @param parametersFrom Interface or abstract class implemented by this type,
     *   and for which type parameters apply. It may be <code>cls</code> itself,
     *   but more commonly it is one of its supertypes.
     */
    protected SimpleType(Class<?> cls,
            String[] typeNames, JavaType[] typeParams,
            Object valueHandler, Object typeHandler, boolean asStatic,
            Class<?> parametersFrom)
=======
    protected SimpleType(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts,
            Object valueHandler, Object typeHandler, boolean asStatic)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        super(cls, 0, valueHandler, typeHandler, asStatic);
        if (typeNames == null || typeNames.length == 0) {
            _typeNames = null;
            _typeParameters = null;
        } else {
            _typeNames = typeNames;
            _typeParameters = typeParams;
        }
        _typeParametersFor = parametersFrom;
=======
        super(cls, bindings, superClass, superInts,
                0, valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    protected SimpleType(Class<?> cls, int extraHash,
=======
    protected SimpleType(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, int extraHash,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        super(cls, extraHash, valueHandler, typeHandler, asStatic);
        _typeNames = null;
        _typeParameters = null;
        _typeParametersFor = cls;
=======
        super(cls, bindings, superClass, superInts, 
                extraHash, valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
     * Method used by core Jackson classes: NOT to be used by application code.
=======
     * Method used by core Jackson classes: NOT to be used by application code:
     * it does NOT properly handle inspection of super-types, so neither parent
     * Classes nor implemented Interfaces are accessible with resulting type
     * instance.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return new SimpleType(raw, null, null, null, null, false, null);
=======
        return new SimpleType(raw, null,
                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?
                null, null, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return new SimpleType(cls);
=======
        TypeBindings b = TypeBindings.emptyBindings();
        return new SimpleType(cls, b,
                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    public SimpleType withTypeHandler(Object h)
=======
    @Deprecated
    protected JavaType _narrow(Class<?> subclass)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic, _typeParametersFor);
=======
        if (_class == subclass) {
            return this;
        }
        // Should we check that there is a sub-class relationship?
        // 15-Jan-2016, tatu: Almost yes, but there are some complications with
        //    placeholder values, so no.
        /*
        if (!_class.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException("Class "+subclass.getName()+" not sub-type of "
                    +_class.getName());
        }
        */
        // 15-Jan-2015, tatu: Not correct; should really re-resolve...
        return new SimpleType(subclass, _bindings, this, _superInterfaces,
                _valueHandler, _typeHandler, _asStatic);
    }
    
    @Override
    public JavaType withContentType(JavaType contentType) {
        throw new IllegalArgumentException("Simple types have no content types; can not call withContentType()");
    }
    
    @Override
    public SimpleType withTypeHandler(Object h) {
        if (_typeHandler == h) {
            return this;
        }
        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic, _typeParametersFor);
=======
        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return _asStatic ? this : new SimpleType(_class,
                _typeNames, _typeParameters, _valueHandler, _typeHandler, true, _typeParametersFor);
=======
        return _asStatic ? this : new SimpleType(_class, _bindings,
                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        if (_typeParameters != null && _typeParameters.length > 0) {
=======

        final int count = _bindings.size();
        if (count > 0) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
            boolean first = true;
            for (JavaType t : _typeParameters) {
                if (first) {
                    first = false;
                } else {
=======
            for (int i = 0; i < count; ++i) {
                JavaType t = containedType(i);
                if (i > 0) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        if (_typeParameters != null) {
=======

        final int count = _bindings.size();
        if (count > 0) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
            for (JavaType param : _typeParameters) {
                sb = param.getGenericSignature(sb);
=======
            for (int i = 0; i < count; ++i) {
                sb = containedType(i).getGenericSignature(sb);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        JavaType[] p1 = _typeParameters;
        JavaType[] p2 = other._typeParameters;
        if (p1 == null) {
            return (p2 == null) || p2.length == 0;
        }
        if (p2 == null) return false;

        if (p1.length != p2.length) return false;
        for (int i = 0, len = p1.length; i < len; ++i) {
            if (!p1[i].equals(p2[i])) {
                return false;
            }
        }
        return true;
=======
        TypeBindings b1 = _bindings;
        TypeBindings b2 = other._bindings;
        return b1.equals(b2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
@SuppressWarnings({"rawtypes", "unchecked"})
=======
@SuppressWarnings({"rawtypes" })
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /* Caching
=======
    /* Constants for "well-known" classes
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Since type resolution can be expensive (specifically when resolving
     * actual generic types), we will use small cache to avoid repetitive
     * resolution of core types
=======
     * Cache {@link Comparable} because it is both parameteric (relatively costly to
     * resolve) and mostly useless (no special handling), better handle directly
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /*
     * Looks like construction of {@link JavaType} instances can be
     * a bottleneck, esp. for root-level Maps, so we better do bit
     * of low-level component caching here...
=======
    /**
     * Cache {@link Enum} because it is parametric AND self-referential (costly to
     * resolve) and useless in itself (no special handling).
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}
     * to its supertypes.
=======
     * Cache {@link Class} because it is nominally parametric, but has no really
     * useful information.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}
     * to its supertypes.
=======
     * Since type resolution can be expensive (specifically when resolving
     * actual generic types), we will use small cache to avoid repetitive
     * resolution of core types
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * ClassLoader used by this factory (Issue #624)
=======
     * ClassLoader used by this factory [databind#624].
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    	return _classLoader;
=======
        return _classLoader;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Shouldbe able to optimize bit more in future...
=======
        // Should be able to optimize bit more in future...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    	return Class.forName(name);
=======
        return Class.forName(name);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        if (baseType.getRawClass() == subclass) {
=======
        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == subclass) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Currently only SimpleType instances can become something else
=======
        
        JavaType newType;

        // also: if we start from untyped, not much to save
        do { // bogus loop to be able to break
            if (rawBase == Object.class) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
                break;
            }
            if (!rawBase.isAssignableFrom(subclass)) {
                throw new IllegalArgumentException(String.format(
                        "Class %s not subtype of %s", subclass.getName(), baseType));
            }
            // A few special cases where we can simplify handling:

            // (1) Original target type has no generics -- just resolve subtype
            if (baseType.getBindings().isEmpty()) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            // (2) A small set of "well-known" List/Map subtypes where can take a short-cut
            if (baseType.isContainerType()) {
                if (baseType.isMapLikeType()) {
                    if ((subclass == HashMap.class)
                            || (subclass == LinkedHashMap.class)
                            || (subclass == EnumMap.class)
                            || (subclass == TreeMap.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                        break;
                    }
                } else if (baseType.isCollectionLikeType()) {
                    if ((subclass == ArrayList.class)
                            || (subclass == LinkedList.class)
                            || (subclass == HashSet.class)
                            || (subclass == TreeSet.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getContentType()));
                        break;
                    }
                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                    //    but they are impl details and we basically do not care...
                    if (rawBase == EnumSet.class) {
                        return baseType;
                    }
                }
            }
            // (3) Sub-class does not take type parameters -- just resolve subtype
            if (subclass.getTypeParameters().length == 0) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }

            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
            // !!! TODO (as of 28-Jan-2016, at least)

            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
            //    a way to fully resolve and merge hierarchies; but that gets expensive
            //    so let's, for now, try to create close-enough approximation that
            //    is not 100% same, structurally, but has equivalent information for
            //    our specific neeeds.
            if (baseType.isInterface()) {
                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null,
                        new JavaType[] { baseType });
            } else {
                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType,
                        NO_TYPES);
            }
            // Only SimpleType returns null, but if so just resolve regularly
            if (newType == null) {
                // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy
                // (hopefully passing null Class for root is ok)
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());        
            }
        } while (false);

        // except possibly handlers
//      newType = newType.withHandlersFrom(baseType);
        return newType;

        // 20-Oct-2015, tatu: Old simplistic approach
        
        /*
        // Currently mostly SimpleType instances can become something else
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* Tricky part here is that some JavaType instances have been constructed
         * from generic type (usually via TypeReference); and in those case
         * types have been resolved. Alternative is that the leaf type is type-erased
         * class, in which case this has not been done.
         * For now simplest way to handle this is to split processing in two: latter
         * case actually fully works; and former mostly works. In future may need to
         * rewrite former part, which requires changes to JavaType as well.
         */
        if (expType == type.getParameterSource()) {
            // Direct type info; good since we can return it as is
            int count = type.containedTypeCount();
            if (count == 0) return null;
            JavaType[] result = new JavaType[count];
            for (int i = 0; i < count; ++i) {
                result[i] = type.containedType(i);
            }
            return result;
=======
        JavaType match = type.findSuperType(expType);
        if (match == null) {
            return NO_TYPES;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* Otherwise need to go through type-erased class. This may miss cases where
         * we get generic type; ideally JavaType/SimpleType would retain information
         * about generic declaration at main level... but let's worry about that
         * if/when there are problems; current handling is an improvement over earlier
         * code.
         */
        Class<?> raw = type.getRawClass();
        return findTypeParameters(raw, expType, new TypeBindings(this, type));
=======
        return match.getBindings().typeParameterArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @since 2.7
=======
     * @deprecated Since 2.7 resolve raw type first, then find type parameters
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType[] findTypeParameters(JavaType type, Class<?> expType, TypeBindings bindings)
    {
        if (expType == type.getParameterSource()) {
            int count = type.containedTypeCount();
            if (count == 0) return null;
            JavaType[] result = new JavaType[count];
            for (int i = 0; i < count; ++i) {
                result[i] = type.containedType(i);
            }
            return result;
        }
        Class<?> raw = type.getRawClass();
        return findTypeParameters(raw, expType, bindings);
=======
    @Deprecated // since 2.7    
    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {
        return findTypeParameters(constructType(clz, bindings), expType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return findTypeParameters(clz, expType, new TypeBindings(this, clz));
    }

    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)
    {
        // First: find full inheritance chain
        HierarchicType subType = _findSuperTypeChain(clz, expType);
        // Caller is supposed to ensure this never happens, so:
        if (subType == null) {
            throw new IllegalArgumentException("Class "+clz.getName()+" is not a subtype of "+expType.getName());
        }
        // Ok and then go to the ultimate super-type:
        HierarchicType superType = subType;
        while (superType.getSuperType() != null) {
            superType = superType.getSuperType();
            Class<?> raw = superType.getRawClass();
            TypeBindings newBindings = new TypeBindings(this, raw);
            if (superType.isGeneric()) { // got bindings, need to resolve
                ParameterizedType pt = superType.asGeneric();
                Type[] actualTypes = pt.getActualTypeArguments();
                TypeVariable<?>[] vars = raw.getTypeParameters();
                int len = actualTypes.length;
                for (int i = 0; i < len; ++i) {
                    String name = vars[i].getName();
                    JavaType type = _constructType(actualTypes[i], bindings);
                    newBindings.addBinding(name, type);
                }
            }
            bindings = newBindings;
        }

        // which ought to be generic (if not, it's raw type)
        if (!superType.isGeneric()) {
            return null;
        }
        return bindings.typesAsArray();
=======
        return findTypeParameters(constructType(clz), expType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return _constructType(type, null);
=======
        return _fromAny(null, type, EMPTY_BINDINGS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return _constructType(type, bindings);
=======
        return _fromAny(null, type, bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType constructType(TypeReference<?> typeRef) {
        return _constructType(typeRef.getType(), null);
=======
    public JavaType constructType(TypeReference<?> typeRef)
    {
        // 19-Oct-2015, tatu: Simpler variant like so should work
        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);

        // but if not, due to funky sub-classing, type variables, what follows
        // is a more complete processing a la Java ClassMate.

        /*
        final Class<?> refdRawType = typeRef.getClass();
        JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);
        JavaType genType = type.findSuperType(TypeReference.class);
        if (genType == null) { // sanity check; shouldn't occur
            throw new IllegalArgumentException("Unparameterized GenericType instance ("+refdRawType.getName()+")");
        }
        TypeBindings b = genType.getBindings();
        JavaType[] params = b.typeParameterArray();
        if (params.length == 0) {
            throw new IllegalArgumentException("Unparameterized GenericType instance ("+refdRawType.getName()+")");
        }
        return params[0];
        */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
    public JavaType constructType(Type type, Class<?> context) {
        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);
        return _constructType(type, b);
=======

    /**
     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
     */
    @Deprecated
    public JavaType constructType(Type type, Class<?> contextClass) {
        TypeBindings bindings = (contextClass == null)
                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
        return _fromAny(null, type, bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Factory method that can be used if type information is passed
     * as Java typing returned from <code>getGenericXxx</code> methods
     * (usually for a return or argument type).
=======
     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _constructType(Type type, TypeBindings context)
    {
        JavaType resultType;

        // simple class?
        if (type instanceof Class<?>) {
            resultType = _fromClass((Class<?>) type, context);
        }
        // But if not, need to start resolving.
        else if (type instanceof ParameterizedType) {
            resultType = _fromParamType((ParameterizedType) type, context);
        }
        else if (type instanceof JavaType) { // [Issue#116]
            return (JavaType) type;
        }
        else if (type instanceof GenericArrayType) {
            resultType = _fromArrayType((GenericArrayType) type, context);
        }
        else if (type instanceof TypeVariable<?>) {
            resultType = _fromVariable((TypeVariable<?>) type, context);
        }
        else if (type instanceof WildcardType) {
            resultType = _fromWildcard((WildcardType) type, context);
        } else {
            // sanity check
            throw new IllegalArgumentException("Unrecognized Type: "+((type == null) ? "[null]" : type.toString()));
        }
        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,
         * for now only call for simple types (i.e. not for arrays, map or collections).
         * Can be changed in future it necessary
         */
        if (_modifiers != null && !resultType.isContainerType()) {
            for (TypeModifier mod : _modifiers) {
                resultType = mod.modifyType(resultType, type, context, this);
            }
        }
        return resultType;
=======
    @Deprecated
    public JavaType constructType(Type type, JavaType contextType) {
        TypeBindings bindings = (contextType == null)
                ? TypeBindings.emptyBindings() : contextType.getBindings();
        return _fromAny(null, type, bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return ArrayType.construct(_constructType(elementType, null), null, null);
=======
        return ArrayType.construct(_fromAny(null, elementType, null), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return ArrayType.construct(elementType, null, null);
=======
        return ArrayType.construct(elementType, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionType.construct(collectionClass, constructType(elementClass));
=======
        return constructCollectionType(collectionClass,
                _fromClass(null, elementClass, EMPTY_BINDINGS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionType.construct(collectionClass, elementType);
=======
        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be
        //    a valid use case here
        return (CollectionType) _fromClass(null, collectionClass,
                TypeBindings.create(collectionClass, elementType));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionLikeType.construct(collectionClass, constructType(elementClass));
=======
        return constructCollectionLikeType(collectionClass,
                _fromClass(null, elementClass, EMPTY_BINDINGS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionLikeType.construct(collectionClass, elementType);
=======
        JavaType type = _fromClass(null, collectionClass,
                TypeBindings.createIfNeeded(collectionClass, elementType));
        if (type instanceof CollectionLikeType) {
            return (CollectionLikeType) type;
        }
        return CollectionLikeType.upgradeFrom(type, elementType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {
        return MapType.construct(mapClass, keyType, valueType);
=======
    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {
        JavaType kt, vt;
        if (mapClass == Properties.class) {
            kt = vt = CORE_TYPE_STRING;
        } else {
            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);
            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);
        }
        return constructMapType(mapClass, kt, vt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {
        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));
=======
    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {
        return (MapType) _fromClass(null, mapClass,
                TypeBindings.create(mapClass, new JavaType[] {
                        keyType, valueType
                }));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {
        return MapLikeType.construct(mapClass, keyType, valueType);
=======
    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {
        return constructMapLikeType(mapClass,
                _fromClass(null, keyClass, EMPTY_BINDINGS),
                _fromClass(null, valueClass, EMPTY_BINDINGS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {
        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));
=======
    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {
        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be
        //    a valid use case here
        JavaType type = _fromClass(null, mapClass,
                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));
        if (type instanceof MapLikeType) {
            return (MapLikeType) type;
        }
        return MapLikeType.upgradeFrom(type, keyType, valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * 
     * @deprecated Since 2.5, use variant that takes one more argument
=======
     *<p>
     * NOTE: was briefly deprecated for 2.6.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return constructSimpleType(rawType, rawType, parameterTypes);
=======
        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Quick sanity check: must match numbers of types with expected...
        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();
        if (typeVars.length != parameterTypes.length) {
            throw new IllegalArgumentException("Parameter type mismatch for "+rawType.getName()
                    +" (and target "+parameterTarget.getName()+"): expected "+typeVars.length
                    +" parameters, was given "+parameterTypes.length);
        }
        String[] names = new String[typeVars.length];
        for (int i = 0, len = typeVars.length; i < len; ++i) {
            names[i] = typeVars[i].getName();
        }
        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);
=======
        return constructSimpleType(rawType, parameterTypes);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType constructReferenceType(Class<?> rawType, JavaType refType)
=======
    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return new ReferenceType(rawType, refType, null, null, false);
=======
        return ReferenceType.construct(rawType, null, // no bindings
                null, null, // or super-class, interfaces?
                referredType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return new SimpleType(cls);
=======
        // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here
        return _constructSimple(cls, EMPTY_BINDINGS, null, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * type <code>List&lt;Integer></code>, you could
=======
     * type <code>List&lt;Set&lt;Integer>></code>, you could
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     *  TypeFactory.constructParametrizedType(List.class, List.class, Integer.class);
=======
     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);
     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * NOTE: type modifiers are NOT called on constructed type itself; but are called
     * when resolving <code>parameterClasses</code> into {@link JavaType}.
=======
     * NOTE: type modifiers are NOT called on constructed type.
     * 
     * @param parametrized Actual full type
     * @param parameterClasses Type parameters to apply
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,
            Class<?>... parameterClasses)
    {
=======
    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            pt[i] = _fromClass(parameterClasses[i], null);
=======
            pt[i] = _fromClass(null, parameterClasses[i], null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return constructParametrizedType(parametrized, parametersFor, pt);
    }

    /**
     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.
     */
    @Deprecated
    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {
        return constructParametrizedType(parametrized, parametrized, parameterClasses);
=======
        return constructParametricType(parametrized, pt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @since 2.5
=======
     * @since 2.5 NOTE: was briefly deprecated for 2.6
     */
    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)
    {
        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));
    }

    /**
     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType resultType;
        
        // Need to check kind of class we are dealing with...
        if (parametrized.isArray()) {
            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?
            if (parameterTypes.length != 1) {
                throw new IllegalArgumentException("Need exactly 1 parameter type for arrays ("+parametrized.getName()+")");
            }
            resultType = constructArrayType(parameterTypes[0]);
        }
        else if (Map.class.isAssignableFrom(parametrized)) {
            if (parameterTypes.length != 2) {
                throw new IllegalArgumentException("Need exactly 2 parameter types for Map types ("+parametrized.getName()+")");
            }
            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);
        }
        else if (Collection.class.isAssignableFrom(parametrized)) {
            if (parameterTypes.length != 1) {
                throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types ("+parametrized.getName()+")");
            }
            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);
        } else {
            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);
        }
        return resultType;
=======
        return constructParametricType(parametrized, parameterTypes);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.
=======
     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    @Deprecated
    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {
        return constructParametrizedType(parametrized, parametrized, parameterTypes);
=======
    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,
            Class<?>... parameterClasses)
    {
        return constructParametricType(parametrized, parameterClasses);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionType.construct(collectionClass, unknownType());
=======
        return constructCollectionType(collectionClass, unknownType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionLikeType.construct(collectionClass, unknownType());
=======
        return constructCollectionLikeType(collectionClass, unknownType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return MapType.construct(mapClass, unknownType(), unknownType());
=======
        return constructMapType(mapClass, unknownType(), unknownType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return MapLikeType.construct(mapClass, unknownType(), unknownType());
=======
        return constructMapLikeType(mapClass, unknownType(), unknownType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /* Actual factory methods
=======
    /* Low-level factory methods
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /**
     * @param context Mapping of formal parameter declarations (for generic
     *   types) into actual types
     */
    protected JavaType _fromClass(Class<?> clz, TypeBindings context)
=======
    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Barring that, we may have recently constructed an instance:
        ClassKey key = new ClassKey(clz);
        JavaType result = _typeCache.get(key); // ok, cache object is synced
        if (result != null) {
            return result;
=======
        // 28-May-2015, tatu: Properties are special, as per [databind#810]; fake "correct" parameter sig
        if (rawClass == Properties.class) {
            kt = vt = CORE_TYPE_STRING;
        } else {
            List<JavaType> typeParams = bindings.getTypeParameters();
            // ok to have no types ("raw")
            switch (typeParams.size()) {
            case 0: // acceptable?
                kt = vt = _unknownType();
                break;
            case 2:
                kt = typeParams.get(0);
                vt = typeParams.get(1);
                break;
            default:
                throw new IllegalArgumentException("Strange Map type "+rawClass.getName()+": can not determine type parameters");
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // If context was needed, weed do:
        /*
        if (context == null) {
            context = new TypeBindings(this, cls);
=======
    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
    {
        List<JavaType> typeParams = bindings.getTypeParameters();
        // ok to have no types ("raw")
        JavaType ct;
        if (typeParams.isEmpty()) {
            ct = _unknownType();
        } else if (typeParams.size() == 1) {
            ct = typeParams.get(0);
        } else {
            throw new IllegalArgumentException("Strange Collection type "+rawClass.getName()+": can not determine type parameters");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        */
=======
        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // First: do we have an array type?
        if (clz.isArray()) {
            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);
            /* Also: although enums can also be fully resolved, there's little
             * point in doing so (T extends Enum<T>) etc.
             */
        } else if (clz.isEnum()) {
            result = new SimpleType(clz);
            /* Maps and Collections aren't quite as hot; problem is, due
             * to type erasure we often do not know typing and can only assume
             * base Object.
             */
        } else if (Map.class.isAssignableFrom(clz)) {
            result = _mapType(clz);
        } else if (Collection.class.isAssignableFrom(clz)) {
            result =  _collectionType(clz);
=======
    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
    {
        List<JavaType> typeParams = bindings.getTypeParameters();
        // ok to have no types ("raw")
        JavaType ct;
        if (typeParams.isEmpty()) {
            ct = _unknownType();
        } else if (typeParams.size() == 1) {
            ct = typeParams.get(0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            // 28-Apr-2015, tatu: New class of types, referential...
            if (AtomicReference.class.isAssignableFrom(clz)) {
                
                JavaType[] pts = findTypeParameters(clz, AtomicReference.class);
                JavaType rt = (pts == null || pts.length != 1) ? unknownType() : pts[0];
                result = constructReferenceType(clz, rt);
            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types
            } else if (Map.Entry.class.isAssignableFrom(clz)) {
                JavaType[] pts = findTypeParameters(clz, Map.Entry.class);
                JavaType kt, vt;
                if (pts == null || pts.length != 2) {
                    kt = vt = unknownType();
                } else {
                    kt = pts[0];
                    vt = pts[1];
                }
                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });
            } else {
                result = new SimpleType(clz);
            }
=======
            throw new IllegalArgumentException("Strange Reference type "+rawClass.getName()+": can not determine type parameters");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        _typeCache.put(key, result); // cache object syncs
        return result;
=======
        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Method used by {@link TypeParser} when generics-aware version
     * is constructed.
=======
     * Factory method to call when no special {@link JavaType} is needed,
     * no generic parameters are passed. Default implementation may check
     * pre-constructed values for "well-known" types, but if none found
     * will simply call {@link #_newSimpleType}
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)
=======
    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        if (clz.isArray()) { // ignore generics (should never have any)
            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);
        }
        if (clz.isEnum()) { // ditto for enums
            return new SimpleType(clz);
        }
        if (Map.class.isAssignableFrom(clz)) {
            // First: if we do have param types, use them
            JavaType keyType, contentType;
            if (paramTypes.size() > 0) {
                keyType = paramTypes.get(0);
                contentType = (paramTypes.size() >= 2) ?
                        paramTypes.get(1) : _unknownType();
                return MapType.construct(clz, keyType, contentType);
            }
            return _mapType(clz);
        }
        if (Collection.class.isAssignableFrom(clz)) {
            if (paramTypes.size() >= 1) {
                return CollectionType.construct(clz, paramTypes.get(0));
=======
        if (bindings.isEmpty()) {
            JavaType result = _findWellKnownSimple(raw);
            if (result != null) {
                return result;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        if (paramTypes.size() == 0) {
            return new SimpleType(clz);
        }
        // Hmmh. Does this actually occur?
        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);
        return constructSimpleType(clz, clz, pt);
=======
        return _newSimpleType(raw, bindings, superClass, superInterfaces);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)
=======
    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* First: what is the actual base type? One odd thing
         * is that 'getRawType' returns Type, not Class<?> as
         * one might expect. But let's assume it is always of
         * type Class: if not, need to add more code to resolve
         * it to Class.
=======
        return new SimpleType(raw, bindings, superClass, superInterfaces);
    }

    protected JavaType _unknownType() {
        /* 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.
         *    This may have been due to potential mutability of the instance; but that
         *    should not be issue any more, and creation is somewhat wasteful. So let's
         *    try reusing singleton/flyweight instance.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType[] pt;
        
        if (paramCount == 0) {
            pt = NO_TYPES;
=======
    /**
     * Helper method called to see if requested, non-generic-parameterized
     * type is one of common, "well-known" types, instances of which are
     * pre-constructed and do not need dynamic caching.
     *
     * @since 2.7
     */
    protected JavaType _findWellKnownSimple(Class<?> clz) {
        if (clz.isPrimitive()) {
            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;
            if (clz == CLS_INT) return CORE_TYPE_INT;
            if (clz == CLS_LONG) return CORE_TYPE_LONG;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            pt = new JavaType[paramCount];
            for (int i = 0; i < paramCount; ++i) {
                pt[i] = _constructType(args[i], context);
            }
=======
            if (clz == CLS_STRING) return CORE_TYPE_STRING;
            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Ok: Map or Collection?
        if (Map.class.isAssignableFrom(rawType)) {
            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails
            JavaType subtype = constructSimpleType(rawType, rawType, pt);
            // 23-Sep-2015, tatu: and why do we not pass 3rd arg of 'context'? Won't help, it seems,
            //   plus causes other issues. Sigh.
            JavaType[] mapParams = findTypeParameters(subtype, Map.class);
            if (mapParams.length != 2) {
                throw new IllegalArgumentException("Could not find 2 type parameters for Map class "+rawType.getName()+" (found "+mapParams.length+")");
            }
            return MapType.construct(rawType, mapParams[0], mapParams[1]);
        }
        if (Collection.class.isAssignableFrom(rawType)) {
            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails
            JavaType subtype = constructSimpleType(rawType, rawType, pt);
            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);
            if (collectionParams.length != 1) {
                throw new IllegalArgumentException("Could not find 1 type parameter for Collection class "+rawType.getName()+" (found "+collectionParams.length+")");
            }
            return CollectionType.construct(rawType, collectionParams[0]);
        }
        // 28-Apr-2015, tatu: New class of types, referential...
        if (AtomicReference.class.isAssignableFrom(rawType)) {
            JavaType rt = null;

            if (rawType == AtomicReference.class) {
                if (paramCount == 1) {
                    rt = pt[0];
                }
            } else {
                JavaType subtype = constructSimpleType(rawType, rawType, pt);
                JavaType[] pts = findTypeParameters(subtype, AtomicReference.class, context);
                if (pts != null && pts.length == 1) {
                    rt = pts[0];
                }
=======
    /*
    /**********************************************************
    /* Actual type resolution, traversal
    /**********************************************************
     */

    /**
     * Factory method that can be used if type information is passed
     * as Java typing returned from <code>getGenericXxx</code> methods
     * (usually for a return or argument type).
     */
    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)
    {
        JavaType resultType;

        // simple class?
        if (type instanceof Class<?>) {
            // Important: remove possible bindings since this is type-erased thingy
            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);
        }
        // But if not, need to start resolving.
        else if (type instanceof ParameterizedType) {
            resultType = _fromParamType(context, (ParameterizedType) type, bindings);
        }
        else if (type instanceof JavaType) { // [databind#116]
            // no need to modify further if we already had JavaType
            return (JavaType) type;
        }
        else if (type instanceof GenericArrayType) {
            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);
        }
        else if (type instanceof TypeVariable<?>) {
            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);
        }
        else if (type instanceof WildcardType) {
            resultType = _fromWildcard(context, (WildcardType) type, bindings);
        } else {
            // sanity check
            throw new IllegalArgumentException("Unrecognized Type: "+((type == null) ? "[null]" : type.toString()));
        }
        /* Need to allow TypeModifiers to alter actual type; however,
         * for now only call for simple types (i.e. not for arrays, map or collections).
         * Can be changed in future it necessary
         */
        if (_modifiers != null && !resultType.isContainerType()) {
            TypeBindings b = resultType.getBindings();
            if (b == null) {
                b = EMPTY_BINDINGS;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);
        }
        if (Map.Entry.class.isAssignableFrom(rawType)) {
            JavaType kt = null, vt = null;

            if (rawType == Map.Entry.class) {
                if (paramCount == 2) {
                    kt = pt[0];
                    vt = pt[1];
                }
            } else {
                // 23-Sep-2015, tatu: Must be careful here; type resolution can NOT be done
                //    directly quite yet. Instead, need to do indirectly...
                JavaType subtype = constructSimpleType(rawType, rawType, pt);
                JavaType[] pts = findTypeParameters(subtype, Map.Entry.class, context);
                if (pts != null && pts.length == 2) {
                    kt = pts[0];
                    vt = pts[1];
                }
=======
            for (TypeModifier mod : _modifiers) {
                resultType = mod.modifyType(resultType, type, b, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        
        if (paramCount == 0) { // no generics
            return new SimpleType(rawType);
        }
        return constructSimpleType(rawType, pt);
=======
        return resultType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)
=======
    /**
     * @param bindings Mapping of formal parameter declarations (for generic
     *   types) into actual types
     */
    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType compType = _constructType(type.getGenericComponentType(), context);
        return ArrayType.construct(compType, null, null);
    }
=======
        // Very first thing: small set of core types we know well:
        JavaType result = _findWellKnownSimple(rawType);
        if (result != null) {
            return result;
        }
        // Barring that, we may have recently constructed an instance:
        // !!! TODO 16-Oct-2015, tatu: For now let's only cached non-parameterized; otherwise
        //     need better cache key
        boolean cachable = (bindings == null) || bindings.isEmpty();
        if (cachable) {
            result = _typeCache.get(rawType); // ok, cache object is synced
            if (result != null) {
                return result;
            }
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)
    {
        final String name = type.getName();
        // 19-Mar-2015: Without context, all we can check are bounds.
=======
        // 15-Oct-2015, tatu: recursive reference?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            // And to prevent infinite loops, now need this:
            context = new TypeBindings(this, (Class<?>) null);
=======
            context = new ClassStack(rawType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            // Ok: here's where context might come in handy!
            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow
             *   unresolved type variables to handle some cases where bounds
             *   are enough. Let's hope it does not hide real fail cases.
             */
            JavaType actualType = context.findType(name, false);
            if (actualType != null) {
                return actualType;
=======
            ClassStack prev = context.find(rawType);
            if (prev != null) {
                // Self-reference: needs special handling, then...
                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);
                prev.addSelfReference(selfRef);
                return selfRef;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // With type variables we must use bound information.
        // Theoretically this gets tricky, as there may be multiple
        // bounds ("... extends A & B"); and optimally we might
        // want to choose the best match. Also, bounds are optional;
        // but here we are lucky in that implicit "Object" is
        // added as bounds if so.
        // Either way let's just use the first bound, for now, and
        // worry about better match later on if there is need.

        /* 29-Jan-2010, tatu: One more problem are recursive types
         *   (T extends Comparable<T>). Need to add "placeholder"
         *   for resolution to catch those.
         */
        context._addPlaceholder(name);
        return _constructType(bounds[0], context);
=======
        if (cachable) {
            _typeCache.putIfAbsent(rawType, result); // cache object syncs
        }
        return result;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)
=======
    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* Similar to challenges with TypeVariable, we may have
         * multiple upper bounds. But it is also possible that if
         * upper bound defaults to Object, we might want to consider
         * lower bounds instead.
         *
         * For now, we won't try anything more advanced; above is
         * just for future reference.
         */
        return _constructType(type.getUpperBounds()[0], context);
=======
        Type parent = ClassUtil.getGenericSuperclass(rawType);
        if (parent == null) {
            return null;
        }
        return _fromAny(context, parent, parentBindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    private JavaType _mapType(Class<?> rawClass)
=======
    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // 28-May-2015, tatu: Properties are special, as per [databind#810]
        if (rawClass == Properties.class) {
            return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING);
=======
        Type[] types = ClassUtil.getGenericInterfaces(rawType);
        if (types == null || types.length == 0) {
            return NO_TYPES;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);
        // ok to have no types ("raw")
        if (typeParams == null) {
            return MapType.construct(rawClass, _unknownType(), _unknownType());
        }
        // but exactly 2 types if any found
        if (typeParams.length != 2) {
            throw new IllegalArgumentException("Strange Map type "+rawClass.getName()+": can not determine type parameters");
=======
        int len = types.length;
        JavaType[] resolved = new JavaType[len];
        for (int i = 0; i < len; ++i) {
            Type type = types[i];
            resolved[i] = _fromAny(context, type, parentBindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return MapType.construct(rawClass, typeParams[0], typeParams[1]);
=======
        return resolved;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    private JavaType _collectionType(Class<?> rawClass)
=======
    /**
     * Helper class used to check whether exact class for which type is being constructed
     * is one of well-known base interfaces or classes that indicates alternate
     * {@link JavaType} implementation.
     */
    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);
        // ok to have no types ("raw")
        if (typeParams == null) {
            return CollectionType.construct(rawClass, _unknownType());
=======
        // Quite simple when we resolving exact class/interface; start with that
        if (rawType == Map.class) {
            return _mapType(rawType, bindings, superClass, superInterfaces);
        }
        if (rawType == Collection.class) {
            return _collectionType(rawType, bindings, superClass, superInterfaces);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // but exactly 2 types if any found
        if (typeParams.length != 1) {
            throw new IllegalArgumentException("Strange Collection type "+rawClass.getName()+": can not determine type parameters");
=======
        // and since 2.6 one referential type
        if (rawType == AtomicReference.class) {
            return _referenceType(rawType, bindings, superClass, superInterfaces);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionType.construct(rawClass, typeParams[0]);
    }    
=======
        // 01-Nov-2015, tatu: As of 2.7, couple of potential `CollectionLikeType`s (like
        //    `Iterable`, `Iterator`), and `MapLikeType`s (`Map.Entry`) are not automatically
        //    detected, related to difficulties in propagating type upwards (Iterable, for
        //    example, is a weak, tag-on type). They may be detectable in future.
        return null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)
=======
    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // can't resolve raw types; possible to have as-of-yet-unbound types too:
        if (leafType != null && leafType.isGeneric()) {
            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();
            for (int i = 0, len = typeVariables.length; i < len; ++i) {
                TypeVariable<?> tv = typeVariables[i];
                if (variableName.equals(tv.getName())) {
                    // further resolution needed?
                    Type type = leafType.asGeneric().getActualTypeArguments()[i];
                    if (type instanceof TypeVariable<?>) {
                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);
                    }
                    // no we're good for the variable (but it may have parameterization of its own)
                    return _constructType(type, bindings);
                }
=======
        // But that's not all: may be possible current type actually implements an
        // interface type. So...
        final int intCount = superInterfaces.length;

        for (int i = 0; i < intCount; ++i) {
            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);
            if (result != null) {
                return result;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return _unknownType();
    }
    
    protected JavaType _unknownType() {
        return new SimpleType(Object.class);
=======
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)
=======
    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,
            TypeBindings parentBindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // If super-type is a class (not interface), bit simpler
        if (supertype.isInterface()) {
            return _findSuperInterfaceChain(subtype, supertype);
=======
        // Assumption here is we'll always get Class, not one of other Types
        Class<?> rawType = (Class<?>) ptype.getRawType();

        // 29-Oct-2015, tatu: For performance reasons, let's streamline handling of
        //   couple of not-so-useful parametric types
        if (rawType == CLS_ENUM) {
            return CORE_TYPE_ENUM;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return _findSuperClassChain(subtype, supertype);
    }
=======
        if (rawType == CLS_COMPARABLE) {
            return CORE_TYPE_COMPARABLE;
        }
        if (rawType == CLS_CLASS) {
            return CORE_TYPE_CLASS;
        }

        // First: what is the actual base type? One odd thing is that 'getRawType'
        // returns Type, not Class<?> as one might expect. But let's assume it is
        // always of type Class: if not, need to add more code to resolve it to Class.        
        Type[] args = ptype.getActualTypeArguments();
        int paramCount = (args == null) ? 0 : args.length;
        JavaType[] pt;
        TypeBindings newBindings;        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)
    {
        HierarchicType current = new HierarchicType(currentType);
        Class<?> raw = current.getRawClass();
        if (raw == target) {
            return current;
        }
        // Otherwise, keep on going down the rat hole...
        Type parent = raw.getGenericSuperclass();
        if (parent != null) {
            HierarchicType sup = _findSuperClassChain(parent, target);
            if (sup != null) {
                sup.setSubType(current);
                current.setSuperType(sup);
                return current;
=======
        if (paramCount == 0) {
            newBindings = EMPTY_BINDINGS;
        } else {
            pt = new JavaType[paramCount];
            for (int i = 0; i < paramCount; ++i) {
                pt[i] = _fromAny(context, args[i], parentBindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return null;
=======
        return _fromClass(context, rawType, newBindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)
=======
    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        HierarchicType current = new HierarchicType(currentType);
        Class<?> raw = current.getRawClass();
        if (raw == target) {
            return new HierarchicType(currentType);
        }
        // Otherwise, keep on going down the rat hole; first implemented interfaces
        /* 16-Aug-2011, tatu: Minor optimization based on profiled hot spot; let's
         *   try caching certain commonly needed cases
         */
        if (raw == HashMap.class) {
            if (target == Map.class) {
                return _hashMapSuperInterfaceChain(current);
            }
        }
        if (raw == ArrayList.class) {
            if (target == List.class) {
                return _arrayListSuperInterfaceChain(current);
            }
        }
        return _doFindSuperInterfaceChain(current, target);
=======
        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);
        return ArrayType.construct(elementType, bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)
=======

    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        Class<?> raw = current.getRawClass();
        Type[] parents = raw.getGenericInterfaces();
        // as long as there are superclasses
        // and unless we have already seen the type (<T extends X<T>>)
        if (parents != null) {
            for (Type parent : parents) {
                HierarchicType sup = _findSuperInterfaceChain(parent, target);
                if (sup != null) {
                    sup.setSubType(current);
                    current.setSuperType(sup);
                    return current;
                }
            }
=======
        // ideally should find it via bindings:
        final String name = var.getName();
        JavaType type = bindings.findBoundType(name);
        if (type != null) {
            return type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // and then super-class if any
        Type parent = raw.getGenericSuperclass();
        if (parent != null) {
            HierarchicType sup = _findSuperInterfaceChain(parent, target);
            if (sup != null) {
                sup.setSubType(current);
                current.setSuperType(sup);
                return current;
            }
=======
        // but if not, use bounds... note that approach here is simplistic; not taking
        // into account possible multiple bounds, nor consider upper bounds.
        if (bindings.hasUnbound(name)) {
            return CORE_TYPE_OBJECT;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return null;
=======
        bindings = bindings.withUnboundVariable(name);

        Type[] bounds = var.getBounds();
        return _fromAny(context, bounds[0], bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)
=======
    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        if (_cachedHashMapType == null) {
            HierarchicType base = current.deepCloneWithoutSubtype();
            _doFindSuperInterfaceChain(base, Map.class);
            _cachedHashMapType = base.getSuperType();
        }
        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();
        current.setSuperType(t);
        t.setSubType(current);
        return current;
    }

    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)
    {
        if (_cachedArrayListType == null) {
            HierarchicType base = current.deepCloneWithoutSubtype();
            _doFindSuperInterfaceChain(base, List.class);
            _cachedArrayListType = base.getSuperType();
        }
        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();
        current.setSuperType(t);
        t.setSubType(current);
        return current;
=======
        /* Similar to challenges with TypeVariable, we may have multiple upper bounds.
         * But it is also possible that if upper bound defaults to Object, we might
         * want to consider lower bounds instead.
         * For now, we won't try anything more advanced; above is just for future reference.
         */
        return _fromAny(context, type.getUpperBounds()[0], bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    private CollectionType(Class<?> collT, JavaType elemT,
=======
    private CollectionType(Class<?> collT, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        super(collT,  elemT, valueHandler, typeHandler, asStatic);
=======
        super(collT, bindings, superClass, superInts, elemT, valueHandler, typeHandler, asStatic);
    }

    /**
     * @since 2.7
     */
    protected CollectionType(TypeBase base, JavaType elemT) {
        super(base, elemT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return new CollectionType(subclass, _elementType, null, null, _asStatic);
=======
    /**
     * @since 2.7
     */
    public static CollectionType construct(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT) {
        return new CollectionType(rawType, bindings, superClass, superInts, elemT,
                null, null, false);
    }

    /**
     * @deprecated Since 2.7, remove from 2.8
     */
    @Deprecated // since 2.7
    public static CollectionType construct(Class<?> rawType, JavaType elemT) {
        // First: may need to fabricate TypeBindings (needed for refining into
        // concrete collection types, as per [databind#1102])
        TypeVariable<?>[] vars = rawType.getTypeParameters();
        TypeBindings bindings;
        if ((vars == null) || (vars.length != 1)) {
            bindings = TypeBindings.emptyBindings();
        } else {
            bindings = TypeBindings.create(rawType, elemT);
        }
        return new CollectionType(rawType, bindings,
                // !!! TODO: Wrong, does have supertypes, but:
                _bogusSuperClass(rawType), null, elemT,
                null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _elementType.getRawClass()) {
            return this;
        }
        return new CollectionType(_class, _elementType.narrowBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
    protected JavaType _narrow(Class<?> subclass) {
        return new CollectionType(subclass, _bindings,
                _superClass, _superInterfaces, _elementType, null, null, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _elementType.getRawClass()) {
=======
    public JavaType withContentType(JavaType contentType) {
        if (_elementType == contentType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType.widenBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
        return new CollectionType(_class, _bindings, _superClass, _superInterfaces,
                contentType, _valueHandler, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType, _valueHandler, h, _asStatic);
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType.withTypeHandler(h),
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType, h, _typeHandler, _asStatic);
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType.withValueHandler(h),
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType.withStaticTyping(),
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    public Class<?> getParameterSource() {
        return java.util.Collection.class;
=======
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return new CollectionType(rawType, bindings,
                superClass, superInterfaces, _elementType,
                _valueHandler, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    protected ArrayType(JavaType componentType, Object emptyInstance,
=======
    protected ArrayType(JavaType componentType, TypeBindings bindings, Object emptyInstance,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        super(emptyInstance.getClass(), componentType.hashCode(),
=======
        // No super-class, interfaces, for now
        super(emptyInstance.getClass(), bindings, null, null,
                componentType.hashCode(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    public static ArrayType construct(JavaType componentType,
            Object valueHandler, Object typeHandler)
    {
        /* This is bit messy: there is apparently no other way to
         * reconstruct actual concrete/raw array class from component
         * type, than to construct an instance, get class (same is
         * true for GenericArracyType as well; hence we won't bother
         * passing that in).
         */
=======
    public static ArrayType construct(JavaType componentType, TypeBindings bindings) {
        return construct(componentType, bindings, null, null);
    }

    public static ArrayType construct(JavaType componentType, TypeBindings bindings,
            Object valueHandler, Object typeHandler) {
        // Figuring out raw class for generic array is actually bit tricky...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(componentType, emptyInstance, null, null, false);
    }                                   
    
=======
        return new ArrayType(componentType, bindings, emptyInstance, valueHandler, typeHandler, false);
    }

    @Override
    public JavaType withContentType(JavaType contentType) {
        Object emptyInstance = Array.newInstance(contentType.getRawClass(), 0);
        return new ArrayType(contentType, _bindings, emptyInstance,
                _valueHandler, _typeHandler, _asStatic);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType, _emptyArray, _valueHandler, h, _asStatic);
=======
        return new ArrayType(_componentType, _bindings, _emptyArray, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType.withTypeHandler(h), _emptyArray,
=======
        return new ArrayType(_componentType.withTypeHandler(h), _bindings, _emptyArray,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType, _emptyArray, h, _typeHandler,_asStatic);
=======
        return new ArrayType(_componentType, _bindings, _emptyArray, h, _typeHandler,_asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType.withValueHandler(h), _emptyArray,
=======
        return new ArrayType(_componentType.withValueHandler(h), _bindings, _emptyArray,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType.withStaticTyping(),
=======
        return new ArrayType(_componentType.withStaticTyping(), _bindings,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    protected JavaType _narrow(Class<?> subclass)
    {
        /* Ok: need a bit of indirection here. First, must replace component
         * type (and check that it is compatible), then re-construct.
         */
        if (!subclass.isArray()) { // sanity check, should never occur
            throw new IllegalArgumentException("Incompatible narrowing operation: trying to narrow "+toString()+" to class "+subclass.getName());
        }
        /* Hmmh. This is an awkward back reference... but seems like the
         * only simple way to do it.
         */
        Class<?> newCompClass = subclass.getComponentType();
        /* 14-Mar-2011, tatu: it gets even worse, as we do not have access to
         *   currently configured TypeFactory. This could theoretically cause
         *   problems (when narrowing from array of Objects, to array of non-standard
         *   Maps, for example); but for now need to defer solving this until
         *   it actually becomes a real problem, not just potential one.
         *   (famous last words?)
         */
        JavaType newCompType = TypeFactory.defaultInstance().constructType(newCompClass);
        return construct(newCompType, _valueHandler, _typeHandler);
=======
    @Deprecated // since 2.7
    protected JavaType _narrow(Class<?> subclass) {
        return _reportUnsupported();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    /**
     * For array types, both main type and content type can be modified;
     * but ultimately they are interchangeable.
     */
=======
    // Should not be called, as array types in Java are not extensible; but
    // let's not freak out even if it is called?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _componentType.getRawClass()) {
            return this;
        }
        return construct(_componentType.narrowBy(contentClass),
                _valueHandler, _typeHandler);
=======
    public JavaType refine(Class<?> contentClass, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    @Override
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _componentType.getRawClass()) {
            return this;
        }
        return construct(_componentType.widenBy(contentClass),
                _valueHandler, _typeHandler);
=======
    private JavaType _reportUnsupported() {
        throw new UnsupportedOperationException("Can not narrow or widen array types");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    public JavaType containedType(int index) {
            return (index == 0) ? _componentType : null;
=======
    public Object getContentTypeHandler() {
        return _componentType.getTypeHandler();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
     * Lazily-instantiated bindings of resolved type parameters
=======
     * Array of type (type variable) names.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
     * Also: we may temporarily want to mark certain named types
     * as resolved (but without exact type); if so, we'll just store
     * names here.
=======
     * Types matching names
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
     * Sometimes it is necessary to allow hierarchic resolution of types: specifically
     * in cases where there are local bindings (for methods, constructors). If so,
     * we'll just use simple delegation model.
=======
     * Names of potentially unresolved type variables.
     *
     * @since 2.3
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**********************************************************
=======
    /**********************************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**********************************************************
=======
    /**********************************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public TypeBindings(TypeFactory typeFactory, Class<?> cc)
=======
    private TypeBindings(String[] names, JavaType[] types, String[] uvars)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        this(typeFactory, null, cc, null);
=======
        _names = (names == null) ? NO_STRINGS : names;
        _types = (types == null) ? NO_TYPES : types;
        if (_names.length != _types.length) {
            throw new IllegalArgumentException("Mismatching names ("+_names.length+"), types ("+_types.length+")");
        }
        int h = 1;
        for (int i = 0, len = _types.length; i < len; ++i) {
            h += _types[i].hashCode();
        }
        _unboundVariables = uvars;
        _hashCode = h;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public TypeBindings(TypeFactory typeFactory, JavaType type)
    {
        this(typeFactory, null, type.getRawClass(), type);
=======
    public static TypeBindings emptyBindings() {
        return EMPTY;
    }

    // Let's just canonicalize serialized EMPTY back to static instance, if need be
    protected Object readResolve() {
        if ((_names == null) || (_names.length == 0)) {
            return EMPTY;
        }
        return this;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public TypeBindings childInstance() {
        return new TypeBindings(_typeFactory, this, _contextClass, _contextType);
=======
    public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList)
    {
        JavaType[] types = (typeList == null || typeList.isEmpty()) ?
                NO_TYPES : typeList.toArray(new JavaType[typeList.size()]);
        return create(erasedType, types);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    private TypeBindings(TypeFactory tf, TypeBindings parent,
            Class<?> cc, JavaType type)
=======
    public static TypeBindings create(Class<?> erasedType, JavaType[] types)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        _typeFactory = tf;
        _parentBindings = parent;
        _contextClass = cc;
        _contextType = type;
=======
        if (types == null) {
            types = NO_TYPES;
        } else switch (types.length) {
        case 1:
            return create(erasedType, types[0]);
        case 2:
            return create(erasedType, types[0], types[1]);
        }
        TypeVariable<?>[] vars = erasedType.getTypeParameters();
        String[] names;
        if (vars == null || vars.length == 0) {
            names = NO_STRINGS;
        } else {
            int len = vars.length;
            names = new String[len];
            for (int i = 0; i < len; ++i) {
                names[i] = vars[i].getName();
            }
        }
        // Check here to give better error message
        if (names.length != types.length) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                   +" with "+types.length+" type parameter"
                   +((types.length == 1) ? "" : "s")+": class expects "+names.length);
        }
        return new TypeBindings(names, types, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Pass-through type resolution methods
    /**********************************************************
     */

    public JavaType resolveType(Class<?> cls) {
        return _typeFactory._constructType(cls, this);
=======
    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1)
    {
        // 30-Oct-2015, tatu: Minor optimization for relatively common cases
        TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType);
        int varLen = (vars == null) ? 0 : vars.length;
        if (varLen != 1) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                    +" with 1 type parameter: class expects "+varLen);
        }
        return new TypeBindings(new String[] { vars[0].getName() },
                new JavaType[] { typeArg1 }, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public JavaType resolveType(Type type) {
        return _typeFactory._constructType(type, this);
=======
    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2)
    {
        // 30-Oct-2015, tatu: Minor optimization for relatively common cases
        TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType);
        int varLen = (vars == null) ? 0 : vars.length;
        if (varLen != 2) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                    +" with 2 type parameters: class expects "+varLen);
        }
        return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() },
                new JavaType[] { typeArg1, typeArg2 }, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Accesors
    /**********************************************************
=======
    /**
     * Alternate factory method that may be called if it is possible that type
     * does or does not require type parameters; this is mostly useful for
     * collection- and map-like types.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE

    public int getBindingCount() {
        if (_bindings == null) {
            _resolve();
=======
    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1)
    {
        TypeVariable<?>[] vars = erasedType.getTypeParameters();
        int varLen = (vars == null) ? 0 : vars.length;
        if (varLen == 0) {
            return EMPTY;
        }
        if (varLen != 1) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                    +" with 1 type parameter: class expects "+varLen);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        return _bindings.size();
=======
        return new TypeBindings(new String[] { vars[0].getName() },
                new JavaType[] { typeArg1 }, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE

    @Deprecated // since 2.6, remove from 2.7
    public JavaType findType(String name) {
        return findType(name, true);
=======
    
    /**
     * Alternate factory method that may be called if it is possible that type
     * does or does not require type parameters; this is mostly useful for
     * collection- and map-like types.
     */
    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types)
    {
        TypeVariable<?>[] vars = erasedType.getTypeParameters();
        if (vars == null || vars.length == 0) {
            return EMPTY;
        }
        if (types == null) {
            types = NO_TYPES;
        }
        int len = vars.length;
        String[] names = new String[len];
        for (int i = 0; i < len; ++i) {
            names[i] = vars[i].getName();
        }
        // Check here to give better error message
        if (names.length != types.length) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                   +" with "+types.length+" type parameter"
                   +((types.length == 1) ? "" : "s")+": class expects "+names.length);
        }
        return new TypeBindings(names, types, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public JavaType findType(String name, boolean mustFind)
=======
    /**
     * Method for creating an instance that has same bindings as this object,
     * plus an indicator for additional type variable that may be unbound within
     * this context; this is needed to resolve recursive self-references.
     */
    public TypeBindings withUnboundVariable(String name)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        if (_bindings == null) {
            _resolve();
        }
        JavaType t = _bindings.get(name);
        if (t != null) {
            return t;
        }
        if (_placeholders != null && _placeholders.contains(name)) {
            return UNBOUND;
        }
        if (_parentBindings != null) {
            return _parentBindings.findType(name);
        }
        // nothing found, so...
        // Should we throw an exception or just return null?
        
        /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within
         *   java.util, such as HashMap$KeySet; so let's punt the problem
         *   (honestly not sure what to do -- they are unbound for good, I think)
         */
        if (_contextClass != null) {
            Class<?> enclosing = _contextClass.getEnclosingClass();
            if (enclosing != null) {
                // [JACKSON-572]: Actually, let's skip this for all non-static inner classes
                //   (which will also cover 'java.util' type cases...
                if (!Modifier.isStatic(_contextClass.getModifiers())) {
                    return UNBOUND;
                }
=======
        int len = (_unboundVariables == null) ? 0 : _unboundVariables.length;
        String[] names =  (len == 0)
                ? new String[1] : Arrays.copyOf(_unboundVariables, len+1);
        names[len] = name;
        return new TypeBindings(_names, _types, names);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                // ... so this piece of code should not be needed any more
                /*
                Package pkg = enclosing.getPackage();
                if (pkg != null) {
                    // as per [JACKSON-533], also include "java.util.concurrent":
                    if (pkg.getName().startsWith("java.util")) {
                        return UNBOUND;
                    }
                }
                */
=======
    /*
    /**********************************************************************
    /* Accessors
    /**********************************************************************
     */
    
    /**
     * Find type bound to specified name, if there is one; returns bound type if so, null if not.
     */
    public JavaType findBoundType(String name)
    {
        for (int i = 0, len = _names.length; i < len; ++i) {
            if (name.equals(_names[i])) {
                return _types[i];
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        if (!mustFind) {
=======
    public boolean isEmpty() {
        return (_types.length == 0);
    }
    
    /**
     * Returns number of bindings contained
     */
    public int size() { 
        return _types.length;
    }

    public String getBoundName(int index)
    {
        if (index < 0 || index >= _names.length) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        
        String className;
        if (_contextClass != null) {
            className = _contextClass.getName();
        } else if (_contextType != null) {
            className = _contextType.toString();
        } else {
            className = "UNKNOWN";
        }
        throw new IllegalArgumentException("Type variable '"+name
                +"' can not be resolved (with context of class "+className+")");
        //t = UNBOUND;                
=======
        return _names[index];
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public void addBinding(String name, JavaType type)
=======
    public JavaType getBoundType(int index)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        // note: emptyMap() is unmodifiable, hence second check is needed:
        if (_bindings == null || _bindings.size() == 0) {
            _bindings = new LinkedHashMap<String,JavaType>();
=======
        if (index < 0 || index >= _types.length) {
            return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        _bindings.put(name, type);
=======
        return _types[index];
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public JavaType[] typesAsArray()
=======
    /**
     * Accessor for getting bound types in declaration order
     */
    public List<JavaType> getTypeParameters()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        if (_bindings == null) {
            _resolve();
=======
        if (_types.length == 0) {
            return Collections.emptyList();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        if (_bindings.size() == 0) {
            return NO_TYPES;
=======
        return Arrays.asList(_types);
    }

    /**
     * @since 2.3
     */
    public boolean hasUnbound(String name) {
        if (_unboundVariables != null) {
            for (int i = _unboundVariables.length; --i >= 0; ) {
                if (name.equals(_unboundVariables[i])) {
                    return true;
                }
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        return _bindings.values().toArray(new JavaType[_bindings.size()]);
=======
        return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**********************************************************
    /* Internal methods
    /**********************************************************
=======
    /**********************************************************************
    /* Standard methods
    /**********************************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    protected void _resolve()
=======
    @Override public String toString()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        _resolveBindings(_contextClass);

        // finally: may have root level type info too
        if (_contextType != null) {
            int count = _contextType.containedTypeCount();
            if (count > 0) {
                for (int i = 0; i < count; ++i) {
                    String name = _contextType.containedTypeName(i);
                    JavaType type = _contextType.containedType(i);
                    addBinding(name, type);
                }
=======
        if (_types.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        sb.append('<');
        for (int i = 0, len = _types.length; i < len; ++i) {
            if (i > 0) {
                sb.append(',');
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public void _addPlaceholder(String name) {
        if (_placeholders == null) {
            _placeholders = new HashSet<String>();
=======
    @Override public boolean equals(Object o)
    {
        if (o == this) return true;
        if (o == null || o.getClass() != getClass()) return false;
        TypeBindings other = (TypeBindings) o;
        int len = _types.length;
        if (len != other.size()) {
            return false;
        }
        JavaType[] otherTypes = other._types;
        for (int i = 0; i < len; ++i) {
            if (!otherTypes[i].equals(_types[i])) {
                return false;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        _placeholders.add(name);
=======
        return true;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    protected void _resolveBindings(Type t)
    {
        if (t == null) return;
=======
    /*
    /**********************************************************************
    /* Package accessible methods
    /**********************************************************************
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                if (_contextType != null && raw.isAssignableFrom(_contextType.getRawClass())) {
                    typeParams = _typeFactory.findTypeParameters(_contextType, raw);
                }
=======
    /*
    /**********************************************************************
    /* Helper classes
    /**********************************************************************
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                for (int i = 0; i < vars.length; i++) {
                    TypeVariable<?> var = vars[i];
=======
    // 30-Oct-2015, tatu: Surprising, but looks like type parameters access can be bit of
    //    a hot spot. So avoid for a small number of common generic types. Note that we do
    //    need both common abstract types and concrete ones; latter for specialization
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        } else { // probably can't be any of these... so let's skip for now
            //if (type instanceof GenericArrayType) {
            //if (type instanceof TypeVariable<?>) {
            // if (type instanceof WildcardType) {
            return;
        }
        // but even if it's not a parameterized type, its super types may be:
        _resolveBindings(raw.getGenericSuperclass());
        for (Type intType : raw.getGenericInterfaces()) {
            _resolveBindings(intType);
        }
    }
=======
            return erasedType.getTypeParameters();
        }    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
    /* 1.6.1+ To make 2 main "optional" handler groups (javax.xml.stream)
=======
    /* To make 2 main "optional" handler groups (javax.xml.stream)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        
        if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) {
            return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE);
        }
        if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {
=======
        if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSuperClassStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
                || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {
=======
                || hasSuperClassStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
    private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix)
=======
    /**
     * Since 2.7 we only need to check for class extension, as all implemented
     * types are classes, not interfaces. This has performance implications for
     * some cases, as we do not need to go over interfaces implemented, just
     * superclasses
     * 
     * @since 2.7
     */
    private boolean hasSuperClassStartingWith(Class<?> rawType, String prefix)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
            /* [databind#915] 26-Sep-2015, tatu: Should be UTC, plan to change
             * it so for 2.7
=======
            /* [databind#915] 05-Nov-2015, tatu: Changed to UTC, from earlier
             * baseline of GMT (up to 2.6)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
            TimeZone.getTimeZone("GMT");
=======
            TimeZone.getTimeZone("UTC");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        protected Impl(Map<Object,Object> shared) {
=======
        protected Impl(Map<?,?> shared) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        protected Impl(Map<Object,Object> shared, Map<Object,Object> nonShared) {
=======
        protected Impl(Map<?,?> shared, Map<Object,Object> nonShared) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        public ContextAttributes withSharedAttributes(Map<Object, Object> shared) {
=======
        public ContextAttributes withSharedAttributes(Map<?,?> shared) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        private Map<Object,Object> _copy(Map<Object,Object> src)
=======
        private Map<Object,Object> _copy(Map<?,?> src)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
        return getTypeFactory().constructType(cls, (TypeBindings) null);
=======
        return getTypeFactory().constructType(cls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
        return getTypeFactory().constructType(valueTypeRef.getType(), (TypeBindings) null);
=======
        return getTypeFactory().constructType(valueTypeRef.getType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java;<<<<<<< MINE
    public T withAttributes(Map<Object,Object> attributes) {
=======
    public T withAttributes(Map<?,?> attributes) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java;<<<<<<< MINE
    
    protected PropertyBindingException(String msg, JsonLocation loc,
=======

    /**
     * @since 2.7
     */
    protected PropertyBindingException(JsonParser p, String msg, JsonLocation loc,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java;<<<<<<< MINE
        
        super(msg, loc);
=======
        super(p, msg, loc);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java;<<<<<<< MINE
     * @param jp Underlying parser used for reading input being used for data-binding
=======
     * @param p Underlying parser used for reading input being used for data-binding
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java;<<<<<<< MINE
    public static UnrecognizedPropertyException from(JsonParser jp,
=======
    public static UnrecognizedPropertyException from(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
        super(msg);
=======
        super(null, msg);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
        super(msg, loc);
=======
        super(null, msg, loc);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
    
    public static InvalidFormatException from(JsonParser jp, String msg,
=======

    /**
     * @since 2.7
     */
    public InvalidFormatException(JsonParser p,
            String msg, Object value, Class<?> targetType)
    {
        super(p, msg);
        _value = value;
        _targetType = targetType;
    }

    public static InvalidFormatException from(JsonParser p, String msg,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
        return new InvalidFormatException(msg, jp.getTokenLocation(),
                value, targetType);
=======
        return new InvalidFormatException(p, msg, value, targetType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java;<<<<<<< MINE
     * @param jp Underlying parser used for reading input being used for data-binding
=======
     * @param p Underlying parser used for reading input being used for data-binding
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java;<<<<<<< MINE
    public static IgnoredPropertyException from(JsonParser jp,
=======
    public static IgnoredPropertyException from(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
     * @param type Type for which materialization maybe needed
=======
     * @param typeDesc Description of the POJO type to resolve
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
     *    null if resolver does not know how to resolve type
=======
     *    null if resolver does not know how to resolve given type
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
            JavaType type) {
        return null;
=======
            BeanDescription typeDesc) {
        return resolveAbstractType(config, typeDesc.getType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
    /* Access to possibly chained introspectors (1.7)
=======
    /* Access to possibly chained introspectors
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
        // !!! Change direction in 2.7 or later
        return findPropertiesToIgnore(ac);
=======
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
        return null;
=======
        // Changed in 2.7 to call from old to new; with 2.6 was opposite
        return findPropertiesToIgnore(ac, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
        JsonInclude.Include def = JsonInclude.Include.USE_DEFAULTS;
        JsonInclude.Include vi = findSerializationInclusion(a, def);
        JsonInclude.Include ci = findSerializationInclusionForContent(a, def);
        return JsonInclude.Value.construct(vi, ci);
=======
        return JsonInclude.Value.empty();
    }

    /*
    /**********************************************************
    /* Serialization: type refinements
    /**********************************************************
     */

    /**
     * Method for accessing annotated type definition that a
     * method/field can have, to be used as the type for serialization
     * instead of the runtime type.
     * Type returned (if any) needs to be widening conversion (super-type).
     * Declared return type of the method is also considered acceptable.
     *
     * @return Class to use instead of runtime type
     *
     * @deprecated Since 2.7 call {@link #refineSerializationType} instead
     */
    @Deprecated // since 2.7
    public Class<?> findSerializationType(Annotated a) {
        return null;
    }

    /**
     * Method for finding possible widening type definition that a property
     * value can have, to define less specific key type to use for serialization.
     * It should be only be used with {@link java.util.Map} types.
     * 
     * @return Class specifying more general type to use instead of
     *   declared type, if annotation found; null if not
     *
     * @deprecated Since 2.7 call {@link #refineSerializationType} instead
     */
    @Deprecated // since 2.7
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {
        return null;
    }

    /**
     * Method for finding possible widening type definition that a property
     * value can have, to define less specific key type to use for serialization.
     * It should be only used with structured types (arrays, collections, maps).
     * 
     * @return Class specifying more general type to use instead of
     *   declared type, if annotation found; null if not
     *
     * @deprecated Since 2.7 call {@link #refineSerializationType} instead
     */
    @Deprecated // since 2.7
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {
        return null;
    }

    /**
     * Method called to find out possible type refinements to use
     * for deserialization.
     *
     * @since 2.7
     */
    public JavaType refineSerializationType(final MapperConfig<?> config,
            final Annotated a, final JavaType baseType) throws JsonMappingException
    {
        JavaType type = baseType;
        final TypeFactory tf = config.getTypeFactory();
        
        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to
        //    now-deprecated secondary methods; this because while
        //    direct sub-class not yet retrofitted may only override
        //    those methods. With 2.8 or later we may consider removal
        //    of these methods

        
        // Ok: start by refining the main type itself; common to all types
        Class<?> serClass = findSerializationType(a);
        if (serClass != null) {
            if (type.hasRawClass(serClass)) {
                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of
                //    static typing this way
                type = type.withStaticTyping();
            } else {
                try {
                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,
                    //   may be needed here too in future?
                    type = tf.constructGeneralizedType(type, serClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(null,
                            String.format("Failed to widen type %s with annotation (value %s), from '%s': %s",
                                    type, serClass.getName(), a.getName(), iae.getMessage()),
                                    iae);
                }
            }
        }
        // Then further processing for container types

        // First, key type (for Maps, Map-like types):
        if (type.isMapLikeType()) {
            JavaType keyType = type.getKeyType();
            Class<?> keyClass = findSerializationKeyType(a, keyType);
            if (keyClass != null) {
                if (keyType.hasRawClass(keyClass)) {
                    keyType = keyType.withStaticTyping();
                } else {
                    try {
                        keyType = tf.constructGeneralizedType(keyType, keyClass);
                    } catch (IllegalArgumentException iae) {
                        throw new JsonMappingException(null,
                                String.format("Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s",
                                        type, keyClass.getName(), a.getName(), iae.getMessage()),
                                        iae);
                    }
                }
                type = ((MapLikeType) type).withKeyType(keyType);
            }
        }

        JavaType contentType = type.getContentType();
        if (contentType != null) { // collection[like], map[like], array, reference
            // And then value types for all containers:
           Class<?> contentClass = findSerializationContentType(a, contentType);
           if (contentClass != null) {
               if (contentType.hasRawClass(contentClass)) {
                   contentType = contentType.withStaticTyping();
               } else {
                   try {
                       contentType = tf.constructGeneralizedType(contentType, contentClass);
                   } catch (IllegalArgumentException iae) {
                       throw new JsonMappingException(null,
                               String.format("Failed to widen value type of %s with concrete-type annotation (value %s), from '%s': %s",
                                       type, contentClass.getName(), a.getName(), iae.getMessage()),
                                       iae);
                   }
               }
               type = type.withContentType(contentType);
           }
        }
        return type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
     * @since 2.2
=======
     * @since 2.2 (although signature did change in 2.7)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)
=======
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
            return null;
=======
            if ((_member != null) && (intr != null)) {
                JsonFormat.Value v = intr.findFormat(_member);
                if (v != null) {
                    return v;
                }
            }
            return EMPTY_FORMAT;
        }

        @Override
        public JsonFormat.Value findPropertyFormat(MapperConfig<?> config, Class<?> baseType) {
            JsonFormat.Value v0 = config.getDefaultPropertyFormat(baseType);
            AnnotationIntrospector intr = config.getAnnotationIntrospector();
            if ((intr == null) || (_member == null)) {
                return v0;
            }
            JsonFormat.Value v = intr.findFormat(_member);
            if (v == null) {
                return v0;
            }
            return v0.withOverrides(v);
        }
        
        @Override
        public JsonInclude.Value findPropertyInclusion(MapperConfig<?> config, Class<?> baseType)
        {
            JsonInclude.Value v0 = config.getDefaultPropertyInclusion(baseType);
            AnnotationIntrospector intr = config.getAnnotationIntrospector();
            if ((intr == null) || (_member == null)) {
                return v0;
            }
            JsonInclude.Value v = intr.findPropertyInclusion(_member);
            if (v == null) {
                return v0;
            }
            return v0.withOverrides(v);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
        public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) {
=======
        public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
                SerializerProvider provider) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java;<<<<<<< MINE
    /* Life-cycle, fluent factories for JsonGenerator.Feature
=======
    /* Life-cycle, fluent factories for JsonGenerator.Feature (2.5)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java;<<<<<<< MINE
    public ObjectWriter withAttributes(Map<Object,Object> attrs) {
=======
    public ObjectWriter withAttributes(Map<?,?> attrs) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
                String.format("Can not construct instance of %s from String value '%s': %s",
                        instClass.getName(), _desc(value), msg),
=======
                String.format("Can not construct instance of %s from String value (%s): %s",
                        instClass.getName(), _quotedString(value), msg),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
                null, instClass);
=======
                value, instClass);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
                String.format("Can not construct Map key of type %s from String \"%s\": %s",
                        keyClass.getName(), _desc(keyValue), msg),
=======
                String.format("Can not construct Map key of type %s from String (%s): %s",
                        keyClass.getName(), _quotedString(keyValue), msg),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    /**
     * Set of {@link SerializationFeature}s enabled.
=======
    /*
    /**********************************************************
    /* Configured helper objects
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
            int generatorFeatures, int generatorFeatureMask)
=======
            int generatorFeatures, int generatorFeatureMask,
            int formatFeatures, int formatFeaturesMask)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)
=======
    private SerializationConfig(SerializationConfig src, JsonInclude.Value incl)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    _generatorFeatures, _generatorFeaturesToChange);
=======
                    _generatorFeatures, _generatorFeaturesToChange,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    /* Factory methods for JsonGenerator.Feature
=======
    /* Factory methods for JsonGenerator.Feature (2.5)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
    }

    /*
    /**********************************************************
    /* Factory methods for FormatFeature (2.7)
    /**********************************************************
     */
    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified feature enabled.
     *
     * @since 2.7
     */
    public SerializationConfig with(FormatFeature feature)
    {
        int newSet = _formatWriteFeatures | feature.getMask();
        int newMask = _formatWriteFeaturesToChange | feature.getMask();
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
=======
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
    }

    /*
    /**********************************************************
    /* Factory methods for FormatFeature (2.7)
    /**********************************************************
     */
    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified feature enabled.
     *
     * @since 2.7
     */
    public SerializationConfig with(FormatFeature feature)
    {
        int newSet = _formatWriteFeatures | feature.getMask();
        int newMask = _formatWriteFeaturesToChange | feature.getMask();
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features enabled.
     *
     * @since 2.7
     */
    public SerializationConfig withFeatures(FormatFeature... features)
    {
        int newSet = _formatWriteFeatures;
        int newMask = _formatWriteFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet |= mask;
            newMask |= mask;
        }
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
        return (_serializationInclusion == incl) ? this:  new SerializationConfig(this, incl);
=======
        return withPropertyInclusion(DEFAULT_INCLUSION.withValueInclusion(incl));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
        if ((_generatorFeaturesToChange != 0) || useBigDec) {
            int orig = g.getFeatureMask();
            int newFlags = (orig & ~_generatorFeaturesToChange) | _generatorFeatures;
=======

        int mask = _generatorFeaturesToChange;
        if ((mask != 0) || useBigDec) {
            int newFlags = _generatorFeatures;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                newFlags |= JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();
            }
            if (orig != newFlags) {
                g.setFeatureMask(newFlags);
=======
                int f = JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();
                newFlags |= f;
                mask |= f;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    /* MapperConfig implementation/overrides
=======
    /* MapperConfig implementation/overrides: introspection
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * Method for setting specific {@link SerializerProvider} to use
     * for handling caching of {@link JsonSerializer} instances.
=======
     * Method for setting "blueprint" {@link SerializerProvider} instance
     * to use as the base for actual provider instances to use for handling
     * caching of {@link JsonSerializer} instances.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {
        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);
=======
    public ObjectMapper setPropertyInclusion(JsonInclude.Value incl) {
        _serializationConfig = _serializationConfig.withPropertyInclusion(incl);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * In either case {@link JsonParser} must point to the first token of
=======
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather
     * to the token following it.
=======
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType)
=======
    public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        return readValues(jp, (JavaType) valueType);
=======
        return readValues(p, (JavaType) valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.
=======
     * Convenience method, equivalent in function to:
     *<pre>
     *   readerFor(valueType).readValues(p);
     *</pre>
     *<p>
     * Type-safe overload of {@link #readValues(JsonParser, ResolvedType)}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)
            throws IOException, JsonProcessingException
=======
    public <T> MappingIterator<T> readValues(JsonParser p, JavaType valueType)
        throws IOException, JsonProcessingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        return new MappingIterator<T>(valueType, jp, ctxt, deser,
=======
        return new MappingIterator<T>(valueType, p, ctxt, deser,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.
=======
     * Convenience method, equivalent in function to:
     *<pre>
     *   readerFor(valueType).readValues(p);
     *</pre>
     *<p>
     * Type-safe overload of {@link #readValues(JsonParser, ResolvedType)}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType)
=======
    public <T> MappingIterator<T> readValues(JsonParser p, Class<T> valueType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        return readValues(jp, _typeFactory.constructType(valueType));
=======
        return readValues(p, _typeFactory.constructType(valueType));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)
=======
    public <T> MappingIterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        return readValues(jp, _typeFactory.constructType(valueTypeRef));
=======
        return readValues(p, _typeFactory.constructType(valueTypeRef));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        // also, as per [Issue-11], consider case for simple cast
=======
        // also, as per [databind#11], consider case for simple cast
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        throws IOException, JsonGenerationException, JsonMappingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
            /* Need to close both generator and value, as long as they haven't yet
             * been closed
             */
=======
            // Need to close both generator and value, as long as they haven't yet been closed
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        throws IOException, JsonGenerationException, JsonMappingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
                /* [JACKSON-546] Throw mapping exception, since it's failure to map,
                 *   not an actual parsing problem
                 */
=======
                // Throw mapping exception, since it's failure to map,
                //   not an actual parsing problem
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
            throw new JsonMappingException("Can not find a deserializer for type "+valueType);
=======
            throw JsonMappingException.from(ctxt,
                    "Can not find a deserializer for type "+valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java;<<<<<<< MINE
     * as <code>START-ARRAY></code>/<code>END-ARRAY</code> and
     * <code>START-OBJECT></code>/<code>END-OBJECT</code> pairs
=======
     * as <code>START-ARRAY</code>/<code>END-ARRAY</code> and
     * <code>START-OBJECT</code>/<code>END-OBJECT</code> pairs
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java;<<<<<<< MINE
     *   will be removed from 2.7
=======
     *   will be removed from 2.8
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
     * @since 2.5.0
=======
     * @since 2.5
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
     * Note that starting with version 1.5, serializers should also be type-aware
     * if they handle polymorphic types. That means that it may be necessary
     * to also use a {@link TypeSerializer} based on declared (static) type
     * being serializer (whereas actual data may be serialized using dynamic
     * type)
=======
     * Note that serializers produced should NOT handle polymorphic serialization
     * aspects; separate {@link TypeSerializer} is to be constructed by caller
     * if and as necessary.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
     * Method called to get a Typeserialize to use for accessing Type Information for a given Java class
=======
     * Method called to get the {@link TypeSerializer} to use for including Type Id necessary
     * for serializing for the given Java class.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
    public final void defaultSerializeValue(Object value, JsonGenerator jgen) throws IOException
=======
    public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                jgen.writeNull();
=======
                gen.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                _nullValueSerializer.serialize(null, jgen, this);
=======
                _nullValueSerializer.serialize(null, gen, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            findTypedValueSerializer(cls, true, null).serialize(value, jgen, this);
=======
            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
    public final void defaultSerializeField(String fieldName, Object value, JsonGenerator jgen)
=======
    public final void defaultSerializeField(String fieldName, Object value, JsonGenerator gen)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        jgen.writeFieldName(fieldName);
=======
        gen.writeFieldName(fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                jgen.writeNull();
=======
                gen.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                _nullValueSerializer.serialize(null, jgen, this);
=======
                _nullValueSerializer.serialize(null, gen, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            findTypedValueSerializer(cls, true, null).serialize(value, jgen, this);
=======
            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        return new JsonMappingException(message);
=======
        return JsonMappingException.from(this, message);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
    protected void _reportIncompatibleRootType(Object value, JavaType rootType)
        throws IOException, JsonProcessingException
=======
    protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        /* 07-Jan-2010, tatu: As per [JACKSON-456] better handle distinction between wrapper types,
         *    primitives
         */
=======
        // One special case: allow primitive/wrapper type coercion
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        throw new JsonMappingException("Incompatible types: declared root type ("+rootType+") vs "
=======
        throw JsonMappingException.from(this,
                "Incompatible types: declared root type ("+rootType+") vs "
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            ser = _createUntypedSerializer(type);
=======
            ser = _createUntypedSerializer(fullType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(iae.getMessage(), null, iae);
=======
            throw JsonMappingException.from(this, iae.getMessage(), iae);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);
=======
            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key
            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(iae.getMessage(), null, iae);
=======
            throw JsonMappingException.from(this, iae.getMessage(), iae);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
     * @since 2.5
=======
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * "Copy method" that will construct a new instance that is identical to
     * this instance, except that its content type will have specified
     * type handler assigned.
=======
     * Mutant factory method that will construct a new instance that is identical to
     * this instance, except that it will have specified content type (element type
     * for arrays, value type for Maps and so forth) handler assigned.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * @return Newly created type instance
=======
     * @return Newly created type instance, with given 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * "Copy method" that will construct a new instance that is identical to
=======
     * Mutant factory method that will construct a new instance that is identical to
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * "Copy method" that will construct a new instance that is identical to
=======
     * Mutant factory method that will construct a new instance that is identical to
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * More efficient version of {@link #narrowBy}, called by
     * internal framework in cases where compatibility checks
     * are to be skipped.
=======
     * Legacy method used for forcing sub-typing of this type into
     * type specified by specific type erasure.
     * Deprecated as of 2.7 as such specializations really ought to
     * go through {@link TypeFactory}, not directly via {@link JavaType}.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    /**
     * Set of {@link DeserializationFeature}s enabled.
=======
    /*
    /**********************************************************
    /* Configured helper objects
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
            int parserFeatures, int parserFeatureMask)
=======
            int parserFeatures, int parserFeatureMask,
            int formatFeatures, int formatFeatureMask)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
            int orig = p.getFeatureMask();
            int newFlags = (orig & ~_parserFeaturesToChange) | _parserFeatures;
            if (orig != newFlags) {
                p.setFeatureMask(newFlags);
            }
=======
            p.overrideStdFeatures(_parserFeatures, _parserFeaturesToChange);
        }
        if (_formatReadFeaturesToChange != 0) {
            p.overrideFormatFeatures(_formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    /* MapperConfig implementation
=======
    /* MapperConfig implementation/overrides: introspection
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
     * may be called to enable access to otherwise unaccessible
     * objects.
=======
     * may be called to enable access to otherwise unaccessible objects.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
     * Note that this setting usually has significant performance implications,
=======
     * Note that this setting may have significant performance implications,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
     * Especially on standard JavaSE platforms difference is significant.
=======
     * Also note that performance effects vary between Java platforms
     * (JavaSE vs Android, for example), as well as JDK versions: older
     * versions seemed to have more significant performance difference.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
 * Default implementation returns suggested ("default") name unmodified.
=======
 * Default (empty) implementation returns suggested ("default") name unmodified.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
     * See {@link LowerCaseWithUnderscoresStrategy} for details.
=======
     * Naming convention used in languages like C, where words are in lower-case
     * letters, separated by underscores.
     * See {@link SnakeCaseStrategy} for details.
     *
     * @since 2.7 (was formerly called {@link #CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES})
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
     * 
     * @since 2.1
=======
     *
     * @since 2.7 (was formerly called {@link #PASCAL_CASE_TO_CAMEL_CASE})
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
     * @since 2.1
=======
     * @since 2.7 (was formerly called {@link PascalCaseStrategy})
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java;<<<<<<< MINE
    public <C extends Collection<?>> SequenceWriter writeAll(C container) throws IOException
    {
=======
    // NOTE: redundant wrt variant that takes Iterable, but can not remove or even
    // deprecate due to backwards-compatibility needs
    public <C extends Collection<?>> SequenceWriter writeAll(C container) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader withAttributes(Map<Object,Object> attrs) {
=======
    public ObjectReader withAttributes(Map<?,?> attrs) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp)
        throws IOException, JsonProcessingException
=======
    public <T> T readValue(JsonParser p) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        return (T) _bind(jp, _valueToUpdate);
=======
        return (T) _bind(p, _valueToUpdate);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp, Class<T> valueType)
        throws IOException, JsonProcessingException
=======
    public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        return (T) forType(valueType).readValue(jp);
=======
        return (T) forType(valueType).readValue(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)
        throws IOException, JsonProcessingException
=======
    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        return (T) forType(valueTypeRef).readValue(jp);
=======
        return (T) forType(valueTypeRef).readValue(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {
        return (T) forType((JavaType)valueType).readValue(jp);
=======
    public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
        return (T) forType((JavaType)valueType).readValue(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {
        return (T) forType(valueType).readValue(jp);
=======
    public <T> T readValue(JsonParser p, JavaType valueType) throws IOException {
        return (T) forType(valueType).readValue(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
     *   withType(valueType).readValues(jp);
=======
     *   withType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)
        throws IOException, JsonProcessingException {
        return forType(valueType).readValues(jp);
=======
    public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException {
        return forType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
     *   withType(valueTypeRef).readValues(jp);
=======
     *   withType(valueTypeRef).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)
        throws IOException, JsonProcessingException {
        return forType(valueTypeRef).readValues(jp);
=======
    public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException {
        return forType(valueTypeRef).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
     *   withType(valueType).readValues(jp);
=======
     *   withType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType)
        throws IOException, JsonProcessingException {
        return readValues(jp, (JavaType) valueType);
=======
    public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException {
        return readValues(p, (JavaType) valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
     *   withType(valueType).readValues(jp);
=======
     *   withType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType)
        throws IOException, JsonProcessingException {
        return forType(valueType).readValues(jp);
=======
    public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException {
        return forType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T extends TreeNode> T readTree(JsonParser jp)
            throws IOException, JsonProcessingException
    {
        return (T) _bindAsTree(jp);
=======
    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {
        return (T) _bindAsTree(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        throw new JsonParseException("Can not detect format from input, does not look like any of detectable formats "
                +detector.toString(),
                JsonLocation.NA);
=======
        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:
        throw new JsonParseException(null, "Can not detect format from input, does not look like any of detectable formats "
                +detector.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        throw new JsonParseException("Can not use source of type "
                +src.getClass().getName()+" with format auto-detection: must be byte- not char-based",
                JsonLocation.NA);
=======
        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:
        throw new JsonParseException(null, "Can not use source of type "
                +src.getClass().getName()+" with format auto-detection: must be byte- not char-based");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
            throw new JsonMappingException("No value type configured for ObjectReader");
=======
            throw JsonMappingException.from(ctxt, "No value type configured for ObjectReader");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
            throw new JsonMappingException("Can not find a deserializer for type "+t);
=======
            throw JsonMappingException.from(ctxt, "Can not find a deserializer for type "+t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
                throw new JsonMappingException("Can not find a deserializer for type "+JSON_NODE_TYPE);
=======
                throw JsonMappingException.from(ctxt,
                        "Can not find a deserializer for type "+JSON_NODE_TYPE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
 * content.
=======
 * content, distinct from low-level I/O problems (signaled using
 * simple {@link java.io.IOException}s) or data encoding/decoding
 * problems (signaled with {@link com.fasterxml.jackson.core.JsonParseException},
 * {@link com.fasterxml.jackson.core.JsonGenerationException}).
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
            Package pkg = cls.getPackage();
            if (pkg != null) {
                sb.append(pkg.getName());
=======
            String pkgName = ClassUtil.getPackageName(cls);
            if (pkgName != null) {
                sb.append(pkgName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
    public static JsonMappingException from(JsonParser jp, String msg) {
        return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation()));
=======
    /**
     * @since 2.7
     */
    public JsonMappingException(Closeable processor, String msg) {
        super(msg);
        _processor = processor;
        if (processor instanceof JsonParser) {
            // 17-Aug-2015, tatu: Use of token location makes some sense from databinding,
            //   since actual parsing (current) location is typically only needed for low-level
            //   parsing exceptions.
            _location = ((JsonParser) processor).getTokenLocation();
        }
    }

    /**
     * @since 2.7
     */
    public JsonMappingException(Closeable processor, String msg, Throwable problem) {
        super(msg, problem);
        _processor = processor;
        if (processor instanceof JsonParser) {
            _location = ((JsonParser) processor).getTokenLocation();
        }
    }

    /**
     * @since 2.7
     */
    public JsonMappingException(Closeable processor, String msg, JsonLocation loc) {
        super(msg, loc);
        _processor = processor;
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(JsonParser p, String msg) {
        return new JsonMappingException(p, msg);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
    public static JsonMappingException from(JsonParser jp, String msg, Throwable problem) {
        return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation()), problem);
=======
    /**
     * @since 2.7
     */
    public static JsonMappingException from(JsonParser p, String msg, Throwable problem) {
        return new JsonMappingException(p, msg, problem);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(JsonGenerator g, String msg) {
        return new JsonMappingException(g, msg, (Throwable) null);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(JsonGenerator g, String msg, Throwable problem) {
        return new JsonMappingException(g, msg, problem);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(DeserializationContext ctxt, String msg) {
        return new JsonMappingException(ctxt.getParser(), msg);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(DeserializationContext ctxt, String msg, Throwable t) {
        return new JsonMappingException(ctxt.getParser(), msg, t);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(SerializerProvider ctxt, String msg) {
        /* 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as
         *   SerializerProvider instance does not currently hold on to generator...
         */
        JsonGenerator g = null;
        return new JsonMappingException(g, msg);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(SerializerProvider ctxt, String msg, Throwable problem) {
        /* 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as
         *   SerializerProvider instance does not currently hold on to generator...
         */
        JsonGenerator g = null;
        return new JsonMappingException(g, msg, problem);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
        return new JsonMappingException("Unexpected IOException (of type "
                +src.getClass().getName()+"): "+src.getMessage(), (JsonLocation)null, src);
=======
        return new JsonMappingException(null,
                String.format("Unexpected IOException (of type %s): %s",
                        src.getClass().getName(), src.getMessage()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
            /* Related to [JACKSON-62], let's use a more meaningful placeholder
             * if all we have is null
             */
=======
            // Let's use a more meaningful placeholder if all we have is null
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
            jme = new JsonMappingException(msg, null, src);
=======
            // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along
            Closeable proc = null;
            if (src instanceof JsonProcessingException) {
                Object proc0 = ((JsonProcessingException) src).getProcessor();
                if (proc0 instanceof Closeable) {
                    proc = (Closeable) proc0;
                }
            }
            jme = new JsonMappingException(proc, msg, src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
          setCodec(new ObjectMapper(this));
=======
            setCodec(new ObjectMapper(this));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
     * Sub-classes need to override this method (as of 1.8)
=======
     * Sub-classes need to override this method
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
     * Sub-classes need to override this method (as of 1.8)
=======
     * Sub-classes need to override this method
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
     * Note: marked as abstract to ensure all implementation
     * classes define it properly.
=======
     * Note: method defined as abstract to ensure all implementation
     * classes explicitly implement method, instead of relying
     * on {@link Object#toString()} definition.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    // For [JACKSON-694]: error message for conflicting getters sub-optimal
=======
    // error message for conflicting getters sub-optimal
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    // [Issue#238]
=======
    // [databind#238]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    // For [Issue#541]
=======
    // For [databind#541]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    // [Issue#238]: ok to have getter, "isGetter"
=======
    // [databind#238]: ok to have getter, "isGetter"
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
 * Unit tests to verify functioning of 
 * {@link PropertyNamingStrategy#CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES} 
 * and
 * {@link PropertyNamingStrategy#PASCAL_CASE_TO_CAMEL_CASE } 
 * inside the context of an ObjectMapper.
 * PASCAL_CASE_TO_CAMEL_CASE was added in Jackson 2.1,
 * as per [JACKSON-63].
=======
 * Unit tests to verify functioning of standard {@link PropertyNamingStrategy}
 * implementations Jackson includes out of the box.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    public static List<Object[]> NAME_TRANSLATIONS = Arrays.asList(new Object[][] {
=======
    public static List<Object[]> SNAKE_CASE_NAME_TRANSLATIONS = Arrays.asList(new Object[][] {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        _lcWithUndescoreMapper.setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);
=======
        _lcWithUndescoreMapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    /* Test methods for CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES
=======
    /* Test methods for SNAKE_CASE
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
     * {@link PropertyNamingStrategy#CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES} 
=======
     * {@link PropertyNamingStrategy#SNAKE_CASE} 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        for (Object[] pair : NAME_TRANSLATIONS) {
            String translatedJavaName = PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES.nameForField(null, null,
=======
        for (Object[] pair : SNAKE_CASE_NAME_TRANSLATIONS) {
            String translatedJavaName = PropertyNamingStrategy.SNAKE_CASE.nameForField(null, null,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    /* Test methods for PASCAL_CASE_TO_CAMEL_CASE (added in 2.1)
=======
    /* Test methods for UPPER_CAMEL_CASE
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
     * {@link PropertyNamingStrategy#PASCAL_CASE_TO_CAMEL_CASE } 
=======
     * {@link PropertyNamingStrategy#UPPER_CAMEL_CASE } 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        String translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField
=======
        String translatedJavaName = PropertyNamingStrategy.UPPER_CAMEL_CASE.nameForField
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField
=======
        translatedJavaName = PropertyNamingStrategy.UPPER_CAMEL_CASE.nameForField
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField
=======
        translatedJavaName = PropertyNamingStrategy.UPPER_CAMEL_CASE.nameForField
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField
=======
        translatedJavaName = PropertyNamingStrategy.UPPER_CAMEL_CASE.nameForField
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
                            .setPropertyNamingStrategy(PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)
=======
                            .setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
        public String findEnumValue(Enum<?> value)
        {
=======
        public String findEnumValue(Enum<?> value) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/JSOGDeserialize622Test.java;<<<<<<< MINE
              throw new JsonMappingException("Could not find key '"+REF_KEY
=======
              throw JsonMappingException.from(jp, "Could not find key '"+REF_KEY
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java;<<<<<<< MINE
    // [Issue#370]
=======
    // [databind#370]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java;<<<<<<< MINE
    // [Issue#370]
=======
    // [databind#370]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    // Also test via Field
=======
    // for [jackson-databind#1023]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
        public void serialize(List<String> value,
                              JsonGenerator jgen,
                              SerializerProvider provider)
=======
        public void serialize(List<String> value, JsonGenerator gen, SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
            jgen.writeString(value.toString());
=======
            gen.writeString(value.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testCollections()
        throws IOException
=======
    public void testCollections() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testBigCollection()
        throws IOException
=======
    public void testBigCollection() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testEnumMap()
        throws IOException
=======
    public void testEnumMap() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testEmptyBeanCollection()
        throws IOException
=======
    public void testEmptyBeanCollection() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testEmptyBeanEnumMap()
        throws IOException
=======
    public void testEmptyBeanEnumMap() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testNullBeanEnumMap()
        throws IOException
=======
    public void testNullBeanEnumMap() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
                              JsonGenerator jgen,
                              SerializerProvider provider)
            throws IOException
=======
                JsonGenerator gen, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
            jgen.writeString(value.toString());
=======
            gen.writeString(value.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // [#335]
=======
    // [databind#335]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // [Databind#565]: Support ser/deser of Map.Entry
=======
    // [databind#565]: Support ser/deser of Map.Entry
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        System.out.println("json: "+json);
=======
//        System.out.println("json: "+json);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        System.out.println("Deserialized to ObjectNode: "+de1);
=======
//        System.out.println("Deserialized to ObjectNode: "+de1);
        assertNotNull(de1);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        System.out.println("Deserialized to MyValue: "+de2);
=======
//        System.out.println("Deserialized to MyValue: "+de2);
        assertNotNull(de2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestFieldDeserialization.java;<<<<<<< MINE
 * deserialized (since version 1.1) as well as
 * setter-accessible properties.
=======
 * deserialized as well as setter-accessible properties.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // Testing [JACKSON-526], "implicit JSON array" for single-element arrays,
=======
    // Testing "implicit JSON array" for single-element arrays,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // [Issue#161]
=======
    // [databind#161]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // [Issue#199]
=======
    // [databind#199]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // for [Issue#506]
=======
    // for [databind#506]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // for [Issue#828]
=======
    // for [databind#828]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE
    public void lostMessage() {
=======
    public void testLostMessage() {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomFactory.java;<<<<<<< MINE
                    throw new JsonParseException("expecting number got "+ t, jp.getCurrentLocation());
=======
                    throw new JsonParseException(jp, "expecting number got "+ t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java;<<<<<<< MINE
            verifyException(jme, "is not assignable to");
=======
            verifyException(jme, "not subtype of");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java;<<<<<<< MINE
            verifyException(jme, "is not assignable to");
=======
            verifyException(jme, "not subtype of");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java;<<<<<<< MINE
        public CustomResolverBase(Class<?> baseType, Class<?> implType) {
=======
        public TestCustomResolverBase(Class<?> baseType, Class<?> implType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorWithNamingStrategy556.java;<<<<<<< MINE
            .setPropertyNamingStrategy(PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)
=======
            .setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java;<<<<<<< MINE
    // [Issue#359]
=======
    // [databind#359]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java;<<<<<<< MINE
            verifyException(e, "from String value 'foobar'");
=======
            verifyException(e, "from String value (\"foobar\")");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
        public JavaType modifyType(JavaType type, Type jdkType, TypeBindings context, TypeFactory typeFactory)
=======
        public JavaType modifyType(JavaType type, Type jdkType, TypeBindings bindings, TypeFactory typeFactory)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
            Class<?> raw = type.getRawClass();
            if (MapMarker.class.isAssignableFrom(raw)) {
                JavaType[] params = typeFactory.findTypeParameters(type, MapMarker.class);
                return typeFactory.constructMapLikeType(raw, params[0], params[1]);
            }
            if (CollectionMarker.class.isAssignableFrom(raw)) {
                JavaType[] params = typeFactory.findTypeParameters(type, CollectionMarker.class);
                return typeFactory.constructCollectionLikeType(raw, params[0]);
=======
            if (!type.isContainerType()) { // not 100% required, minor optimization
                Class<?> raw = type.getRawClass();
                if (raw == MapMarker.class) {
                    return MapLikeType.upgradeFrom(type, type.containedType(0), type.containedType(1));
                }
                if (raw == CollectionMarker.class) {
                    return CollectionLikeType.upgradeFrom(type, type.containedType(0));
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
    public void testLikeTypeConstruction() throws Exception
=======
    public void testMapLikeTypeConstruction() throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
        
        type = mapper.constructType(MyCollectionLikeType.class);
=======
    }
    
    public void testCollectionLikeTypeConstruction() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));

        JavaType type = mapper.constructType(MyCollectionLikeType.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java;<<<<<<< MINE
        public TestEnum deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
            String code = jp.getText();
=======
        public TestEnum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
            String code = p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java;<<<<<<< MINE
                throw new InvalidFormatException("Undefined ISO-639 language code", jp.getCurrentLocation(), code, TestEnum.class);
=======
                throw InvalidFormatException.from(p, "Undefined ISO-639 language code",
                        code, TestEnum.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java;<<<<<<< MINE
        .writeAll(new Bean[] { new Bean(3), new Bean(1) });
=======
        .writeAll(new Bean[] { new Bean(3), new Bean(1) })
        .writeAll(Arrays.asList(new Bean(5), new Bean(7)))
        ;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java;<<<<<<< MINE
        assertEquals(aposToQuotes("{'a':13}\n{'a':-6}\n{'a':3}\n{'a':1}"),
=======
        assertEquals(aposToQuotes("{'a':13}\n{'a':-6}\n{'a':3}\n{'a':1}\n{'a':5}\n{'a':7}"),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java;<<<<<<< MINE
        assertTrue(result.containsKey("id"));
        assertTrue(result.containsKey("name"));
=======
        if (!result.containsKey("id")
                || !result.containsKey("name")) {
            fail("Should have both 'id' and 'name', but content = "+result);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
        assertTrue(arrayT.equals(ArrayType.construct(tf.constructType(String.class), null, null)));
        assertFalse(arrayT.equals(ArrayType.construct(tf.constructType(Integer.class), null, null)));

        // Also, must NOT try to create using simple type
        try {
            SimpleType.construct(String[].class);
        } catch (IllegalArgumentException e) {
            verifyException(e, "for an array");
        }
    }

    public void testCollectionType()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        // List<String>
        JavaType collectionT = CollectionType.construct(List.class, tf.constructType(String.class));
        assertNotNull(collectionT);
        assertTrue(collectionT.isContainerType());

        // NOPs:
        assertSame(collectionT, collectionT.narrowContentsBy(String.class));

        assertNotNull(collectionT.toString());

        assertTrue(collectionT.equals(collectionT));
        assertFalse(collectionT.equals(null));
        assertFalse(collectionT.equals("xyz"));

        assertTrue(collectionT.equals(CollectionType.construct(List.class, tf.constructType(String.class))));
        assertFalse(collectionT.equals(CollectionType.construct(Set.class, tf.constructType(String.class))));

        // Also, must NOT try to create using simple type
        try {
            SimpleType.construct(ArrayList.class);
        } catch (IllegalArgumentException e) {
            verifyException(e, "for a Collection");
        }
=======
        assertTrue(arrayT.equals(ArrayType.construct(tf.constructType(String.class), null)));
        assertFalse(arrayT.equals(ArrayType.construct(tf.constructType(Integer.class), null)));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
    // [Issue#116]
=======
    // [databind#116]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
    public void testList()
=======
    public void testListViaTypeRef()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
        t = tf.constructType(LongList.class);
        type = (CollectionType) t;
=======
    public void testListViaClass()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(LongList.class);
        JavaType type = (CollectionType) t;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());
        assertSame(String.class, ((MapType) t).getContentType().getRawClass());
=======
        assertSame(String.class, mt.getKeyType().getRawClass());
        assertSame(String.class, mt.getContentType().getRawClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
            verifyException(e, "Need exactly 2 parameter types for Map types");
=======
            verifyException(e, "Can not create TypeBindings for class java.util.Map");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
            verifyException(e, "expected 1 parameters, was given 2");
=======
            verifyException(e, "Can not create TypeBindings for class ");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    /* Unit tests: low-level inheritance resolution
=======
    /* Unit tests: collection type parameter resolution
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    public void testSuperTypeDetectionClass()
=======
    public void testCollections()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        HierarchicType sub = tf._findSuperTypeChain(MyStringIntMap.class, HashMap.class);
        assertNotNull(sub);
        assertEquals(2, _countSupers(sub));
        assertSame(MyStringIntMap.class, sub.getRawClass());
        HierarchicType sup = sub.getSuperType();
        assertSame(MyStringXMap.class, sup.getRawClass());
        HierarchicType sup2 = sup.getSuperType();
        assertSame(HashMap.class, sup2.getRawClass());
        assertNull(sup2.getSuperType());
=======
        JavaType t = tf.constructType(ArrayList.class);
        assertEquals(CollectionType.class, t.getClass());
        assertSame(ArrayList.class, t.getRawClass());

        // And then the proper way
        t = tf.constructType(new TypeReference<ArrayList<String>>() { });
        assertEquals(CollectionType.class, t.getClass());
        assertSame(ArrayList.class, t.getRawClass());

        JavaType elemType = ((CollectionType) t).getContentType();
        assertNotNull(elemType);
        assertSame(SimpleType.class, elemType.getClass());
        assertSame(String.class, elemType.getRawClass());

        // And alternate method too
        t = tf.constructCollectionType(ArrayList.class, String.class);
        assertEquals(CollectionType.class, t.getClass());
        assertSame(String.class, ((CollectionType) t).getContentType().getRawClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE

    public void testSuperTypeDetectionInterface()
=======
    
    // since 2.7
    public void testCollectionTypesRefined()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        // List first
        TypeFactory tf = TypeFactory.defaultInstance();
        HierarchicType sub = tf._findSuperTypeChain(MyList.class, List.class);
        assertNotNull(sub);
        assertEquals(2, _countSupers(sub));
        assertSame(MyList.class, sub.getRawClass());
        HierarchicType sup = sub.getSuperType();
        assertSame(IntermediateList.class, sup.getRawClass());
        HierarchicType sup2 = sup.getSuperType();
        assertSame(List.class, sup2.getRawClass());
        assertNull(sup2.getSuperType());
        
        // Then Map
        sub = tf._findSuperTypeChain(MyMap.class, Map.class);
        assertNotNull(sub);
        assertEquals(2, _countSupers(sub));
        assertSame(MyMap.class, sub.getRawClass());
        sup = sub.getSuperType();
        assertSame(IntermediateMap.class, sup.getRawClass());
        sup2 = sup.getSuperType();
        assertSame(Map.class, sup2.getRawClass());
        assertNull(sup2.getSuperType());
    }

    private int _countSupers(HierarchicType t)
    {
        int depth = 0;
        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {
            ++depth;
        }
        return depth;
=======
        TypeFactory tf = newTypeFactory();
        JavaType type = tf.constructType(new TypeReference<List<Long>>() { });
        assertEquals(List.class, type.getRawClass());
        assertEquals(Long.class, type.getContentType().getRawClass());
        // No super-class, since it's an interface:
        assertNull(type.getSuperClass());

        // But then refine to reflect sub-classing
        JavaType subtype = tf.constructSpecializedType(type, ArrayList.class);
        assertEquals(ArrayList.class, subtype.getRawClass());
        assertEquals(Long.class, subtype.getContentType().getRawClass());

        // but with refinement, should have non-null super class
        // 20-Oct-2015, tatu: For now refinement does not faithfully replicate the
        //    structure, it only retains most important information. Here it means
        //    that actually existing super-classes are skipped, and only original
        //    type is linked as expected
        /*
        JavaType superType = subtype.getSuperClass();
        assertNotNull(superType);
        assertEquals(AbstractList.class, superType.getRawClass());
        */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    /* Unit tests: map/collection type parameter resolution
=======
    /* Unit tests: map type parameter resolution
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        assertTrue(t.hasGenericTypes());
        assertEquals(2, t.containedTypeCount());
        assertEquals(String.class, t.containedType(0).getRawClass());
        assertEquals(Integer.class, t.containedType(1).getRawClass());
        // NOTE: no key/content types, at least not as of 2.5
=======
        JavaType mapEntryType = t.findSuperType(Map.Entry.class);
        assertNotNull(mapEntryType);
        assertTrue(mapEntryType.hasGenericTypes());
        assertEquals(2, mapEntryType.containedTypeCount());
        assertEquals(String.class, mapEntryType.containedType(0).getRawClass());
        assertEquals(Integer.class, mapEntryType.containedType(1).getRawClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        type = tf.constructRawCollectionLikeType(String.class); // class doesn't really matter
=======
        // actually, should also allow "no type vars" case
        type = tf.constructRawCollectionLikeType(String.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        type = tf.constructRawMapLikeType(String.class); // class doesn't really matter
=======
        type = tf.constructRawMapLikeType(MapLike.class); // must have type vars
        assertTrue(type.isMapLikeType());
        assertEquals(TypeFactory.unknownType(), type.getKeyType());
        assertEquals(TypeFactory.unknownType(), type.getContentType());

        // actually, should also allow "no type vars" case
        type = tf.constructRawMapLikeType(String.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    // [Issue#489]
=======
    // [databind#489]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        assertEquals(1, tf._typeCache.size());
=======
        // 19-Oct-2015, tatu: This is pretty fragile but
        assertEquals(6, tf._typeCache.size());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java;<<<<<<< MINE
    public void test() throws IOException
=======
    public void test868() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
    public void testGeneratingJsonSchema()
        throws Exception
=======
    public void testOldSchemaGeneration() throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
    public void testSchemaSerialization()
            throws Exception
=======
    public void testSchemaSerialization() throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
	Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);
	assertNotNull(result);
	// no need to check out full structure, just basics...
	assertEquals("object", result.get("type"));
	// only add 'required' if it is true...
	assertNull(result.get("required"));
	assertNotNull(result.get("properties"));
    }

    public void testInvalidCall()
        throws Exception
    {
        // not ok to pass null
        try {
            MAPPER.generateJsonSchema(null);
            fail("Should have failed");
        } catch (IllegalArgumentException iae) {
            verifyException(iae, "class must be provided");
        }
=======
        Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);
        assertNotNull(result);
        // no need to check out full structure, just basics...
        assertEquals("object", result.get("type"));
        // only add 'required' if it is true...
        assertNull(result.get("required"));
        assertNotNull(result.get("properties"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
    // [Issue#271]
=======
    // [databind#271]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java;<<<<<<< MINE
    @JsonTypeIdResolver(CustomIdResolver.class)
=======
    @JsonTypeIdResolver(TestCustomIdResolver.class)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java;<<<<<<< MINE
        public CustomIdResolver(String idForBean) {
=======
        public TestCustomIdResolver(String idForBean) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java;<<<<<<< MINE
            if (resolverClass == CustomIdResolver.class) {
                return new CustomIdResolver("!!!");
=======
            if (resolverClass == TestCustomIdResolver.class) {
                return new TestCustomIdResolver("!!!");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java;<<<<<<< MINE
        public ListWrapper(T... values) {
=======
        public ListWrapper(@SuppressWarnings("unchecked") T... values) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java;<<<<<<< MINE
    /* Additional assert methods
=======
    /* Factory methods
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestVersions.java;<<<<<<< MINE
        assertFalse("Should find version information (got "+v+")", v.isUknownVersion());
=======
        assertFalse("Should find version information (got "+v+")", v.isUnknownVersion());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
    // For [databind#703]
=======
    // For [databind#703], [databind#978]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
        // but this used to pass, incorrectly
=======
        // but this used to pass, incorrectly, second time around
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java;<<<<<<< MINE
            if (name.equals("uri")) {
                assertToken(JsonToken.VALUE_STRING, t);
                assertEquals(FixtureObjectBase.VALUE_URSTR, getAndVerifyText(jp));
            } else if (name.equals("url")) {
=======
            if (name.equals("uri") || name.equals("url")) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/ImplicitParamsForCreator806Test.java;<<<<<<< MINE
            .setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES)
=======
            .setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java;<<<<<<< MINE
    // For [Issue#426]
=======
    // For [databind#426]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java;<<<<<<< MINE
        void setUserId(String id) {
            setUserId(new Integer(id));
=======
        void setUserId(CharSequence id) {
            // 21-Dec-2015, tatu: With a fix in 2.7, use of String would not
            //   trigger the problem, so use CharSequence...
            setUserId(new Integer(id.toString()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_37034fc_bacb37f/rev_37034fc-bacb37f/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
                                           ? format.getPattern()
                                           : StdDateFormat.DATE_FORMAT_STR_ISO8601;
=======
                                    ? format.getPattern()
                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_37034fc_bacb37f/rev_37034fc-bacb37f/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
                                       ? format.getLocale()
                                       : serializers.getLocale();
=======
                                    ? format.getLocale()
                                    : serializers.getLocale();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0934fb7_493ba8d/rev_0934fb7-493ba8d/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java;<<<<<<< MINE
        Enum<?> defaultEnum = (ai == null) ? null : ai.findDefaultEnumValue(enumCls);
        return new EnumResolver(enumCls, enumValues, map, defaultEnum);
    }

    /**
     * @deprecated Since 2.8, use {@link #constructUsingMethod(Class, Method, AnnotationIntrospector)} instead
     */
    @Deprecated
    public static EnumResolver constructUsingMethod(Class<Enum<?>> enumCls, Method accessor) {
        return constructUsingMethod(enumCls, accessor, null);
    }
=======
        return new EnumResolver(enumCls, enumValues, map);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e09adcb_f1f4023/rev_e09adcb-f1f4023/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    /* Abstract method impls
=======
    /* Contextualization (support for property annotations)
    /**********************************************************
     */

    @Override
    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property) throws JsonMappingException
    {
        TypeSerializer typeSer = _valueTypeSerializer;
        if (typeSer != null) {
            typeSer = typeSer.forProperty(property);
        }
        // First: do we have an annotation override from property?
        JsonSerializer<?> ser = findAnnotatedContentSerializer(provider, property);;
        if (ser == null) {
            // If not, use whatever was configured by type
            ser = _valueSerializer;
            if (ser == null) {
                // A few conditions needed to be able to fetch serializer here:
                if (_useStatic(provider, property, _referredType)) {
                    ser = _findSerializer(provider, _referredType, property);
                }
            } else {
                ser = provider.handlePrimaryContextualization(ser, property);
            }
        }
        // Also: may want to have more refined exclusion based on referenced value
        JsonInclude.Include contentIncl = _contentInclusion;
        if (property != null) {
            JsonInclude.Value incl = property.findPropertyInclusion(provider.getConfig(),
                    AtomicReference.class);
            JsonInclude.Include newIncl = incl.getContentInclusion();
            if ((newIncl != contentIncl) && (newIncl != JsonInclude.Include.USE_DEFAULTS)) {
                contentIncl = newIncl;
            }
        }
        return withResolved(property, typeSer, ser, _unwrapper, contentIncl);
    }

    protected boolean _useStatic(SerializerProvider provider, BeanProperty property,
            JavaType referredType)
    {
        // First: no serializer for `Object.class`, must be dynamic
        if (referredType.isJavaLangObject()) {
            return false;
        }
        // but if type is final, might as well fetch
        if (referredType.isFinal()) { // or should we allow annotation override? (only if requested...)
            return true;
        }
        // also: if indicated by typing, should be considered static
        if (referredType.useStaticType()) {
            return true;
        }
        // if neither, maybe explicit annotation?
        AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        if ((intr != null) && (property != null)) {
            Annotated ann = property.getMember();
            if (ann != null) {
                JsonSerialize.Typing t = intr.findSerializationTyping(property.getMember());
                if (t == JsonSerialize.Typing.STATIC) {
                    return true;
                }
                if (t == JsonSerialize.Typing.DYNAMIC) {
                    return false;
                }
            }
        }
        // and finally, may be forced by global static typing (unlikely...)
        return provider.isEnabled(MapperFeature.USE_STATIC_TYPING);
    }

    /*
    /**********************************************************
    /* Accessors
    /**********************************************************
     */

    @Override
    public boolean isEmpty(SerializerProvider provider, AtomicReference<?> value)
    {
        if (value == null) {
            return true;
        }
        Object contents = value.get();
        if (contents == null) {
            return true;
        }
        if (_contentInclusion == null) {
            return false;
        }
        JsonSerializer<Object> ser = _valueSerializer;
        if (ser == null) {
            try {
                ser = _findCachedSerializer(provider, contents.getClass());
            } catch (JsonMappingException e) { // nasty but necessary
                throw new RuntimeJsonMappingException(e);
            }
        }
        return ser.isEmpty(provider, contents);

    }

    @Override
    public boolean isUnwrappingSerializer() {
        return (_unwrapper != null);
    }

    /*
    /**********************************************************
    /* Serialization methods
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9845fb2_779411e/rev_9845fb2-779411e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    protected Object _getReferenced(AtomicReference<?> value) {
        return value.get();
=======
    public void serializeWithType(AtomicReference<?> ref,
            JsonGenerator g, SerializerProvider provider,
            TypeSerializer typeSer) throws IOException
    {
        Object value = ref.get();
        if (value == null) {
            if (_unwrapper == null) {
                provider.defaultSerializeNull(g);
            }
            return;
        }

        // 19-Apr-2016, tatu: In order to basically "skip" the whole wrapper level
        //    (which is what non-polymorphic serialization does too), we will need
        //    to simply delegate call, I think, and NOT try to use it here.
        
        // Otherwise apply type-prefix/suffix, then std serialize:
        /*
        typeSer.writeTypePrefixForScalar(ref, g);
        serialize(ref, g, provider);
        typeSer.writeTypeSuffixForScalar(ref, g);
        */

        JsonSerializer<Object> ser = _valueSerializer;
        if (ser == null) {
            ser = _findCachedSerializer(provider, value.getClass());
        }
        ser.serializeWithType(value, g, provider, typeSer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_580e652_2520c29/rev_580e652-2520c29/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE

    @Deprecated // since 2.8
    public AtomicReferenceDeserializer(JavaType fullType) {
        this(fullType, null, null);
=======
    protected final JavaType _referencedType;
    
    protected final TypeDeserializer _valueTypeDeserializer;

    protected final JsonDeserializer<?> _valueDeserializer;

    /**
     * @param referencedType Parameterization of this reference
     */
    public AtomicReferenceDeserializer(JavaType referencedType) {
        this(referencedType, null, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6580a9d_f40e6c1/rev_6580a9d-f40e6c1/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
    protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt)
=======
    protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6580a9d_f40e6c1/rev_6580a9d-f40e6c1/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return new java.util.Date(jp.getLongValue());
=======
            return new java.util.Date(p.getLongValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c270be0_cc53828/rev_c270be0-cc53828/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java;<<<<<<< MINE
        return _idFrom(value, type, _typeFactory);
=======
        return _idFrom(value, type);
    }

    @Deprecated // since 2.3
    @Override
    public JavaType typeFromId(String id) {
        return _typeFromId(id, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c4ecc55_f6fbed5/rev_c4ecc55-f6fbed5/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE
            p.nextToken();
=======
            t = p.nextToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_02a803a_0aa6486/rev_02a803a-0aa6486/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
            if (index >= 0 && index <= _enumsByIndex.length) {
=======
            if (index >= 0 && index < _enumsByIndex.length) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_facb2c0_e4b261e/rev_facb2c0-e4b261e/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionDeserialization.java;<<<<<<< MINE
    // [Issue#381]
=======
    // [databind#381]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_facb2c0_e4b261e/rev_facb2c0-e4b261e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-235]: need to retain name of managed forward references:
=======
        // need to retain name of managed forward references:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        return (_property == prop) ? this : new AsArrayTypeSerializer(this._idResolver, prop);
=======
        return (_property == prop) ? this : new AsArrayTypeSerializer(_idResolver, prop);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartObject();
=======
        g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g, Class<?> type) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartObject();
=======
        g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartArray();
=======
        g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g, Class<?> type) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartArray();
=======
        g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g, Class<?> type) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException {
        jgen.writeEndObject();
        if (!jgen.canWriteTypeId()) {
            jgen.writeEndArray();
=======
    public void writeTypeSuffixForObject(Object value, JsonGenerator g) throws IOException {
        g.writeEndObject();
        if (!g.canWriteTypeId()) {
            g.writeEndArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypeSuffixForArray(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeEndArray();
        if (!jgen.canWriteTypeId()) {
            jgen.writeEndArray();
=======
        g.writeEndArray();
        if (!g.canWriteTypeId()) {
            g.writeEndArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException {
        if (!jgen.canWriteTypeId()) {
=======
    public void writeTypeSuffixForScalar(Object value, JsonGenerator g) throws IOException {
        if (!g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeEndArray();
=======
            g.writeEndArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForObject(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartObject();
=======
        g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForArray(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartArray();
=======
        g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForScalar(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForObject(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForObject(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForArray(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForArray(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForScalar(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForScalar(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        return (_property == prop) ? this : new AsWrapperTypeSerializer(this._idResolver, prop);
=======
        return (_property == prop) ? this : new AsWrapperTypeSerializer(_idResolver, prop);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
        writeTypePrefixForScalar(value, jgen);
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g, Class<?> type) throws IOException {
        writeTypePrefixForScalar(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
        writeTypePrefixForObject(value, jgen);
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g, Class<?> type) throws IOException {
        writeTypePrefixForObject(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
        writeTypePrefixForArray(value, jgen);
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g, Class<?> type) throws IOException {
        writeTypePrefixForArray(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_75b7049_d44600d/rev_75b7049-d44600d/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex,
            boolean explicit) {
=======
    /**
     * @return True if specified Creator is to be used
     */
    protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
    {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_48902b1_7fe2d4f/rev_48902b1-7fe2d4f/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
     * /********************************************************** /* Helper
     * class(es) /**********************************************************
=======
    /**********************************************************
    /* Helper class(es)
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_a66b4e0_cc478a2/rev_a66b4e0-cc478a2/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                if (enclosing != null && enclosing == _beanType.getRawClass()) {
=======
                if ((enclosing != null) && (enclosing == _beanType.getRawClass())) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e0be428_8d5bd66/rev_e0be428-8d5bd66/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java;<<<<<<< MINE
        return provider.findTypedValueSerializer(type, true, prop);
=======
        // 13-Mar-2017, tatu: Used to call `findTypeValueSerializer()`, but contextualization
        //   not working for that case for some reason
//        return provider.findTypedValueSerializer(type, true, prop);
        return provider.findValueSerializer(type, prop);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_ab494a1_23d49e3/rev_ab494a1-23d49e3/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return typeDeserializer.deserializeTypedFromScalar(p, ctxt);
    }

    /**
     * Overridden to simply call <code>deserialize()</code> method that does not take value
     * to update, since scalar values are usually non-mergeable.
     */
    @Override // since 2.9
    public T deserialize(JsonParser p, DeserializationContext ctxt, T intoValue) throws IOException {
        // 25-Oct-2016, tatu: And if attempt is made, see if we are to complain...
        ctxt.reportBadMerge(this);
        // except that it is possible to suppress this; and if so...
        return deserialize(p, ctxt);
    }

    /**
     * By default assumption is that scalar types can not be updated: many are immutable
     * values (such as primitives and wrappers)
     */
    @Override // since 2.9
    public Boolean supportsUpdate(DeserializationConfig config) {
        return Boolean.FALSE;
    }

    // Typically Scalar values have default setting of "nulls as nulls"
    @Override
    public AccessPattern getNullAccessPattern() {
        return AccessPattern.ALWAYS_NULL;
    }

    // While some scalar types have non-null empty values (hence can't say "ALWAYS_NULL")
    // they are mostly immutable, shareable and so constant.
    @Override // since 2.9
    public AccessPattern getEmptyAccessPattern() {
        return AccessPattern.CONSTANT;
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return typeDeserializer.deserializeTypedFromScalar(p, ctxt);
    }

    protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        JsonToken t;
        if (ctxt.hasSomeOfFeatures(FEATURES_ACCEPT_ARRAYS)) {
            t = p.nextToken();
            if (t == JsonToken.END_ARRAY) {
                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
                    return getNullValue(ctxt);
                }
            }
            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
                final T parsed = deserialize(p, ctxt);
                if (p.nextToken() != JsonToken.END_ARRAY) {
                    handleMissingEndArrayForSingle(p, ctxt);
                }
                return parsed;            
            }
        } else {
            t = p.getCurrentToken();
        }
        @SuppressWarnings("unchecked")
        T result = (T) ctxt.handleUnexpectedToken(_valueClass, t, p, null);
        return result;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java;<<<<<<< MINE
    protected SettableBeanProperty withDelegate(SettableBeanProperty d) {
        return new InnerClassProperty(d, _creator);
=======
    public InnerClassProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new InnerClassProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java;<<<<<<< MINE
    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        return new ObjectIdValueProperty(this, deser, _nullProvider);
    }

    @Override
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new ObjectIdValueProperty(this, _valueDeserializer, nva);
=======
    public ObjectIdValueProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new ObjectIdValueProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        return new MethodProperty(this, deser, _nullProvider);
    }

    @Override
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new MethodProperty(this, _valueDeserializer, nva);
=======
    public MethodProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new MethodProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new FieldProperty(this, _valueDeserializer, nva);
=======
    public FieldProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new FieldProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new SetterlessProperty(this, _valueDeserializer, nva);
=======
    public SetterlessProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new SetterlessProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2db5afe_934f485/rev_2db5afe-934f485/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java;<<<<<<< MINE
        // 19-Oct-2016, tatu: Simplified to bare essentials since this is deprecated
        g.writeFieldName(value.toString());
=======
        String str;
        Class<?> cls = value.getClass();

        if (cls == String.class) {
            str = (String) value;
        } else if (cls.isEnum()) {
            // 24-Sep-2015, tatu: Minor improvement over older (2.6.2 and before) code: at least
            //     use name/toString() variation for as per configuration
            if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {
                str = value.toString();
            } else {
                Enum<?> en = (Enum<?>) value;
                if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {
                    str = String.valueOf(en.ordinal());
                } else {
                    str = en.name();
                }
            }
        } else if (value instanceof Date) {
            provider.defaultSerializeDateKey((Date) value, g);
            return;
        } else if (cls == Class.class) {
            str = ((Class<?>) value).getName();
        } else {
            str = value.toString();
        }
        g.writeFieldName(str);
    }

    @Override
    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {
        return createSchemaNode("string");
    }

    @Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _addMemberMethods(_class, this, _memberMethods, _primaryMixIn, mixins);
=======
        _addMemberMethods(_class, this, memberMethods, _primaryMixIn, mixins);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                    _memberMethods, mixin, mixins);
=======
                    memberMethods, mixin, mixins);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                _addMethodMixIns(_class, _memberMethods, mixin, mixins);
=======
                _addMethodMixIns(_class, memberMethods, mixin, mixins);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                            _memberMethods.add(am);
=======
                            memberMethods.add(am);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            _fields = Collections.emptyList();
=======
            f = Collections.emptyList();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            f = new ArrayList<AnnotatedField>(foundFields.size());
            f.addAll(foundFields.values());
=======
            f = new ArrayList<AnnotatedField>(foundFields.size());
            f.addAll(foundFields.values());
        }
        _fields = f;
    }

    /*
    /**********************************************************
    /* Helper methods for resolving class annotations
    /* (resolution consisting of inheritance, overrides,
    /* and injection of mix-ins as necessary)
    /**********************************************************
     */
    
    /**
     * Helper method for adding any mix-in annotations specified
     * class might have.
     */
    protected void _addClassMixIns(AnnotationMap annotations, JavaType target)
    {
        if (_mixInResolver != null) {
            final Class<?> toMask = target.getRawClass();
            _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask));
        }
    }

    protected void _addClassMixIns(AnnotationMap annotations, Class<?> target)
    {
        if (_mixInResolver != null) {
            _addClassMixIns(annotations, target, _mixInResolver.findMixInClassFor(target));
        }
    }

    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask,
            Class<?> mixin)
    {
        if (mixin == null) {
            return;
        }
        // Ok, first: annotations from mix-in class itself:
        _addAnnotationsIfNotPresent(annotations, ClassUtil.findClassAnnotations(mixin));

        /* And then from its supertypes, if any. But note that we will
         * only consider super-types up until reaching the masked
         * class (if found); this because often mix-in class
         * is a sub-class (for convenience reasons). And if so, we
         * absolutely must NOT include super types of masked class,
         * as that would inverse precedence of annotations.
         */
        for (Class<?> parent : ClassUtil.findSuperClasses(mixin, toMask, false)) {
            _addAnnotationsIfNotPresent(annotations, ClassUtil.findClassAnnotations(parent));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6b9782b_96eb83b/rev_6b9782b-96eb83b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                    // otherwise just ignored
=======
                    // 23-Sep-2016, tatu: [databind#1383]: Need to also sever link to avoid possible
                    //    later problems with "unresolved" constructor property
                    if (argDef != null) {
                        ((POJOPropertyBuilder) argDef).removeConstructors();
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38f749b_147fb08/rev_38f749b-147fb08/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
            Logger.getLogger(OptionalHandlerFactory.class.getName())
                .log(Level.INFO, "Could not load DOM `Node` and/or `Document` classes: no DOM support");
=======
            Logger.getLogger("com.fasterxml.jackson.databind.ext.OptionalHandlerFactory")
                .log(Level.INFO, "Could not load DOM `Node` and/or `Document` classes: ignoring");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38f749b_147fb08/rev_38f749b-147fb08/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
            x = Java7Support.instance();
        } catch (Throwable t) { }
        _jdk7Helper = x;
=======
            cls = Class.forName("java.nio.file.Path");
        } catch (Exception e) {
            Logger.getLogger("com.fasterxml.jackson.databind.ext.OptionalHandlerFactory")
                .log(Level.INFO, "Could not load Java7 `java.nio.file.Path` class: ignoring");
        }
        CLASS_JAVA7_PATH = cls;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
    public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException
=======
    public final void serialize(JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
            jg.writeNull();
=======
            g.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
            jg.writeString(_value);
=======
            g.writeString(_value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_991ccbe_ddfddfb/rev_991ccbe-ddfddfb/src/test/java/com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java;<<<<<<< MINE
+" 'obj':[ '"+NASTY_CLASS+"',\n"
=======
+" 'obj':[ '"+clsName+"',\n"
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_991ccbe_ddfddfb/rev_991ccbe-ddfddfb/src/test/java/com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java;<<<<<<< MINE
        } catch (InvalidDefinitionException e) {
            verifyException(e, "Illegal type");
            verifyException(e, "to deserialize");
            verifyException(e, "prevented for security reasons");
            BeanDescription desc = e.getBeanDescription();
            assertNotNull(desc);
            assertEquals(NASTY_CLASS, desc.getBeanClass().getName());
=======
        } catch (JsonMappingException e) {
            _verifySecurityException(e, clsName);
        }
    }

    // // // Tests for [databind#1737]

    public void testJDKTypes1737() throws Exception
    {
        _testTypes1737(java.util.logging.FileHandler.class);
        _testTypes1737(java.rmi.server.UnicastRemoteObject.class);
    }

    // 17-Aug-2017, tatu: Ideally would test handling of 3rd party types, too,
    //    but would require adding dependencies. This may be practical when
    //    checking done by module, but for now let's not do that for databind.

    /*
    public void testSpringTypes1737() throws Exception
    {
        _testTypes1737("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor");
        _testTypes1737("org.springframework.beans.factory.config.PropertyPathFactoryBean");
    }

    public void testC3P0Types1737() throws Exception
    {
        _testTypes1737("com.mchange.v2.c3p0.JndiRefForwardingDataSource");
        _testTypes1737("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource");
    }
    */

    private void _testTypes1737(Class<?> nasty) throws Exception {
        _testTypes1737(nasty.getName());
    }

    private void _testTypes1737(String clsName) throws Exception
    {
        // While usually exploited via default typing let's not require
        // it here; mechanism still the same
        String json = aposToQuotes(
                "{'v':['"+clsName+"','/tmp/foobar.txt']}"
                );
        try {
            MAPPER.readValue(json, PolyWrapper.class);
            fail("Should not pass");
        } catch (JsonMappingException e) {
            _verifySecurityException(e, clsName);
        }
    }

    protected void _verifySecurityException(Throwable t, String clsName) throws Exception
    {
        // 17-Aug-2017, tatu: Expected type more granular in 2.9 (over 2.8)
        _verifyException(t, JsonMappingException.class,
            "Illegal type",
            "to deserialize",
            "prevented for security reasons");
        verifyException(t, clsName);
    }

    protected void _verifyException(Throwable t, Class<?> expExcType,
            String... patterns) throws Exception
    {
        Class<?> actExc = t.getClass();
        if (!expExcType.isAssignableFrom(actExc)) {
            fail("Expected Exception of type '"+expExcType.getName()+"', got '"
                    +actExc.getName()+"', message: "+t.getMessage());
        }
        for (String pattern : patterns) {
            verifyException(t, pattern);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_998d79f_9d4a741/rev_998d79f-9d4a741/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
            boolean explicit, SettableBeanProperty[] injectables)
    {
        int delegateIndex = 0; // !!! TO FIX !!!
        if (creator.getParameterType(delegateIndex).isCollectionLikeType()) {
=======
            boolean explicit, SettableBeanProperty[] injectables,
            int delegateeIndex)
    {
        if (creator.getParameterType(delegateeIndex).isCollectionLikeType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b505162_4675896/rev_b505162-4675896/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // 20-Oct-2015, tatu: Old simplistic approach

        /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException("Class "+subclass.getClass().getName()+" not subtype of "+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, EMPTY_BINDINGS);
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
=======
    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)
    {
        PlaceholderForType[] placeholders = new PlaceholderForType[typeParamCount];
        for (int i = 0; i < typeParamCount; ++i) {
            placeholders[i] = new PlaceholderForType(i);
        }
        TypeBindings b = TypeBindings.create(subclass, placeholders);
        // First: pseudo-resolve to get placeholders in place:
        JavaType tmpSub = _fromClass(null, subclass, b);
        // Then find super-type
        JavaType baseWithPlaceholders = tmpSub.findSuperType(baseType.getRawClass());
        if (baseWithPlaceholders == null) { // should be found but...
            throw new IllegalArgumentException(String.format(
                    "Internal error: unable to locate supertype (%s) from resolved subtype %s", baseType.getRawClass().getName(),
                    subclass.getName()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b505162_4675896/rev_b505162-4675896/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Otherwise, two choices: match N first, or empty. Do latter, for now
        return EMPTY_BINDINGS;
=======
        return true;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6ec6e3e_a43d23d/rev_6ec6e3e-a43d23d/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
    public final boolean isArray() {
        return getNodeType() == JsonNodeType.ARRAY;
=======
    public boolean isMissingNode() {
        return false;
    }

    @Override
    public boolean isArray() {
        return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_985a3f9_dfaca81/rev_985a3f9-dfaca81/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        /* Let's try to figure out the reason, to give better error
         * messages
         */
=======
        // Let's try to figure out the reason, to give better error messages
>>>>>>> YOURS
