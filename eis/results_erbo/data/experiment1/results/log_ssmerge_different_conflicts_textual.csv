file;linedbasedConf
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_cbfafc6_bc4153e/rev_cbfafc6-bc4153e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE
import com.fasterxml.jackson.core.io.SerializedString;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_cbfafc6_bc4153e/rev_cbfafc6-bc4153e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE

    @Override
    public void writeFieldName(SerializedString name)
        throws IOException, JsonGenerationException
    {
        _append(JsonToken.FIELD_NAME, name);
        _writeContext.writeFieldName(name.getValue());
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java;<<<<<<< MINE
                    +" or make serializer extend 'com.fasterxml.jackson.databind.ser.std.SerializerBase'"); 
=======
                    +" or make serializer extend 'com.fasterxml.jackson.databind.ser.std.StdSerializer'"); 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
                if (t.isArrayType()) {
=======
                while (t.isArrayType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
                if (t.isArrayType()) {
=======
                while (t.isArrayType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
=======

    // 24-May-2012, tatu: Comment out for 2.0.x to keep tests green; leave for 2.1 to fix
    
    /*
    // [JACKSON-822]: ensure that type can be coerced
    public void testTypedLists() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        List<Issue822Interface> list = new ArrayList<Issue822Interface>();
        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());
        // start with specific value case:
        assertEquals("{\"a\":3}", singleJson);
        // then lists
        list.add(new Issue822Impl());
        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})
                .writeValueAsString(list);
        assertEquals("[{\"a\":3}]", listJson);
    }

    // [JACKSON-822]: ensure that type can be coerced
    public void testTypedArrays() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("[{\"a\":3}]", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(
                new Issue822Interface[] { new Issue822Impl() }));
    }
    */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForArrays.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonTypeInfo;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForArrays.java;<<<<<<< MINE
=======

    // test for [JACKSON-845]
    public void testArraysOfArrays() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);

        Object value = new Object[][] { new Object[] {} };
        String json = mapper.writeValueAsString(value);

        // try with different (but valid) nominal types:
        _testArraysAs(mapper, json, Object[][].class);
        _testArraysAs(mapper, json, Object[].class);
        _testArraysAs(mapper, json, Object.class);
    }

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */
    
    protected void _testArraysAs(ObjectMapper mapper, String json, Class<?> type)
        throws Exception
    {
        Object o = mapper.readValue(json, type);
        assertNotNull(o);
        assertTrue(o instanceof Object[]);
        Object[] main = (Object[]) o;
        assertEquals(1, main.length);
        Object element = main[0];
        assertNotNull(element);
        assertTrue(element instanceof Object[]);
        assertEquals(0, ((Object[]) element).length);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
import java.lang.reflect.Type;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;
=======
import com.fasterxml.jackson.databind.node.ObjectNode;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE

            JavaType propType = prop.getSerializationType();
            BeanSerializerBase.depositSchemaProperty(prop, objectVisitor);
=======
            if (filter != null) {
            	filter.depositSchemaProperty(prop, propertiesNode, provider);
            	 continue;
            }
            depositSchemaProperty(prop, propertiesNode, provider);

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
=======
    /**
     * 	Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.
     * 	Otherwise, add the default schema {@link JsonNode} in place of the writer's output
     * 
     * @param writer Bean property serializer to use to create schema value
     * @param propertiesNode Node which the given property would exist within
     * @param provider Provider that can be used for accessing dynamic aspects of serialization
     * 	processing
     * 	
     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}
     */
    public static void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider)
    {
        JavaType propType = writer.getSerializationType();

        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...
        Type hint = (propType == null) ? writer.getGenericPropertyType() : propType.getRawClass();
        JsonNode schemaNode;
        // Maybe it already has annotated/statically configured serializer?
        JsonSerializer<Object> ser = writer.getSerializer();

        try {
            if (ser == null) { // nope
                Class<?> serType = writer.getRawSerializationType();
                if (serType == null) {
                    serType = writer.getPropertyType();
                }
                ser = provider.findValueSerializer(serType, writer);
            }
            boolean isOptional = !BeanSerializerBase.isPropertyRequired(writer, provider);
            if (ser instanceof SchemaAware) {
                schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;
            } else {  
                schemaNode = JsonSchema.getDefaultSchemaNode(); 
            }
        } catch (JsonMappingException e) {
            schemaNode = JsonSchema.getDefaultSchemaNode(); 
            // TODO: handle in better way (why not throw?)
        }
        propertiesNode.put(writer.getName(), schemaNode);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.core.JsonGenerator;
=======
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonFormat.Shape;
import com.fasterxml.jackson.core.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;
=======
import com.fasterxml.jackson.databind.introspect.Annotated;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.ser.ContextualSerializer;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
    	if (visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {
    		visitor.expectIntegerFormat(typeHint);
    	} else {
    		JsonStringFormatVisitor stringVisitor = visitor.expectStringFormat(typeHint);
    		if (typeHint != null) {
    			if (typeHint.isEnumType()) {
    				Set<String> enums = new HashSet<String>();
    				for (SerializedString value : _values.values()) {
    					enums.add(value.getValue());
    				}
    				stringVisitor.enumTypes(enums);
    			}
    		}
    	}
=======
        if (_serializeAsIndex(provider)) {
            return createSchemaNode("integer", true);
        }
        ObjectNode objectNode = createSchemaNode("string", true);
        if (typeHint != null) {
            JavaType type = provider.constructType(typeHint);
            if (type.isEnumType()) {
                ArrayNode enumNode = objectNode.putArray("enum");
                for (SerializedString value : _values.values()) {
                    enumNode.add(value.getValue());
                }
            }
        }
        return objectNode;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f46d555_e134bf0/rev_f46d555-e134bf0/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;
import com.fasterxml.jackson.databind.introspect.ClassIntrospector;
import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;
import com.fasterxml.jackson.databind.introspect.VisibilityChecker;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
=======
import com.fasterxml.jackson.databind.introspect.*;
import com.fasterxml.jackson.databind.jsonschema.JsonSchema;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            jgen.writeBinary(value);
=======
            jgen.writeBinary(provider.getConfig().getBase64Variant(),
                    value, 0, value.length);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            jgen.writeBinary(value);
=======
            jgen.writeBinary(provider.getConfig().getBase64Variant(),
                    value, 0, value.length);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
            JsonNode old = node.put(fieldName, value);
=======
            JsonNode old = node.replace(fieldName, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    
=======

    @Override
    public Object findNamingStrategy(AnnotatedClass ac)
    {
        JsonNaming ann = ac.getAnnotation(JsonNaming.class);
        return (ann == null) ? null : ann.value();
    } 

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.util.ClassUtil;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
        PropertyNamingStrategy naming = _config.getPropertyNamingStrategy();
=======
        PropertyNamingStrategy naming = _findNamingStrategy();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
=======

    private PropertyNamingStrategy _findNamingStrategy()
    {
        Object namingDef = (_annotationIntrospector == null)? null
                : _annotationIntrospector.findNamingStrategy(_classDef);
        if (namingDef == null) {
            return _config.getPropertyNamingStrategy();
        }
        if (namingDef instanceof PropertyNamingStrategy) {
            return (PropertyNamingStrategy) namingDef;
        }
        /* Alas, there's no way to force return type of "either class
         * X or Y" -- need to throw an exception after the fact
         */
        if (!(namingDef instanceof Class)) {
            throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type "
                    +namingDef.getClass().getName()+"; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead");
        }
        Class<?> namingClass = (Class<?>)namingDef;
        if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) {
            throw new IllegalStateException("AnnotationIntrospector returned Class "
                    +namingClass.getName()+"; expected Class<PropertyNamingStrategy>");
        }
        HandlerInstantiator hi = _config.getHandlerInstantiator();
        if (hi != null) {
            return hi.namingStrategyInstance(_config, _classDef, namingClass);
        }
        return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass,
                    _config.canOverrideAccessModifiers());
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java;<<<<<<< MINE
        jg.writeBinary(_data);
=======
        jg.writeBinary(provider.getConfig().getBase64Variant(),
                _data, 0, _data.length);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
    /* Extended ObjectNode API, mutators, generic
=======
    /* Extended ObjectNode API, mutators, since 2.1
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * Method that will set specified field, replacing old value,
     * if any.
=======
     * Method that will set specified field, replacing old value, if any.
     * Note that this is identical to {@link #replace(String, JsonNode)},
     * except for return value.
     *<p>
     * NOTE: added to replace those uses of {@link #put(String, JsonNode)}
     * where chaining with 'this' is desired.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
=======
     * @return This node after adding/replacing property value (to allow chaining)
     *
     * @since 2.1
     */
    public JsonNode set(String fieldName, JsonNode value)
    {
        if (value == null) {
            value = nullNode();
        }
        _put(fieldName, value);
        return this;
    }

    /**
     * Method for adding given properties to this object node, overriding
     * any existing values for those properties.
     * 
     * @param properties Properties to add
     * 
     * @return This node after adding/replacing property values (to allow chaining)
     *
     * @since 2.1
     */
    public JsonNode setAll(Map<String,JsonNode> properties)
    {
        if (_children == null) {
            _children = new LinkedHashMap<String, JsonNode>(properties);
        } else {
            for (Map.Entry<String, JsonNode> en : properties.entrySet()) {
                JsonNode n = en.getValue();
                if (n == null) {
                    n = nullNode();
                }
                _children.put(en.getKey(), n);
            }
        }
        return this;
    }

    /**
     * Method for adding all properties of the given Object, overriding
     * any existing values for those properties.
     * 
     * @param other Object of which properties to add to this object
     *
     * @return This node after addition (to allow chaining)
     *
     * @since 2.1
     */
    public JsonNode setAll(ObjectNode other)
    {
        int len = other.size();
        if (len > 0) {
            if (_children == null) {
                _children = new LinkedHashMap<String, JsonNode>(len);
            }
            other.putContentsTo(_children);
        }
        return this;
    }
    
    /**
     * Method for replacing value of specific property with passed
     * value, and returning value (or null if none).
     *
     * @param fieldName Property of which value to replace
     * @param value Value to set property to, replacing old value if any
     * 
     * @return Old value of the property; null if there was no such property
     *   with value
     * 
     * @since 2.1
     */
    public JsonNode replace(String fieldName, JsonNode value)
    {
        if (value == null) { // let's not store 'raw' nulls but nodes
            value = nullNode();
        }
        return _put(fieldName, value);
    }

    /**
     * Method for removing field entry from this ObjectNode, and
     * returning instance after removal.
     * 
     * @return This node after removing entry (if any)
     * 
     * @since 2.1
     */
    public JsonNode without(String fieldName)
    {
        if (_children != null) {
            _children.remove(fieldName);
        }
        return this;
    }

    /**
     * Method for removing specified field properties out of
     * this ObjectNode.
     * 
     * @param fieldNames Names of fields to remove
     * 
     * @return This node after removing entries
     * 
     * @since 2.1
     */
    public ObjectNode without(Collection<String> fieldNames)
    {
        if (_children != null) {
            for (String fieldName : fieldNames) {
                _children.remove(fieldName);
            }
        }
        return this;
    }
    
    /*
    /**********************************************************
    /* Extended ObjectNode API, mutators, generic
    /**********************************************************
     */
    
    /**
     * Method that will set specified field, replacing old value, if any.
     *
     * @param value to set field to; if null, will be converted
     *   to a {@link NullNode} first  (to remove field entry, call
     *   {@link #remove} instead)
     *<p>
     * NOTE: this method will be <b>deprecated</b> in 2.2; and should
     * be replace with either
     * {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},
     * depending on which return value is desired for possible chaining.
     *   
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE

=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This ObjectNode after removing entries
=======
     * @return This node after removing entries
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This ObjectNode after removing all entries
=======
     * @return This node after removing all entries
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: this method will be <b>deprecated</b> in 2.2; and should
     * be replace with {@link #setAll(Map)}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This node (to allow chaining)
=======
     * @return This node after adding/replacing property values (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
    public JsonNode putAll(Map<String,JsonNode> properties)
    {
        if (_children == null) {
            _children = new LinkedHashMap<String, JsonNode>(properties);
        } else {
            for (Map.Entry<String, JsonNode> en : properties.entrySet()) {
                JsonNode n = en.getValue();
                if (n == null) {
                    n = nullNode();
                }
                _children.put(en.getKey(), n);
            }
        }
        return this;
=======
    public JsonNode putAll(Map<String,JsonNode> properties) {
        return setAll(properties);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: this method will be <b>deprecated</b> in 2.2; and should
     * be replace with {@link #setAll(ObjectNode)}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
    public JsonNode putAll(ObjectNode other)
    {
        int len = other.size();
        if (len > 0) {
            if (_children == null) {
                _children = new LinkedHashMap<String, JsonNode>(len);
            }
            other.putContentsTo(_children);
        }
        return this;
=======
    public JsonNode putAll(ObjectNode other) {
        return setAll(other);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This ObjectNode (to allow call chaining)
=======
     * @return This node (to allow call chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This ObjectNode (to allow call chaining)
=======
     * @return This node (to allow call chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
     * @return This <code>ObjectNode</code>
=======
     * @return This node (to allow chaining)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java;<<<<<<< MINE
=======
     * 
     * @return Node removed, if any; null if none
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java;<<<<<<< MINE
=======
    /**
     * Method for removing all elements of this array, leaving the
     * array empty.
     * 
     * @return This node (to allow chaining)
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java;<<<<<<< MINE
=======

    /**
     * Method called to construct a NamingStrategy instance used for specified
     * class.
     * 
     * @since 2.1
     */
    public PropertyNamingStrategy namingStrategyInstance(MapperConfig<?> config,
            Annotated annotated, Class<?> implClass) {
        return null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.Base64Variant;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======

    /**
     * Explicitly default {@link Base64Variant} to use for handling
     * binary data (<code>byte[]</code>), used with data formats
     * that use base64 encoding (like JSON, CSV).
     * 
     * @since 2.1
     */
    protected final Base64Variant _defaultBase64;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
            Locale locale, TimeZone tz)
=======
            Locale locale, TimeZone tz, Base64Variant defaultBase64)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        _defaultBase64 = defaultBase64;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_classIntrospector == ci) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_annotationIntrospector == ai) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_visibilityChecker == vc) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_propertyNamingStrategy == pns) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_typeFactory == tf) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_typeResolverBuilder == typer) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                typer, _dateFormat, _handlerInstantiator, _locale, _timeZone);
=======
                typer, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_dateFormat == df) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone);
=======
                _typeResolverBuilder, df, _handlerInstantiator, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_handlerInstantiator == hi) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, hi, _locale, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, hi, _locale,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_locale == l) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l, _timeZone);
=======
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l,
                _timeZone, _defaultBase64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
                _typeResolverBuilder, df, _handlerInstantiator, _locale, tz);
=======
                _typeResolverBuilder, df, _handlerInstantiator, _locale,
                tz, _defaultBase64);
    }

    /**
     * @since 2.1
     */
    public BaseSettings with(Base64Variant base64) {
        if (base64 == _defaultBase64) {
            return this;
        }
        return new BaseSettings(_classIntrospector, _annotationIntrospector,
                _visibilityChecker, _propertyNamingStrategy, _typeFactory,
                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,
                _timeZone, base64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======

    public Base64Variant getBase64Variant() {
        return _defaultBase64;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.Base64Variant;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
=======

    /**
     * Method called during deserialization if Base64 encoded content
     * needs to be decoded. Default version just returns default Jackson
     * uses, which is modified-mime which does not add linefeeds (because
     * those would have to be escaped in JSON strings); but this can
     * be configured on {@link ObjectWriter}.
     */
    public Base64Variant getBase64Variant() {
        return _base.getBase64Variant();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.Base64Variant;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java;<<<<<<< MINE
     * Explicitly definite root name to use, if any; if empty
=======
     * Explicitly defined root name to use, if any; if empty
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java;<<<<<<< MINE
=======

    /**
     * Method for constructing and returning a new instance with different
     * default {@link Base64Variant} to use with base64-encoded binary values.
     */
    public abstract T with(Base64Variant base64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.annotation;

import java.lang.annotation.*;

import com.fasterxml.jackson.databind.PropertyNamingStrategy;

/**
 * Annotation that can be used to indicate a {@link PropertyNamingStrategy}
 * to use for annotated class. Overrides the global (default) strategy.
 * 
 * @since 2.1
 */
@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@com.fasterxml.jackson.annotation.JacksonAnnotation
public @interface JsonNaming
{
    public Class<? extends PropertyNamingStrategy> value();
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
    
=======

    /**
     * Method for finding {@link PropertyNamingStrategy} for given
     * class, if any specified by annotations; and if so, either return
     * a {@link PropertyNamingStrategy} instance, or Class to use for
     * creating instance
     * 
     * @return Sub-class or instance of {@link PropertyNamingStrategy}, if one
     *   is specified for given class; null if not.
     * 
     * @since 2.1
     */
    public Object findNamingStrategy(AnnotatedClass ac) {
        return null;
    }    

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
        
=======

        @Override
        public Object findNamingStrategy(AnnotatedClass ac)
        {
            Object str = _primary.findNamingStrategy(ac);
            if (str == null) {
                str = _secondary.findNamingStrategy(ac);
            }
            return str;
        }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.Base64Variant;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======

    @Override
    public SerializationConfig with(Base64Variant base64) {
        return _withBase(_base.with(base64));
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
            TimeZone.getTimeZone("GMT")
=======
            TimeZone.getTimeZone("GMT"),
            Base64Variants.getDefaultVariant() // 2.1
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * Equivalent to:
     *<pre>
     *  mapper.setSerializationConfig(mapper.getSerializationConfig().withSerializationInclusion(incl));
     *</pre>
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
   
=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======

    /**
     * Factory method for constructing {@link ObjectWriter} that will
     * use specified Base64 encoding variant for Base64-encoded binary data.
     * 
     * @since 2.1
     */
    public ObjectWriter writer(Base64Variant defaultBase64) {
        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======

    /**
     * Factory method for constructing {@link ObjectReader} that will
     * use specified Base64 encoding variant for Base64-encoded binary data.
     * 
     * @since 2.1
     */
    public ObjectReader reader(Base64Variant defaultBase64) {
        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======

    @Override
    public DeserializationConfig with(Base64Variant base64) {
        return _withBase(_base.with(base64));
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    
    /**
     * Method called during deserialization if Base64 encoded content
     * needs to be decoded. Default version just returns default Jackson
     * uses, which is modified-mime which does not add linefeeds (because
     * those would have to be escaped in JSON strings).
     */
    public Base64Variant getBase64Variant() {
        return Base64Variants.getDefaultVariant();
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader with(DeserializationFeature feature) 
    {
        DeserializationConfig newConfig = _config.with(feature);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
    public ObjectReader with(DeserializationFeature feature) {
        return _with(_config.with(feature));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.with(first, other);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
        return _with(_config.with(first, other));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader withFeatures(DeserializationFeature... features)
    {
        DeserializationConfig newConfig = _config.withFeatures(features);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
    public ObjectReader withFeatures(DeserializationFeature... features) {
        return _with(_config.withFeatures(features));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader without(DeserializationFeature feature) 
    {
        DeserializationConfig newConfig = _config.without(feature);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
    public ObjectReader without(DeserializationFeature feature) {
        return _with(_config.without(feature)); 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.without(first, other);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
        return _with(_config.without(first, other));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader withoutFeatures(DeserializationFeature... features)
    {
        DeserializationConfig newConfig = _config.withoutFeatures(features);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
    public ObjectReader withoutFeatures(DeserializationFeature... features) {
        return _with(_config.withoutFeatures(features));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader with(JsonNodeFactory f)
    {
        DeserializationConfig newConfig = _config.with(f);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
    public ObjectReader with(JsonNodeFactory f) {
        return _with(_config.with(f));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader withRootName(String rootName)
    {
        DeserializationConfig newConfig = _config.withRootName(rootName);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
    public ObjectReader withRootName(String rootName) {
        return _with(_config.withRootName(rootName));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.withView(activeView);
        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);
=======
        return _with(_config.withView(activeView));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.with(l);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
        return _with(_config.with(l));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.with(tz);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
        return _with(_config.with(tz));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        DeserializationConfig newConfig = _config.withHandler(h);
        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);
=======
        return _with(_config.withHandler(h));
    }

    public ObjectReader with(Base64Variant defaultBase64) {
        return _with(_config.with(defaultBase64));
    }

    protected ObjectReader _with(DeserializationConfig newConfig) {
        if (newConfig == _config) return this;
        return new ObjectReader(this, newConfig);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    
static int col = 0;
=======
//static int col = 0;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        n.put("a", text);
=======
        n.set("a", text);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        n.putAll(n2);
=======
        n.setAll(n2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        n.put("null", (JsonNode)null);
=======
        n.set("null", (JsonNode)null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        n.putAll(nodes);
=======
        n.setAll(nodes);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        o1.putAll(o2);
=======
        o1.setAll(o2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        o1.put("x", (ObjectNode) null);
=======
        o1.set("x", null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        dest.putAll(src);
=======
        dest.setAll(src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        assertSame(ob, ob.remove(Arrays.asList("a", "c")));
=======
        assertSame(ob, ob.without(Arrays.asList("a", "c")));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java;<<<<<<< MINE
        n1.put("x", TextNode.valueOf("Test"));
=======
        n1.set("x", TextNode.valueOf("Test"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java;<<<<<<< MINE
        n2.put("x", TextNode.valueOf("Test"));
=======
        n2.set("x", TextNode.valueOf("Test"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java;<<<<<<< MINE
=======
import org.junit.Assert;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java;<<<<<<< MINE
=======
    // as per [Issue#42], allow Base64 variant use as well
    public void testBase64Variants() throws Exception
    {
        final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8");
        
        // default encoding is "MIME, no linefeeds", so:
        Assert.assertArrayEquals(INPUT, MAPPER.readValue(
                quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="),
                byte[].class));
        ObjectReader reader = MAPPER.reader(byte[].class);
        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(
                quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="
        )));

        // but others should be slightly different
        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(
                quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="
        )));
        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(
                quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"
        )));
        // PEM mandates 64 char lines:
        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(
                quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="
        )));
    }    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java;<<<<<<< MINE
        n.put("pojo", mapper.getNodeFactory().POJONode("abc"));
=======
        n.set("pojo", mapper.getNodeFactory().POJONode("abc"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java;<<<<<<< MINE
        n.put("pojo", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));
=======
        n.set("pojo", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java;<<<<<<< MINE
        n.put("pojo", mapper.getNodeFactory().POJONode(new Bean()));
=======
        n.set("pojo", mapper.getNodeFactory().POJONode(new Bean()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.Base64Variants;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
=======
    private final ObjectMapper MAPPER = new ObjectMapper();
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("true", serializeAsString(mapper, Boolean.TRUE));
        assertEquals("false", serializeAsString(mapper, Boolean.FALSE));
=======
        assertEquals("true", serializeAsString(MAPPER, Boolean.TRUE));
        assertEquals("false", serializeAsString(MAPPER, Boolean.FALSE));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("[true,false]", serializeAsString(mapper, new boolean[] { true, false} ));
        assertEquals("[true,false]", serializeAsString(mapper, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));
=======
        assertEquals("[true,false]", serializeAsString(MAPPER, new boolean[] { true, false} ));
        assertEquals("[true,false]", serializeAsString(MAPPER, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        String str1 = serializeAsString(mapper, data);
        String str2 = serializeAsString(mapper, data2);
        assertArrayEquals(data, mapper.readValue(str1, byte[].class));
        assertArrayEquals(data2, mapper.readValue(str2, Byte[].class));
=======
        String str1 = serializeAsString(MAPPER, data);
        String str2 = serializeAsString(MAPPER, data2);
        assertArrayEquals(data, MAPPER.readValue(str1, byte[].class));
        assertArrayEquals(data2, MAPPER.readValue(str2, Byte[].class));
    }

    // as per [Issue#42], allow Base64 variant use as well
    public void testBase64Variants() throws Exception
    {
        final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8");
        
        // default encoding is "MIME, no linefeeds", so:
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), MAPPER.writeValueAsString(INPUT));
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="),
                MAPPER.writer(Base64Variants.MIME_NO_LINEFEEDS).writeValueAsString(INPUT));

        // but others should be slightly different
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="),
                MAPPER.writer(Base64Variants.MIME).writeValueAsString(INPUT));
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"), // no padding or LF
                MAPPER.writer(Base64Variants.MODIFIED_FOR_URL).writeValueAsString(INPUT));
        // PEM mandates 64 char lines:
        assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="),
                MAPPER.writer(Base64Variants.PEM).writeValueAsString(INPUT));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE

=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("[0,1]", serializeAsString(mapper, new short[] { 0, 1 }));
        assertEquals("[2,3]", serializeAsString(mapper, new Short[] { 2, 3 }));
=======
        assertEquals("[0,1]", serializeAsString(MAPPER, new short[] { 0, 1 }));
        assertEquals("[2,3]", serializeAsString(MAPPER, new Short[] { 2, 3 }));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("[0,-3]", serializeAsString(mapper, new int[] { 0, -3 }));
        assertEquals("[13,9]", serializeAsString(mapper, new Integer[] { 13, 9 }));
=======
        assertEquals("[0,-3]", serializeAsString(MAPPER, new int[] { 0, -3 }));
        assertEquals("[13,9]", serializeAsString(MAPPER, new Integer[] { 13, 9 }));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
           assertEquals(expected,serializeAsString(mapper, Float.valueOf(f)));
=======
           assertEquals(expected,serializeAsString(MAPPER, Float.valueOf(f)));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
            assertEquals(expected,serializeAsString(mapper, Double.valueOf(d)));
=======
            assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
            assertEquals(expected,serializeAsString(mapper, value));
=======
            assertEquals(expected, MAPPER.writeValueAsString(value));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java;<<<<<<< MINE
        String result = serializeAsString(java.util.List.class);
=======
        String result = MAPPER.writeValueAsString(java.util.List.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.annotation.JsonNaming;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java;<<<<<<< MINE
=======

    // [Issue#45]: Support @JsonNaming
    @JsonNaming(PrefixStrategy.class)
    static class BeanWithPrefixNames
    {
        protected int a = 3;
        
        public int getA() { return a; }
        public void setA(int value) { a = value; }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java;<<<<<<< MINE
=======

    // @JsonNaming / [Issue#45]
    public void testPerClassAnnotation() throws Exception
    {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.setPropertyNamingStrategy(new LcStrategy());
        BeanWithPrefixNames input = new BeanWithPrefixNames();
        String json = mapper.writeValueAsString(input);
        assertEquals("{\"Get-a\":3}", json);

        BeanWithPrefixNames output = mapper.readValue("{\"Set-a\":7}",
                BeanWithPrefixNames.class);
        assertEquals(7, output.a);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
    private static final long serialVersionUID = 612196544186875755L;

    /*
=======
    /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
	 */
=======
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
	protected SimpleBeanPropertyFilter() { }
=======
    protected SimpleBeanPropertyFilter() { }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
	/**
	 * Factory method to construct filter that filters out all properties <b>except</b>
	 * ones includes in set
	 */
	public static SimpleBeanPropertyFilter filterOutAllExcept(Set<String> properties) {
		return new FilterExceptFilter(properties);
	}

	public static SimpleBeanPropertyFilter filterOutAllExcept(String... propertyArray) {
		HashSet<String> properties = new HashSet<String>(propertyArray.length);
		Collections.addAll(properties, propertyArray);
		return new FilterExceptFilter(properties);
	}

	public static SimpleBeanPropertyFilter serializeAllExcept(Set<String> properties) {
		return new SerializeExceptFilter(properties);
	}

	public static SimpleBeanPropertyFilter serializeAllExcept(String... propertyArray) {
		HashSet<String> properties = new HashSet<String>(propertyArray.length);
		Collections.addAll(properties, propertyArray);
		return new SerializeExceptFilter(properties);
	}
=======
    /**
     * Factory method to construct filter that filters out all properties <b>except</b>
     * ones includes in set
     */
    public static SimpleBeanPropertyFilter filterOutAllExcept(Set<String> properties) {
        return new FilterExceptFilter(properties);
    }

    public static SimpleBeanPropertyFilter filterOutAllExcept(String... propertyArray) {
        HashSet<String> properties = new HashSet<String>(propertyArray.length);
        Collections.addAll(properties, propertyArray);
        return new FilterExceptFilter(properties);
    }

    public static SimpleBeanPropertyFilter serializeAllExcept(Set<String> properties) {
        return new SerializeExceptFilter(properties);
    }

    public static SimpleBeanPropertyFilter serializeAllExcept(String... propertyArray) {
        HashSet<String> properties = new HashSet<String>(propertyArray.length);
        Collections.addAll(properties, propertyArray);
        return new SerializeExceptFilter(properties);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
    /*
=======
    /*
    /**********************************************************
    /* Methods for sub-classes
    /**********************************************************
     */

    /**
     * Method called to determine whether property will be included
     * (if 'true' returned) or filtered out (if 'false' returned)
     */
    protected abstract boolean include(BeanPropertyWriter writer);

    public void serializeAsField(Object bean, JsonGenerator jgen,
            SerializerProvider provider, BeanPropertyWriter writer) throws Exception
    {
        if (include(writer)) {
            writer.serializeAsField(bean, jgen, provider);
        }
    }

    
    public void depositSchemaProperty(BeanPropertyWriter writer,
            ObjectNode propertiesNode, SerializerProvider provider)
        throws JsonMappingException
    {
        if (include(writer)) {
            writer.depositSchemaProperty(propertiesNode, provider);
        }
    }

    public void depositSchemaProperty(BeanPropertyWriter writer,
            JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)
        throws JsonMappingException
    {
        if (include(writer)) {
            writer.depositSchemaProperty(objectVisitor);
        }
    }
    
    /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_70c2de9_152c17d/rev_70c2de9-152c17d/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
     */

    /**
     * Filter implementation which defaults to filtering out unknown
     * properties and only serializes ones explicitly listed.
     */
    public static class FilterExceptFilter
        extends SimpleBeanPropertyFilter
    {
        // generated for 2.1.0
        private static final long serialVersionUID = -5409460444028386035L;

        /**
         * Set of property names to serialize.
         */
        protected final Set<String> _propertiesToInclude;

        public FilterExceptFilter(Set<String> properties) {
            _propertiesToInclude = properties;
        }

		public void serializeAsField(Object bean, JsonGenerator jgen,
				SerializerProvider provider, BeanPropertyWriter writer) throws Exception
		{
			if (_propertiesToInclude.contains(writer.getName())) {
				writer.serializeAsField(bean, jgen, provider);
			}
		}
		
		public void depositSchemaProperty(BeanPropertyWriter writer,
				ObjectNode propertiesNode, SerializerProvider provider) {
			if (_propertiesToInclude.contains(writer.getName())) {
				BeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);
			}
		}
		
		public void depositSchemaProperty(BeanPropertyWriter writer,
				JsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {
			if (_propertiesToInclude.contains(writer.getName())) {
				BeanSerializerBase.depositSchemaProperty(writer, objectVisitor);
			}
		}
    }

    /**
     * Filter implementation which defaults to serializing all
     * properties, except for ones explicitly listed to be filtered out.
     */
    public static class SerializeExceptFilter
        extends SimpleBeanPropertyFilter
    {
        // generated for 2.1.0
        private static final long serialVersionUID = 6654996217449646999L;

        /**
         * Set of property names to filter out.
         */
        protected final Set<String> _propertiesToExclude;

		public SerializeExceptFilter(Set<String> properties) {
			_propertiesToExclude = properties;
		}

		public void serializeAsField(Object bean, JsonGenerator jgen,
				SerializerProvider provider, BeanPropertyWriter writer) throws Exception
		{
			if (!_propertiesToExclude.contains(writer.getName())) {
				writer.serializeAsField(bean, jgen, provider);
			}
		}

		public void depositSchemaProperty(BeanPropertyWriter writer,
				ObjectNode propertiesNode, SerializerProvider provider) {
			if (!_propertiesToExclude.contains(writer.getName())) {
				BeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);
			}
		}
		
		public void depositSchemaProperty(BeanPropertyWriter writer,
				JsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {
			if (!_propertiesToExclude.contains(writer.getName())) {
				BeanSerializerBase.depositSchemaProperty(writer, objectVisitor);
			}
		}
    }
=======
     */

    /**
     * Filter implementation which defaults to filtering out unknown
     * properties and only serializes ones explicitly listed.
     */
    public static class FilterExceptFilter
        extends SimpleBeanPropertyFilter
    {
        /**
         * Set of property names to serialize.
         */
        protected final Set<String> _propertiesToInclude;

        public FilterExceptFilter(Set<String> properties) {
            _propertiesToInclude = properties;
        }

        @Override
        protected boolean include(BeanPropertyWriter writer) {
            return _propertiesToInclude.contains(writer.getName());
        }
    }

    /**
     * Filter implementation which defaults to serializing all
     * properties, except for ones explicitly listed to be filtered out.
     */
    public static class SerializeExceptFilter
        extends SimpleBeanPropertyFilter
    {
        /**
         * Set of property names to filter out.
         */
        protected final Set<String> _propertiesToExclude;

        public SerializeExceptFilter(Set<String> properties) {
            _propertiesToExclude = properties;
        }

        @Override
        protected boolean include(BeanPropertyWriter writer) {
            return !_propertiesToExclude.contains(writer.getName());
        }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f7ef407_8221fe1/rev_f7ef407-8221fe1/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java;<<<<<<< MINE
     * 
     * Feature is disabled by default
     * @since 2.4
=======
     * Feature is disabled by default.
     * 
     * @since 2.4
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7d0445b_184cae3/rev_7d0445b-184cae3/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.ObjectIdResolver;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7d0445b_184cae3/rev_7d0445b-184cae3/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_62425ef_fd0f1fe/rev_62425ef-fd0f1fe/src/test/java/com/fasterxml/jackson/databind/introspect/TestMixinMerging.java;<<<<<<< MINE
package com.fasterxml.jackson.databind.introspect;

import com.fasterxml.jackson.databind.BaseMapTest;

public class TestMixinMerging extends BaseMapTest
{
    // for [Issue#515]
    public void testDisappearingMixins515() throws Exception
    {
        // TBI
    }
}=======
package com.fasterxml.jackson.databind.introspect;

import com.fasterxml.jackson.annotation.JsonProperty;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.module.SimpleModule;

public class TestMixinMerging extends BaseMapTest
{
    public interface Contact {
        String getCity();
    }

    static class ContactImpl implements Contact {
        public String getCity() { return "Seattle"; }
    }

    static class ContactMixin implements Contact {
        @JsonProperty
        public String getCity() { return null; }
    }

    public interface Person extends Contact {}

    static class PersonImpl extends ContactImpl implements Person {}

    static class PersonMixin extends ContactMixin implements Person {}

    /*
    /**********************************************************
    /* Unit tests
    /**********************************************************
     */
    
    // for [Issue#515]
    public void testDisappearingMixins515() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)
            .disable(MapperFeature.AUTO_DETECT_FIELDS)
            .disable(MapperFeature.AUTO_DETECT_GETTERS)
            .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)
            .disable(MapperFeature.INFER_PROPERTY_MUTATORS);
        SimpleModule module = new SimpleModule("Test");
        module.setMixInAnnotation(Person.class, PersonMixin.class);        
        mapper.registerModule(module);

        assertEquals("{\"city\":\"Seattle\"}", mapper.writeValueAsString(new PersonImpl()));
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
        /* 15-Jan-2010, tatu: This should probably be rewritten, given that
         *    more information about content type is actually being explicitly
         *    passed. So there should be less need to try to re-process that
         *    information.
         */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
        JavaType contentType = null;
        if (typeHint != null) {
            JavaType javaType = provider.constructType(typeHint);
            contentType = javaType.getContentType();
            if (contentType == null) { // could still be parametrized (Iterators)
                if (typeHint instanceof ParameterizedType) {
                    Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();
                    if (typeArgs.length == 1) {
                        contentType = provider.constructType(typeArgs[0]);
                    }
                }
            }
        }
        if (contentType == null && _elementType != null) {
            contentType = _elementType;
        }
=======
        JavaType contentType = _elementType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
            TypeFactory tf = visitor.getProvider().getTypeFactory();
            JavaType contentType = tf.moreSpecificType(_elementType, typeHint.getContentType());
            if (contentType == null) {
                throw new JsonMappingException("Could not resolve type");
            }
=======
            /* 01-Sep-2014, tatu: Earlier was trying to make use of 'typeHint' for some
             *   reason, causing NPE (as per https://github.com/FasterXML/jackson-module-jsonSchema/issues/34)
             *   if coupled with `@JsonValue`. But I can't see much benefit of trying to rely
             *   on TypeHint here so code is simplified like so:
             */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
                valueSer = visitor.getProvider().findValueSerializer(contentType, _property);
=======
                valueSer = visitor.getProvider().findValueSerializer(_elementType, _property);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
            arrayVisitor.itemsFormat(valueSer, contentType);
=======
            arrayVisitor.itemsFormat(valueSer, _elementType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
            Class<?> serType = getRawSerializationType();
            if (serType == null) {
                serType = getPropertyType();
            }
            ser = provider.findValueSerializer(serType, this);
=======
            ser = provider.findValueSerializer(getType(), this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
    private static final long serialVersionUID = 278445030337366675L;
=======
    private static final long serialVersionUID = 1;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
                /* As per [Issue#305], need to provide contextual info. But for
=======
                /* As per [Databind#305], need to provide contextual info. But for
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
                    if (_defaultImpl == null) {
=======
                    deser = _findDefaultImplDeserializer(ctxt);
                    if (deser == null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
                    deser = _findDefaultImplDeserializer(ctxt);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
            if (_defaultImpl == null) {
=======
            deser = _findDefaultImplDeserializer(ctxt);
            if (deser == null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
            deser = _findDefaultImplDeserializer(ctxt);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
 * Basic serializer that can take Json "Object" structure and
=======
 * Basic serializer that can take JSON "Object" structure and
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
            } catch(UnresolvedForwardReference reference) {
=======
            } catch (UnresolvedForwardReference reference) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
=======
            } catch (Exception e) {
                wrapAndThrow(e, result, fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
=======
            } catch (Exception e) {
                wrapAndThrow(e, result, fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
                        wrapAndThrow(e, _mapType.getRawClass());
=======
                        wrapAndThrow(e, _mapType.getRawClass(), propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
            Object value;            
            if (t == JsonToken.VALUE_NULL) {
                value = valueDes.getNullValue();
            } else if (typeDeser == null) {
                value = valueDes.deserialize(jp, ctxt);
            } else {
                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);
=======
            Object value; 

            try {
                if (t == JsonToken.VALUE_NULL) {
                    value = valueDes.getNullValue();
                } else if (typeDeser == null) {
                    value = valueDes.deserialize(jp, ctxt);
                } else {
                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);
                }
            } catch (Exception e) {
                wrapAndThrow(e, _mapType.getRawClass(), propName);
                return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
            wrapAndThrow(e, _mapType.getRawClass());
=======
            wrapAndThrow(e, _mapType.getRawClass(), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
    @Deprecated // since 2.5
    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {
        wrapAndThrow(t, ref, null);
=======
    @Deprecated // since 2.5
    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {
        wrapAndThrow(t, ref, null);
    }
    
    // note: copied from BeanDeserializer; should try to share somehow...
    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException
    {
        // to handle StackOverflow:
        while (t instanceof InvocationTargetException && t.getCause() != null) {
            t = t.getCause();
        }
        // Errors and "plain" IOExceptions to be passed as is
        if (t instanceof Error) {
            throw (Error) t;
        }
        // ... except for mapping exceptions
        if (t instanceof IOException && !(t instanceof JsonMappingException)) {
            throw (IOException) t;
        }
        throw JsonMappingException.wrapWithPath(t, ref, key);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still
    //   not really robust
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                // [JACKSON-334]: may be missing milliseconds... if so, add
=======
                // Milliseconds partial or missing; and even seconds are optional
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                // '+0000' (5 chars); should come after '.000' (4 chars) of milliseconds, so:
                c = dateStr.charAt(len-9);
                if (Character.isDigit(c)) {
=======
                // remove 'T', '+'/'-' and 4-digit timezone-offset
                int timeLen = len - dateStr.lastIndexOf('T') - 6;
                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss
                    int offset = len - 5; // insertion offset, before tz-offset
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                    sb.insert(len-5, ".000");
=======
                    switch (timeLen) {
                    case 11:
                        sb.insert(offset, '0'); break;
                    case 10:
                        sb.insert(offset, "00"); break;
                    case 9: // is this legal? (just second fraction marker)
                        sb.insert(offset, "000"); break;
                    case 8:
                        sb.insert(offset, ".000"); break;
                    case 7: // not legal to have single-digit second
                        break;
                    case 6: // probably not legal, but let's allow
                        sb.insert(offset, "00.000");
                    case 5: // is legal to omit seconds
                        sb.insert(offset, ":00.000");
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                /* 24-Nov-2009, tatu: Ugh. This is getting pretty
                 *   ugly. Need to rewrite!
                 */

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                if (timeLen <= 8) {
                    sb.append(".000");
=======
                if (timeLen < 12) { // missing, or partial
                    switch (timeLen) {
                    case 11: sb.append('0');
                    case 10: sb.append('0');
                    case 9: sb.append('0');
                        break;
                    default:
                        sb.append(".000");
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java;<<<<<<< MINE
    private final Class<? extends ObjectIdResolver> _resolver;
=======
    protected final Class<? extends ObjectIdResolver> _resolver;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java;<<<<<<< MINE
        return new ObjectIdInfo(_propertyName, _scope, _generator, state);
=======
        return new ObjectIdInfo(_propertyName, _scope, _generator, state, _resolver);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
                // [Issue#541] ... but only as long as it's visible
                if (!node.isVisible) {
                    continue;
                }
                
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
            if ("true".equals(_value.trim())) {
=======
            String v = _value.trim();
            if ("true".equals(v)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
=======
            if ("false".equals(v)) {
                return false;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                        if (typeParams != null) {
=======
                        if (typeParams != null && typeParams.length > i) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java;<<<<<<< MINE
     * Feature is enabled by default.
=======
     * Feature is disabled by default.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.*;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
=======
    // For [Issue#541]
    static class Bean541 {
        protected String str;

        @JsonCreator
        public Bean541(@JsonProperty("str") String str) {
            this.str = str;
        }

        @JsonProperty("s")
        public String getStr() {
            return str;
        }
     }
     
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
=======

    public void testIssue541() throws Exception {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.disable(
                MapperFeature.AUTO_DETECT_CREATORS,
                MapperFeature.AUTO_DETECT_FIELDS,
                MapperFeature.AUTO_DETECT_GETTERS,
                MapperFeature.AUTO_DETECT_IS_GETTERS,
                MapperFeature.AUTO_DETECT_SETTERS,
                MapperFeature.USE_GETTERS_AS_SETTERS
        );
        Bean541 data = mapper.readValue("{\"str\":\"the string\"}", Bean541.class);
        if (data == null) {
            throw new IllegalStateException("data is null");
        }
        if (!"the string".equals(data.getStr())) {
            throw new IllegalStateException("bad value for data.str");
        }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======

        assertTrue(TextNode.valueOf("true").asBoolean(true));
        assertTrue(TextNode.valueOf("true").asBoolean(false));
        assertFalse(TextNode.valueOf("false").asBoolean(true));
        assertFalse(TextNode.valueOf("false").asBoolean(false));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java;<<<<<<< MINE
=======
    // [Databind#570]
    public void testISO8601PartialMilliseconds() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(2014, c.get(Calendar.YEAR));
        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));
        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(600, c.get(Calendar.MILLISECOND));

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(2014, c.get(Calendar.YEAR));
        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));
        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(0, c.get(Calendar.MINUTE));
        assertEquals(0, c.get(Calendar.SECOND));
        assertEquals(610, c.get(Calendar.MILLISECOND));

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(20, c.get(Calendar.MINUTE));
        assertEquals(30, c.get(Calendar.SECOND));
        assertEquals(450, c.get(Calendar.MILLISECOND));
    }

    public void testISO8601MissingSeconds() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    
        inputStr = "1997-07-16T19:20+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(0, c.get(Calendar.SECOND));
        assertEquals(0, c.get(Calendar.MILLISECOND));
}

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java;<<<<<<< MINE
        //    for #338 I thinl
=======
        //    for #338 I think
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java;<<<<<<< MINE
 * Unit tests related to [JACKSON-712]; specialized handling of
=======
 * Unit tests related to specialized handling of
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java;<<<<<<< MINE
    
=======

    // [Databind#511] types

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,
            include = JsonTypeInfo.As.WRAPPER_OBJECT)
    @JsonSubTypes(@JsonSubTypes.Type(name="sub1", value = BadSub1.class))
    public static class BadItem {}

    public static class BadSub1 extends BadItem {
        public String a ;
    }

    public static class Good {
        public List<GoodItem> many;
    }

    public static class Bad {
        public List<BadItem> many;
    }
 
    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,
            include = JsonTypeInfo.As.WRAPPER_OBJECT)
    @JsonSubTypes({@JsonSubTypes.Type(name="sub1", value = GoodSub1.class),
            @JsonSubTypes.Type(name="sub2", value = GoodSub2.class) })
    public static class GoodItem {}

    public static class GoodSub1 extends GoodItem {
        public String a ;
    }
    public static class GoodSub2 extends GoodItem {
        public String b ;

    }    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java;<<<<<<< MINE
    // [Issue#148]
=======
    // [Databind#148]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java;<<<<<<< MINE
    // [Issue#148]
=======
    // [Databind#148]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java;<<<<<<< MINE
=======

    // [Databind#511]
    public void testInvalidTypeId511() throws Exception {
        ObjectMapper mapper = new ObjectMapper().disable(
                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE,
                DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,
                DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES
        );
        String json = "{\"many\":[{\"sub1\":{\"a\":\"foo\"}},{\"sub2\":{\"b\":\"bar\"}}]}" ;
        Good goodResult = mapper.readValue(json, Good.class) ;
        assertNotNull(goodResult) ;
        Bad badResult = mapper.readValue(json, Bad.class);
        assertNotNull(badResult);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.TypeFactory;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java;<<<<<<< MINE
    // Beans for [JACKSON-387], [JACKSON-430]
=======
    static class WrappedContainerWithField {
        public ContainerWithField<?> animalContainer;
    }

	// Beans for [JACKSON-387], [JACKSON-430]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java;<<<<<<< MINE
=======
    // [Issue#543]
    static class ContainerWithTwoAnimals<U extends Animal,V extends Animal> extends ContainerWithField<U> {
         public V otherAnimal;
        
         public ContainerWithTwoAnimals(U a1, V a2) {
              super(a1);
              otherAnimal = a2;
         }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java;<<<<<<< MINE
=======
    private final ObjectMapper MAPPER = objectMapper();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java;<<<<<<< MINE
        String json = new ObjectMapper().writeValueAsString(new ContainerWithGetter<Animal>(dog));
=======
        String json = MAPPER.writeValueAsString(new ContainerWithGetter<Animal>(dog));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java;<<<<<<< MINE
        String json = new ObjectMapper().writeValueAsString(new ContainerWithField<Animal>(dog));
=======
        String json = MAPPER.writeValueAsString(new ContainerWithField<Animal>(dog));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java;<<<<<<< MINE
=======

    // [Issue#543]
    public void testValueWithMoreGenericParameters() throws Exception
    {
        WrappedContainerWithField wrappedContainerWithField = new WrappedContainerWithField();
        wrappedContainerWithField.animalContainer = new ContainerWithTwoAnimals<Dog,Dog>(new Dog("d1",1), new Dog("d2",2));
        String json = MAPPER.writeValueAsString(wrappedContainerWithField);
        assertNotNull(json);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonIdentityReference;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java;<<<<<<< MINE
=======
    @JsonIdentityReference(alwaysAsId = true) // #524
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_17ab26b_c271fbc/rev_17ab26b-c271fbc/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #setMixIns(Class, Class)}.
     */
    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {
        setMixIns(sourceMixins);
    }

    /**
     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.
=======
     * Method to use for adding mix-in annotations to use for augmenting
     * specified class or interface. All annotations from
     * <code>mixinSource</code> are taken to override annotations
     * that <code>target</code> (or its supertypes) has.
     *
     * @param target Class (or interface) whose annotations to effectively override
     * @param mixinSource Class (or interface) whose annotations are to
     *   be "added" to target's annotations, overriding as necessary
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_655d2a1_edf8674/rev_655d2a1-edf8674/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2a2ae59_d7a94ed/rev_2a2ae59-d7a94ed/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
            throw new IllegalStateException("Could not resolve Object Id ["+id+"] -- unresolved forward-reference?");
=======
            throw new UnresolvedForwardReference("Could not resolve Object Id ["+id+"] -- unresolved forward-reference?", jp.getCurrentLocation(), roid);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2a2ae59_d7a94ed/rev_2a2ae59-d7a94ed/src/test/java/com/fasterxml/jackson/databind/deser/TestForwardReference.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Test for testing forward reference handling
 */
public class TestForwardReference extends BaseMapTest {

	private final ObjectMapper MAPPER = new ObjectMapper()
			.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
			.enable(SerializationFeature.INDENT_OUTPUT)
			.setSerializationInclusion(JsonInclude.Include.NON_NULL);

	/** Tests that we can read a hierarchical structure with forward references*/
	public void testForwardRef() throws IOException {
		MAPPER.readValue("{" +
				"  \"@type\" : \"TestForwardReference$ForwardReferenceContainerClass\"," +
				"  \"frc\" : \"willBeForwardReferenced\"," +
				"  \"yac\" : {" +
				"    \"@type\" : \"TestForwardReference$YetAnotherClass\"," +
				"    \"frc\" : {" +
				"      \"@type\" : \"One\"," +
				"      \"id\" : \"willBeForwardReferenced\"" +
				"    }," +
				"    \"id\" : \"anId\"" +
				"  }," +
				"  \"id\" : \"ForwardReferenceContainerClass1\"" +
				"}", ForwardReferenceContainerClass.class);


	}

	@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include= JsonTypeInfo.As.PROPERTY)
	public static class ForwardReferenceContainerClass
	{
		public ForwardReferenceClass frc;
		public YetAnotherClass yac;
		public String id;
	}

	@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)
	@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id")
	@JsonSubTypes({
			@JsonSubTypes.Type(value = ForwardReferenceClassOne.class, name = "One"),
			@JsonSubTypes.Type(value = ForwardReferenceClassTwo.class, name = "Two")})
	private static abstract class ForwardReferenceClass
	{
		public String id;
		public void setId(String id) {
			this.id = id;
		}
	}

	@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)
	private static class YetAnotherClass
	{
		public YetAnotherClass() {}
		public ForwardReferenceClass frc;
		public String id;
	}

	public static class ForwardReferenceClassOne extends ForwardReferenceClass { }

	public static class ForwardReferenceClassTwo extends ForwardReferenceClass { }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_64319ad_87e4661/rev_64319ad-87e4661/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
=======
    /**
     * Turns out that these are expensive enough to create so that caching
     * does make sense.
     *<p>
     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is
     * a value type deserializer; this caused an issue with 2.4.4 of
     * JAXB Annotations (failing a test).
     * It is also possible that some other settings could make deserializers
     * un-cacheable; but on the other hand, caching can make a big positive
     * difference with performance... so it's a hard choice.
     * 
     * @since 2.4.4
     */
    @Override
    public boolean isCachable() {
        return (_valueTypeDeserializer == null) && (_ignorableProperties == null);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
=======
    @SuppressWarnings("unchecked")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
=======

        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization
         *    should always be called separately, from within "createContextual()".
         *    But this is a very singular deserializer since it operates on `Object`
         *    (and often for `?` type parameter), and as a result, easily and commonly
         *    results in cycles, being value deserializer for various Maps and Collections.
         *    Because of this, we must somehow break the cycles. This is done here by
         *    forcing pseudo-contextualization with null property.
         */

        // So: first find possible custom instances
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
=======

        // and then do bogus contextualization, in case custom ones need to resolve dependencies of
        // their own
        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null);
        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null);
        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null);
        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
    
=======

    /**
     * We only use contextualization for optimizing the case where no customization
     * occurred; if so, can slip in a more streamlined version.
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
        JsonDeserializer<?> mapDeserializer = _mapDeserializer;
        if (mapDeserializer instanceof ContextualDeserializer) {
            mapDeserializer = ((ContextualDeserializer)mapDeserializer).createContextual(ctxt, property);
        }
        JsonDeserializer<?> listDeserializer = _listDeserializer;
        if (listDeserializer instanceof ContextualDeserializer) {
            listDeserializer = ((ContextualDeserializer)listDeserializer).createContextual(ctxt, property);
        }
        JsonDeserializer<?> stringDeserializer = _stringDeserializer;
        if (stringDeserializer instanceof ContextualDeserializer) {
            stringDeserializer = ((ContextualDeserializer)stringDeserializer).createContextual(ctxt, property);
        }
        JsonDeserializer<?> numberDeserializer = _numberDeserializer;
        if (numberDeserializer instanceof ContextualDeserializer) {
            numberDeserializer = ((ContextualDeserializer)numberDeserializer).createContextual(ctxt, property);
        }

        // And if anything changed, we'll need to change too!
        if ((mapDeserializer != _mapDeserializer)
                || (listDeserializer != _listDeserializer)
                || (stringDeserializer != _stringDeserializer)
                || (numberDeserializer != _numberDeserializer)
                ) {
            return _withResolved(mapDeserializer, listDeserializer,
                    stringDeserializer, numberDeserializer);
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE

    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes
     *   sense to also mark this is cachable, since lookup not exactly free, and
     *   since it's not uncommon to "read anything"
     */
    @Override
    public boolean isCachable() { return true; }
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
 * Unit tests for verifying "old" data binding from JSON to JDK objects;
=======
 * Unit tests for verifying "raw" (or "untyped") data binding from JSON to JDK objects;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
=======
@SuppressWarnings("serial")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
    @SuppressWarnings("serial")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
        public String deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException
        {
=======
        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
    @SuppressWarnings("serial")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
        public Number deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException
        {
=======
        public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
    @SuppressWarnings("serial")
=======
    // Let's make this Contextual, to tease out cyclic resolution issues, if any
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
=======
        implements ContextualDeserializer
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
=======

        @Override
        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
                BeanProperty property) throws JsonMappingException
        {
            // For now, we just need to access "untyped" deserializer; not use it.
            
            /*JsonDeserializer<Object> ob = */
            ctxt.findContextualValueDeserializer(ctxt.constructType(Object.class), property);
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
    @SuppressWarnings("serial")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38573ad_3e0d5d8/rev_38573ad-3e0d5d8/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java;<<<<<<< MINE
=======
import java.util.Currency;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38573ad_3e0d5d8/rev_38573ad-3e0d5d8/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java;<<<<<<< MINE
=======
    public final static int TYPE_CURRENCY = 16;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38573ad_3e0d5d8/rev_38573ad-3e0d5d8/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java;<<<<<<< MINE
=======
        } else if (raw == Currency.class) {
            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);
            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38573ad_3e0d5d8/rev_38573ad-3e0d5d8/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java;<<<<<<< MINE

=======
        case TYPE_CURRENCY:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IOException e) {
                throw ctxt.weirdKeyException(_keyClass, key, "unable to parse key as currency");
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38573ad_3e0d5d8/rev_38573ad-3e0d5d8/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java;<<<<<<< MINE
=======
    public void testCurrencyKeyMap() throws Exception {
        Currency key = Currency.getInstance("USD");
        String JSON = "{ \"" + key + "\":4}";
        Map<Currency, Object> result = MAPPER.readValue(JSON, new TypeReference<Map<Currency, Object>>() {
        });
        assertNotNull(result);
        assertEquals(1, result.size());
        Object ob = result.keySet().iterator().next();
        assertNotNull(ob);
        assertEquals(Currency.class, ob.getClass());
        assertEquals(key, ob);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_1710240_00bb11e/rev_1710240-00bb11e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE

    // [databind#47]
    public void testMapJsonValueKey() throws Exception
    {
        WatMap input = new WatMap();
        input.put(new Wat("3"), true);

        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(input);
        assertEquals(aposToQuotes("{'3':true}"), json);
    }
=======

    public void testClassKey() throws IOException
    {
        Map<Class<?>,Integer> map = new LinkedHashMap<Class<?>,Integer>();
        map.put(String.class, 2);
        String json = MAPPER.writeValueAsString(map);
        assertEquals(aposToQuotes("{'java.lang.String':2}"), json);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_474c010_14d979d/rev_474c010-14d979d/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
import com.fasterxml.jackson.annotation.*;

=======
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
import com.fasterxml.jackson.annotation.JsonTypeName;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_474c010_14d979d/rev_474c010-14d979d/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // for [databind#47]
    public static class Wat
    {
        private final String wat;

        @JsonCreator
        Wat(String wat) {
            this.wat = wat;
        }

        @JsonValue
        public String getWat() {
            return wat;
        }

        @Override
        public String toString() {
            return "(String)[Wat: " + wat + "]";
        }
    }

    static class WatMap extends HashMap<Wat,Boolean> { }

=======
    // for [databind#691]
    @JsonTypeInfo(use=Id.NAME)
    @JsonTypeName("mymap")
    static class MapWithTypedValues extends LinkedHashMap<String,String> { }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7e507d1_e4ece74/rev_7e507d1-e4ece74/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
        _injectableValues = src._injectableValues;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7cf964a_195e9b5/rev_7cf964a-195e9b5/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                /* 18-Sep-2014, tatu: This is unfortunate patch over related change
                 *    that pushes creation of "unknown type" serializer deeper down
                 *    in BeanSerializerFactory; as a result, we need to "undo" creation
                 *    here.
                 */
                if (isUnknownTypeSerializer(ser)) {
                    return null;
                }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7cf964a_195e9b5/rev_7cf964a-195e9b5/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
=======
        /* 18-Sep-2014, tatu: This is unfortunate patch over related change
         *    that pushes creation of "unknown type" serializer deeper down
         *    in BeanSerializerFactory; as a result, we need to "undo" creation
         *    here.
         */
        if (isUnknownTypeSerializer(ser)) {
            return null;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_43f2f31_466f706/rev_43f2f31-466f706/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java;<<<<<<< MINE
import com.fasterxml.jackson.core.io.NumberOutput;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_dd955cf_66bfe66/rev_dd955cf-66bfe66/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
=======
import com.fasterxml.jackson.annotation.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_dd955cf_66bfe66/rev_dd955cf-66bfe66/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
import com.fasterxml.jackson.annotation.JsonTypeName;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6098024_7ff745c/rev_6098024-7ff745c/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java;<<<<<<< MINE
import com.fasterxml.jackson.core.io.NumberOutput;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6098024_7ff745c/rev_6098024-7ff745c/src/test/java/com/fasterxml/jackson/databind/deser/TestForwardReference.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import com.fasterxml.jackson.annotation.*;

import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

import java.io.IOException;

/**
 * Test for testing forward reference handling
 */
public class TestForwardReference extends BaseMapTest {

	private final ObjectMapper MAPPER = new ObjectMapper()
			.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
			.enable(SerializationFeature.INDENT_OUTPUT)
			.setSerializationInclusion(JsonInclude.Include.NON_NULL);

	/** Tests that we can read a hierarchical structure with forward references*/
	public void testForwardRef() throws IOException {
		MAPPER.readValue("{" +
				"  \"@type\" : \"TestForwardReference$ForwardReferenceContainerClass\"," +
				"  \"frc\" : \"willBeForwardReferenced\"," +
				"  \"yac\" : {" +
				"    \"@type\" : \"TestForwardReference$YetAnotherClass\"," +
				"    \"frc\" : {" +
				"      \"@type\" : \"One\"," +
				"      \"id\" : \"willBeForwardReferenced\"" +
				"    }," +
				"    \"id\" : \"anId\"" +
				"  }," +
				"  \"id\" : \"ForwardReferenceContainerClass1\"" +
				"}", ForwardReferenceContainerClass.class);


	}

	@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include= JsonTypeInfo.As.PROPERTY)
	public static class ForwardReferenceContainerClass
	{
		public ForwardReferenceClass frc;
		public YetAnotherClass yac;
		public String id;
	}

	@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)
	@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id")
	@JsonSubTypes({
			@JsonSubTypes.Type(value = ForwardReferenceClassOne.class, name = "One"),
			@JsonSubTypes.Type(value = ForwardReferenceClassTwo.class, name = "Two")})
	private static abstract class ForwardReferenceClass
	{
		public String id;
		public void setId(String id) {
			this.id = id;
		}
	}

	@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)
	static class YetAnotherClass
	{
		public YetAnotherClass() {}
		public ForwardReferenceClass frc;
		public String id;
	}

	public static class ForwardReferenceClassOne extends ForwardReferenceClass { }

	public static class ForwardReferenceClassTwo extends ForwardReferenceClass { }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7ed436a_841a1a7/rev_7ed436a-841a1a7/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonGenerationException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0f7f583_61c226c/rev_0f7f583-61c226c/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java;<<<<<<< MINE
=======
import java.util.Collection;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0f7f583_61c226c/rev_0f7f583-61c226c/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.deser.std.EnumDeserializer;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0f7f583_61c226c/rev_0f7f583-61c226c/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0f7f583_61c226c/rev_0f7f583-61c226c/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java;<<<<<<< MINE
    
=======

    // [Issue#745]
    static class DelegatingDeserializers extends Deserializers.Base
    {
        @Override
        public JsonDeserializer<?> findEnumDeserializer(final Class<?> type, final DeserializationConfig config, final BeanDescription beanDesc) throws JsonMappingException {
            final Collection<AnnotatedMethod> factoryMethods = beanDesc.getFactoryMethods();
            if (factoryMethods != null) {
                for (AnnotatedMethod am : factoryMethods) {
                    final JsonCreator creator = am.getAnnotation(JsonCreator.class);
                    if (creator != null) {
                        return EnumDeserializer.deserializerForCreator(config, type, am);
                    }
                }
            }
            return null;
        }
    }

    // [Issue#745]
    static class DelegatingDeserializersModule extends SimpleModule
    {
        @Override
        public void setupModule(final SetupContext context) {
            context.addDeserializers(new DelegatingDeserializers());
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0f7f583_61c226c/rev_0f7f583-61c226c/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java;<<<<<<< MINE
=======

    // [Issue#745]
    public void testDeserializerForCreatorWithEnumMaps() throws Exception
    {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new DelegatingDeserializersModule());
        EnumMap<EnumWithCreator,String> value = mapper.readValue("{\"enumA\":\"value\"}",
            new TypeReference<EnumMap<EnumWithCreator,String>>() {});
        assertEquals("value", value.get(EnumWithCreator.A));
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7785dff_0ec81c0/rev_7785dff-0ec81c0/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.struct;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.JsonIdentityReference;
import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import com.fasterxml.jackson.annotation.ObjectIdResolver;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.cfg.ContextAttributes;
import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;
import com.fasterxml.jackson.databind.deser.UnresolvedId;
import com.fasterxml.jackson.databind.struct.TestObjectId.Company;
import com.fasterxml.jackson.databind.struct.TestObjectId.Employee;

/**
 * Unit test to verify handling of Object Id deserialization
 */
public class TestObjectIdDeserialization extends BaseMapTest
{
    private static final String POOL_KEY = "POOL";

    // // Classes for external id use

    @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="id")
    static class Identifiable
    {
        public int value;

        public Identifiable next;

        public Identifiable() { this(0); }
        public Identifiable(int v) {
            value = v;
        }
    }

    @JsonIdentityInfo(generator=ObjectIdGenerators.UUIDGenerator.class, property="#")
    static class UUIDNode
    {
        public int value;
        public UUIDNode parent;
        public UUIDNode first;
        public UUIDNode second;

        public UUIDNode() { this(0); }
        public UUIDNode(int v) { value = v; }
    }

    // // Classes for external id from property annotations:

    static class IdWrapper
    {
        @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@id")
        public ValueNode node;

        public IdWrapper() { }
        public IdWrapper(int v) {
            node = new ValueNode(v);
        }
    }

    static class ValueNode {
        public int value;
        public IdWrapper next;
        
        public ValueNode() { this(0); }
        public ValueNode(int v) { value = v; }
    }

    // // Classes for external id use

    @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="customId")
    static class IdentifiableCustom
    {
        public int value;

        public int customId;
        
        public IdentifiableCustom next;
        
        public IdentifiableCustom() { this(-1, 0); }
        public IdentifiableCustom(int i, int v) {
            customId = i;
            value = v;
        }
    }

    static class IdWrapperExt
    {
        @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class,
        		property="customId")
        public ValueNodeExt node;

        public IdWrapperExt() { }
        public IdWrapperExt(int v) {
            node = new ValueNodeExt(v);
        }
    }

    static class ValueNodeExt
    {
        public int value;
        protected int customId;
        public IdWrapperExt next;
        
        public ValueNodeExt() { this(0); }
        public ValueNodeExt(int v) { value = v; }

        public void setCustomId(int i) {
        	customId = i;
        }
    }
    
    static class MappedCompany {
        public Map<Integer, Employee> employees;
    }

    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)
    static class AnySetterObjectId {
        protected Map<String, AnySetterObjectId> values = new HashMap<String, AnySetterObjectId>();

        @JsonAnySetter
        public void anySet(String field, AnySetterObjectId value) {
            // Ensure that it is never called with null because of unresolved reference.
            assertNotNull(value);
            values.put(field, value);
        }
    }

    static class CustomResolutionWrapper {
        public List<WithCustomResolution> data;
    }

    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id", resolver = PoolResolver.class)
    @JsonIdentityReference(alwaysAsId = true) // #524
    static class WithCustomResolution {
        public int id;
        public int data;

        public WithCustomResolution(int id, int data)
        {
            this.id = id;
            this.data = data;
        }
    }

    public static class PoolResolver implements ObjectIdResolver {
        private Map<Object,WithCustomResolution> _pool;

        public PoolResolver() {}
        public PoolResolver(Map<Object,WithCustomResolution> pool){ _pool = pool; }

        @Override
        public void bindItem(IdKey id, Object pojo){ }

        @Override
        public Object resolveId(IdKey id){ return _pool.get(id.key); }

        @Override
        public boolean canUseFor(ObjectIdResolver resolverType)
        {
            return resolverType.getClass() == getClass() && _pool != null && !_pool.isEmpty();
        }
        
        @Override
        public ObjectIdResolver newForDeserialization(Object c)
        {
            DeserializationContext context = (DeserializationContext)c;
            @SuppressWarnings("unchecked")
            Map<Object,WithCustomResolution> pool = (Map<Object,WithCustomResolution>)context.getAttribute(POOL_KEY);
            return new PoolResolver(pool);
        }
    }
    
    /*
    /*****************************************************
    /* Unit tests, external id deserialization
    /*****************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();
    
    private final static String EXP_SIMPLE_INT_CLASS = "{\"id\":1,\"value\":13,\"next\":1}";

    public void testSimpleDeserializationClass() throws Exception
    {
        // then bring back...
        Identifiable result = MAPPER.readValue(EXP_SIMPLE_INT_CLASS, Identifiable.class);
        assertEquals(13, result.value);
        assertSame(result, result.next);
    }

    // Should be ok NOT to have Object id, as well
    public void testMissingObjectId() throws Exception
    {
        Identifiable result = MAPPER.readValue(aposToQuotes("{'value':28, 'next':{'value':29}}"),
                Identifiable.class);
        assertNotNull(result);
        assertEquals(28, result.value);
        assertNotNull(result.next);
        assertEquals(29, result.next.value);
    }
    
    public void testSimpleUUIDForClassRoundTrip() throws Exception
    {
        UUIDNode root = new UUIDNode(1);
        UUIDNode child1 = new UUIDNode(2);
        UUIDNode child2 = new UUIDNode(3);
        root.first = child1;
        root.second = child2;
        child1.parent = root;
        child2.parent = root;
        child1.first = child2;

        String json = MAPPER.writeValueAsString(root);

        // and should come back the same too...
        UUIDNode result = MAPPER.readValue(json, UUIDNode.class);
        assertEquals(1, result.value);
        UUIDNode result2 = result.first;
        UUIDNode result3 = result.second;
        assertNotNull(result2);
        assertNotNull(result3);
        assertEquals(2, result2.value);
        assertEquals(3, result3.value);

        assertSame(result, result2.parent);
        assertSame(result, result3.parent);
        assertSame(result3, result2.first);
    }

    // Bit more complex, due to extra wrapping etc:
    private final static String EXP_SIMPLE_INT_PROP = "{\"node\":{\"@id\":1,\"value\":7,\"next\":{\"node\":1}}}";
        
    public void testSimpleDeserializationProperty() throws Exception
    {
        IdWrapper result = MAPPER.readValue(EXP_SIMPLE_INT_PROP, IdWrapper.class);
        assertEquals(7, result.node.value);
        assertSame(result.node, result.node.next.node);
    }

    // Another test to ensure ordering is not required (i.e. can do front references)
    public void testSimpleDeserWithForwardRefs() throws Exception
    {
        IdWrapper result = MAPPER.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}"
                ,IdWrapper.class);
        assertEquals(7, result.node.value);
        assertSame(result.node, result.node.next.node);
    }

    public void testForwardReference()
        throws Exception
    {
        String json = "{\"employees\":["
                      + "{\"id\":1,\"name\":\"First\",\"manager\":2,\"reports\":[]},"
                      + "{\"id\":2,\"name\":\"Second\",\"manager\":null,\"reports\":[1]}"
                      + "]}";
        Company company = MAPPER.readValue(json, Company.class);
        assertEquals(2, company.employees.size());
        Employee firstEmployee = company.employees.get(0);
        Employee secondEmployee = company.employees.get(1);
        assertEquals(1, firstEmployee.id);
        assertEquals(2, secondEmployee.id);
        assertEquals(secondEmployee, firstEmployee.manager); // Ensure that forward reference was properly resolved.
        assertEquals(firstEmployee, secondEmployee.reports.get(0)); // And that back reference is also properly resolved.
    }

    public void testForwardReferenceInCollection()
        throws Exception
    {
        String json = "{\"employees\":["
                      + "{\"id\":1,\"name\":\"First\",\"manager\":null,\"reports\":[2]},"
                      + "{\"id\":2,\"name\":\"Second\",\"manager\":1,\"reports\":[]}"
                      + "]}";
        Company company = MAPPER.readValue(json, Company.class);
        assertEquals(2, company.employees.size());
        Employee firstEmployee = company.employees.get(0);
        Employee secondEmployee = company.employees.get(1);
        assertEmployees(firstEmployee, secondEmployee);
    }

    public void testForwardReferenceInMap()
        throws Exception
    {
        String json = "{\"employees\":{"
                      + "\"1\":{\"id\":1,\"name\":\"First\",\"manager\":null,\"reports\":[2]},"
                      + "\"2\": 2,"
                      + "\"3\":{\"id\":2,\"name\":\"Second\",\"manager\":1,\"reports\":[]}"
                      + "}}";
        MappedCompany company = MAPPER.readValue(json, MappedCompany.class);
        assertEquals(3, company.employees.size());
        Employee firstEmployee = company.employees.get(1);
        Employee secondEmployee = company.employees.get(3);
        assertEmployees(firstEmployee, secondEmployee);
    }

    private void assertEmployees(Employee firstEmployee, Employee secondEmployee)
    {
        assertEquals(1, firstEmployee.id);
        assertEquals(2, secondEmployee.id);
        assertEquals(1, firstEmployee.reports.size());
        assertSame(secondEmployee, firstEmployee.reports.get(0)); // Ensure that forward reference was properly resolved and in order.
        assertSame(firstEmployee, secondEmployee.manager); // And that back reference is also properly resolved.
    }

    public void testForwardReferenceAnySetterCombo() throws Exception {
        String json = "{\"@id\":1, \"foo\":2, \"bar\":{\"@id\":2, \"foo\":1}}";
        AnySetterObjectId value = MAPPER.readValue(json, AnySetterObjectId.class);
        assertSame(value.values.get("bar"), value.values.get("foo"));
    }

    public void testUnresolvedForwardReference()
        throws Exception
    {
        String json = "{\"employees\":[" 
                      + "{\"id\":1,\"name\":\"First\",\"manager\":null,\"reports\":[3]},"
                      + "{\"id\":2,\"name\":\"Second\",\"manager\":3,\"reports\":[]}" 
                      + "]}";
        try {
            MAPPER.readValue(json, Company.class);
            fail("Should have thrown.");
        } catch (UnresolvedForwardReference exception) {
            // Expected
            List<UnresolvedId> unresolvedIds = exception.getUnresolvedIds();
            assertEquals(2, unresolvedIds.size());
            UnresolvedId firstUnresolvedId = unresolvedIds.get(0);
            assertEquals(3, firstUnresolvedId.getId());
            assertEquals(Employee.class, firstUnresolvedId.getType());
            UnresolvedId secondUnresolvedId = unresolvedIds.get(1);
            assertEquals(firstUnresolvedId.getId(), secondUnresolvedId.getId());
            assertEquals(Employee.class, secondUnresolvedId.getType());
        }
    }

    // [databind#299]: Allow unresolved ids to become nulls
    public void testUnresolvableAsNull() throws Exception
    {
        IdWrapper w = MAPPER.reader(IdWrapper.class)
                .without(DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS)
                .readValue(aposToQuotes("{'node':123}"));
        assertNotNull(w);
        assertNull(w.node);
    }

    public void testKeepCollectionOrdering() throws Exception
    {
        String json = "{\"employees\":[2,1,"
                + "{\"id\":1,\"name\":\"First\",\"manager\":null,\"reports\":[2]},"
                + "{\"id\":2,\"name\":\"Second\",\"manager\":1,\"reports\":[]}"
                + "]}";
        Company company = MAPPER.readValue(json, Company.class);
        assertEquals(4, company.employees.size());
        // Deser must keep object ordering.
        Employee firstEmployee = company.employees.get(1);
        Employee secondEmployee = company.employees.get(0);
        assertSame(firstEmployee, company.employees.get(2));
        assertSame(secondEmployee, company.employees.get(3));
        assertEmployees(firstEmployee, secondEmployee);
    }

    public void testKeepMapOrdering()
        throws Exception
    {
        String json = "{\"employees\":{"
                      + "\"1\":2, \"2\":1,"
                      + "\"3\":{\"id\":1,\"name\":\"First\",\"manager\":null,\"reports\":[2]},"
                      + "\"4\":{\"id\":2,\"name\":\"Second\",\"manager\":1,\"reports\":[]}"
                      + "}}";
        MappedCompany company = MAPPER.readValue(json, MappedCompany.class);
        assertEquals(4, company.employees.size());
        Employee firstEmployee = company.employees.get(2);
        Employee secondEmployee = company.employees.get(1);
        assertEmployees(firstEmployee, secondEmployee);
        // Deser must keep object ordering. Not sure if it's really important for maps,
        // but since default map is LinkedHashMap might as well ensure it does...
        Iterator<Entry<Integer,Employee>> iterator = company.employees.entrySet().iterator();
        assertSame(secondEmployee, iterator.next().getValue());
        assertSame(firstEmployee, iterator.next().getValue());
        assertSame(firstEmployee, iterator.next().getValue());
        assertSame(secondEmployee, iterator.next().getValue());
    }

    /*
    /*****************************************************
    /* Unit tests, custom (property-based) id deserialization
    /*****************************************************
     */

    private final static String EXP_CUSTOM_VIA_CLASS = "{\"customId\":123,\"value\":-900,\"next\":123}";

    public void testCustomDeserializationClass() throws Exception
    {
        // then bring back...
        IdentifiableCustom result = MAPPER.readValue(EXP_CUSTOM_VIA_CLASS, IdentifiableCustom.class);
        assertEquals(-900, result.value);
        assertSame(result, result.next);
    }

    private final static String EXP_CUSTOM_VIA_PROP = "{\"node\":{\"customId\":3,\"value\":99,\"next\":{\"node\":3}}}";
    
    public void testCustomDeserializationProperty() throws Exception
    {
        // then bring back...
        IdWrapperExt result = MAPPER.readValue(EXP_CUSTOM_VIA_PROP, IdWrapperExt.class);
        assertEquals(99, result.node.value);
        assertSame(result.node, result.node.next.node);
        assertEquals(3, result.node.customId);
    }

    /*
    /*****************************************************
    /* Unit tests, custom id resolver
    /*****************************************************
     */

    public void testCustomPoolResolver() throws Exception
    {
        Map<Object,WithCustomResolution> pool = new HashMap<Object,WithCustomResolution>();
        pool.put(1, new WithCustomResolution(1, 1));
        pool.put(2, new WithCustomResolution(2, 2));
        pool.put(3, new WithCustomResolution(3, 3));
        pool.put(4, new WithCustomResolution(4, 4));
        pool.put(5, new WithCustomResolution(5, 5));
        ContextAttributes attrs = MAPPER.getDeserializationConfig().getAttributes().withSharedAttribute(POOL_KEY, pool);
        String content = "{\"data\":[1,2,3,4,5]}";
        CustomResolutionWrapper wrapper = MAPPER.reader(CustomResolutionWrapper.class).with(attrs).readValue(content);
        assertFalse(wrapper.data.isEmpty());
        for (WithCustomResolution ob : wrapper.data) {
            assertSame(pool.get(ob.id), ob);
        }
    }

    /*
    /*****************************************************
    /* Unit tests, missing/null Object id [databind#742]
    /*****************************************************
     */

    /*
    private final static String EXP_SIMPLE_INT_CLASS = "{\"id\":1,\"value\":13,\"next\":1}";
    @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="id")
    static class Identifiable
    {
        public int value;

        public Identifiable next;
    }
    */

    public void testNullObjectId() throws Exception
    {
        // Ok, so missing Object Id is ok, but so is null.
        
        Identifiable value = MAPPER.readValue
                (aposToQuotes("{'value':3, 'next':null, 'id':null}"), Identifiable.class);
        assertNotNull(value);
        assertEquals(3, value.value);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_817a45a_85282b1/rev_817a45a-85282b1/src/test/java/com/fasterxml/jackson/databind/convert/TestUpdateValue.java;<<<<<<< MINE
=======
import java.io.IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_817a45a_85282b1/rev_817a45a-85282b1/src/test/java/com/fasterxml/jackson/databind/convert/TestUpdateValue.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.ObjectMapper;
=======
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.module.SimpleModule;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_817a45a_85282b1/rev_817a45a-85282b1/src/test/java/com/fasterxml/jackson/databind/convert/TestUpdateValue.java;<<<<<<< MINE
        
=======

    // for [databind#744]
    static class DataA {
        public int i = 1;
        public int j = 2;

    }

    static class DataB {
        public DataA da = new DataA();
        public int k = 3;
    }

    static class DataADeserializer extends StdDeserializer<DataA> {
        private static final long serialVersionUID = 1L;

        DataADeserializer() {
            super(DataA.class);
        }

        public DataA deserialize(JsonParser jp, DeserializationContext ctxt)
                throws JsonProcessingException, IOException {
            if (jp.getCurrentToken() != JsonToken.START_OBJECT) {
                throw ctxt.mappingException("Wrong current token, expected START_OBJECT, got: "
                        +jp.getCurrentToken());
            }
            /*JsonNode node =*/ jp.readValueAsTree();

            DataA da = new DataA();
            da.i = 5;
            return da;
        }
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_817a45a_85282b1/rev_817a45a-85282b1/src/test/java/com/fasterxml/jackson/databind/convert/TestUpdateValue.java;<<<<<<< MINE
=======

    // [databind#744]
    public void testIssue744() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule();
        module.addDeserializer(DataA.class, new DataADeserializer());
        mapper.registerModule(module);

        DataB db = new DataB();
        db.da.i = 11;
        db.k = 13;
        String jsonBString = mapper.writeValueAsString(db);
        JsonNode jsonBNode = mapper.valueToTree(db);

        // create parent
        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);
        assertEquals(5, dbNewViaString.da.i);
        assertEquals(13, dbNewViaString.k);

        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);
        assertEquals(5, dbNewViaNode.da.i);
        assertEquals(13, dbNewViaNode.k);

        // update parent
        DataB dbUpdViaString = new DataB();
        DataB dbUpdViaNode = new DataB();

        assertEquals(1, dbUpdViaString.da.i);
        assertEquals(3, dbUpdViaString.k);
        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);
        assertEquals(5, dbUpdViaString.da.i);
        assertEquals(13, dbUpdViaString.k);

        assertEquals(1, dbUpdViaNode.da.i);
        assertEquals(3, dbUpdViaNode.k);
        
        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);
        assertEquals(5, dbUpdViaNode.da.i);
        assertEquals(13, dbUpdViaNode.k);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java;<<<<<<< MINE
        if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) {
=======
        Class<?> rawValueType = valueType.getRawClass();
        if ((rawBuildType != rawValueType)
                && !rawBuildType.isAssignableFrom(rawValueType)
                && !rawValueType.isAssignableFrom(rawBuildType)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.JsonProcessingException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java;<<<<<<< MINE
        
	/*
=======

    // for [databind#761]

    @JsonDeserialize(builder=ValueInterfaceBuilder.class)
    interface ValueInterface {
        int getX();
    }

    @JsonDeserialize(builder=ValueInterface2Builder.class)
    interface ValueInterface2 {
        int getX();
    }
    
    static class ValueInterfaceImpl implements ValueInterface
    {
        final int _x;

        protected ValueInterfaceImpl(int x) {
            _x = x+1;
        }

        @Override
        public int getX() {
            return _x;
        }
    }

    static class ValueInterface2Impl implements ValueInterface2
    {
        final int _x;

        protected ValueInterface2Impl(int x) {
            _x = x+1;
        }

        @Override
        public int getX() {
            return _x;
        }
    }
    
    static class ValueInterfaceBuilder
    {
        public int x;

        public ValueInterfaceBuilder withX(int x0) {
            this.x = x0;
            return this;
        }

        public ValueInterface build() {
            return new ValueInterfaceImpl(x);
        }
    }

    static class ValueInterface2Builder
    {
        public int x;

        public ValueInterface2Builder withX(int x0) {
            this.x = x0;
            return this;
        }

        // should also be ok: more specific type
        public ValueInterface2Impl build() {
            return new ValueInterface2Impl(x);
        }
    }
    
    // for [databind#761]
    @JsonDeserialize(builder = ValueBuilderWrongBuildType.class)
    static class ValueClassWrongBuildType {
    }

    static class ValueBuilderWrongBuildType
    {
        public int x;

        public ValueBuilderWrongBuildType withX(int x0) {
            this.x = x0;
            return this;
        }

        public ValueClassXY build() {
            return null;
        }
    }

    /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java;<<<<<<< MINE
    	String json = "{\"x\":1,\"y\":2}";
    	Object o = mapper.readValue(json, ValueClassXY.class);
    	assertNotNull(o);
    	assertSame(ValueClassXY.class, o.getClass());
    	ValueClassXY value = (ValueClassXY) o;
    	// note: ctor adds one to both values
    	assertEquals(value._x, 2);
    	assertEquals(value._y, 3);
=======
        String json = "{\"x\":1,\"y\":2}";
        Object o = mapper.readValue(json, ValueClassXY.class);
        assertNotNull(o);
    	    assertSame(ValueClassXY.class, o.getClass());
    	    ValueClassXY value = (ValueClassXY) o;
    	    // note: ctor adds one to both values
    	    assertEquals(value._x, 2);
    	    assertEquals(value._y, 3);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java;<<<<<<< MINE
    	String json = "{\"c\":3,\"a\":2,\"b\":-9}";
    	ValueClassABC value = mapper.readValue(json, ValueClassABC.class);
    	assertNotNull(value);
    	// note: ctor adds one to both values
    	assertEquals(value.a, 2);
    	assertEquals(value.b, -9);
    	assertEquals(value.c, 3);
=======
        String json = "{\"c\":3,\"a\":2,\"b\":-9}";
        ValueClassABC value = mapper.readValue(json, ValueClassABC.class);
        assertNotNull(value);
    	    // note: ctor adds one to both values
        assertEquals(value.a, 2);
        assertEquals(value.b, -9);
        assertEquals(value.c, 3);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java;<<<<<<< MINE
=======

    // for [databind#761]
    
    public void testBuilderMethodReturnMoreGeneral() throws Exception
    {
        final String json = "{\"x\":1}";
        ValueInterface value = mapper.readValue(json, ValueInterface.class);
        assertEquals(2, value.getX());
    }

    public void testBuilderMethodReturnMoreSpecific() throws Exception
    {
        final String json = "{\"x\":1}";
        ValueInterface2 value = mapper.readValue(json, ValueInterface2.class);
        assertEquals(2, value.getX());
    }
    
    public void testBuilderMethodReturnInvalidType() throws Exception
    {
        final String json = "{\"x\":1}";
        try {
            mapper.readValue(json, ValueClassWrongBuildType.class);
            fail("Missing expected JsonProcessingException exception");
        } catch(JsonProcessingException e) {
            assertTrue(
                    "Exception cause must be IllegalArgumentException",
                    e.getCause() instanceof IllegalArgumentException);
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_54b2a5f_7d5c50b/rev_54b2a5f-7d5c50b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
        if (typeHint != null && stringVisitor != null) {
=======
        if (stringVisitor != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_54b2a5f_7d5c50b/rev_54b2a5f-7d5c50b/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java;<<<<<<< MINE
    public SerializableString serializedValueFor(Enum<?> key) {
        return _textual[key.ordinal()];
    }

    public Collection<SerializableString> values() {
        return Arrays.asList(_textual);
    }

    /**
     * Convenience accessor for getting raw Enum instances.
     * 
     * @since 2.6
     */
    public List<Enum<?>> enums() {
        return Arrays.asList(_values);
    }
=======
    /**
     * Convenience accessor for getting raw Enum instances.
     * 
     * @since 2.6
     */
    @SuppressWarnings("unchecked")
    public Collection<Enum<?>> enums() {
        return (Collection<Enum<?>>) _values.keySet();
    }

    public SerializableString serializedValueFor(Enum<?> key) { return _values.get(key); }
    public Collection<SerializableString> values() { return _values.values(); }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4ef389_7db1f44/rev_f4ef389-7db1f44/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    private final boolean _isAnnotationBundle(Annotation ann) {
        return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);
    }

=======
    private final boolean _isAnnotationBundle(Annotation ann) {
        return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);
    }

    /**
     * Helper method that gets methods declared in given class; usually a simple thing,
     * but sometimes (as per [databind#785]) more complicated, depending on classloader
     * setup.
     *
     * @since 2.4.7
     */
    protected Method[] _findClassMethods(Class<?> cls)
    {
        try {
            return cls.getDeclaredMethods();
        } catch (final NoClassDefFoundError ex) {
            // One of the methods had a class that was not found in the cls.getClassLoader.
            // Maybe the developer was nice and has a different class loader for this context.
            final ClassLoader loader = Thread.currentThread().getContextClassLoader();
            if(loader == null){
                // Nope... this is going to end poorly
                throw ex;
            }
            final Class<?> contextClass;
            try {
                contextClass = loader.loadClass(cls.getName());
            } catch (ClassNotFoundException e) {
                // !!! TODO: 08-May-2015, tatu: Chain appropriately once we have JDK7 as baseline
                //ex.addSuppressed(e); Not until 1.7
               throw ex;
            }
            return contextClass.getDeclaredMethods(); // Cross fingers
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_cb6dddd_f92a6b3/rev_cb6dddd-f92a6b3/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE

    // [databind#743]
    public void testRawValue() throws Exception
    {
        ObjectNode root = MAPPER.createObjectNode();
        root.putRawValue("a", new RawValue(new SerializedString("[1, 2, 3]")));

        assertEquals("{\"a\":[1, 2, 3]}", MAPPER.writeValueAsString(root));
    }

    // [databind#790]
    public void testCustomComparators() throws Exception
    {
        ObjectNode root1 = MAPPER.createObjectNode();
        root1.put("value", 5);
        ObjectNode root2 = MAPPER.createObjectNode();
        root2.put("value", 5.0);

        // default equals(): not strictly equal
        assertFalse(root1.equals(root2));
        assertFalse(root2.equals(root1));
        assertTrue(root1.equals(root1));
        assertTrue(root2.equals(root2));

        // but. Custom comparator can make all the difference
        Comparator<JsonNode> cmp = new Comparator<JsonNode>() {

            @Override
            public int compare(JsonNode o1, JsonNode o2) {
                if (o1.equals(o2)) {
                    return 0;
                }
                if ((o1 instanceof NumericNode) && (o2 instanceof NumericNode)) {
                    double d1 = ((NumericNode) o1).asDouble();
                    double d2 = ((NumericNode) o2).asDouble();
                    if (d1 == d2) { // strictly equals because it's integral value
                        return 0;
                    }
                }
                return 0;
            }
        };
        assertTrue(root1.equals(cmp, root2));
        assertTrue(root2.equals(cmp, root1));
        assertTrue(root1.equals(cmp, root1));
        assertTrue(root2.equals(cmp, root2));
    }
=======

    // [databind#793]
    public void testArrayWithDefaultTyping() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .enableDefaultTyping();

        JsonNode array = mapper.readTree("[ 1, 2 ]");
        assertTrue(array.isArray());
        assertEquals(2, array.size());

        JsonNode obj = mapper.readTree("{ \"a\" : 2 }");
        assertTrue(obj.isObject());
        assertEquals(1, obj.size());
        assertEquals(2, obj.path("a").asInt());
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
     * values for creator method need to be buffered, first; and 
=======
     * values for creator method need to be buffered, first; and
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    protected Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt,
            SettableBeanProperty prop)
        throws IOException
    {
        try {
            return prop.deserialize(p, ctxt);
        } catch (Exception e) {
            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);
            // never gets here, unless caller returns
            return null;
        }
    }

=======
    protected Object deserializeWithErrorWrapping(SettableBeanProperty creatorProp, JsonParser p, DeserializationContext ctxt,
                                                  String propName)
            throws IOException {
        try {
            return creatorProp.deserialize(p, ctxt);
        } catch (IOException e) {
            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
            // exception below will be throw only if someone overwrite default implementation of wrapAndThrow method
            throw e;
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            handleUnknownProperty(p, ctxt, bean, propName);         
=======
            handleUnknownProperty(p, ctxt, bean, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandlingWithDefaultDeserialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;

public class TestExceptionHandlingWithDefaultDeserialization extends BaseMapTest {

    static class Foo {

        private Bar bar;

        public Foo() {
        }

        public Bar getBar() {
            return bar;
        }
    }

    static class Bar {

        private Baz baz;

        public Bar() {
        }

        public Baz getBaz() {
            return baz;
        }
    }

    static class Baz {

        private String qux;

        public Baz() {
        }

        public String getQux() {
            return qux;
        }
    }

    public void testShouldThrowJsonMappingExceptionWithPathReference() throws IOException {
        // given
        ObjectMapper mapper = new ObjectMapper();
        String input = "{\"bar\":{\"baz\":{qux:\"quxValue\"))}";

        // when
        try {
            mapper.readValue(input, Foo.class);
            fail("Upsss! Exception has not been thrown.");
        } catch (JsonMappingException ex) {
            // then
            assertEquals("com.fasterxml.jackson.databind.deser.Foo[\"bar\"]->com.fasterxml.jackson.databind.deser.Bar[\"baz\"]",
                    ex.getPathReference());
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2abf5a3_5f09320/rev_2abf5a3-5f09320/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandlingWithJsonCreatorDeserialization.java;<<<<<<< MINE
package com.fasterxml.jackson.databind.deser;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;

public class TestExceptionHandlingWithJsonCreatorDeserialization extends BaseMapTest {

    static class Foo {

        private Bar bar;

        @JsonCreator
        public Foo(@JsonProperty("bar") Bar bar) {
            this.bar = bar;
        }

        public Bar getBar() {
            return bar;
        }
    }

    static class Bar {

        private Baz baz;

        @JsonCreator
        public Bar(@JsonProperty("baz") Baz baz) {
            this.baz = baz;
        }

        public Baz getBaz() {
            return baz;
        }
    }


    static class Baz {

        private String qux;

        @JsonCreator
        public Baz(@JsonProperty("qux") String qux) {
            this.qux = qux;
        }

        public String getQux() {
            return qux;
        }
    }

    public void testShouldThrowJsonMappingExceptionWithPathReference() throws IOException {
        // given
        ObjectMapper mapper = new ObjectMapper();
        String input = "{\"bar\":{\"baz\":{qux:\"quxValue\"))}";

        // when
        try {
            mapper.readValue(input, Foo.class);
            fail("Upsss! Exception has not been thrown.");
        } catch (JsonMappingException ex) {
            // then
            assertEquals("com.fasterxml.jackson.databind.deser.Foo[\"bar\"]->com.fasterxml.jackson.databind.deser.Bar[\"baz\"]",
                    ex.getPathReference());
        }
    }
}=======
package com.fasterxml.jackson.databind.deser;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;

public class TestExceptionHandlingWithJsonCreatorDeserialization extends BaseMapTest {

    static class Foo {

        private Bar bar;

        @JsonCreator
        public Foo(@JsonProperty("bar") Bar bar) {
            this.bar = bar;
        }

        public Bar getBar() {
            return bar;
        }
    }

    static class Bar {

        private Baz baz;

        @JsonCreator
        public Bar(@JsonProperty("baz") Baz baz) {
            this.baz = baz;
        }

        public Baz getBaz() {
            return baz;
        }
    }

    static class Baz {

        private String qux;

        @JsonCreator
        public Baz(@JsonProperty("qux") String qux) {
            this.qux = qux;
        }

        public String getQux() {
            return qux;
        }
    }

    public void testShouldThrowJsonMappingExceptionWithPathReference() throws IOException {
        // given
        ObjectMapper mapper = new ObjectMapper();
        String input = "{\"bar\":{\"baz\":{qux:\"quxValue\"))}";

        // when
        try {
            mapper.readValue(input, Foo.class);
            fail("Upsss! Exception has not been thrown.");
        } catch (JsonMappingException ex) {
            // then
            assertEquals("com.fasterxml.jackson.databind.deser.Foo[\"bar\"]->com.fasterxml.jackson.databind.deser.Bar[\"baz\"]",
                    ex.getPathReference());
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6172d75_726b6e0/rev_6172d75-726b6e0/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
    protected Object _deserializeWithErrorWrapping(JsonParser p, DeserializationContext ctxt,
            SettableBeanProperty prop)
        throws IOException
    {
=======
    protected Object deserializeWithErrorWrapping(SettableBeanProperty prop,
            JsonParser p, DeserializationContext ctxt, String propName) throws IOException
    {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6172d75_726b6e0/rev_6172d75-726b6e0/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            return prop.deserialize(p, ctxt);
        } catch (Exception e) {
            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);
            // never gets here, unless caller returns
            return null;
=======
            return prop.deserialize(p, ctxt);
        } catch (IOException e) {
            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
            // exception below will be throw only if someone overwrite default implementation of wrapAndThrow method
            throw e;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_945c545_a23ff9f/rev_945c545-a23ff9f/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e5b8ff1_5183922/rev_e5b8ff1-5183922/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
=======
    public MappingJsonFactory(JsonFactory src, ObjectMapper mapper)
    {
        super(src, mapper);
        if (mapper == null) {
          setCodec(new ObjectMapper(this));
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e5b8ff1_5183922/rev_e5b8ff1-5183922/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
        return new MappingJsonFactory(null);
=======
        return new MappingJsonFactory(this, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e5b8ff1_5183922/rev_e5b8ff1-5183922/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
=======
        assertFalse(m.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
        m.enable(JsonParser.Feature.ALLOW_COMMENTS);
        assertTrue(m.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e5b8ff1_5183922/rev_e5b8ff1-5183922/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
=======

        // [Issue#913]: Ensure JsonFactory Features copied
        assertTrue(m2.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_313a713_d21210b/rev_313a713-d21210b/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java;<<<<<<< MINE
=======

    @Override
    public int hashCode() {
        return 0;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_313a713_d21210b/rev_313a713-d21210b/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java;<<<<<<< MINE
=======
    @Override public abstract int hashCode();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_313a713_d21210b/rev_313a713-d21210b/src/main/java/com/fasterxml/jackson/databind/node/BooleanNode.java;<<<<<<< MINE
=======
    public int hashCode() {
        return Boolean.valueOf(_value).hashCode();
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_313a713_d21210b/rev_313a713-d21210b/src/main/java/com/fasterxml/jackson/databind/node/NullNode.java;<<<<<<< MINE
=======

    @Override
    public int hashCode() {
        return 0;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
=======
        Class<?> enumClass = type.getRawClass();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());
=======
        // 24-Sep-2015, bim: a key deserializer is the preferred thing.
        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);
        }
        Class<?> enumClass = type.getRawClass();
        // 23-Nov-2010, tatu: Custom deserializer?
        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);
        if (custom != null) {
            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);
=======
            return des;
        } else {
            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.
            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);
            if (custom != null) {
                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);
            }
            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());
            if (valueDesForKey != null) {
                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
=======
     * Helper method called to check if a class or method
     * has annotation that tells which class to use for deserialization.
     * Returns null if no such annotation found.
     */
    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt,
                                                                      Annotated ann)
            throws JsonMappingException
    {
        Object deserDef = ctxt.getAnnotationIntrospector().findKeyDeserializer(ann);
        if (deserDef == null) {
            return null;
        }
        return ctxt.keyDeserializerInstance(ann, deserDef);
    }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/KeyEnum.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.module.customenumkey;

/**
 */
public enum KeyEnum {
    replacements,
    rootDirectory,
    licenseString
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/TestEnumModule.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.module.customenumkey;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.module.SimpleSerializers;

public class TestEnumModule extends SimpleModule {

    public TestEnumModule() {
        super(ModuleVersion.VERSION);
    }

    public void setupModule(SetupContext context) {
        context.setMixInAnnotations(TestEnum.class, TestEnumMixin.class);
        SimpleSerializers keySerializers = new SimpleSerializers();
        keySerializers.addSerializer(new TestEnumKeySerializer());
        context.addKeySerializers(keySerializers);
    }

    public static ObjectMapper setupObjectMapper(ObjectMapper mapper) {
        final TestEnumModule module = new TestEnumModule();
        mapper.registerModule(module);
        return mapper;
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/TestEnumDeserializer.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.module.customenumkey;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;

import java.io.IOException;

/**
 *
 */
public class TestEnumDeserializer extends StdDeserializer<TestEnum> {

    public TestEnumDeserializer() {
        super(TestEnum.class);
    }

    @Override
    public TestEnum deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
        String code = jp.getText();
        try {
            return TestEnum.lookup(code);
        } catch (IllegalArgumentException e) {
            throw new InvalidFormatException("Undefined ISO-639 language code", jp.getCurrentLocation(), code, TestEnum.class);
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/Bean.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.module.customenumkey;

import java.io.File;
import java.util.Map;

/**
 *
 */
public class Bean {
    private File rootDirectory;
    private String licenseString;
    private Map<TestEnum, Map<String, String>> replacements;

    public File getRootDirectory() {
        return rootDirectory;
    }

    public void setRootDirectory(File rootDirectory) {
        this.rootDirectory = rootDirectory;
    }

    public String getLicenseString() {
        return licenseString;
    }

    public void setLicenseString(String licenseString) {
        this.licenseString = licenseString;
    }

    public Map<TestEnum, Map<String, String>> getReplacements() {
        return replacements;
    }

    public void setReplacements(Map<TestEnum, Map<String, String>> replacements) {
        this.replacements = replacements;
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/TestEnumKeySerializer.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.module.customenumkey;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;

import java.io.IOException;

/**
 * Jackson serializer for LanguageCode used as a key.
 */
public class TestEnumKeySerializer extends JsonSerializer<TestEnum> {
    @Override
    public void serialize(TestEnum test, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeFieldName(test.code());
    }

    @Override
    public Class<TestEnum> handledType() {
        return TestEnum.class;
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/TestEnumKeyDeserializer.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.module.customenumkey;

import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.KeyDeserializer;

import java.io.IOException;

/**
 *
 */
public class TestEnumKeyDeserializer extends KeyDeserializer {
    @Override
    public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
        try {
            return TestEnum.lookup(key);
        } catch (IllegalArgumentException e) {
            throw ctxt.weirdKeyException(TestEnum.class, key, "Unknown code");
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/TestEnum.java;<<<<<<< MINE
=======
/******************************************************************************
 * * This data and information is proprietary to, and a valuable trade secret
 * * of, Basis Technology Corp.  It is given in confidence by Basis Technology
 * * and may only be used as permitted under the license agreement under which
 * * it has been distributed, and in no other way.
 * *
 * * Copyright (c) 2015 Basis Technology Corporation All rights reserved.
 * *
 * * The technical data and information provided herein are provided with
 * * `limited rights', and the computer software provided herein is provided
 * * with `restricted rights' as those terms are defined in DAR and ASPR
 * * 7-104.9(a).
 ******************************************************************************/

package com.fasterxml.jackson.databind.module.customenumkey;

/**
 *
 */
public enum TestEnum {
    RED("red"),
    GREEN("green");

    private final String code;

    TestEnum(String code) {
        this.code = code;
    }

    public static TestEnum lookup(String lower) {
        for (TestEnum item : values()) {
            if (item.code().equals(lower)) {
                return item;
            }
        }
        throw new IllegalArgumentException("Invalid code " + lower);
        }

    public String code() {
        return code;
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/TestEnumSerializer.java;<<<<<<< MINE
=======
/******************************************************************************
 ** This data and information is proprietary to, and a valuable trade secret
 ** of, Basis Technology Corp.  It is given in confidence by Basis Technology
 ** and may only be used as permitted under the license agreement under which
 ** it has been distributed, and in no other way.
 **
 ** Copyright (c) 2014 Basis Technology Corporation All rights reserved.
 **
 ** The technical data and information provided herein are provided with
 ** `limited rights', and the computer software provided herein is provided
 ** with `restricted rights' as those terms are defined in DAR and ASPR
 ** 7-104.9(a).
 ******************************************************************************/

package com.fasterxml.jackson.databind.module.customenumkey;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;

import java.io.IOException;

/**
 * Jackson serializer for LanguageCode.
 */
public class TestEnumSerializer extends JsonSerializer<TestEnum> {
    @Override
    public void serialize(TestEnum languageCode, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeString(languageCode.code());
    }

    @Override
    public Class<TestEnum> handledType() {
        return TestEnum.class;
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/customenumkey/ModuleVersion.java;<<<<<<< MINE
=======
/******************************************************************************
 ** This data and information is proprietary to, and a valuable trade secret
 ** of, Basis Technology Corp.  It is given in confidence by Basis Technology
 ** and may only be used as permitted under the license agreement under which
 ** it has been distributed, and in no other way.
 **
 ** Copyright (c) 2014 Basis Technology Corporation All rights reserved.
 **
 ** The technical data and information provided herein are provided with
 ** `limited rights', and the computer software provided herein is provided
 ** with `restricted rights' as those terms are defined in DAR and ASPR
 ** 7-104.9(a).
 ******************************************************************************/

package com.fasterxml.jackson.databind.module.customenumkey;

import com.fasterxml.jackson.core.Version;

/**
 * Common class to set up Jackson version from property.
 */
final class ModuleVersion {
    static final Version VERSION = new Version(0, 0, 0, "", "", "");

    private ModuleVersion() {
        //
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f4f71b9_2eafcdf/rev_f4f71b9-2eafcdf/src/test/java/com/fasterxml/jackson/databind/module/TestCustomKeyDeserializer.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.module;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.customenumkey.KeyEnum;
import com.fasterxml.jackson.databind.module.customenumkey.TestEnum;
import com.fasterxml.jackson.databind.module.customenumkey.TestEnumModule;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.common.collect.Maps;
import com.google.common.io.Resources;
import org.junit.Ignore;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.util.Map;
import java.util.Set;

import static junit.framework.TestCase.assertNotNull;
import static org.junit.Assert.assertEquals;

/**
 *
 */
public class TestCustomKeyDeserializer {
    @Test
    public void troubleWithKeys() throws Exception {
        ObjectMapper plainObjectMapper = new ObjectMapper();
        JsonNode tree = plainObjectMapper.readTree(Resources.getResource("data/enum-custom-key-test.json"));
        ObjectMapper fancyObjectMapper = TestEnumModule.setupObjectMapper(new ObjectMapper());
        // this line is might throw with Jackson 2.6.2.
        Map<TestEnum, Set<String>> map = fancyObjectMapper.convertValue(tree, new TypeReference<Map<TestEnum, Set<String>>>() {
        });
        assertNotNull(map);
    }

    @Ignore("issue 749, more or less")
    @Test
    public void tree() throws Exception {

        Map<KeyEnum, Object> inputMap = Maps.newHashMap();
        Map<TestEnum, Map<String, String>> replacements = Maps.newHashMap();
        Map<String, String> reps = Maps.newHashMap();
        reps.put("1", "one");
        replacements.put(TestEnum.GREEN, reps);
        inputMap.put(KeyEnum.replacements, replacements);
        ObjectMapper mapper = TestEnumModule.setupObjectMapper(new ObjectMapper());
        JsonNode tree = mapper.valueToTree(inputMap);
        ObjectNode ob = (ObjectNode) tree;
        JsonNode inner = ob.get("replacements");
        String firstFieldName = inner.fieldNames().next();
        assertEquals("green", firstFieldName);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_90da5db_2a9808c/rev_90da5db-2a9808c/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6c1badb_795dd01/rev_6c1badb-795dd01/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
                throw new NumberFormatException("Invalid number: " + value);
=======
                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6c1badb_795dd01/rev_6c1badb-795dd01/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
                throw new NumberFormatException("Invalid number: " + value);
=======
                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_321562a_6aaa38b/rev_321562a-6aaa38b/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE

    static class ExplicitBean {
      @JsonProperty("firstName")
      String userFirstName = "Peter";
      @JsonProperty("lastName")
      String userLastName = "Venkman";
      @JsonProperty
      String userAge = "35";
    }

    public void testExplicitRename() throws Exception {
      ObjectMapper m = new ObjectMapper();
      m.setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);
      m.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
      // by default, renaming will not take place on explicitly named fields
      assertEquals(aposToQuotes("{'firstName':'Peter','lastName':'Venkman','user_age':'35'}"),
          m.writeValueAsString(new ExplicitBean()));

      m = new ObjectMapper();
      m.setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);
      m.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
      m.enable(MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING);
      // w/ feature enabled, ALL property names should get re-written
      assertEquals(aposToQuotes("{'first_name':'Peter','last_name':'Venkman','user_age':'35'}"),
          m.writeValueAsString(new ExplicitBean()));

      // test deserialization as well
      ExplicitBean bean =
          m.readValue(aposToQuotes("{'first_name':'Egon','last_name':'Spengler','user_age':'32'}"),
              ExplicitBean.class);

      assertNotNull(bean);
      assertEquals("Egon", bean.userFirstName);
      assertEquals("Spengler", bean.userLastName);
      assertEquals("32", bean.userAge);

    }
=======

    // Also verify that "no naming strategy" should be ok
    public void testExplicitNoNaming() throws Exception
    {
        ObjectMapper mapper = objectMapper();
        String json = mapper.writeValueAsString(new DefaultNaming());
        assertEquals(aposToQuotes("{'someValue':3}"), json);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f75f2bf_660ec8f/rev_f75f2bf-660ec8f/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
            return PropertyName.construct(jg.value());
        }
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            return PropertyName.construct(pann.value());
        }
        PropertyName ctorName = _findConstructorName(a);
        if (ctorName != null) {
            return ctorName;
        }
        if (_hasAnnotation(a, JsonSerialize.class)
                || _hasAnnotation(a, JsonView.class)
                || _hasAnnotation(a, JsonRawValue.class)) {
            return PropertyName.USE_DEFAULT;
=======
            name = jg.value();
        } else {
            JsonProperty pann = _findAnnotation(a, JsonProperty.class);
            if (pann != null) {
                name = pann.value();
                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but
                 *   it's actually bit tricky to do it more efficiently (meta-annotations
                 *   add more lookups; AnnotationMap costs etc)
                 */
            } else if (_hasAnnotation(a, JsonSerialize.class)
                    || _hasAnnotation(a, JsonView.class)
                    || _hasAnnotation(a, JsonRawValue.class)
                    || _hasAnnotation(a, JsonUnwrapped.class)
                    || _hasAnnotation(a, JsonBackReference.class)
                    || _hasAnnotation(a, JsonManagedReference.class)) {
                name = "";
            } else {
                return null;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_be11363_c966a03/rev_be11363-c966a03/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
=======
        if (_delegateDeserializer != null) {
            /* 24-Nov-2015, tatu: Use of delegating creator needs to have precedence, and basically
             *   external type id handling just has to be ignored, as they would relate to target
             *   type and not delegate type. Whether this works as expected is another story, but
             *   there's no other way to really mix these conflicting features.
             */
            return _valueInstantiator.createUsingDelegate(ctxt,
                    _delegateDeserializer.deserialize(p, ctxt));
        }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    // [JACKSON-799] stuff:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
=======
    static class FooImplNoAnno implements Fooable {
        @Override
        public int getFoo() { return 42; }
        public int getBar() { return 15; }
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    // Also test via Field
    static class FooableWithFieldWrapper {
        @JsonSerialize(as=Fooable.class)
        public FooImplNoAnno getFoo() {
            return new FooImplNoAnno();
        }
    }
    
=======
    // Also test via Field
    static class FooableWithFieldWrapper {
        @JsonSerialize(as=Fooable.class)
        public Fooable getFoo() {
            return new FooImplNoAnno();
        }
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    // [JACKSON-799]
    public void testSerializeAsInClass() throws IOException
    {
=======
    public void testSerializeAsInClass() throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    public void testSerializeAsForArrayProp() throws IOException
    {
        assertEquals("{\"foos\":[{\"foo\":42}]}", WRITER.writeValueAsString(new Fooables()));
=======
    public void testSerializeAsForArrayProp() throws IOException {
        assertEquals("{\"foos\":[{\"foo\":42}]}",
                WRITER.writeValueAsString(new Fooables()));
    }

    public void testSerializeAsForSimpleProp() throws IOException {
        assertEquals("{\"foo\":{\"foo\":42}}",
                WRITER.writeValueAsString(new FooableWrapper()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    public void testSerializeAsForSimpleProp() throws IOException
    {
        assertEquals("{\"foo\":{\"foo\":42}}", WRITER.writeValueAsString(new FooableWrapper()));
=======
    public void testSerializeWithFieldAnno() throws IOException {
        assertEquals("{\"foo\":{\"foo\":42}}",
                WRITER.writeValueAsString(new FooableWithFieldWrapper()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        AnnotationMap ca = new AnnotationMap();
        // Should skip processing if annotation processing disabled
=======
        AnnotationMap ca = new AnnotationMap();
        // [JACKSON-659] Should skip processing if annotation processing disabled
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);
=======
                _addClassMixIns(ca, _class, _primaryMixIn);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            _addAnnotationsIfNotPresent(ca,
                    ClassUtil.findClassAnnotations(_class));
=======
            _addAnnotationsIfNotPresent(ca, _class.getDeclaredAnnotations());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                _addClassMixIns(ca, type);
                _addAnnotationsIfNotPresent(ca,
                        ClassUtil.findClassAnnotations(type.getRawClass()));
=======
                _addClassMixIns(ca, cls);
                _addAnnotationsIfNotPresent(ca, cls.getDeclaredAnnotations());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            _addClassMixIns(_classAnnotations, Object.class);
=======
            _addClassMixIns(ca, Object.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8caf290_ccf82e8/rev_8caf290-ccf82e8/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return ca;
=======
        _classAnnotations = ca;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_86c3652_8716072/rev_86c3652-8716072/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE

    // for [databind#898]
    public void testSerializerProviderAccess() throws Exception
    {
        // ensure we have "fresh" instance, just in case
        ObjectMapper mapper = new ObjectMapper();
        JsonSerializer<?> ser = mapper.getSerializerProviderInstance()
                .findValueSerializer(Bean.class);
        assertNotNull(ser);
        assertEquals(Bean.class, ser.handledType());
    }
=======

    // for [databind#1074]
    public void testCopyOfParserFeatures() throws Exception
    {
        // ensure we have "fresh" instance to start with
        ObjectMapper mapper = new ObjectMapper();
        assertFalse(mapper.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
        assertTrue(mapper.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));

        ObjectMapper copy = mapper.copy();
        assertTrue(copy.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));

        // also verify there's no back-linkage
        copy.configure(JsonParser.Feature.ALLOW_COMMENTS, false);
        assertFalse(copy.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
        assertTrue(mapper.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8716072_70d961b/rev_8716072-70d961b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.ser;

import java.io.*;
import java.text.*;
import java.util.*;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.*;

public class TestDateSerialization
    extends BaseMapTest
{
    static class TimeZoneBean {
        private TimeZone tz;
        
        public TimeZoneBean(String name) {
            tz = TimeZone.getTimeZone(name);
        }

        public TimeZone getTz() { return tz; }
    }

    static class DateAsNumberBean {
        @JsonFormat(shape=JsonFormat.Shape.NUMBER)
        public Date date;
        public DateAsNumberBean(long l) { date = new java.util.Date(l); }
    }

    static class SqlDateAsDefaultBean {
        public java.sql.Date date;
        public SqlDateAsDefaultBean(long l) { date = new java.sql.Date(l); }
    }

    static class SqlDateAsNumberBean {
        @JsonFormat(shape=JsonFormat.Shape.NUMBER)
        public java.sql.Date date;
        public SqlDateAsNumberBean(long l) { date = new java.sql.Date(l); }
    }
    
    static class DateAsStringBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd")
        public Date date;
        public DateAsStringBean(long l) { date = new java.util.Date(l); }
    }

    static class DateInCETBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd,HH:00", timezone="CET")
        public Date date;
        public DateInCETBean(long l) { date = new java.util.Date(l); }
    }

    static class CalendarAsStringBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd")
        public Calendar value;
        public CalendarAsStringBean(long l) {
            value = new GregorianCalendar();
            value.setTimeInMillis(l);
        }
    }
    
    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();
    
    public void testDateNumeric() throws IOException
    {
        // default is to output time stamps...
        assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));
        // shouldn't matter which offset we give...
        String json = MAPPER.writeValueAsString(new Date(199L));
        assertEquals("199", json);
    }

    public void testDateISO8601() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        // let's hit epoch start
        String json = mapper.writeValueAsString(new Date(0L));
        assertEquals("\"1970-01-01T00:00:00.000+0000\"", json);
    }

    public void testDateOther() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");
        df.setTimeZone(TimeZone.getTimeZone("PST"));
        mapper.setDateFormat(df);
        // let's hit epoch start, offset by a bit
        assertEquals(quote("1969-12-31X16:00:00"), mapper.writeValueAsString(new Date(0L)));
    }

    @SuppressWarnings("deprecation")
    public void testSqlDate() throws IOException
    {
        // use date 1999-04-01 (note: months are 0-based, use constant)
        java.sql.Date date = new java.sql.Date(99, Calendar.APRIL, 1);
        assertEquals(quote("1999-04-01"), MAPPER.writeValueAsString(date));

        java.sql.Date date0 = new java.sql.Date(0L);
        assertEquals(aposToQuotes("{'date':'"+date0.toString()+"'}"),
                MAPPER.writeValueAsString(new SqlDateAsDefaultBean(0L)));

        // but may explicitly force timestamp too
        assertEquals(aposToQuotes("{'date':0}"), MAPPER.writeValueAsString(new SqlDateAsNumberBean(0L)));
    }

    public void testSqlTimestamp() throws IOException
    {
        java.sql.Timestamp input = new java.sql.Timestamp(0L);
        // just should produce same output as standard `java.util.Date`:
        Date altTnput = new Date(0L);
        assertEquals(MAPPER.writeValueAsString(altTnput),
                MAPPER.writeValueAsString(input));
    }

    public void testSqlTime() throws IOException
    {
        java.sql.Time input = new java.sql.Time(0L);
        assertEquals(quote(input.toString()), MAPPER.writeValueAsString(input));
    }
    
    public void testTimeZone() throws IOException
    {
        TimeZone input = TimeZone.getTimeZone("PST");
        String json = MAPPER.writeValueAsString(input);
        assertEquals(quote("PST"), json);
    }

    // [JACKSON-663]
    public void testTimeZoneInBean() throws IOException
    {
        String json = MAPPER.writeValueAsString(new TimeZoneBean("PST"));
        assertEquals("{\"tz\":\"PST\"}", json);
    }
    
    // [JACKSON-648]: (re)configuring via ObjectWriter
    public void testDateUsingObjectWriter() throws IOException
    {
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");
        df.setTimeZone(TimeZone.getTimeZone("PST"));
        assertEquals(quote("1969-12-31X16:00:00"),
                MAPPER.writer(df).writeValueAsString(new Date(0L)));
        ObjectWriter w = MAPPER.writer((DateFormat)null);
        assertEquals("0", w.writeValueAsString(new Date(0L)));

        w = w.with(df);
        assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L)));
        w = w.with((DateFormat) null);
        assertEquals("0", w.writeValueAsString(new Date(0L)));
    }

    // [JACKSON-606]
    public void testDatesAsMapKeys() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        Map<Date,Integer> map = new HashMap<Date,Integer>();
        assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS));
        map.put(new Date(0L), Integer.valueOf(1));
        // by default will serialize as ISO-8601 values...
        assertEquals("{\"1970-01-01T00:00:00.000+0000\":1}", mapper.writeValueAsString(map));
        
        // but can change to use timestamps too
        mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);
        assertEquals("{\"0\":1}", mapper.writeValueAsString(map));
    }

    // [JACKSON-435]
    public void testDateWithJsonFormat() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        String json;

        // first: test overriding writing as timestamp
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsNumberBean(0L));
        assertEquals(aposToQuotes("{'date':0}"), json);

        // then reverse
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writer().with(getUTCTimeZone()).writeValueAsString(new DateAsStringBean(0L));
        assertEquals("{\"date\":\"1970-01-01\"}", json);

        // and with different DateFormat; CET is one hour ahead of GMT
        json = mapper.writeValueAsString(new DateInCETBean(0L));
        assertEquals("{\"date\":\"1970-01-01,01:00\"}", json);
        
        // and for [Issue#423] as well:
        json = mapper.writer().with(getUTCTimeZone()).writeValueAsString(new CalendarAsStringBean(0L));
        assertEquals("{\"value\":\"1970-01-01\"}", json);
    }

    /**
     * Test to ensure that setting a TimeZone _after_ dateformat should enforce
     * that timezone on format, regardless of TimeZone format had.
     */
    public void testWithTimeZoneOverride() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z"));
        mapper.setTimeZone(TimeZone.getTimeZone("PST"));
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        String json = mapper.writeValueAsString(new Date(0));
        // pacific time is GMT-8; so midnight becomes 16:00 previous day:
        assertEquals(quote("1969-12-31/16:00 PST"), json);

        // Let's also verify that Locale won't matter too much...
        mapper.setLocale(Locale.FRANCE);
        json = mapper.writeValueAsString(new Date(0));
        assertEquals(quote("1969-12-31/16:00 PST"), json);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_290f9a6_386e9f7/rev_290f9a6-386e9f7/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
    public void serialize(java.sql.Time value, JsonGenerator jgen, SerializerProvider provider) throws IOException
=======
    public void serialize(java.sql.Time value, JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_290f9a6_386e9f7/rev_290f9a6-386e9f7/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
        jgen.writeString(value.toString());
=======
        g.writeString(value.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_290f9a6_386e9f7/rev_290f9a6-386e9f7/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
        DateSerializer dateSer = DateSerializer.instance;
        concrete.put(java.util.Date.class.getName(), dateSer);
        // note: timestamps are very similar to java.util.Date, thus serialized as such
        concrete.put(java.sql.Timestamp.class.getName(), dateSer);
        
        // leave some of less commonly used ones as lazy, no point in proactive construction
        concLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);
        concLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);
=======
        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
        _concrete.put(java.util.Date.class.getName(), DateSerializer.instance);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_db9584c_89559a2/rev_db9584c-89559a2/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
            if ((v2 == null) || comparator.compare(entry.getValue(), v2) != 0) {
=======
            if ((v2 == null) || !entry.getValue().equals(comparator, v2)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_db9584c_89559a2/rev_db9584c-89559a2/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java;<<<<<<< MINE
            if (comparator.compare(l1.get(i), l2.get(i)) != 0) {
=======
            if (!l1.get(i).equals(comparator, l2.get(i))) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java;<<<<<<< MINE
        // [Issue#124]: May have a content converter
=======
        // [databind#124]: May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java;<<<<<<< MINE
            if ((_valueTypeIsStatic && _valueType.getRawClass() != Object.class)
                    || hasContentTypeAnnotation(provider, property)) {
=======
            if (_valueTypeIsStatic && !_valueType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java;<<<<<<< MINE
    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException
=======
    public void serialize(Object value, JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java;<<<<<<< MINE
        throw new JsonGenerationException(_msg);
=======
        throw new JsonGenerationException(_msg, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java;<<<<<<< MINE
            JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e);
=======
            JsonMappingException mapE = JsonMappingException.from(gen, "Infinite recursion (StackOverflowError)", e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java;<<<<<<< MINE
            throw new JsonMappingException("Unwrapped property requires use of type information: can not serialize without disabling `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS`");
=======
            throw JsonMappingException.from(gen,
                    "Unwrapped property requires use of type information: can not serialize without disabling `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS`");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/FilteredBeanPropertyWriter.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.JsonMappingException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/FilteredBeanPropertyWriter.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/FilteredBeanPropertyWriter.java;<<<<<<< MINE
=======

        @Override
        public void depositSchemaProperty(JsonObjectFormatVisitor v,
                SerializerProvider provider) throws JsonMappingException
        {
            Class<?> activeView = provider.getActiveView();
            if (activeView == null || _view.isAssignableFrom(activeView)) {
                super.depositSchemaProperty(v, provider);
            }
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/FilteredBeanPropertyWriter.java;<<<<<<< MINE
=======

        @Override
        public void depositSchemaProperty(JsonObjectFormatVisitor v,
                SerializerProvider provider) throws JsonMappingException
        {
            Class<?> activeView = provider.getActiveView();
            if (activeView != null) {
                int i = 0, len = _views.length;
                for (; i < len; ++i) {
                    if (_views[i].isAssignableFrom(activeView)) break;
                }
                if (i == len) { // not match? Just don't deposit
                    return;
                }
            }
            super.depositSchemaProperty(v, provider);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/AttributePropertyWriter.java;<<<<<<< MINE
            JsonInclude.Include inclusion)
=======
            JsonInclude.Value inclusion)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
            writer.depositSchemaProperty(objectVisitor);
=======
            writer.depositSchemaProperty(objectVisitor, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java;<<<<<<< MINE
            writer.depositSchemaProperty(objectVisitor);
=======
            writer.depositSchemaProperty(objectVisitor, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java;<<<<<<< MINE
            failForEmpty(value);
=======
            failForEmpty(gen, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java;<<<<<<< MINE
            failForEmpty(value);
=======
            failForEmpty(gen, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java;<<<<<<< MINE
    protected void failForEmpty(Object value) throws JsonMappingException
    {
        throw new JsonMappingException("No serializer found for class "+value.getClass().getName()+" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )");
=======
    protected void failForEmpty(JsonGenerator gen, Object value) throws JsonMappingException {
        throw JsonMappingException.from(gen,
                "No serializer found for class "+value.getClass().getName()+" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java;<<<<<<< MINE
        Boolean unwrapSingle = null;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java;<<<<<<< MINE
            JsonFormat.Value format = property.findFormatOverrides(ai);
            if (format != null) {
                unwrapSingle = format.getFeature(JsonFormat.Feature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);
            }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java;<<<<<<< MINE
=======
        // but since formats have both property overrides and global per-type defaults,
        // need to do that separately
        Boolean unwrapSingle = findFormatFeature(provider, property, String[].class,
                JsonFormat.Feature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java;<<<<<<< MINE
        if (visitor != null) {
            JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
            if (v2 != null) {
                v2.itemsFormat(JsonFormatTypes.STRING);
            }
        }
=======
        visitArrayFormat(visitor, typeHint, JsonFormatTypes.STRING);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java;<<<<<<< MINE
    public void depositSchemaProperty(final JsonObjectFormatVisitor visitor)
            throws JsonMappingException {
        SerializerProvider provider = visitor.getProvider();
=======
    public void depositSchemaProperty(final JsonObjectFormatVisitor visitor,
            SerializerProvider provider) throws JsonMappingException
    {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java;<<<<<<< MINE
            super.depositSchemaProperty(visitor);
=======
            super.depositSchemaProperty(visitor, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
            JsonFormat.Value format = property.findFormatOverrides(intr);
=======
            JsonFormat.Value format = property.findPropertyFormat(provider.getConfig(), _handledType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
                // 20-Aug-2013, tatu: Need to avoid trying to access serializer for java.lang.Object tho
                if ((_staticTyping && _elementType.getRawClass() != Object.class)
                        || hasContentTypeAnnotation(provider, property)) {
=======
                if (_staticTyping && !_elementType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
        JsonArrayFormatVisitor arrayVisitor = (visitor == null) ? null : visitor.expectArrayFormat(typeHint);
        if (arrayVisitor != null) {
            /* 01-Sep-2014, tatu: Earlier was trying to make use of 'typeHint' for some
             *   reason, causing NPE (as per https://github.com/FasterXML/jackson-module-jsonSchema/issues/34)
             *   if coupled with `@JsonValue`. But I can't see much benefit of trying to rely
             *   on TypeHint here so code is simplified like so:
             */
            JsonSerializer<?> valueSer = _elementSerializer;
            if (valueSer == null) {
                valueSer = visitor.getProvider().findValueSerializer(_elementType, _property);
            }
            arrayVisitor.itemsFormat(valueSer, _elementType);
=======
        JsonSerializer<?> valueSer = _elementSerializer;
        if (valueSer == null) {
            valueSer = visitor.getProvider().findValueSerializer(_elementType, _property);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
=======
        visitArrayFormat(visitor, typeHint, valueSer, _elementType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java;<<<<<<< MINE
                        // To fix [JACKSON-508]
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java;<<<<<<< MINE
            // [JACKSON-55] Need to add reference information
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java;<<<<<<< MINE
                    // [JACKSON-55] Need to add reference information
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java;<<<<<<< MINE
            JsonFormat.Value format = property.findFormatOverrides(intr);
=======
            JsonFormat.Value format = property.findPropertyFormat(provider.getConfig(), _handledType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java;<<<<<<< MINE
                if (_staticTyping || hasContentTypeAnnotation(provider, property)) {
=======
                if (_staticTyping && !_elementType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java;<<<<<<< MINE
                throw new JsonMappingException("Could not resolve type");
=======
                throw JsonMappingException.from(visitor.getProvider(), "Could not resolve type");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
 * Container class for serializers used for handling standard JDK-provided types.
=======
 * Container class for serializers used for handling standard JDK-provided
 * types.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
public class NumberSerializers
{
    protected NumberSerializers() { }
=======
public class NumberSerializers {
    protected NumberSerializers() {
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers)
    {
=======
    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        implements ContextualSerializer
    {
        protected final static Integer EMPTY_INTEGER = Integer.valueOf(0);

=======
            implements ContextualSerializer {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        protected Base(Class<?> cls, JsonParser.NumberType numberType, String schemaType) {
=======
        protected Base(Class<?> cls, JsonParser.NumberType numberType,
                String schemaType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                    || (numberType == JsonParser.NumberType.BIG_INTEGER)
                    ;
=======
                    || (numberType == JsonParser.NumberType.BIG_INTEGER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
=======
        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor,
                JavaType typeHint) throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
                if (v2 != null) {
                    v2.numberType(_numberType);
                }
=======
                visitIntFormat(visitor, typeHint, _numberType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);
                if (v2 != null) {
                    v2.numberType(_numberType);
                }
=======
                visitFloatFormat(visitor, typeHint, _numberType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                BeanProperty property) throws JsonMappingException
        {
=======
                BeanProperty property) throws JsonMappingException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                    JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(m);
=======
                    JsonFormat.Value format = prov.getAnnotationIntrospector()
                            .findFormat(m);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    /**********************************************************
    /* Concrete serializers, numerics
    /**********************************************************
=======
     * /********************************************************** /* Concrete
     * serializers, numerics
     * /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    public final static class ShortSerializer extends Base<Short>
    {
        private final static Short EMPTY = (short) 0;
=======
    public final static class ShortSerializer extends Base<Object> {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, "number"); }

        @Override
        public boolean isEmpty(SerializerProvider prov, Short value) {
            return EMPTY.equals(value);
=======
        public ShortSerializer() {
            super(Short.class, JsonParser.NumberType.INT, "number");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {
            gen.writeNumber(value.shortValue());
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
            gen.writeNumber(((Short) value).shortValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
     *<p>
     * Since this is one of "native" types, no type information is ever
     * included on serialization (unlike for most scalar types)
     *<p>
=======
     * <p>
     * Since this is one of "native" types, no type information is ever included
     * on serialization (unlike for most scalar types)
     * <p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    public final static class IntegerSerializer extends Base<Object>
    {
        public IntegerSerializer() { super(Integer.class, JsonParser.NumberType.INT ,"integer"); }
    
=======
    public final static class IntegerSerializer extends Base<Object> {
        public IntegerSerializer() {
            super(Integer.class, JsonParser.NumberType.INT, "integer");
        }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                SerializerProvider provider, TypeSerializer typeSer) throws IOException {
=======
                SerializerProvider provider, TypeSerializer typeSer)
                throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
            serialize(value, gen, provider);            
        }

        @Override
        public boolean isEmpty(SerializerProvider prov, Object value) {
            return EMPTY_INTEGER.equals(value);
=======
            serialize(value, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
     * instead, cast is to {@link java.lang.Number}, and conversion is
     * by calling {@link java.lang.Number#intValue}.
=======
     * instead, cast is to {@link java.lang.Number}, and conversion is by
     * calling {@link java.lang.Number#intValue}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    public final static class IntLikeSerializer extends Base<Number>
    {
=======
    public final static class IntLikeSerializer extends Base<Object> {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public boolean isEmpty(SerializerProvider prov, Number value) {
            return value.intValue() == 0;
        }

        @Override
        public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {
            gen.writeNumber(value.intValue());
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
            gen.writeNumber(((Number) value).intValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    public final static class LongSerializer extends Base<Object>
    {
        private final static Long EMPTY = 0L;

=======
    public final static class LongSerializer extends Base<Object> {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    
        public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, "number"); }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        @Override
        public boolean isEmpty(SerializerProvider prov, Object value) {
            return EMPTY.equals(value);
=======
        public LongSerializer() {
            super(Long.class, JsonParser.NumberType.LONG, "number");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    public final static class FloatSerializer extends Base<Object>
    {
        private final static Float EMPTY = 0f;

=======
    public final static class FloatSerializer extends Base<Object> {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, "number"); }

        @Override
        public boolean isEmpty(SerializerProvider prov, Object value) {
            return EMPTY.equals(value);
=======
        public FloatSerializer() {
            super(Float.class, JsonParser.NumberType.FLOAT, "number");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
     * This is the special serializer for regular {@link java.lang.Double}s
     * (and primitive doubles)
     *<p>
     * Since this is one of "native" types, no type information is ever
     * included on serialization (unlike for most scalar types as of 1.5)
=======
     * This is the special serializer for regular {@link java.lang.Double}s (and
     * primitive doubles)
     * <p>
     * Since this is one of "native" types, no type information is ever included
     * on serialization (unlike for most scalar types as of 1.5)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    public final static class DoubleSerializer extends Base<Object>
    {
        private final static Double EMPTY = 0d;

=======
    public final static class DoubleSerializer extends Base<Object> {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
    
        public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, "number"); }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        @Override
        public boolean isEmpty(SerializerProvider prov, Object value) {
            return EMPTY.equals(value);
=======
        public DoubleSerializer() {
            super(Double.class, JsonParser.NumberType.DOUBLE, "number");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
=======
        public void serialize(Object value, JsonGenerator gen,
                SerializerProvider provider) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
                SerializerProvider provider, TypeSerializer typeSer) throws IOException {
=======
                SerializerProvider provider, TypeSerializer typeSer)
                throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java;<<<<<<< MINE
            serialize(value, gen, provider);            
=======
            serialize(value, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
        		Boolean asNumber = (format.getShape() == JsonFormat.Shape.STRING) ? Boolean.FALSE : null;
                // If not, do we have a pattern?
                TimeZone tz = format.getTimeZone();
                if (format.hasPattern()) {
                    String pattern = format.getPattern();
                    final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();
=======
                if (format.getShape() == JsonFormat.Shape.STRING) {
                    TimeZone tz = format.getTimeZone();
                    final String pattern = format.hasPattern()
                                           ? format.getPattern()
                                           : StdDateFormat.DATE_FORMAT_STR_ISO8601;
                    final Locale loc = format.hasLocale()
                                       ? format.getLocale()
                                       : serializers.getLocale();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
                    return withFormat(asNumber, df);
                }
                // If not, do we at least have a custom timezone?
                if (tz != null) {
                    DateFormat df = serializers.getConfig().getDateFormat();
                    // one shortcut: with our custom format, can simplify handling a bit
                    if (df.getClass() == StdDateFormat.class) {
                        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();
                        df = StdDateFormat.getISO8601Format(tz, loc);
                    } else {
                        // otherwise need to clone, re-set timezone:
                        df = (DateFormat) df.clone();
                        df.setTimeZone(tz);
                    }
                    return withFormat(asNumber, df);
=======
                    return withFormat(Boolean.FALSE, df);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                v2.numberType(JsonParser.NumberType.LONG);
                v2.format(JsonValueFormat.UTC_MILLISEC);
            }
=======
            visitIntFormat(visitor, typeHint,
                    JsonParser.NumberType.LONG, JsonValueFormat.UTC_MILLISEC);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
            JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);
            if (v2 != null) {
                v2.format(JsonValueFormat.DATE_TIME);
            }
=======
            visitStringFormat(visitor, typeHint, JsonValueFormat.DATE_TIME);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java;<<<<<<< MINE
    
    /**
     * @deprecated Since 2.5
     */
    @Deprecated
    public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType) {
        return getStdKeySerializer(null, keyType.getRawClass(), true);
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java;<<<<<<< MINE

    /*
    /**********************************************************
    /* Deprecated implementations: to be removed in future
    /**********************************************************
     */

    @Deprecated // since 2.6; remove from 2.7 or later
    public static class DateKeySerializer extends StdSerializer<Date> {
        protected final static JsonSerializer<?> instance = new DateKeySerializer();

        public DateKeySerializer() { super(Date.class); }
        
        @Override
        public void serialize(Date value, JsonGenerator g, SerializerProvider provider) throws IOException {
            provider.defaultSerializeDateKey(value, g);
        }
    }

    @Deprecated // since 2.6; remove from 2.7 or later
    public static class CalendarKeySerializer extends StdSerializer<Calendar> {
        protected final static JsonSerializer<?> instance = new CalendarKeySerializer();

        public CalendarKeySerializer() { super(Calendar.class); }

        @Override
        public void serialize(Calendar value, JsonGenerator g, SerializerProvider provider) throws IOException {
            provider.defaultSerializeDateKey(value.getTimeInMillis(), g);
        }
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.JsonParser.NumberType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
=======
import com.fasterxml.jackson.databind.jsonFormatVisitors.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
=======
    /**
     * Unique key we use to store a temporary lock, to prevent infinite recursion
     * when resolving content converters (see [databind#357]).
     *<p>
     * NOTE: may need to revisit this if nested content converters are needed; if so,
     * may need to create per-call lock object. But let's start with a simpler
     * solution for now.
     *
     * @since 2.7
     */
    private final static Object CONVERTING_CONTENT_CONVERTER_LOCK = new Object();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    /* Helper methods for JSON Schema generation
=======
    /* Type introspection API, partial/default implementation
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    
=======

    /**
     * Default implementation specifies no format. This behavior is usually
     * overriden by custom serializers.
     */
    @Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
        throws JsonMappingException
    {
        visitor.expectAnyFormat(typeHint);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    public JsonNode getSchema(SerializerProvider provider, Type typeHint)
        throws JsonMappingException
=======
    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    	ObjectNode schema = (ObjectNode) getSchema(provider, typeHint);
    	if (!isOptional) {
    		schema.put("required", !isOptional);
    	}
=======
        ObjectNode schema = (ObjectNode) getSchema(provider, typeHint);
        if (!isOptional) {
    		    schema.put("required", !isOptional);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    
=======

    /*
    /**********************************************************
    /* Helper methods for JSON Schema generation
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
        // as per [JACKSON-563]. Note that 'required' defaults to false
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
=======

    /**
     * Helper method that calls necessary visit method(s) to indicate that the
     * underlying JSON type is JSON String.
     *
     * @since 2.7
     */
    protected void visitStringFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint)
            throws JsonMappingException {
        if (visitor != null) {
            /*JsonStringFormatVisitor v2 =*/ visitor.expectStringFormat(typeHint);
        }
    }

    /**
     * Helper method that calls necessary visit method(s) to indicate that the
     * underlying JSON type is JSON String, but that there is a more refined
     * logical type
     *
     * @since 2.7
     */
    protected void visitStringFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            JsonValueFormat format)
        throws JsonMappingException
    {
        if (visitor != null) {
            JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);
            if (v2 != null) {
                v2.format(format);
            }
        }
    }

    /**
     * Helper method that calls necessary visit method(s) to indicate that the
     * underlying JSON type is JSON Integer number.
     *
     * @since 2.7
     */
    protected void visitIntFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            NumberType numberType)
        throws JsonMappingException
    {
        if (visitor != null) {
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                if (numberType != null) {
                    v2.numberType(numberType);
                }
            }
        }
    }

    /**
     * Helper method that calls necessary visit method(s) to indicate that the
     * underlying JSON type is JSON Integer number, but that there is also a further
     * format restriction involved.
     *
     * @since 2.7
     */
    protected void visitIntFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            NumberType numberType, JsonValueFormat format)
        throws JsonMappingException
    {
        if (visitor != null) {
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                if (numberType != null) {
                    v2.numberType(numberType);
                }
                if (format != null) {
                    v2.format(format);
                }
            }
        }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
     * Default implementation specifies no format. This behavior is usually
     * overriden by custom serializers.
=======
     * Helper method that calls necessary visit method(s) to indicate that the
     * underlying JSON type is a floating-point JSON number.
     *
     * @since 2.7
     */
    protected void visitFloatFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            NumberType numberType)
        throws JsonMappingException
    {
        if (visitor != null) {
            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);
            if (v2 != null) {
                v2.numberType(numberType);
            }
        }
    }

    /**
     * @since 2.7
     */
    protected void visitArrayFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            JsonSerializer<?> itemSerializer, JavaType itemType)
        throws JsonMappingException
    {
        if (visitor != null) {
            JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
            if (v2 != null) {
                if (itemSerializer != null) {
                    v2.itemsFormat(itemSerializer, itemType);
                }
            }
        }
    }

    /**
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    @Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
=======
    protected void visitArrayFormat(JsonFormatVisitorWrapper visitor, JavaType typeHint,
            JsonFormatTypes itemType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
        visitor.expectAnyFormat(typeHint);
=======
        if (visitor != null) {
            JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
            if (v2 != null) {
                v2.itemsFormat(itemType);
            }
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
            
=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
        // [JACKSON-55] Need to add reference information
=======
        // Need to add reference information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
        // [JACKSON-55] Need to add reference information
=======
        // Need to add reference information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
=======
        Object ob = provider.getAttribute(CONVERTING_CONTENT_CONVERTER_LOCK);
        if (ob != null) {
            return existingSerializer;
        }
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
                Object convDef = intr.findSerializationContentConverter(m);
=======
                provider.setAttribute(CONVERTING_CONTENT_CONVERTER_LOCK, Boolean.TRUE);
                Object convDef;
                try {
                    convDef = intr.findSerializationContentConverter(m);
                } finally {
                    provider.setAttribute(CONVERTING_CONTENT_CONVERTER_LOCK, null);
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
                    if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) {
=======
                    if ((existingSerializer == null) && !delegateType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
            throw new JsonMappingException("Can not resolve PropertyFilter with id '"+filterId+"'; no FilterProvider configured");
=======
            throw JsonMappingException.from(provider,
                    "Can not resolve PropertyFilter with id '"+filterId+"'; no FilterProvider configured");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
=======

    /**
     * Helper method that may be used to find if this deserializer has specific
     * {@link JsonFormat} settings, either via property, or through type-specific
     * defaulting.
     *
     * @param typeForDefaults Type (erased) used for finding default format settings, if any
     *
     * @since 2.7
     */
    protected JsonFormat.Value findFormatOverrides(SerializerProvider provider,
            BeanProperty prop, Class<?> typeForDefaults)
    {
        if (prop != null) {
            return prop.findPropertyFormat(provider.getConfig(), typeForDefaults);
        }
        // even without property or AnnotationIntrospector, may have type-specific defaults
        return provider.getDefaultPropertyFormat(typeForDefaults);
    }

    /**
     * Convenience method that uses {@link #findFormatOverrides} to find possible
     * defaults and/of overrides, and then calls <code>JsonFormat.Value.getFeature(...)</code>
     * to find whether that feature has been specifically marked as enabled or disabled.
     * 
     * @param typeForDefaults Type (erased) used for finding default format settings, if any
     *
     * @since 2.7
     */
    protected Boolean findFormatFeature(SerializerProvider provider,
            BeanProperty prop, Class<?> typeForDefaults, JsonFormat.Feature feat)
    {
        JsonFormat.Value format = findFormatOverrides(provider, prop, typeForDefaults);
        if (format != null) {
            return format.getFeature(feat);
        }
        return null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
    @Deprecated // since 2.5
    public NumberSerializer() {
        super(Number.class);
        _isInt = false;
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
    public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException
=======
    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber((BigDecimal) value);
=======
            g.writeNumber((BigDecimal) value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber((BigInteger) value);
=======
            g.writeNumber((BigInteger) value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
        /* These shouldn't match (as there are more specific ones),
         * but just to be sure:
         */
        } else if (value instanceof Integer) {
            jgen.writeNumber(value.intValue());
=======
        // These should not occur, as more specific methods should have been called; but
        // just in case let's cover all bases:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber(value.longValue());
=======
            g.writeNumber(value.longValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber(value.doubleValue());
=======
            g.writeNumber(value.doubleValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber(value.floatValue());
        } else if ((value instanceof Byte) || (value instanceof Short)) {
            jgen.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers
=======
            g.writeNumber(value.floatValue());
        } else if (value instanceof Integer || value instanceof Byte || value instanceof Short) {
            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            jgen.writeNumber(value.toString());
=======
            g.writeNumber(value.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                v2.numberType(JsonParser.NumberType.BIG_INTEGER);
            }
=======
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java;<<<<<<< MINE
            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);
            if (v2 != null) {
                Class<?> h = handledType();
                if (h == BigDecimal.class) {
                    v2.numberType(JsonParser.NumberType.BIG_DECIMAL);
                } // otherwise it's for Number... anything we could do there?
=======
            Class<?> h = handledType();
            if (h == BigDecimal.class) {
                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);
            } else {
                // otherwise bit unclear what to call... but let's try:
                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
    public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider)
=======
    public void serialize(byte[] value, JsonGenerator g, SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
        jgen.writeBinary(provider.getConfig().getBase64Variant(),
=======
        g.writeBinary(provider.getConfig().getBase64Variant(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
    public void serializeWithType(byte[] value, JsonGenerator jgen, SerializerProvider provider,
=======
    public void serializeWithType(byte[] value, JsonGenerator g, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
        typeSer.writeTypePrefixForScalar(value, jgen);
        jgen.writeBinary(provider.getConfig().getBase64Variant(),
=======
        typeSer.writeTypePrefixForScalar(value, g);
        g.writeBinary(provider.getConfig().getBase64Variant(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
        typeSer.writeTypeSuffixForScalar(value, jgen);
=======
        typeSer.writeTypeSuffixForScalar(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteArraySerializer.java;<<<<<<< MINE
        if (visitor != null) {
            JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
            if (v2 != null) {
                v2.itemsFormat(JsonFormatTypes.STRING);
            }
        }
=======
        // while logically (and within JVM) binary, gets encoded as Base64 String
        visitArrayFormat(visitor, typeHint, JsonFormatTypes.STRING);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.SerializerProvider;
=======
import com.fasterxml.jackson.databind.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java;<<<<<<< MINE
        JsonStringFormatVisitor v2 = (visitor == null) ? null : visitor.expectStringFormat(typeHint);
        if (v2 != null) {
            v2.format(JsonValueFormat.DATE_TIME);
        }
=======
        visitStringFormat(visitor, typeHint, JsonValueFormat.DATE_TIME);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
=======
import com.fasterxml.jackson.databind.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java;<<<<<<< MINE
        visitor.expectStringFormat(typeHint);
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java;<<<<<<< MINE
    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,
=======
    public void serializeWithType(T value, JsonGenerator g, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java;<<<<<<< MINE
        typeSer.writeTypePrefixForScalar(value, jgen);
        serialize(value, jgen, provider);
        typeSer.writeTypeSuffixForScalar(value, jgen);
=======
        typeSer.writeTypePrefixForScalar(value, g);
        serialize(value, g, provider);
        typeSer.writeTypeSuffixForScalar(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java;<<<<<<< MINE
        if (visitor != null) {
            // 13-Sep-2013, tatu: Let's assume it's usually a String, right?
//            visitor.expectAnyFormat(typeHint);
            visitor.expectStringFormat(typeHint);
        }
=======
        // 13-Sep-2013, tatu: Let's assume it's usually a String, right?
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java;<<<<<<< MINE
            final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
            JsonFormat.Value format = property.findFormatOverrides(intr);
=======
            JsonFormat.Value format = property.findPropertyFormat(provider.getConfig(), _handledType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java;<<<<<<< MINE
        visitor.expectStringFormat(typeHint);
=======
        // type not really known, but since it is a JSON string:
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
     * Value that indicates suppression mechanism to use; either one of
     * values of {@link com.fasterxml.jackson.annotation.JsonInclude.Include}, or actual object to compare
     * against ("default value")
=======
     * Value that indicates suppression mechanism to use for <b>values contained</b>;
     * either one of values of {@link com.fasterxml.jackson.annotation.JsonInclude.Include},
     * or actual object to compare against ("default value").
     * Note that inclusion value for Map instance itself is handled by caller (POJO
     * property that refers to the Map value).
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
        if (propertyAcc != null && intr != null) {
=======
        if ((propertyAcc != null) && (intr != null)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
            JsonInclude.Include incl = intr.findSerializationInclusionForContent(propertyAcc, null);
            if (incl != null) {
=======
        }
        if (property != null) {
            JsonInclude.Value inclV = property.findPropertyInclusion(provider.getConfig(), Map.class);
            JsonInclude.Include incl = inclV.getContentInclusion();
            if ((incl != null) && (incl != JsonInclude.Include.USE_DEFAULTS)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
            if ((_valueTypeIsStatic && _valueType.getRawClass() != Object.class)
                    || hasContentTypeAnnotation(provider, property)) {
=======
            if (_valueTypeIsStatic && !_valueType.isJavaLangObject()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java;<<<<<<< MINE
    public boolean isEmpty(SerializerProvider prov, Map<?,?> value) {
        return (value == null) || value.isEmpty();
=======
    public boolean isEmpty(SerializerProvider prov, Map<?,?> value)
    {
        if (value == null || value.isEmpty()) {
            return true;
        }
        // 05-Nove-2015, tatu: Simple cases are cheap, but for recursive
        //   emptiness checking we actually need to see if values are empty as well.
        Object supp = this._suppressableValue;

        if ((supp == null) || (supp == JsonInclude.Include.ALWAYS)) {
            return false;
        }
        JsonSerializer<Object> valueSer = _valueSerializer;
        if (valueSer != null) {
            for (Object elemValue : value.values()) {
                if ((elemValue != null) && !valueSer.isEmpty(prov, elemValue)) {
                    return false;
                }
            }
            return true;
        }
        // But if not statically known, try this:
        PropertySerializerMap serializers = _dynamicValueSerializers;
        for (Object elemValue : value.values()) {
            if (elemValue == null) {
                continue;
            }
            Class<?> cc = elemValue.getClass();
            // 05-Nov-2015, tatu: Let's not worry about generic types here, actually;
            //   unlikely to make any difference, but does add significant overhead
            valueSer = serializers.serializerFor(cc);
            if (valueSer == null) {
                try {
                    valueSer = _findAndAddDynamic(serializers, cc, prov);
                } catch (JsonMappingException e) { // Ugh... can not just throw as-is, so...
                    // 05-Nov-2015, tatu: For now, probably best not to assume empty then
                    return false;
                }
                serializers = _dynamicValueSerializers;
            }
            if (!valueSer.isEmpty(prov, elemValue)) {
                return false;
            }
        }
        return true;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.JavaType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.PropertyMetadata;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.type.TypeFactory;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
    private static final long serialVersionUID = 1L;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    /**
     * @deprecated since 2.4
     */
    @Deprecated // since 2.4
    public MapProperty(TypeSerializer typeSer) {
        this(typeSer, null);
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
        super((prop == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL : prop.getMetadata());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void serializeAsField(Object value, JsonGenerator jgen,
=======
    public void serializeAsField(Object value, JsonGenerator gen,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        _keySerializer.serialize(_key, jgen, provider);
=======
        _keySerializer.serialize(_key, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
            _valueSerializer.serialize(value, jgen, provider);
=======
            _valueSerializer.serialize(value, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);
=======
            _valueSerializer.serializeWithType(value, gen, provider, _typeSerializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void serializeAsOmittedField(Object value, JsonGenerator jgen,
=======
    public void serializeAsOmittedField(Object value, JsonGenerator gen,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        if (!jgen.canOmitFields()) {
            jgen.writeOmittedField(getName());
=======
        if (!gen.canOmitFields()) {
            gen.writeOmittedField(getName());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void serializeAsElement(Object value, JsonGenerator jgen,
=======
    public void serializeAsElement(Object value, JsonGenerator gen,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
            _valueSerializer.serialize(value, jgen, provider);
=======
            _valueSerializer.serialize(value, gen, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);
=======
            _valueSerializer.serializeWithType(value, gen, provider, _typeSerializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void serializeAsPlaceholder(Object value, JsonGenerator jgen,
=======
    public void serializeAsPlaceholder(Object value, JsonGenerator gen,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        jgen.writeNull();
=======
        gen.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Rest of BeanProperty, nop
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)
=======
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        // !!! TODO
=======
        if (_property != null) {
            _property.depositSchemaProperty(objectVisitor, provider);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
        // !!! TODO
=======
        // nothing to do here
   }

    @Override
    public JavaType getType() {
        return (_property == null) ? TypeFactory.unknownType() : _property.getType();
    }

    @Override
    public PropertyName getWrapperName() {
        return (_property == null) ? null : _property.getWrapperName();
    }

    @Override
    public AnnotatedMember getMember() {
        return (_property == null) ? null : _property.getMember();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
import java.lang.reflect.Type;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonGenerationException;
=======
import com.fasterxml.jackson.annotation.JsonInclude;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.SerializerProvider;
=======
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.introspect.Annotated;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
import com.fasterxml.jackson.databind.ser.ContextualSerializer;
import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.util.NameTransformer;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
=======
    implements ContextualSerializer
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
     * @deprecated Since 2.6
=======
     * Declared type parameter for Optional.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    @Deprecated
    public AtomicReferenceSerializer() { super(AtomicReference.class, false); }
=======
    protected final JavaType _referredType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    public AtomicReferenceSerializer(ReferenceType type) {
        super(type);
=======
    protected final BeanProperty _property;

    /**
     * Type serializer used for values, if any.
     *
     * @since 2.7
     */
    protected final TypeSerializer _valueTypeSerializer;

    /**
     * @since 2.7
     */
    protected final JsonSerializer<Object> _valueSerializer;

    /**
     * To support unwrapped values of dynamic types, will need this:
     *
     * @since 2.7
     */
    protected final NameTransformer _unwrapper;

    /**
     * Further guidance on serialization-inclusion (or not), regarding
     * contained value (if any).
     *
     * @since 2.7
     */
    protected final JsonInclude.Include _contentInclusion;
    
    /**
     * If element type can not be statically determined, mapping from
     * runtime type to serializer is handled using this object
     *
     * @since 2.7
     */
    protected transient PropertySerializerMap _dynamicSerializers;

    /*
    /**********************************************************
    /* Constructors, factory methods
    /**********************************************************
     */

    public AtomicReferenceSerializer(ReferenceType fullType, boolean staticTyping, TypeSerializer vts,
            JsonSerializer<Object> ser)
    {
        super(fullType);
        _referredType = fullType.getReferencedType();
        _property = null;
        _valueTypeSerializer = vts;
        _valueSerializer = ser;
        _unwrapper = null;
        _contentInclusion = null;
        _dynamicSerializers = PropertySerializerMap.emptyForProperties();
    }

    @SuppressWarnings("unchecked")
    protected AtomicReferenceSerializer(AtomicReferenceSerializer base, BeanProperty property,
            TypeSerializer vts, JsonSerializer<?> valueSer,
            NameTransformer unwrapper,
            JsonInclude.Include contentIncl)
    {
        super(base);
        _referredType = base._referredType;
        _dynamicSerializers = base._dynamicSerializers;
        _property = property;
        _valueTypeSerializer = vts;
        _valueSerializer = (JsonSerializer<Object>) valueSer;
        _unwrapper = unwrapper;
        if ((contentIncl == JsonInclude.Include.USE_DEFAULTS)
                || (contentIncl == JsonInclude.Include.ALWAYS)) {
            _contentInclusion = null;
        } else {
            _contentInclusion = contentIncl;
        }
    }

    @Override
    public JsonSerializer<AtomicReference<?>> unwrappingSerializer(NameTransformer transformer) {
        JsonSerializer<Object> ser = _valueSerializer;
        if (ser != null) {
            ser = ser.unwrappingSerializer(transformer);
        }
        NameTransformer unwrapper = (_unwrapper == null) ? transformer
                : NameTransformer.chainedTransformer(transformer, _unwrapper);
        return withResolved(_property, _valueTypeSerializer, ser, unwrapper, _contentInclusion);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
=======
    protected AtomicReferenceSerializer withResolved(BeanProperty prop,
            TypeSerializer vts, JsonSerializer<?> valueSer,
            NameTransformer unwrapper,
            JsonInclude.Include contentIncl)
    {
        if ((_property == prop) && (contentIncl == _contentInclusion)
                && (_valueTypeSerializer == vts) && (_valueSerializer == valueSer)
                && (_unwrapper == unwrapper)) {
            return this;
        }
        return new AtomicReferenceSerializer(this, prop, vts, valueSer, unwrapper, contentIncl);
    }

    /*
    /**********************************************************
    /* Contextualization (support for property annotations)
    /**********************************************************
     */

    @Override
    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property) throws JsonMappingException
    {
        TypeSerializer typeSer = _valueTypeSerializer;
        if (typeSer != null) {
            typeSer = typeSer.forProperty(property);
        }
        JsonSerializer<?> ser = _valueSerializer;
        if (ser == null) {
            // A few conditions needed to be able to fetch serializer here:
            if (_useStatic(provider, property, _referredType)) {
                ser = _findSerializer(provider, _referredType, property);
            }
        } else {
            ser = provider.handlePrimaryContextualization(ser, property);
        }
        // Also: may want to have more refined exclusion based on referenced value
        JsonInclude.Include contentIncl = _contentInclusion;
        if (property != null) {

            JsonInclude.Value incl = property.findPropertyInclusion(provider.getConfig(),
                    AtomicReference.class);
            JsonInclude.Include newIncl = incl.getContentInclusion();
            if ((newIncl != contentIncl) && (newIncl != JsonInclude.Include.USE_DEFAULTS)) {
                contentIncl = newIncl;
            }
        }
        return withResolved(property, typeSer, ser, _unwrapper, contentIncl);
    }

    protected boolean _useStatic(SerializerProvider provider, BeanProperty property,
            JavaType referredType)
    {
        // First: no serializer for `Object.class`, must be dynamic
        if (referredType.isJavaLangObject()) {
            return false;
        }
        // but if type is final, might as well fetch
        if (referredType.isFinal()) { // or should we allow annotation override? (only if requested...)
            return true;
        }
        // also: if indicated by typing, should be considered static
        if (referredType.useStaticType()) {
            return true;
        }
        // if neither, maybe explicit annotation?
        AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        if ((intr != null) && (property != null)) {
            Annotated ann = property.getMember();
            if (ann != null) {
                JsonSerialize.Typing t = intr.findSerializationTyping(property.getMember());
                if (t == JsonSerialize.Typing.STATIC) {
                    return true;
                }
                if (t == JsonSerialize.Typing.DYNAMIC) {
                    return false;
                }
            }
        }
        // and finally, may be forced by global static typing (unlikely...)
        return provider.isEnabled(MapperFeature.USE_STATIC_TYPING);
    }

    /*
    /**********************************************************
    /* Accessors
    /**********************************************************
     */

    @Override
    public boolean isEmpty(SerializerProvider provider, AtomicReference<?> value)
    {
        if (value == null) {
            return true;
        }
        Object contents = value.get();
        if (contents == null) {
            return true;
        }
        if (_contentInclusion == null) {
            return false;
        }
        JsonSerializer<Object> ser = _valueSerializer;
        if (ser == null) {
            try {
                ser = _findCachedSerializer(provider, value.getClass());
            } catch (JsonMappingException e) { // nasty but necessary
                throw new RuntimeJsonMappingException(e);
            }
        }
        return ser.isEmpty(provider, contents);

    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    public boolean isEmpty(SerializerProvider provider, AtomicReference<?> value) {
        return (value == null) || (value.get() == null);
=======
    public boolean isUnwrappingSerializer() {
        return (_unwrapper != null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    
=======

    /*
    /**********************************************************
    /* Serialization methods
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    public void serialize(AtomicReference<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {
        provider.defaultSerializeValue(value.get(), jgen);
=======
    public void serialize(AtomicReference<?> ref, JsonGenerator g, SerializerProvider provider)
        throws IOException
    {
        Object value = ref.get();
        if (value == null) {
            if (_unwrapper == null) {
                provider.defaultSerializeNull(g);
            }
            return;
        }
        JsonSerializer<Object> ser = _valueSerializer;
        if (ser == null) {
            ser = _findCachedSerializer(provider, value.getClass());
        }
        if (_valueTypeSerializer != null) {
            ser.serializeWithType(value, g, provider, _valueTypeSerializer);
        } else {
            ser.serialize(value, g, provider);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {
        return createSchemaNode("any", true);
=======
    public void serializeWithType(AtomicReference<?> ref,
            JsonGenerator g, SerializerProvider provider,
            TypeSerializer typeSer) throws IOException
    {
        Object value = ref.get();
        if (value == null) {
            if (_unwrapper == null) {
                provider.defaultSerializeNull(g);
            }
            return;
        }

        // Otherwise apply type-prefix/suffix, then std serialize:
        typeSer.writeTypePrefixForScalar(ref, g);
        serialize(ref, g, provider);
        typeSer.writeTypeSuffixForScalar(ref, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    
=======

    /*
    /**********************************************************
    /* Introspection support
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
        visitor.expectAnyFormat(typeHint);
=======
        JsonSerializer<?> ser = _valueSerializer;
        if (ser == null) {
            ser = _findSerializer(visitor.getProvider(), _referredType, _property);
            if (_unwrapper != null) {
                ser = ser.unwrappingSerializer(_unwrapper);
            }
        }
        ser.acceptJsonFormatVisitor(visitor, _referredType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
=======

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */
    
    /**
     * Helper method that encapsulates logic of retrieving and caching required
     * serializer.
     */
    private final JsonSerializer<Object> _findCachedSerializer(SerializerProvider provider,
            Class<?> type) throws JsonMappingException
    {
        JsonSerializer<Object> ser = _dynamicSerializers.serializerFor(type);
        if (ser == null) {
            ser = _findSerializer(provider, type, _property);
            if (_unwrapper != null) {
                ser = ser.unwrappingSerializer(_unwrapper);
            }
            _dynamicSerializers = _dynamicSerializers.newWith(type, ser);
        }
        return ser;
    }

    private final JsonSerializer<Object> _findSerializer(SerializerProvider provider,
            Class<?> type, BeanProperty prop) throws JsonMappingException
    {
        return provider.findTypedValueSerializer(type, true, prop);
    }

    private final JsonSerializer<Object> _findSerializer(SerializerProvider provider,
        JavaType type, BeanProperty prop) throws JsonMappingException
    {
        return provider.findTypedValueSerializer(type, true, prop);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
            // [Issue#124]: allow use of converters
=======
            // [databind#124]: allow use of converters
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
                    type = provider.constructType(prop.getGenericPropertyType());
=======
                    // 30-Oct-2015, tatu: Not sure why this was used
//                    type = provider.constructType(prop.getGenericPropertyType());
                    // but this looks better
                    type = prop.getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
        throws IOException, JsonGenerationException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
            JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e);
            String name = (i == props.length) ? "[anySetter]" : props[i].getName();
=======
            // 10-Dec-2015, tatu: and due to above, avoid "from" method, call ctor directly:
            //JsonMappingException mapE = JsonMappingException.from(gen, "Infinite recursion (StackOverflowError)", e);
            JsonMappingException mapE = new JsonMappingException(gen, "Infinite recursion (StackOverflowError)", e);

             String name = (i == props.length) ? "[anySetter]" : props[i].getName();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
            JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e);
=======
            // Minimize call depth since we are close to fail:
            //JsonMappingException mapE = JsonMappingException.from(gen, "Infinite recursion (StackOverflowError)", e);
            JsonMappingException mapE = new JsonMappingException(gen, "Infinite recursion (StackOverflowError)", e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
=======
        final SerializerProvider provider = visitor.getProvider();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
            for (int i = 0; i < _props.length; i++) {
                filter.depositSchemaProperty(_props[i], objectVisitor, visitor.getProvider());
=======
            for (int i = 0, end = _props.length; i < end; ++i) {
                filter.depositSchemaProperty(_props[i], objectVisitor, provider);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java;<<<<<<< MINE
            for (int i = 0; i < _props.length; i++) {
                _props[i].depositSchemaProperty(objectVisitor);
=======
            Class<?> view = ((_filteredProps == null) || (provider == null))
                    ? null : provider.getActiveView();
            final BeanPropertyWriter[] props;
            if (view != null) {
                props = _filteredProps;
            } else {
                props = _props;
            }

            for (int i = 0, end = props.length; i < end; ++i) {
                BeanPropertyWriter prop = props[i];
                if (prop != null) { // may be filtered out unconditionally
                    prop.depositSchemaProperty(objectVisitor, provider);
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java;<<<<<<< MINE
    @Deprecated // since 2.5
    public boolean isEmpty(UUID value) {
        return isEmpty(null, value);
    }

    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                v2.numberType(JsonParser.NumberType.INT);
            }
=======
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) {
                v2.numberType(JsonParser.NumberType.LONG);
            }
=======
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java;<<<<<<< MINE
    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
        jgen.writeString((String) value);
=======
    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
        gen.writeString((String) value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java;<<<<<<< MINE
        if (visitor != null) visitor.expectStringFormat(typeHint);
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java;<<<<<<< MINE
                throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value");
=======
                throw JsonMappingException.from(provider,
                        "Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java;<<<<<<< MINE
                throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaItemDefinition value");
=======
                throw JsonMappingException.from(provider,
                        "Failed to parse @JsonSerializableSchema.schemaItemDefinition value");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java;<<<<<<< MINE
    public void serialize(File value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
        jgen.writeString(value.getAbsolutePath());
=======
    public void serialize(File value, JsonGenerator g, SerializerProvider provider) throws IOException {
        g.writeString(value.getAbsolutePath());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java;<<<<<<< MINE
        visitor.expectStringFormat(typeHint);
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java;<<<<<<< MINE
            JsonFormat.Value format = property.findFormatOverrides(intr);
=======
            JsonFormat.Value format = property.findPropertyFormat(provider.getConfig(), _handledType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java;<<<<<<< MINE
        // #124: May have a content converter
=======
        // [databind#124]: May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java;<<<<<<< MINE
        if (visitor != null) {
            visitor.expectStringFormat(typeHint);
        }
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java;<<<<<<< MINE
            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);
            if (v2 != null) { // typically serialized as a small number (byte or int)
                v2.numberType(JsonParser.NumberType.INT);
            }
=======
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java;<<<<<<< MINE
    public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,
=======
    public final void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java;<<<<<<< MINE
        serialize(value, jgen, provider);            
=======
        serialize(value, gen, provider);            
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.BOOLEAN);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.BOOLEAN);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
    /**
     * @deprecated Since 2.6 use the main-level implementation, base class of this class
     */
    @Deprecated
    @JacksonStdImpl
    public static class ByteArraySerializer
        extends com.fasterxml.jackson.databind.ser.std.ByteArraySerializer
    {
        public ByteArraySerializer() { super(); }
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.INTEGER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.INTEGER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.STRING);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.STRING);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.INTEGER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.INTEGER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
                throws JsonMappingException
=======
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.NUMBER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.NUMBER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java;<<<<<<< MINE
            if (visitor != null) {
                JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
                if (v2 != null) {
                    v2.itemsFormat(JsonFormatTypes.NUMBER);
                }
            }
=======
            visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonGenerationException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
    public void serialize(Class<?> value, JsonGenerator jgen, SerializerProvider provider)
        throws IOException, JsonGenerationException
=======
    public void serialize(Class<?> value, JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
        jgen.writeString(value.getName());
=======
        g.writeString(value.getName());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
            throws JsonMappingException
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java;<<<<<<< MINE
        visitor.expectStringFormat(typeHint);
=======
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
        throws IOException, JsonGenerationException
=======
            throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
     * Jackson 1.5 did NOT include any type information; but this seems wrong,
     * and so 1.6 WILL include type information.
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
            TypeSerializer typeSer)
        throws IOException, JsonGenerationException
=======
            TypeSerializer typeSer) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
        /* 01-Jan-2010, tatu: Not 100% sure what we should say here:
         *   type is basically not known. This seems closest
         *   approximation
         */
=======
        // Not 100% sure what we should say here: type is basically not known.
        // This seems like closest approximation
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
        /* 01-Jan-2010, tatu: Not 100% sure what we should say here:
         *   type is basically not known. This seems closest
         *   approximation
         */
=======
        // Not 100% sure what we should say here: type is basically not known.
        // This seems like closest approximation
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
import java.lang.reflect.Type;
=======
import com.fasterxml.jackson.annotation.JsonInclude;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
import com.fasterxml.jackson.annotation.JsonInclude;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
            JsonInclude.Include inclusion)
=======
            JsonInclude.Value inclusion)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
    protected static boolean _suppressNulls(JsonInclude.Include inclusion) {
        return (inclusion != JsonInclude.Include.ALWAYS);
=======
    protected static boolean _suppressNulls(JsonInclude.Value inclusion) {
        if (inclusion == null) {
            return false;
        }
        JsonInclude.Include incl = inclusion.getValueInclusion();
        return (incl != JsonInclude.Include.ALWAYS) && (incl != JsonInclude.Include.USE_DEFAULTS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
    protected static Object _suppressableValue(JsonInclude.Include inclusion) {
        if ((inclusion == JsonInclude.Include.NON_EMPTY)
                || (inclusion == JsonInclude.Include.NON_EMPTY)) {
            return MARKER_FOR_EMPTY;
=======
    protected static Object _suppressableValue(JsonInclude.Value inclusion) {
        if (inclusion == null) {
            return false;
        }
        JsonInclude.Include incl = inclusion.getValueInclusion();
        if ((incl == JsonInclude.Include.ALWAYS)
                || (incl == JsonInclude.Include.NON_NULL)
                || (incl == JsonInclude.Include.USE_DEFAULTS)) {
            return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
        return null;
=======
        return MARKER_FOR_EMPTY;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
    @Override
    public Class<?> getPropertyType() {
        return _declaredType.getRawClass();
    }

    @Override
    public Type getGenericPropertyType() {
        return getPropertyType();
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java;<<<<<<< MINE
    protected abstract Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception;
=======
    protected abstract Object value(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw new JsonMappingException(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw JsonMappingException.from(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw JsonMappingException.from(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw JsonMappingException.from(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(msg, e);
=======
            throw JsonMappingException.from(gen, msg, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
=======
        // 07-Nov-2015, tatu: One special case, Object.class; will work only if
        //   empty beans are allowed or custom serializer registered. Easiest to
        //   check here.
        if (cls == Object.class) {
            if (!_config.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {
                return true;
            }
        }
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
import java.util.concurrent.atomic.AtomicReference;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
    protected final static HashMap<String, JsonSerializer<?>> _concrete =
        new HashMap<String, JsonSerializer<?>>();
=======
    protected final static HashMap<String, JsonSerializer<?>> _concrete;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
    protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy =
        new HashMap<String, Class<? extends JsonSerializer<?>>>();
=======
    protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
=======
        HashMap<String, Class<? extends JsonSerializer<?>>> concLazy
            = new HashMap<String, Class<? extends JsonSerializer<?>>>();
        HashMap<String, JsonSerializer<?>> concrete
            = new HashMap<String, JsonSerializer<?>>();

        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concrete.put(String.class.getName(), new StringSerializer());
=======
        concrete.put(String.class.getName(), new StringSerializer());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concrete.put(StringBuffer.class.getName(), sls);
        _concrete.put(StringBuilder.class.getName(), sls);
        _concrete.put(Character.class.getName(), sls);
        _concrete.put(Character.TYPE.getName(), sls);
=======
        concrete.put(StringBuffer.class.getName(), sls);
        concrete.put(StringBuilder.class.getName(), sls);
        concrete.put(Character.class.getName(), sls);
        concrete.put(Character.TYPE.getName(), sls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        NumberSerializers.addAll(_concrete);
        _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));
        _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));
=======
        NumberSerializers.addAll(concrete);
        concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));
        concrete.put(Boolean.class.getName(), new BooleanSerializer(false));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));
        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));
=======
        concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));
        concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
        _concrete.put(java.util.Date.class.getName(), DateSerializer.instance);
=======
        concrete.put(Calendar.class.getName(), CalendarSerializer.instance);
        concrete.put(java.util.Date.class.getName(), DateSerializer.instance);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
                _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);
=======
                concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
                _concreteLazy.put(en.getKey().getName(), cls);
=======
                concLazy.put(en.getKey().getName(), cls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);
=======
        concLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);

        _concrete = concrete;
        _concreteLazy = concLazy;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
                            ClassUtil.checkAndFixAccess(m);
=======
                            ClassUtil.checkAndFixAccess(m, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        if (type.isReferenceType()) {
            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {
                return new AtomicReferenceSerializer((ReferenceType) type);
            }
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(m);
=======
                ClassUtil.checkAndFixAccess(m, prov.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        // Then check for optional/external serializers [JACKSON-386]
=======
        // Then check for optional/external serializers 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
=======
            // 18-Oct-2015, tatu: With 2.7, need to dig type info:
            JavaType mapEntryType = type.findSuperType(Map.Entry.class);
            
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
            JavaType kt = type.containedType(0);
=======
            JavaType kt = mapEntryType.containedType(0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
            JavaType vt = type.containedType(1);
=======
            JavaType vt = mapEntryType.containedType(1);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        Class<?> type = javaType.getRawClass();
=======
        Class<?> rawType = javaType.getRawClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        if (Iterator.class.isAssignableFrom(type)) {
=======
        if (Iterator.class.isAssignableFrom(rawType)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        if (Iterable.class.isAssignableFrom(type)) {
=======
        if (Iterable.class.isAssignableFrom(rawType)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        if (CharSequence.class.isAssignableFrom(type)) {
=======
        if (CharSequence.class.isAssignableFrom(rawType)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);

        if (incl != null) {
            switch (incl) {
            case NON_DEFAULT:
                // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean "NON_EMPTY"...
                incl = JsonInclude.Include.NON_EMPTY;
                break;
            default:
                // all other modes actually good as is, unless we'll find better ways
                break;
            }
            return incl;
=======
        JsonInclude.Value inclV = beanDesc.findPropertyInclusion(config.getDefaultPropertyInclusion());
        
        if (inclV == null) {
            return null;
        }
        JsonInclude.Include incl = inclV.getContentInclusion();
        switch (incl) {
        case USE_DEFAULTS: // means "dunno"
            return null;
        case NON_DEFAULT:
            // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean "NON_EMPTY"...
            // 11-Nov-2015, tatu: With 2.6, we did indeed revert to "NON_EMPTY", but that did
            //    not go well, so with 2.7, we'll do this instead...
            //   But not 100% sure if we ought to call new `JsonSerializer.findDefaultValue()`;
            //   to do that, would need to locate said serializer
//            incl = JsonInclude.Include.NON_EMPTY;
            break;
        default:
            // all other modes actually good as is, unless we'll find better ways
            break;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        return null;
=======
        return incl;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
    
    /**
     * Helper method used to encapsulate details of annotation-based type coercion
     */
    @SuppressWarnings("unchecked")
    protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config,
            Annotated a, T type)
    {
        // first: let's check class for the instance itself:
        Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);
        if (superclass != null) {
            try {
                type = (T) type.widenBy(superclass);
            } catch (IllegalArgumentException iae) {
                throw new IllegalArgumentException("Failed to widen type "+type+" with concrete-type annotation (value "+superclass.getName()+"), method '"+a.getName()+"': "+iae.getMessage());
            }
        }
        return modifySecondaryTypesByAnnotation(config, a, type);
    }

    @SuppressWarnings("unchecked")
    protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config,
            Annotated a, T type)
    {
        AnnotationIntrospector intr = config.getAnnotationIntrospector();
        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapType)) {
                    throw new IllegalArgumentException("Illegal key-type annotation: type "+type+" is not a Map type");
                }
                try {
                    type = (T) ((MapType) type).widenKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new IllegalArgumentException("Failed to narrow key type "+type+" with key-type annotation ("+keyClass.getName()+"): "+iae.getMessage());
                }
            }
            
            // and finally content class; only applicable to structured types
            Class<?> cc = intr.findSerializationContentType(a, type.getContentType());
            if (cc != null) {
                try {
                    type = (T) type.widenContentsBy(cc);
                } catch (IllegalArgumentException iae) {
                    throw new IllegalArgumentException("Failed to narrow content type "+type+" with content-type annotation ("+cc.getName()+"): "+iae.getMessage());
                }
            }
        }
        return type;
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
     * If so, will try to instantiate key serializer and return it; otherwise returns null.
=======
     * If so, will try to instantiate value serializer and return it; otherwise returns null.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.util.TypeKey;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE
    private final HashMap<com.fasterxml.jackson.databind.util.TypeKey, JsonSerializer<Object>> _sharedMap
        = new HashMap<com.fasterxml.jackson.databind.util.TypeKey, JsonSerializer<Object>>(64);
=======
    private final HashMap<TypeKey, JsonSerializer<Object>> _sharedMap
        = new HashMap<TypeKey, JsonSerializer<Object>>(64);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE
            /* Finally: some serializers want to do post-processing, after
             * getting registered (to handle cyclic deps).
             */
            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done
             *   in synchronized manner; this because while we do need to register
             *   instance first, we also must keep lock until resolution is complete
=======
            // Need resolution to handle cyclic POJO type dependencies
            /* 14-May-2011, tatu: Resolving needs to be done in synchronized manner;
             *   this because while we do need to register instance first, we also must
             *   keep lock until resolution is complete.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE
            /* Finally: some serializers want to do post-processing, after
             * getting registered (to handle cyclic deps).
             */
            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done
             *   in synchronized manner; this because while we do need to register
             *   instance first, we also must keep lock until resolution is complete
=======
            // Need resolution to handle cyclic POJO type dependencies
            /* 14-May-2011, tatu: Resolving needs to be done in synchronized manner;
             *   this because while we do need to register instance first, we also must
             *   keep lock until resolution is complete.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE
=======
            if (ser instanceof ResolvableSerializer) {
                ((ResolvableSerializer) ser).resolve(provider);
            }
        }
    }

    /**
     * Another alternative that will cover both access via raw type and matching
     * fully resolved type, in one fell swoop.
     *
     * @since 2.7
     */
    public void addAndResolveNonTypedSerializer(Class<?> rawType, JavaType fullType,
            JsonSerializer<Object> ser,
            SerializerProvider provider)
        throws JsonMappingException
    {
        synchronized (this) {
            Object ob1 = _sharedMap.put(new TypeKey(rawType, false), ser);
            Object ob2 = _sharedMap.put(new TypeKey(fullType, false), ser);
            if ((ob1 == null) || (ob2 == null)) {
                _readOnlyMap.set(null);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE

    /*
    /**************************************************************
    /* Helper class(es)
    /**************************************************************
     */

    /**
     * @deprecated Since 2.6; replaced by {@link com.fasterxml.jackson.databind.util.TypeKey}
     */
    @Deprecated
    public final static class TypeKey extends com.fasterxml.jackson.databind.util.TypeKey
    {
        public TypeKey(Class<?> key, boolean typed) {
            super(key, typed);
        }

        public TypeKey(JavaType key, boolean typed) {
            super(key, typed);
        }
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java;<<<<<<< MINE
     * specified type, which is not of a container type (for which other methods are
     * called).
=======
     * specified type, which is not of a container or reference type (for which
     * other methods are called).
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java;<<<<<<< MINE
=======
     * given {@link ReferenceType}
     *
     * @since 2.7
     */
    public JsonSerializer<?> findReferenceSerializer(SerializationConfig config,
            ReferenceType type, BeanDescription beanDesc,
            TypeSerializer contentTypeSerializer, JsonSerializer<Object> contentValueSerializer);
    
    /**
     * Method called by serialization framework first time a serializer is needed for
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java;<<<<<<< MINE
        
=======

        @Override
        public JsonSerializer<?> findReferenceSerializer(SerializationConfig config,
                ReferenceType type, BeanDescription beanDesc,
                TypeSerializer contentTypeSerializer, JsonSerializer<Object> contentValueSerializer) {
            // 21-Oct-2015, tatu: For backwards compatibility, let's delegate to "bean" variant,
            //    for 2.7 -- remove work-around from 2.8 or later
            return findSerializer(config, type, beanDesc);
        }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java;<<<<<<< MINE
            throw new JsonMappingException("Value returned by 'any-getter' ("
=======
            throw JsonMappingException.from(gen, "Value returned by 'any-getter' ("
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java;<<<<<<< MINE
            throw new JsonMappingException("Value returned by 'any-getter' ("
=======
            throw JsonMappingException.from(gen, "Value returned by 'any-getter' ("
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
=======
     *
     * @deprecated Since 2.7: should not be needed; should be enough to see if
     *     type has 'isStatic' modifier
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
=======
        /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
=======
        */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
=======
import java.util.concurrent.atomic.AtomicReference;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.ser.std.AtomicReferenceSerializer;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.*;
=======
import com.fasterxml.jackson.databind.type.ReferenceType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
        // Next: we may have annotations that further define types to use...
        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);
=======
        // Next: we may have annotations that further indicate actual type to use (a super type)
        final AnnotationIntrospector intr = config.getAnnotationIntrospector();
        JavaType type = (intr == null) ? origType
                : intr.refineSerializationType(config, beanDesc.getClassInfo(), origType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
        // One more twist, as per [Issue#288]; probably need to get new BeanDesc
=======
        // One more twist, as per [databind#288]; probably need to get new BeanDesc
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                // [Issue#23]: Need to figure out how to force passed parameterization
                //  to stick...
                /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
=======
            // 03-Aug-2012, tatu: As per [databind#40], may require POJO serializer...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            // Modules may provide serializers of POJO types:
            for (Serializers serializers : customSerializers()) {
                ser = serializers.findSerializer(config, type, beanDesc);
                if (ser != null) {
                    break;
=======
            if (type.isReferenceType()) {
                ser = findReferenceSerializer(prov, (ReferenceType) type, beanDesc, staticTyping);
            } else {
                // Modules may provide serializers of POJO types:
                for (Serializers serializers : customSerializers()) {
                    ser = serializers.findSerializer(config, type, beanDesc);
                    if (ser != null) {
                        break;
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc)
=======
    public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type,
            BeanDescription beanDesc)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            //   as per [Issue#24]
=======
            //   as per [databind#24]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    public JsonSerializer<?> findReferenceSerializer(SerializerProvider prov, ReferenceType refType,
            BeanDescription beanDesc, boolean staticTyping)
        throws JsonMappingException
    {
        JavaType contentType = refType.getContentType(); 
        TypeSerializer contentTypeSerializer = contentType.getTypeHandler();
        final SerializationConfig config = prov.getConfig();
        if (contentTypeSerializer == null) {
            contentTypeSerializer = createTypeSerializer(config, contentType);
        }
        JsonSerializer<Object> contentSerializer = contentType.getValueHandler();
        for (Serializers serializers : customSerializers()) {
            JsonSerializer<?> ser = serializers.findReferenceSerializer(config, refType, beanDesc,
                    contentTypeSerializer, contentSerializer);
            if (ser != null) {
                return ser;
            }
        }
        if (refType.isTypeOrSubTypeOf(AtomicReference.class)) {
            return new AtomicReferenceSerializer(refType, staticTyping,
                    contentTypeSerializer, contentSerializer);
        }
        return null;
    }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                anyGetter.fixAccess();
=======
                anyGetter.fixAccess(config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());
=======
            JavaType type = anyGetter.getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
        TypeBindings typeBind = beanDesc.bindingsForBeanType();
=======
        final boolean fixAccess = config.canOverrideAccessModifiers();
        final boolean forceAccess = fixAccess && config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            // [JACKSON-762]: type id? Requires special handling:
=======
            // Type id? Requires special handling:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                    if (config.canOverrideAccessModifiers()) {
                        accessor.fixAccess();
=======
                    if (fixAccess) {
                        accessor.fixAccess(forceAccess);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            // [JACKSON-235]: suppress writing of back references
=======
            // suppress writing of back references
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor));
=======
                result.add(_constructWriter(prov, property, pb, staticTyping, (AnnotatedMethod) accessor));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor));
=======
                result.add(_constructWriter(prov, property, pb, staticTyping, (AnnotatedField) accessor));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            BeanPropertyDefinition propDef, TypeBindings typeContext,
=======
            BeanPropertyDefinition propDef,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
            accessor.fixAccess();
=======
            accessor.fixAccess(prov.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
        JavaType type = accessor.getType(typeContext);
=======
        JavaType type = accessor.getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
    // @since 2.7
    private final static Object NO_DEFAULT_MARKER = Boolean.FALSE;
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
    final protected JsonInclude.Include _defaultInclusion;
=======
    final protected JsonInclude.Value _defaultInclusion;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
     * we need to know the default value of the bean, to know if property value
=======
     * we may need to know the default value of the bean, to know if property value
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: only used if enclosing class defines NON_DEFAULT, but NOT if it is the
     * global default OR per-property override.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        _defaultInclusion = beanDesc.findSerializationInclusion(config.getSerializationInclusion());
=======
        _defaultInclusion = beanDesc.findPropertyInclusion(config.getDefaultPropertyInclusion());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        JsonInclude.Include inclusion = propDef.findInclusion();
        if ((inclusion == null)
                || (inclusion == JsonInclude.Include.USE_DEFAULTS)) { // since 2.6
=======
        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());
        JsonInclude.Include inclusion = inclV.getValueInclusion();
        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...
            inclusion = JsonInclude.Include.ALWAYS;
        }

        /*
        JsonInclude.Include inclusion = propDef.findInclusion().getValueInclusion();
        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // since 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
        */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
            valueToSuppress = getDefaultValue(propDef.getName(), am);
=======
            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,
            //    so that if enclosing class has this, we may need to values of property,
            //    whereas for global defaults OR per-property overrides, we have more
            //    static definition. Sigh.
            // First: case of class specifying it; try to find POJO property defaults
            JavaType t = (serializationType == null) ? declaredType : serializationType;
            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {
                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, t);
            } else {
                valueToSuppress = getDefaultValue(t);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        // [JACKSON-120]: Check to see if serialization type is fixed
        Class<?> serClass = _annotationIntrospector.findSerializationType(a);
        if (serClass != null) {
=======
        JavaType secondary = _annotationIntrospector.refineSerializationType(_config, a, declaredType);
        // 11-Oct-2015, tatu: As of 2.7, not 100% sure following checks are needed. But keeping
        //    for now, just in case
        if (secondary != declaredType) {
            Class<?> serClass = secondary.getRawClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
                declaredType = declaredType.widenBy(serClass);
=======
                ; // fine as is
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
                /* 03-Dec-2010, tatu: Actually, ugh, to resolve [JACKSON-415] may further relax this
=======
                /* 03-Dec-2010, tatu: Actually, ugh, we may need to further relax this
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
                declaredType = _config.constructSpecializedType(declaredType, serClass);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        }

        // Should not have to do static method but...
        JavaType secondary = BasicSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType);
        if (secondary != declaredType) {
            useStaticTyping = true;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        
        /* [JACKSON-114]: if using static typing, declared type is known
         * to be the type...
         */
=======
        // If using static typing, declared type is known to be the type...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        if (typing != null && typing != JsonSerialize.Typing.DEFAULT_TYPING) {
=======
        if ((typing != null) && (typing != JsonSerialize.Typing.DEFAULT_TYPING)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        return useStaticTyping ? declaredType : null;
=======
        if (useStaticTyping) {
            // 11-Oct-2015, tatu: Make sure JavaType also "knows" static-ness...
            return declaredType.withStaticTyping();
            
        }
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        if (_defaultBean == null) {
=======
        Object def = _defaultBean;
        if (def == null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
            _defaultBean = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());
            if (_defaultBean == null) {
=======
            def = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());
            if (def == null) {
                // 06-Nov-2015, tatu: As per [databind#998], do not fail.
                /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
                 */

                // And use a marker
                def = NO_DEFAULT_MARKER;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
            _defaultBean = def;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        return _defaultBean;
=======
        return (def == NO_DEFAULT_MARKER) ? null : _defaultBean;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
    protected Object getDefaultValue(String name, AnnotatedMember member)
=======
    /**
     * Accessor used to find out "default value" for given property, to use for
     * comparing values to serialize, to determine whether to exclude value from serialization with
     * inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_EMPTY}.
     * This method is called when we specifically want to know default value within context
     * of a POJO, when annotation is within containing class, and not for property or
     * defined as global baseline.
     *<p>
     * Note that returning of pseudo-type 
     *
     * @since 2.7
     */
    protected Object getPropertyDefaultValue(String name, AnnotatedMember member,
            JavaType type)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
        if (defaultBean == null) {
            return getDefaultValue(type);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
    /**
     * Accessor used to find out "default value" to use for comparing values to
     * serialize, to determine whether to exclude value from serialization with
     * inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}.
     *<p>
     * Default logic is such that for primitives and wrapper types for primitives, expected
     * defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String,
     * and for structured (Maps, Collections, arrays) and reference types, criteria
     * {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}
     * is used.
     *
     * @since 2.7
     */
    protected Object getDefaultValue(JavaType type)
    {
        // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special
        //   handling for primitives since they are never passed as nulls.
        Class<?> cls = type.getRawClass();

        Class<?> prim = ClassUtil.primitiveType(cls);
        if (prim != null) {
            return ClassUtil.defaultValue(prim);
        }
        if (type.isContainerType() || type.isReferenceType()) {
            return JsonInclude.Include.NON_EMPTY;
        }
        if (cls == String.class) {
            return "";
        }
        return null;
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
import com.fasterxml.jackson.databind.introspect.ConcreteBeanPropertyBase;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    extends ConcreteBeanPropertyBase // since 2.7
    implements java.io.Serializable
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    private static final long serialVersionUID = 1L;

    protected PropertyWriter(PropertyMetadata md) {
        super(md);
    }

    protected PropertyWriter(BeanPropertyDefinition propDef) {
        super(propDef.getMetadata());
    }

    protected PropertyWriter(PropertyWriter base) {
        super(base);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
    public abstract void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)
=======
    @Override
    public abstract void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
import com.fasterxml.jackson.annotation.JsonFormat;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
public class BeanPropertyWriter extends PropertyWriter
    implements BeanProperty,
        java.io.Serializable // since 2.6.2
=======
public class BeanPropertyWriter
    extends PropertyWriter // which extends `ConcreteBeanPropertyBase`
    implements java.io.Serializable // since 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
    // as of 2.6.2
    private static final long serialVersionUID = 4603296144163950020L;
=======
    // As of 2.7
    private static final long serialVersionUID = 1L;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
    /**
     * Marker we use to indicate case where we have done format lookup,
     * but found nothing; marker used to avoid having to repeat such lookups.
     *
     * @since 2.6
     */
    protected final static JsonFormat.Value NO_FORMAT = new JsonFormat.Value();

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
    
    /**
     * Additional information about property
     *
     * @since 2.3
     */
    protected final PropertyMetadata _metadata;

    /**
     * Lazily accessed value for per-property format override definition.
     * 
     * @since 2.6
     */
    protected transient JsonFormat.Value _format;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
        super(propDef);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        _metadata = propDef.getMetadata();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
        super(PropertyMetadata.STD_REQUIRED_OR_OPTIONAL);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        _metadata = null;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
        super(base);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        // one more thing: copy internal settings, if any (since 1.7)
=======
        // one more thing: copy internal settings, if any
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        _metadata = base._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
        super(base);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        _metadata = base._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
    @Override public boolean isRequired() { return _metadata.isRequired(); }
    @Override public PropertyMetadata getMetadata() { return _metadata; }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
    
    @Override
    public JsonFormat.Value findFormatOverrides(AnnotationIntrospector intr) {
        JsonFormat.Value f = _format;
        if (f == null) { // not yet looked up, do that
            f = ((intr == null) || (_member == null)) ? null
                    : intr.findFormat(_member);
            _format = (f == null) ? NO_FORMAT : f;
        }
        return (f == NO_FORMAT) ? null : f;
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
    /**
     * Note: will be defined in {@link BeanProperty}; as of now is not yet.
     *<p>
     * TODO: move to {@link BeanProperty} in near future, once all standard
     * implementations define it.
     * 
     * @since 2.5
     */
    public boolean isVirtual() { return false; }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======

    /*
    public JavaType getFullPropertyType() {
        if (_accessorMethod != null) {
            return _accessorMethod.getType()
        }
        if (_field != null) {
            return _field.getType();
        }
        return null;
    }
    */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7, to be removed from 2.8, use {@link #getType()} instead.
     */
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        return (_accessorMethod != null) ? _accessorMethod.getReturnType() : _field.getType();
=======
        if (_accessorMethod != null) {
            return _accessorMethod.getReturnType();
        }
        if (_field != null) {
            return _field.getType();
        }
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
     *
     * @deprecated Since 2.7, to be removed from 2.8, use {@link #getType()} instead.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
    public void depositSchemaProperty(JsonObjectFormatVisitor v)
=======
    public void depositSchemaProperty(JsonObjectFormatVisitor v,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();
=======
        Type hint = (propType == null) ? getType() : propType.getRawClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
                throw new JsonMappingException("Direct self-reference leading to cycle");
=======
                throw JsonMappingException.from(gen, "Direct self-reference leading to cycle");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonValue;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	/**
=======
    /**
     * This is a CSS color (like "#FF0000" or "red"), based on CSS
         2.1 [W3C.CR-CSS21-20070719].
     */
    COLOR("color"),

    /**
     * This SHOULD be a date in the format of YYYY-MM-DD.  It is
     recommended that you use the "date-time" format instead of "date"
     unless you need to transfer only the date part.
     */
    DATE("date"),

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	/**
	 * This SHOULD be a date in the format of YYYY-MM-DD.  It is
      recommended that you use the "date-time" format instead of "date"
      unless you need to transfer only the date part.
	 */
	DATE("date"),

	/**
	 * This SHOULD be a time in the format of hh:mm:ss.  It is
      recommended that you use the "date-time" format instead of "time"
      unless you need to transfer only the time part.
	 */
	TIME("time"),
=======
     /**
      * This SHOULD be an email address.
      */
     EMAIL("email"),

     /**
      * This SHOULD be a host-name.
      */
     HOST_NAME("host-name"),
     
     /**
      * This SHOULD be an ip version 4 address.
      */
     IP_ADDRESS("ip-address"),

     /**
      * This SHOULD be an ip version 6 address.
      */
     IPV6("ipv6"),

     /**
      * This SHOULD be a phone number (format MAY follow E.123).
      */
     PHONE("phone"),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	/**
	 * This SHOULD be the difference, measured in
      milliseconds, between the specified time and midnight, 00:00 of
      January 1, 1970 UTC.  The value SHOULD be a number (integer or
      float).
	 */
	UTC_MILLISEC("utc-millisec"),

	/**
=======
     /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	 * This is a CSS color (like "#FF0000" or "red"), based on CSS
  		2.1 [W3C.CR-CSS21-20070719].
	 */
	COLOR("color"),

	/**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	 * This SHOULD be a phone number (format MAY follow E.123).
	 */
	PHONE("phone"),
=======
      * This SHOULD be a time in the format of hh:mm:ss.  It is
      recommended that you use the "date-time" format instead of "time"
      unless you need to transfer only the time part.
      */
     TIME("time"),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	/**
	 * This SHOULD be an email address.
	 */
	EMAIL("email"),

	/**
	 * This SHOULD be an ip version 4 address.
	 */
	IP_ADDRESS("ip-address"),
	
	/**
	 * This SHOULD be an ip version 6 address.
	 */
	IPV6("ipv6"),
	
	/**
	 * This SHOULD be a host-name.
	 */
	HOST_NAME("host-name")
=======
     /**
      * This SHOULD be the difference, measured in
      milliseconds, between the specified time and midnight, 00:00 of
      January 1, 1970 UTC.  The value SHOULD be a number (integer or
      float).
      */
     UTC_MILLISEC("utc-millisec"),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
=======
     @JsonValue // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserializeTypedFromObject(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        if (jp.canReadTypeId()) {
            Object typeId = jp.getTypeId();
=======
        if (p.canReadTypeId()) {
            Object typeId = p.getTypeId();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                return _deserializeWithNativeTypeId(jp, ctxt, typeId);
=======
                return _deserializeWithNativeTypeId(p, ctxt, typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        JsonToken t = jp.getCurrentToken();
=======
        JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            t = jp.nextToken();
        } else if (t == JsonToken.START_ARRAY) {
=======
            t = p.nextToken();
        } else if (/*t == JsonToken.START_ARRAY ||*/ t != JsonToken.FIELD_NAME) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);
        } else if (t != JsonToken.FIELD_NAME) {
            return _deserializeTypedUsingDefaultImpl(jp, ctxt, null);
=======
            return _deserializeTypedUsingDefaultImpl(p, ctxt, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {
            String name = jp.getCurrentName();
            jp.nextToken(); // to point to the value
            if (_typePropertyName.equals(name)) { // gotcha!
                return _deserializeTypedForId(jp, ctxt, tb);
=======
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String name = p.getCurrentName();
            p.nextToken(); // to point to the value
            if (name.equals(_typePropertyName)) { // gotcha!
                return _deserializeTypedForId(p, ctxt, tb);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                tb = new TokenBuffer(jp, ctxt);
=======
                tb = new TokenBuffer(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            tb.copyCurrentStructure(jp);
=======
            tb.copyCurrentStructure(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb);
=======
        return _deserializeTypedUsingDefaultImpl(p, ctxt, tb);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    protected Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException
=======
    protected Object _deserializeTypedForId(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        String typeId = jp.getText();
=======
        String typeId = p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                tb = new TokenBuffer(jp, ctxt);
=======
                tb = new TokenBuffer(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            tb.writeFieldName(jp.getCurrentName());
=======
            tb.writeFieldName(p.getCurrentName());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);
=======
            p = JsonParserSequence.createFlattened(tb.asParser(p), p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        jp.nextToken(); // to skip past String value
=======
        p.nextToken(); // to skip past String value
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        return deser.deserialize(jp, ctxt);
=======
        return deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException
=======
    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                jp = tb.asParser(jp);
=======
                p = tb.asParser(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
                jp.nextToken();
=======
                p.nextToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
            return deser.deserialize(jp, ctxt);
=======
            return deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);
=======
        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromAny(jp, ctxt);
=======
        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromAny(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,
=======
        throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    /* As per [JACKSON-352], also need to re-route "unknown" version. Need to think
=======
    /* Also need to re-route "unknown" version. Need to think
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException {
        /* [JACKSON-387]: Sometimes, however, we get an array wrapper; specifically
         *   when an array or list has been serialized with type information.
=======
    public Object deserializeTypedFromAny(JsonParser p, DeserializationContext ctxt) throws IOException {
        /* Sometimes, however, we get an array wrapper; specifically
         * when an array or list has been serialized with type information.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromArray(jp, ctxt);
=======
        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java;<<<<<<< MINE
        return deserializeTypedFromObject(jp, ctxt);
=======
        return deserializeTypedFromObject(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);
=======
                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config);
=======
                AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config);
=======
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);
=======
                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config);
=======
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config);
=======
                ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);
=======
                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                    final AnnotationIntrospector ai = config.getAnnotationIntrospector();
                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);
=======
                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);
=======
                AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java;<<<<<<< MINE
                    AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);
=======
                    AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java;<<<<<<< MINE
=======
 * Note that ALL sub-class need to re-implement
 * {@link #typeFromId(DatabindContext, String)} method; otherwise implementation
 * will not work.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java;<<<<<<< MINE
        return typeFromId(id);
=======
        // 22-Dec-2015, tatu: Must be overridden by sub-classes, so let's throw
        //    an exception if not
        throw new IllegalStateException("Sub-class "+getClass().getName()+" MUST implement "
                +"`typeFromId(DatabindContext,String)");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java;<<<<<<< MINE
     *<p>
     * TODO: demote down to be part of {@link TypeIdResolver} in 2.6 or 2.7
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeObjectFieldStart(_validTypeId(typeId));
=======
            g.writeObjectFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g, Class<?> type) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeObjectFieldStart(_validTypeId(typeId));
=======
            g.writeObjectFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
=======
            g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeArrayFieldStart(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeArrayFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type) throws IOException
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g, Class<?> type) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
=======
            g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeArrayFieldStart(_validTypeId(typeId));
=======
            g.writeArrayFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeFieldName(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeFieldName(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g, Class<?> type) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeFieldName(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeFieldName(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException
=======
    public void writeTypeSuffixForObject(Object value, JsonGenerator g) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        jgen.writeEndObject();
        if (!jgen.canWriteTypeId()) {
=======
        g.writeEndObject();
        if (!g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeEndObject();
=======
            g.writeEndObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException
=======
    public void writeTypeSuffixForArray(Object value, JsonGenerator g) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        jgen.writeEndArray();
        if (!jgen.canWriteTypeId()) {
=======
        g.writeEndArray();
        if (!g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeEndObject();
=======
            g.writeEndObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException {
        if (!jgen.canWriteTypeId()) {
=======
    public void writeTypeSuffixForScalar(Object value, JsonGenerator g) throws IOException {
        if (!g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeEndObject();
=======
            g.writeEndObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForObject(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
=======
            g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeObjectFieldStart(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeObjectFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForArray(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
=======
            g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeArrayFieldStart(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeArrayFieldStart(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForScalar(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartObject();
            jgen.writeFieldName(_validTypeId(typeId));
=======
            g.writeStartObject();
            g.writeFieldName(_validTypeId(typeId));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForObject(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForObject(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForArray(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForArray(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForScalar(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForScalar(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
     * @since 2.6.0
=======
     * Helper method used to ensure that intended type id is output as something that is valid:
     * currently only used to ensure that `null` output is converted to an empty String.
     *
     * @since 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
        _typePropertyName = typePropertyName;
=======
        // 22-Dec-2015, tatu: as per [databind#1055], avoid NPE
        _typePropertyName = (typePropertyName == null) ? "" : typePropertyName;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
        // defaults are fine, although concurrency of 4 bit more frugal than 16:
        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 4);
=======
        // defaults are fine, although shouldn't need much concurrency
        _deserializers = new ConcurrentHashMap<String, JsonDeserializer<Object>>(16, 0.75f, 2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
=======
            // 01-Nov-2015, tatu: Actually this is still exactly wrong. Should fix.
            // 15-Jan-2016, tatu: ... as witnessed by [databind#1083], patched, but
            //     fundamentally this call can't be made to work for all cases
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java;<<<<<<< MINE
=======
    // !!! TODO: remove from 2.8
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java;<<<<<<< MINE
    @Deprecated // since 2.4
=======
    @Deprecated // since 2.5
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java;<<<<<<< MINE
=======
    /**
     * Method called for error-reporting and diagnostics purposes.
     * 
     * @since 2.7 -- but since 2.5 has existed in {@link com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase}
     */
    public String getDescForKnownTypeIds();
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
    implements ContextualDeserializer // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
    /**
     * Specific override for this instance (from proper, or global per-type overrides)
     * to indicate whether single value may be taken to mean an unwrapped one-element array
     * or not. If null, left to global defaults.
     *
     * @since 2.7
     */
    protected final Boolean _unwrapSingle;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        _unwrapSingle = null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
    /**
     * @since 2.7
     */
    protected PrimitiveArrayDeserializers(PrimitiveArrayDeserializers<?> base,
            Boolean unwrapSingle) {
        super(base._valueClass);
        _unwrapSingle = unwrapSingle;
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
    /**
     * @since 2.7
     */
    protected abstract PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle);

    @Override
    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
            BeanProperty property) throws JsonMappingException
    {
        Boolean unwrapSingle = findFormatFeature(ctxt, property, _valueClass,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
        if (unwrapSingle == _unwrapSingle) {
            return this;
        }
        return withResolved(unwrapSingle);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
        return typeDeserializer.deserializeTypedFromArray(p, ctxt);
    }
    
    protected T handleNonArray(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        // [JACKSON-620] Empty String can become null...
        if (p.hasToken(JsonToken.VALUE_STRING)
                && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
            if (p.getText().length() == 0) {
                return null;
            }
        }
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (canWrap) {
            return handleSingleElementUnwrapped(p, ctxt);
        }
        throw ctxt.mappingException(_valueClass);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======

    protected abstract T handleSingleElementUnwrapped(JsonParser p,
            DeserializationContext ctxt) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
    */
=======
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        protected CharDeser(CharDeser base, Boolean unwrapSingle) {
            super(base, unwrapSingle);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            // 11-Dec-2015, tatu: Not sure how re-wrapping would work; omit
            return this;
        }
        
        @Override
        public char[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            JsonToken t = jp.getCurrentToken();
=======
            JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                char[] buffer = jp.getTextCharacters();
                int offset = jp.getTextOffset();
                int len = jp.getTextLength();
=======
                char[] buffer = p.getTextCharacters();
                int offset = p.getTextOffset();
                int len = p.getTextLength();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (jp.isExpectedStartArrayToken()) {
=======
            if (p.isExpectedStartArrayToken()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
=======
                while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                    String str = jp.getText();
=======
                    String str = p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                        throw JsonMappingException.from(jp, "Can not convert a JSON String of length "+str.length()+" into a char element of char array");
=======
                        throw JsonMappingException.from(p, "Can not convert a JSON String of length "+str.length()+" into a char element of char array");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                Object ob = jp.getEmbeddedObject();
=======
                Object ob = p.getEmbeddedObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======

        @Override
        protected char[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            // not sure how this should work so just return `null` so:
            throw ctxt.mappingException(_valueClass);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        protected BooleanDeser(BooleanDeser base, Boolean unwrapSingle) {
            super(base, unwrapSingle);
        }

        @Override
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new BooleanDeser(this, unwrapSingle);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt)
=======
        public boolean[] deserialize(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                    boolean value = _parseBooleanPrimitive(jp, ctxt);
=======
                    boolean value = _parseBooleanPrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new boolean[] { _parseBooleanPrimitive(jp, ctxt) };
=======
        @Override
        protected boolean[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new boolean[] { _parseBooleanPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        protected ByteDeser(ByteDeser base, Boolean unwrapSingle) {
            super(base, unwrapSingle);
        }

        @Override
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new ByteDeser(this, unwrapSingle);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        public byte[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            JsonToken t = jp.getCurrentToken();
=======
            JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                return jp.getBinaryValue(ctxt.getBase64Variant());
=======
                return p.getBinaryValue(ctxt.getBase64Variant());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                Object ob = jp.getEmbeddedObject();
=======
                Object ob = p.getEmbeddedObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
=======
                while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                        value = jp.getByteValue();
=======
                        value = p.getByteValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        @Override
        protected byte[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            JsonToken t = jp.getCurrentToken();
=======
            JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                value = jp.getByteValue();
=======
                value = p.getByteValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                // [JACKSON-79]: should probably accept nulls as 'false'
=======
                // should probably accept nulls as 'false'
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        protected ShortDeser(ShortDeser base, Boolean unwrapSingle) {
            super(base, unwrapSingle);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new ShortDeser(this, unwrapSingle);
        }
        
        @Override
        public short[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
                    short value = _parseShortPrimitive(jp, ctxt);
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
                    short value = _parseShortPrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new short[] { _parseShortPrimitive(jp, ctxt) };
=======
        @Override
        protected short[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new short[] { _parseShortPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        protected IntDeser(IntDeser base, Boolean unwrapSingle) {
            super(base, unwrapSingle);
        }

        @Override
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new IntDeser(this, unwrapSingle);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        public int[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                    int value = _parseIntPrimitive(jp, ctxt);
=======
                    int value = _parseIntPrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new int[] { _parseIntPrimitive(jp, ctxt) };
=======
        @Override
        protected int[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new int[] { _parseIntPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        protected LongDeser(LongDeser base, Boolean unwrapSingle) {
            super(base, unwrapSingle);
        }

        @Override
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new LongDeser(this, unwrapSingle);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        public long[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
                    long value = _parseLongPrimitive(jp, ctxt);
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
                    long value = _parseLongPrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new long[] { _parseLongPrimitive(jp, ctxt) };
=======
        @Override
        protected long[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new long[] { _parseLongPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        protected FloatDeser(FloatDeser base, Boolean unwrapSingle) {
            super(base, unwrapSingle);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public float[] deserialize(JsonParser jp, DeserializationContext ctxt)
=======
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new FloatDeser(this, unwrapSingle);
        }

        @Override
        public float[] deserialize(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                    float value = _parseFloatPrimitive(jp, ctxt);
=======
                    float value = _parseFloatPrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final float[] handleNonArray(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new float[] { _parseFloatPrimitive(jp, ctxt) };
=======
        @Override
        protected float[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new float[] { _parseFloatPrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        protected DoubleDeser(DoubleDeser base, Boolean unwrapSingle) {
            super(base, unwrapSingle);
        }

        @Override
        protected PrimitiveArrayDeserializers<?> withResolved(Boolean unwrapSingle) {
            return new DoubleDeser(this, unwrapSingle);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
        public double[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            if (!jp.isExpectedStartArrayToken()) {
                return handleNonArray(jp, ctxt);
=======
            if (!p.isExpectedStartArrayToken()) {
                return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
                while (jp.nextToken() != JsonToken.END_ARRAY) {
                    double value = _parseDoublePrimitive(jp, ctxt);
=======
                while (p.nextToken() != JsonToken.END_ARRAY) {
                    double value = _parseDoublePrimitive(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
        private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
        {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
            return new double[] { _parseDoublePrimitive(jp, ctxt) };
=======
        @Override
        protected double[] handleSingleElementUnwrapped(JsonParser p,
                DeserializationContext ctxt) throws IOException {
            return new double[] { _parseDoublePrimitive(p, ctxt) };
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(ctor);
=======
                ClassUtil.checkAndFixAccess(ctor, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(m);
=======
                ClassUtil.checkAndFixAccess(m, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
=======
     public ArrayBlockingQueueDeserializer(JavaType collectionType,
            JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser,
            ValueInstantiator valueInstantiator)
    {
        super(collectionType, valueDeser, valueTypeDeser, valueInstantiator);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
    public ArrayBlockingQueueDeserializer(JavaType collectionType,
=======
     protected ArrayBlockingQueueDeserializer(JavaType collectionType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
            JsonDeserializer<Object> delegateDeser)
=======
            JsonDeserializer<Object> delegateDeser, Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
        super(collectionType, valueDeser, valueTypeDeser, valueInstantiator, delegateDeser);
=======
        super(collectionType, valueDeser, valueTypeDeser, valueInstantiator,
                delegateDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
            JsonDeserializer<?> vd, TypeDeserializer vtd)
=======
            JsonDeserializer<?> vd, TypeDeserializer vtd, Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) {
=======
        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)
                && (_unwrapSingle == unwrapSingle)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java;<<<<<<< MINE
                _valueInstantiator, (JsonDeserializer<Object>) dd);
=======
                _valueInstantiator, (JsonDeserializer<Object>) dd, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
            ClassUtil.checkAndFixAccess(factory.getMember());
=======
            ClassUtil.checkAndFixAccess(factory.getMember(),
                    config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
            // ... unless told not to do that. :-) (as per [JACKSON-412])
            _checkFailOnNumber(ctxt);
            
=======
            // ... unless told not to do that
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
=======
            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {
                _failOnNumber(ctxt, p, index);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
                throw ctxt.weirdNumberException(Integer.valueOf(index), _enumClass(),
=======
                throw ctxt.weirdNumberException(index, _enumClass(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
            // [#149]: Allow use of 'String' indexes as well
=======
            // [databind#149]: Allow use of 'String' indexes as well
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
                    _checkFailOnNumber(ctxt);
=======
                    if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {
                        _failOnNumber(ctxt, p, ix);
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
    protected void _checkFailOnNumber(DeserializationContext ctxt) throws IOException
=======
    protected void _failOnNumber(DeserializationContext ctxt, JsonParser p, int index)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {
            throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)");
        }
=======
        throw InvalidFormatException.from(p,
                String.format("Not allowed to deserialize Enum value out of JSON number (%d): disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow",
                        index),
                        index, _enumClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
    public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public String deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
        JsonToken curr = jp.getCurrentToken();
        if (curr == JsonToken.VALUE_STRING) {
            return jp.getText();
=======
        if (p.hasToken(JsonToken.VALUE_STRING)) {
            return p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE

        // Issue#381
        if (curr == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
            jp.nextToken();
            final String parsed = _parseString(jp, ctxt);
            if (jp.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
=======
        JsonToken t = p.getCurrentToken();
        // [databind#381]
        if ((t == JsonToken.START_ARRAY) && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
            p.nextToken();
            final String parsed = _parseString(p, ctxt);
            if (p.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
        // [JACKSON-330]: need to gracefully handle byte[] data, as base64
        if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {
            Object ob = jp.getEmbeddedObject();
=======
        // need to gracefully handle byte[] data, as base64
        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {
            Object ob = p.getEmbeddedObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
                return Base64Variants.getDefaultVariant().encode((byte[]) ob, false);
=======
                return ctxt.getBase64Variant().encode((byte[]) ob, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
        String text = jp.getValueAsString();
=======
        String text = p.getValueAsString();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
        throw ctxt.mappingException(_valueClass, curr);
=======
        throw ctxt.mappingException(_valueClass, p.getCurrentToken());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
    // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
=======
    // Since we can never have type info ("natural type"; String, Boolean, Integer, Double):
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java;<<<<<<< MINE
    public String deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return deserialize(jp, ctxt);
=======
    public String deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
=======
    /**
     * Specific override for this instance (from proper, or global per-type overrides)
     * to indicate whether single value may be taken to mean an unwrapped one-element array
     * or not. If null, left to global defaults.
     *
     * @since 2.7
     */
    protected final Boolean _unwrapSingle;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = null;
    }

    /**
     * @since 2.7
     */
    @SuppressWarnings("unchecked" )
    protected EnumSetDeserializer(EnumSetDeserializer base,
            JsonDeserializer<?> deser, Boolean unwrapSingle) {
        super(EnumSet.class);
        _enumType = base._enumType;
        _enumClass = base._enumClass;
        _enumDeserializer = (JsonDeserializer<Enum<?>>) deser;
        _unwrapSingle = unwrapSingle;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
        return new EnumSetDeserializer(_enumType, deser);
=======
        return new EnumSetDeserializer(this, deser, _unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
    
=======

    public EnumSetDeserializer withResolved(JsonDeserializer<?> deser, Boolean unwrapSingle) {
        if ((_unwrapSingle == unwrapSingle) && (_enumDeserializer == deser)) {
            return this;
        }
        return new EnumSetDeserializer(this, deser, unwrapSingle);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
=======
        Boolean unwrapSingle = findFormatFeature(ctxt, property, EnumSet.class,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
        return withDeserializer(deser);
=======
        return withResolved(deser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
    public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public EnumSet<?> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
        if (!jp.isExpectedStartArrayToken()) {
            throw ctxt.mappingException(EnumSet.class);
=======
        if (!p.isExpectedStartArrayToken()) {
            return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
=======
            while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
                Enum<?> value = _enumDeserializer.deserialize(jp, ctxt);
=======
                Enum<?> value = _enumDeserializer.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
        return typeDeserializer.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
=======

    @SuppressWarnings("unchecked") 
    protected EnumSet<?> handleNonArray(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));

        if (!canWrap) {
            throw ctxt.mappingException(EnumSet.class);
        }

        EnumSet result = constructSet();
        // First: since `null`s not allowed, slightly simpler...
        if (p.hasToken(JsonToken.VALUE_NULL)) {
            throw ctxt.mappingException(_enumClass);
        }
        try {
            Enum<?> value = _enumDeserializer.deserialize(p, ctxt);
            if (value != null) { 
                result.add(value);
            }
        } catch (Exception e) {
            throw JsonMappingException.wrapWithPath(e, result, result.size());
        }
        return result;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return _parseBooleanFromNumber(jp, ctxt);
=======
            return _parseBooleanFromOther(jp, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return Boolean.valueOf(_parseBooleanFromNumber(p, ctxt));
=======
            return Boolean.valueOf(_parseBooleanFromOther(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
    protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt)
=======
    protected final boolean _parseBooleanFromOther(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        if (jp.getNumberType() == NumberType.LONG) {
            return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE;
=======
        if (p.getNumberType() == NumberType.LONG) {
            return (p.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        String str = jp.getText();
=======
        String str = p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?
        // for now, MIN_VALUE, since MIN_NORMAL is JDK 1.6
=======
        // avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return Double.MIN_VALUE;
=======
            return Double.MIN_NORMAL; // since 2.7; was MIN_VALUE prior
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
    protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected final String _parseString(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        JsonToken t = jp.getCurrentToken();
=======
        JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return jp.getText();
=======
            return p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        
        // Issue#381
=======
        // [databind#381]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            jp.nextToken();
            final String parsed = _parseString(jp, ctxt);
            if (jp.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
=======
            p.nextToken();
            final String parsed = _parseString(p, ctxt);
            if (p.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        String value = jp.getValueAsString();
=======
        String value = p.getValueAsString();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        throw ctxt.mappingException(String.class, jp.getCurrentToken());
=======
        throw ctxt.mappingException(String.class, p.getCurrentToken());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
     *     for passing deserialized values; provided so deserializer can be contextualized if necessary (since 1.7)
=======
     *     for passing deserialized values; provided so deserializer can be contextualized if necessary
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
    
=======

    /**
     * Helper method that may be used to find if this deserializer has specific
     * {@link JsonFormat} settings, either via property, or through type-specific
     * defaulting.
     *
     * @param typeForDefaults Type (erased) used for finding default format settings, if any
     *
     * @since 2.7
     */
    protected JsonFormat.Value findFormatOverrides(DeserializationContext ctxt,
            BeanProperty prop, Class<?> typeForDefaults)
    {
        if (prop != null) {
            return prop.findPropertyFormat(ctxt.getConfig(), typeForDefaults);
        }
        // even without property or AnnotationIntrospector, may have type-specific defaults
        return ctxt.getDefaultPropertyFormat(typeForDefaults);
    }

    /**
     * Convenience method that uses {@link #findFormatOverrides} to find possible
     * defaults and/of overrides, and then calls
     * <code>JsonFormat.Value.getFeature(feat)</code>
     * to find whether that feature has been specifically marked as enabled or disabled.
     * 
     * @param typeForDefaults Type (erased) used for finding default format settings, if any
     *
     * @since 2.7
     */
    protected Boolean findFormatFeature(DeserializationContext ctxt,
            BeanProperty prop, Class<?> typeForDefaults, JsonFormat.Feature feat)
    {
        JsonFormat.Value format = findFormatOverrides(ctxt, prop, typeForDefaults);
        if (format != null) {
            return format.getFeature(feat);
        }
        return null;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
            _badFormat(id);
=======
            _badFormat(id, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
            _badFormat(id);
=======
            _badFormat(id, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
        long l1 = intFromChars(id, 0);
=======
        long l1 = intFromChars(id, 0, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
        long l2 = ((long) shortFromChars(id, 9)) << 16;
        l2 |= shortFromChars(id, 14);
=======
        long l2 = ((long) shortFromChars(id, 9, ctxt)) << 16;
        l2 |= shortFromChars(id, 14, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
        int i1 = (shortFromChars(id, 19) << 16) | shortFromChars(id, 24);
=======
        int i1 = (shortFromChars(id, 19, ctxt) << 16) | shortFromChars(id, 24, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
        l2 = intFromChars(id, 28);
=======
        l2 = intFromChars(id, 28, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    private void _badFormat(String uuidStr) {
        throw new NumberFormatException("UUID has to be represented by the standard 36-char representation");
=======
    private void _badFormat(String uuidStr, DeserializationContext ctxt)
        throws JsonMappingException
    {
        throw InvalidFormatException.from(ctxt.getParser(),
                String.format("UUID has to be represented by standard 36-char representation: input String '%s'",
                        uuidStr),
                uuidStr, handledType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    static int intFromChars(String str, int index) {
        return (byteFromChars(str, index) << 24) + (byteFromChars(str, index+2) << 16) + (byteFromChars(str, index+4) << 8) + byteFromChars(str, index+6);
=======
    static int intFromChars(String str, int index, DeserializationContext ctxt) throws JsonMappingException {
        return (byteFromChars(str, index, ctxt) << 24)
                + (byteFromChars(str, index+2, ctxt) << 16)
                + (byteFromChars(str, index+4, ctxt) << 8)
                + byteFromChars(str, index+6, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    static int shortFromChars(String str, int index) {
        return (byteFromChars(str, index) << 8) + byteFromChars(str, index+2);
=======
    static int shortFromChars(String str, int index, DeserializationContext ctxt) throws JsonMappingException {
        return (byteFromChars(str, index, ctxt) << 8) + byteFromChars(str, index+2, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    static int byteFromChars(String str, int index)
=======
    static int byteFromChars(String str, int index, DeserializationContext ctxt) throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
            return _badChar(str, index, c1);
=======
            return _badChar(str, index, ctxt, c1);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
        return _badChar(str, index+1, c2);
=======
        return _badChar(str, index+1, ctxt, c2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    static int _badChar(String uuidStr, int index, char c) {
        throw new NumberFormatException("Non-hex character '"+c+"', not valid character for a UUID String"
                +"' (value 0x"+Integer.toHexString(c)+") for UUID String \""+uuidStr+"\"");
=======
    static int _badChar(String uuidStr, int index, DeserializationContext ctxt, char c) throws JsonMappingException {
        String msg = String.format(
"Non-hex character '%c' (value 0x%s), not valid for UUID String: input String '%s'",
        c, Integer.toHexString(c), uuidStr);
        throw InvalidFormatException.from(ctxt.getParser(), msg, uuidStr, UUID.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
    private UUID _fromBytes(byte[] bytes, DeserializationContext ctxt) throws IOException {
=======
    private UUID _fromBytes(byte[] bytes, DeserializationContext ctxt) throws JsonMappingException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java;<<<<<<< MINE
            ctxt.mappingException("Can only construct UUIDs from byte[16]; got %d bytes",
                    bytes.length);
=======
            throw InvalidFormatException.from(ctxt.getParser(),
                    "Can only construct UUIDs from byte[16]; got "+bytes.length+" bytes",
                    bytes, handledType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
=======
    /**
     * Specific override for this instance (from proper, or global per-type overrides)
     * to indicate whether single value may be taken to mean an unwrapped one-element array
     * or not. If null, left to global defaults.
     *
     * @since 2.7
     */
    protected final Boolean _unwrapSingle;
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        this(collectionType, valueInstantiator, null, valueDeser);
=======
        this(collectionType, valueInstantiator, null, valueDeser, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            JsonDeserializer<?> valueDeser)
=======
            JsonDeserializer<?> valueDeser, Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = unwrapSingle;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            JsonDeserializer<?> valueDeser)
=======
            JsonDeserializer<?> valueDeser, Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        if ((_valueDeserializer == valueDeser) && (_delegateDeserializer == delegateDeser)) {
=======
        if ((_unwrapSingle == unwrapSingle)
                && (_valueDeserializer == valueDeser) && (_delegateDeserializer == delegateDeser)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                _valueInstantiator, delegateDeser, valueDeser);
=======
                _valueInstantiator, delegateDeser, valueDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            // #125: May have a content converter
=======
            // [databind#125]: May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        } 
=======
        }
        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
        //   comes down to "List vs Collection" I suppose... for now, pass Collection
        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        return withResolved(delegate, valueDeser);
=======
        return withResolved(delegate, valueDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt)
=======
    public Collection<String> deserialize(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                    _delegateDeserializer.deserialize(jp, ctxt));
=======
                    _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        return deserialize(jp, ctxt, result);
=======
        return deserialize(p, ctxt, result);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt,
=======
    public Collection<String> deserialize(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt, result);
=======
        if (!p.isExpectedStartArrayToken()) {
            return handleNonArray(p, ctxt, result);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer);
=======
            return deserializeUsingCustom(p, ctxt, result, _valueDeserializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                String value = jp.nextTextValue();
=======
                String value = p.nextTextValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                JsonToken t = jp.getCurrentToken();
=======
                JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                    value = _parseString(jp, ctxt);
=======
                    value = _parseString(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt,
=======
    private Collection<String> deserializeUsingCustom(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            if (jp.nextTextValue() == null) {
                JsonToken t = jp.getCurrentToken();
=======
            if (p.nextTextValue() == null) {
                JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt);
=======
                value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
                value = deser.deserialize(jp, ctxt);
=======
                value = deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
        return typeDeserializer.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
    private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException
=======
    private final Collection<String> handleNonArray(JsonParser p, DeserializationContext ctxt, Collection<String> result) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        // [JACKSON-526]: implicit arrays from single values?
        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
=======
        // implicit arrays from single values?
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (!canWrap) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
        JsonToken t = jp.getCurrentToken();
=======
        JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
            value = (valueDes == null) ? _parseString(jp, ctxt) : valueDes.deserialize(jp, ctxt);
=======
            value = (valueDes == null) ? _parseString(p, ctxt) : valueDes.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            return _deserializeUsingPropertyBased(jp, ctxt);
=======
            return _deserializeUsingPropertyBased(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                    _delegateDeserializer.deserialize(jp, ctxt));
=======
                    _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            throw JsonMappingException.from(jp, "Can not instantiate abstract type "+_beanType
=======
            throw JsonMappingException.from(p, "Can not instantiate abstract type "+_beanType
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            throw new JsonMappingException("Can not deserialize Throwable of type "+_beanType
=======
            throw JsonMappingException.from(p,"Can not deserialize Throwable of type "+_beanType
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {
            String propName = jp.getCurrentName();
=======
        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {
            String propName = p.getCurrentName();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            jp.nextToken(); // to point to field value
=======
            p.nextToken(); // to point to field value
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                    prop.deserializeAndSet(jp, ctxt, throwable);
=======
                    prop.deserializeAndSet(p, ctxt, throwable);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                pending[pendingIx++] = prop.deserialize(jp, ctxt);
=======
                pending[pendingIx++] = prop.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());
=======
                    throwable = _valueInstantiator.createFromString(ctxt, p.getText());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                jp.skipChildren();
=======
                p.skipChildren();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);
=======
                _anySetter.deserializeAndSet(p, ctxt, throwable, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java;<<<<<<< MINE
            handleUnknownProperty(jp, ctxt, throwable, propName);
=======
            handleUnknownProperty(p, ctxt, throwable, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
=======
        if ((valueDeser == _valueDeserializer) && (typeDeser == _valueTypeDeserializer)) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
=======
        } else { // otherwise directly assigned, probably not contextual yet:
            deser = ctxt.handleSecondaryContextualization(deser, property, _referencedType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
        if (deser == _valueDeserializer && typeDeser == _valueTypeDeserializer) {
            return this;
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
    public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
        /* 06-Nov-2013, tatu: Looks like the only way to make polymorphic deser to work
         *   correctly is to add support here; problem being that handler is not available
         *   for nominal type of AtomicReference but only "contained" type...
         */
        if (_valueTypeDeserializer != null) {
            return new AtomicReference<Object>(_valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer));
        }
        return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt));
=======
    public AtomicReference<?> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
        Object contents = (_valueTypeDeserializer == null)
                ? _valueDeserializer.deserialize(p, ctxt)
                : _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
        return new AtomicReference<Object>(contents);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
    public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt,
            TypeDeserializer typeDeserializer) throws IOException {
        return (Object[]) typeDeserializer.deserializeTypedFromAny(jp, ctxt);
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
            TypeDeserializer typeDeserializer) throws IOException
    {
        final JsonToken t = p.getCurrentToken();
        if (t == JsonToken.VALUE_NULL) { // can this actually happen?
            return getNullValue(ctxt);
        }
        // 22-Oct-2015, tatu: This handling is probably not needed (or is wrong), but
        //   could be result of older (pre-2.7) Jackson trying to serialize natural types.
        //  Because of this, let's allow for now, unless proven problematic
        if ((t != null) && t.isScalarValue()) {
            return deserialize(p, ctxt);
        }
        // andn this is what should really happen
        return typeDeserializer.deserializeTypedFromAny(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java;<<<<<<< MINE
            if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
=======
            if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.JsonTokenId;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonMappingException;
=======
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
=======

        @Override
        public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {
            // [databind#1095]: Should not allow coercion from into null from Empty String
            // either, if `null` not allowed
            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {
                throw ctxt.mappingException(
                        "Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)",
                        handledType().toString());
            }
            return _nullValue;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
        // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
=======
        // Since we can never have type info ("natural type"; String, Boolean, Integer, Double):
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
            throws IOException, JsonProcessingException
=======
            throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
            throws IOException, JsonProcessingException
=======
            throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
        // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
=======
        // Since we can never have type info ("natural type"; String, Boolean, Integer, Double):
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
        // 1.6: since we can never have type info ("natural type"; String, Boolean, Integer, Double):
=======
        // Since we can never have type info ("natural type"; String, Boolean, Integer, Double):
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java;<<<<<<< MINE
     * Since 1.5, there is one additional complication: some numeric
=======
     * There is one additional complication: some numeric
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
=======
    /**
     * Specific override for this instance (from proper, or global per-type overrides)
     * to indicate whether single value may be taken to mean an unwrapped one-element array
     * or not. If null, left to global defaults.
     *
     * @since 2.7
     */
    protected final Boolean _unwrapSingle;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
=======
    protected ObjectArrayDeserializer(ObjectArrayDeserializer base,
            JsonDeserializer<Object> elemDeser, TypeDeserializer elemTypeDeser,
            Boolean unwrapSingle)
    {
        super(base._arrayType);
        _arrayType = base._arrayType;
        _elementClass = base._elementClass;
        _untyped = base._untyped;

        _elementDeserializer = elemDeser;
        _elementTypeDeserializer = elemTypeDeser;
        _unwrapSingle = unwrapSingle;
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    @SuppressWarnings("unchecked")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        if ((elemDeser == _elementDeserializer) && (elemTypeDeser == _elementTypeDeserializer)) {
=======
        return withResolved(elemTypeDeser, elemDeser, _unwrapSingle);
    }

    /**
     * @since 2.7
     */
    @SuppressWarnings("unchecked")
    public ObjectArrayDeserializer withResolved(TypeDeserializer elemTypeDeser,
            JsonDeserializer<?> elemDeser, Boolean unwrapSingle)
    {
        if ((unwrapSingle == _unwrapSingle)
                && (elemDeser == _elementDeserializer)
                && (elemTypeDeser == _elementTypeDeserializer)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        return new ObjectArrayDeserializer(_arrayType,
                (JsonDeserializer<Object>) elemDeser, elemTypeDeser);
=======
        return new ObjectArrayDeserializer(this,
                (JsonDeserializer<Object>) elemDeser, elemTypeDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        // #125: May have a content converter
=======
        Boolean unwrapSingle = findFormatFeature(ctxt, property, _arrayType.getRawClass(),
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
        // May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        return withDeserializer(elemTypeDeser, deser);
=======
        return withResolved(elemTypeDeser, deser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    public Object[] deserialize(JsonParser jp, DeserializationContext ctxt)
        throws IOException, JsonProcessingException
=======
    public Object[] deserialize(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt);
=======
        if (!p.isExpectedStartArrayToken()) {
            return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
=======
            while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
                    value = _elementDeserializer.deserialize(jp, ctxt);
=======
                    value = _elementDeserializer.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
                    value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser);
=======
                    value = _elementDeserializer.deserializeWithType(p, ctxt, typeDeser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt,
=======
    public Object[] deserializeWithType(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        return (Object[]) typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
        return (Object[]) typeDeserializer.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    protected Byte[] deserializeFromBase64(JsonParser jp, DeserializationContext ctxt)
        throws IOException, JsonProcessingException
=======
    protected Byte[] deserializeFromBase64(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        byte[] b = jp.getBinaryValue(ctxt.getBase64Variant());
=======
        byte[] b = p.getBinaryValue(ctxt.getBase64Variant());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt)
        throws IOException, JsonProcessingException
=======
    protected Object[] handleNonArray(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        // [JACKSON-620] Empty String can become null...
        if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
=======
        // Empty String can become null...
        if (p.hasToken(JsonToken.VALUE_STRING)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
            String str = jp.getText();
=======
            String str = p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
            /* 04-Oct-2009, tatu: One exception; byte arrays are generally
             *   serialized as base64, so that should be handled
             */
            if (jp.getCurrentToken() == JsonToken.VALUE_STRING
                && _elementClass == Byte.class) {
                return deserializeFromBase64(jp, ctxt);
=======
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (!canWrap) {
            // One exception; byte arrays are generally serialized as base64, so that should be handled
            if (p.getCurrentToken() == JsonToken.VALUE_STRING
                    // note: not `byte[]`, but `Byte[]` -- former is primitive array
                    && _elementClass == Byte.class) {
                return deserializeFromBase64(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        JsonToken t = jp.getCurrentToken();
=======
        JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
            value = _elementDeserializer.deserialize(jp, ctxt);
=======
            value = _elementDeserializer.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
            value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer);
=======
            value = _elementDeserializer.deserializeWithType(p, ctxt, _elementTypeDeserializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    private static final long serialVersionUID = 1L;
=======
    private static final long serialVersionUID = 2L;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
=======
    /**
     * Specific override for this instance (from proper, or global per-type overrides)
     * to indicate whether single value may be taken to mean an unwrapped one-element array
     * or not. If null, left to global defaults.
     *
     * @since 2.7
     */
    protected final Boolean _unwrapSingle;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
        super(String[].class);
        _elementDeserializer = null;
=======
        this(null, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    protected StringArrayDeserializer(JsonDeserializer<?> deser) {
=======
    protected StringArrayDeserializer(JsonDeserializer<?> deser, Boolean unwrapSingle) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = unwrapSingle;
    }

    /**
     * Contextualization is needed to see whether we can "inline" deserialization
     * of String values, or if we have to use separate value deserializer.
     */
    @Override
    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException
    {
        JsonDeserializer<?> deser = _elementDeserializer;
        // May have a content converter
        deser = findConvertingContentDeserializer(ctxt, property, deser);
        JavaType type = ctxt.constructType(String.class);
        if (deser == null) {
            deser = ctxt.findContextualValueDeserializer(type, property);
        } else { // if directly assigned, probably not yet contextual, so:
            deser = ctxt.handleSecondaryContextualization(deser, property, type);
        }
        // One more thing: allow unwrapping?
        Boolean unwrapSingle = findFormatFeature(ctxt, property, String[].class,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
        // Ok ok: if all we got is the default String deserializer, can just forget about it
        if ((deser != null) && isDefaultDeserializer(deser)) {
            deser = null;
        }
        if ((_elementDeserializer == deser) && (_unwrapSingle == unwrapSingle)) {
            return this;
        }
        return new StringArrayDeserializer(deser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
   
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public String[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt);
=======
        if (!p.isExpectedStartArrayToken()) {
            return handleNonArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
            return _deserializeCustom(jp, ctxt);
=======
            return _deserializeCustom(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                String value = jp.nextTextValue();
=======
                String value = p.nextTextValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                    JsonToken t = jp.getCurrentToken();
=======
                    JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                        value = _parseString(jp, ctxt);
=======
                        value = _parseString(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected final String[] _deserializeCustom(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                if (jp.nextTextValue() == null) {
                    JsonToken t = jp.getCurrentToken();
=======
                if (p.nextTextValue() == null) {
                    JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                    value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt);
=======
                    value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                    value = deser.deserialize(jp, ctxt);
=======
                    value = deser.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return typeDeserializer.deserializeTypedFromArray(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    private final String[] handleNonArray(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
        // [JACKSON-526]: implicit arrays from single values?
        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
=======
        // implicit arrays from single values?
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (canWrap) {
            return new String[] { p.hasToken(JsonToken.VALUE_NULL) ? null : _parseString(p, ctxt) };
        } else if (p.hasToken(JsonToken.VALUE_STRING)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
                String str = jp.getText();
                if (str.length() == 0) {
                    return null;
                }
=======
            String str = p.getText();
            if (str.length() == 0) {
                return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
            throw ctxt.mappingException(_valueClass);
        }
        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };
    }

    /**
     * Contextualization is needed to see whether we can "inline" deserialization
     * of String values, or if we have to use separate value deserializer.
     */
    @Override
    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException
    {
        JsonDeserializer<?> deser = _elementDeserializer;
        // #125: May have a content converter
        deser = findConvertingContentDeserializer(ctxt, property, deser);
        JavaType type = ctxt.constructType(String.class);
        if (deser == null) {
            deser = ctxt.findContextualValueDeserializer(type, property);
        } else { // if directly assigned, probably not yet contextual, so:
            deser = ctxt.handleSecondaryContextualization(deser, property, type);
        }
        // Ok ok: if all we got is the default String deserializer, can just forget about it
        if (deser != null && this.isDefaultDeserializer(deser)) {
            deser = null;
        }
        if (_elementDeserializer != deser) {
            return new StringArrayDeserializer(deser);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
        return this;
=======
        throw ctxt.mappingException(_valueClass);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
import java.lang.reflect.InvocationTargetException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======

    // // // Array delegate construction

    protected JavaType _arrayDelegateType;
    protected AnnotatedWithParams _arrayDelegateCreator;
    protected SettableBeanProperty[] _arrayDelegateArguments;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======

        _arrayDelegateType = src._arrayDelegateType;
        _arrayDelegateCreator = src._arrayDelegateCreator;
        _arrayDelegateArguments = src._arrayDelegateArguments;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
    public void configureFromArraySettings(
            AnnotatedWithParams arrayDelegateCreator,
            JavaType arrayDelegateType,
            SettableBeanProperty[] arrayDelegateArgs)
    {
        _arrayDelegateCreator = arrayDelegateCreator;
        _arrayDelegateType = arrayDelegateType;
        _arrayDelegateArguments = arrayDelegateArgs;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======

    @Override
    public boolean canCreateUsingArrayDelegate() {
        return _arrayDelegateType != null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
    public JavaType getArrayDelegateType(DeserializationConfig config) {
        return _arrayDelegateType;
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
        } catch (Exception e) {
            throw wrapException(e);
=======
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
        } catch (Exception e) {
            throw wrapException(e);
=======
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        if (_delegateCreator == null) { // sanity-check; caller should check
            throw new IllegalStateException("No delegate constructor for "+getValueTypeDesc());
        }
        try {
            // First simple case: just delegate, no injectables
            if (_delegateArguments == null) {
                return _delegateCreator.call1(delegate);
            }
            // And then the case with at least one injectable...
            final int len = _delegateArguments.length;
            Object[] args = new Object[len];
            for (int i = 0; i < len; ++i) {
                SettableBeanProperty prop = _delegateArguments[i];
                if (prop == null) { // delegate
                    args[i] = delegate;
                } else { // nope, injectable:
                    args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null);
                }
            }
            // and then try calling with full set of arguments
            return _delegateCreator.call(args);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
        } catch (Exception e) {
            throw wrapException(e);
=======
        return _createUsingDelegate(_delegateCreator, _delegateArguments, ctxt, delegate);
    }

    @Override
    public Object createUsingArrayDelegate(DeserializationContext ctxt, Object delegate) throws IOException
    {
        if (_arrayDelegateCreator == null) { // sanity-check; caller should check
            // fallback to the classic delegate creator
            return createUsingDelegate(ctxt, delegate);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        return _createUsingDelegate(_arrayDelegateCreator, _arrayDelegateArguments, ctxt, delegate);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        if (_fromStringCreator != null) {
            try {
                return _fromStringCreator.call1(value);
            } catch (Exception e) {
                throw wrapException(e);
            } catch (ExceptionInInitializerError e) {
                throw wrapException(e);
            }
=======
        if (_fromStringCreator == null) {
            return _createFromStringFallbacks(ctxt, value);
        }
        try {
            return _fromStringCreator.call1(value);
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        return _createFromStringFallbacks(ctxt, value);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        } catch (Exception e) {
            throw wrapException(e);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
=======
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        if (_fromLongCreator == null) {
            throw ctxt.mappingException("Can not instantiate value of type %s"
                    +" from Long integral number (%s); no single-long-arg constructor/factory method",
                    getValueTypeDesc(), value);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
            if (_fromLongCreator != null) {
                return _fromLongCreator.call1(Long.valueOf(value));
            }
        } catch (Exception e) {
            throw wrapException(e);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
=======
            return _fromLongCreator.call1(Long.valueOf(value));
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        throw ctxt.mappingException("Can not instantiate value of type %s"
                +" from Long integral number (%s); no single-long-arg constructor/factory method",
                getValueTypeDesc(), value);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        if (_fromDoubleCreator == null) {
            throw ctxt.mappingException("Can not instantiate value of type %s"
                    +" from Floating-point number (%s); no one-double/Double-arg constructor/factory method",
                    getValueTypeDesc(), value);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
            if (_fromDoubleCreator != null) {
                return _fromDoubleCreator.call1(Double.valueOf(value));
            }
        } catch (Exception e) {
            throw wrapException(e);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
=======
            return _fromDoubleCreator.call1(Double.valueOf(value));
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        throw ctxt.mappingException("Can not instantiate value of type %s"
                +" from Floating-point number (%s); no one-double/Double-arg constructor/factory method",
                getValueTypeDesc(), value);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        if (_fromBooleanCreator == null) {
            throw ctxt.mappingException("Can not instantiate value of type %s"
                    +" from Boolean value (%s); no single-boolean/Boolean-arg constructor/factory method",
                    getValueTypeDesc(), value);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
            if (_fromBooleanCreator != null) {
                return _fromBooleanCreator.call1(Boolean.valueOf(value));
            }
        } catch (Exception e) {
            throw wrapException(e);
        } catch (ExceptionInInitializerError e) {
            throw wrapException(e);
=======
            return _fromBooleanCreator.call1(Boolean.valueOf(value));
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        throw ctxt.mappingException("Can not instantiate value of type %s"
                +" from Boolean value (%s); no single-boolean/Boolean-arg constructor/factory method",
                getValueTypeDesc(), value);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
    public AnnotatedWithParams getArrayDelegateCreator() {
        return _arrayDelegateCreator;
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7 call either {@link #unwrapAndWrapException} or
     *  {@link #wrapAsJsonMappingException}
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        while (t.getCause() != null) {
            t = t.getCause();
=======
        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only
        //   does so if and until `JsonMappingException` is found.
        for (Throwable curr = t; curr != null; curr = curr.getCause()) {
            if (curr instanceof JsonMappingException) {
                return (JsonMappingException) curr;
            }
        }
        return new JsonMappingException(null,
                "Instantiation of "+getValueTypeDesc()+" value failed: "+t.getMessage(), t);
    }

    /**
     * @since 2.7
     */
    protected JsonMappingException unwrapAndWrapException(DeserializationContext ctxt, Throwable t)
    {
        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only
        //   does so if and until `JsonMappingException` is found.
        for (Throwable curr = t; curr != null; curr = curr.getCause()) {
            if (curr instanceof JsonMappingException) {
                return (JsonMappingException) curr;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        String msg = String.format("Instantiation of %s value failed (%s): %s",
                getValueTypeDesc(), t.getClass().getName(), t.getMessage());
        return JsonMappingException.from(ctxt.getParser(), msg, t);
    }

    /**
     * @since 2.7
     */
    protected JsonMappingException wrapAsJsonMappingException(DeserializationContext ctxt,
            Throwable t)
    {
        // 05-Nov-2015, tatu: Only avoid wrapping if already a JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        return new JsonMappingException("Instantiation of "+getValueTypeDesc()+" value failed: "+t.getMessage(), t);
=======
        String msg = String.format("Instantiation of %s value failed (%s): %s",
                getValueTypeDesc(), t.getClass().getName(), t.getMessage());
        return JsonMappingException.from(ctxt.getParser(), msg, t);
    }

    /**
     * @since 2.7
     */
    protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt,
            Throwable t)
    {
        // 05-Nov-2015, tatu: Seems like there are really only 2 useless wrapper errors/exceptions,
        //    so just peel those, and nothing else
        if ((t instanceof ExceptionInInitializerError) // from static initialization block
                || (t instanceof InvocationTargetException) // from constructor/method
                ) {
            Throwable cause = t.getCause();
            if (cause != null) {
                t = cause;
            }
        }
        return wrapAsJsonMappingException(ctxt, t);
    }

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    private Object _createUsingDelegate(
            AnnotatedWithParams delegateCreator,
            SettableBeanProperty[] delegateArguments,
            DeserializationContext ctxt,
            Object delegate)
            throws IOException
    {
        if (delegateCreator == null) { // sanity-check; caller should check
            throw new IllegalStateException("No delegate constructor for "+getValueTypeDesc());
        }
        try {
            // First simple case: just delegate, no injectables
            if (delegateArguments == null) {
                return delegateCreator.call1(delegate);
            }
            // And then the case with at least one injectable...
            final int len = delegateArguments.length;
            Object[] args = new Object[len];
            for (int i = 0; i < len; ++i) {
                SettableBeanProperty prop = delegateArguments[i];
                if (prop == null) { // delegate
                    args[i] = delegate;
                } else { // nope, injectable:
                    args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null);
                }
            }
            // and then try calling with full set of arguments
            return delegateCreator.call(args);
        } catch (Throwable t) {
            throw rewrapCtorProblem(ctxt, t);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
        throw new JsonMappingException(msg, p.getTokenLocation());
=======
        throw JsonMappingException.from(p, msg);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
		break;
=======
                break;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
=======
        case JsonTokenId.ID_FIELD_NAME:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
        case JsonTokenId.ID_FIELD_NAME:
            return deserializeObject(p, ctxt, nodeFactory);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
    /**
     * Specific override for this instance (from proper, or global per-type overrides)
     * to indicate whether single value may be taken to mean an unwrapped one-element array
     * or not. If null, left to global defaults.
     *
     * @since 2.7
     */
    protected final Boolean _unwrapSingle;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null);
=======
        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
            JsonDeserializer<Object> delegateDeser)
=======
            JsonDeserializer<Object> delegateDeser,
            Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = unwrapSingle;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = src._unwrapSingle;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
            JsonDeserializer<?> vd, TypeDeserializer vtd)
=======
            JsonDeserializer<?> vd, TypeDeserializer vtd,
            Boolean unwrapSingle)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) {
=======
        if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)
                && (_unwrapSingle == unwrapSingle)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
                _valueInstantiator, (JsonDeserializer<Object>) dd);
=======
                _valueInstantiator, (JsonDeserializer<Object>) dd, unwrapSingle);
    }

    /**
     * @deprecated Since 2.7 as it does not pass `unwrapSingle`
     */
    @Deprecated // since 2.7 -- will not retain "unwrapSingle" setting
    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd,
            JsonDeserializer<?> vd, TypeDeserializer vtd)
    {
        return withResolved(dd, vd, vtd, _unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
        // [databind#1043]: allow per-property allow-wrapping of single overrides:
        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
        //   comes down to "List vs Collection" I suppose... for now, pass Collection
        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        // #125: May have a content converter
=======
        // May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        return withResolved(delegateDeser, valueDeser, valueTypeDeser);
=======
        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        if (p.getCurrentToken() == JsonToken.VALUE_STRING) {
=======
        if (p.hasToken(JsonToken.VALUE_STRING)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
        // [JACKSON-526]: implicit arrays from single values?
        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
=======
        // Implicit arrays from single values?
        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                ((_unwrapSingle == null) &&
                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
        if (!canWrap) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java;<<<<<<< MINE
 * so that other classes can access information about contained (value)
 * types
=======
 * so that other classes can access information about contained (value) types
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java;<<<<<<< MINE
    /**
     * @deprecated Since 2.3 use one that takes {@link JavaType}
     */
    @Deprecated
    protected ContainerDeserializerBase(Class<?> selfType) {
        super(selfType);
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
            jp.nextToken();
            final T value = deserialize(jp, ctxt);
            if (jp.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, 
=======
        if (p.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
            p.nextToken();
            final T value = deserialize(p, ctxt);
            if (p.nextToken() != JsonToken.END_ARRAY) {
                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
        String text = jp.getValueAsString();
=======
        String text = p.getValueAsString();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {
=======
        if (p.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
            Object ob = jp.getEmbeddedObject();
=======
            Object ob = p.getEmbeddedObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java;<<<<<<< MINE
                        throw new InvalidFormatException("Bracketed IPv6 address must contain closing bracket",
=======
                        throw new InvalidFormatException(ctxt.getParser(),
                                "Bracketed IPv6 address must contain closing bracket",
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,
=======
    public void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
        Object value = deserialize(jp, ctxt);
=======
        Object value = deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
            _throwAsIOE(e, value);
=======
            _throwAsIOE(p, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
    public Object deserializeSetAndReturn(JsonParser jp,
=======
    public Object deserializeSetAndReturn(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
        Object value = deserialize(jp, ctxt);
=======
        Object value = deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
            _throwAsIOE(e, value);
=======
            _throwAsIOE(p, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
=======
            // 15-Sep-2015, tatu: How coud we get a ref to JsonParser?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
=======
            // 15-Sep-2015, tatu: How coud we get a ref to JsonParser?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
    public void deserializeAndSet(JsonParser jp,
=======
    public void deserializeAndSet(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
        Object value = deserialize(jp, ctxt);
=======
        Object value = deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
            _throwAsIOE(e, value);
=======
            _throwAsIOE(p, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
    public Object deserializeSetAndReturn(JsonParser jp,
=======
    public Object deserializeSetAndReturn(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
        Object value = deserialize(jp, ctxt);
=======
        Object value = deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
            _throwAsIOE(e, value);
=======
            _throwAsIOE(p, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
=======
            // 15-Sep-2015, tatu: How coud we get a ref to JsonParser?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
=======
            // 15-Sep-2015, tatu: How coud we get a ref to JsonParser?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.BeanDescription;
import com.fasterxml.jackson.databind.DeserializationConfig;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JavaType;
=======
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.TypeBindings;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
    protected final static int C_ARRAY_DELEGATE = 8;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    final protected boolean _forceAccess;
    
    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
    protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[8];
=======
    protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[9];
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
    protected SettableBeanProperty[] _arrayDelegateArgs;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
    public CreatorCollector(BeanDescription beanDesc, boolean canFixAccess)
=======
    public CreatorCollector(BeanDescription beanDesc, MapperConfig<?> config)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        _canFixAccess = canFixAccess;
=======
        _canFixAccess = config.canOverrideAccessModifiers();
        _forceAccess = config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        JavaType delegateType;
        boolean maybeVanilla = !_hasNonDefaultCreator;

        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {
            delegateType = null;
        } else {
            // need to find type...
            int ix = 0;
            if (_delegateArgs != null) {
                for (int i = 0, len = _delegateArgs.length; i < len; ++i) {
                    if (_delegateArgs[i] == null) { // marker for delegate itself
                        ix = i;
                        break;
                    }
                }
            }
            TypeBindings bindings = _beanDesc.bindingsForBeanType();
            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));
        }

=======
        final JavaType delegateType = _computeDelegateType(_creators[C_DELEGATE], _delegateArgs);
        final JavaType arrayDelegateType = _computeDelegateType(_creators[C_ARRAY_DELEGATE], _arrayDelegateArgs);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        maybeVanilla &= !_hasNonDefaultCreator;

        if (maybeVanilla) {
=======
        if (!_hasNonDefaultCreator) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
        inst.configureFromArraySettings(_creators[C_ARRAY_DELEGATE], arrayDelegateType, _arrayDelegateArgs);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        verifyNonDup(creator, C_DELEGATE, explicit);
        _delegateArgs = injectables;
=======
        if (creator.getParameterType(0).isCollectionLikeType()) {
            verifyNonDup(creator, C_ARRAY_DELEGATE, explicit);
            _arrayDelegateArgs = injectables;
        } else {
            verifyNonDup(creator, C_DELEGATE, explicit);
            _delegateArgs = injectables;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        // [JACKSON-470] Better ensure we have no duplicate names either...
=======
        // Better ensure we have no duplicate names either...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
    private JavaType _computeDelegateType(AnnotatedWithParams creator, SettableBeanProperty[] delegateArgs)
    {
        if (!_hasNonDefaultCreator || (creator == null)) {
            return null;
        } else {
            // need to find type...
            int ix = 0;
            if (delegateArgs != null) {
                for (int i = 0, len = delegateArgs.length; i < len; ++i) {
                    if (delegateArgs[i] == null) { // marker for delegate itself
                        ix = i;
                        break;
                    }
                }
            }
            return creator.getParameterType(ix);
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
            ClassUtil.checkAndFixAccess((Member) member.getAnnotated());
=======
            ClassUtil.checkAndFixAccess((Member) member.getAnnotated(), _forceAccess);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonProcessingException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.PropertyName;
=======

import com.fasterxml.jackson.databind.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
    public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,
            Object instance)
        throws IOException, JsonProcessingException
=======
    public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
            Object instance) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
        JsonToken t = jp.getCurrentToken();
=======
        JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
            throw new JsonMappingException("Problem deserializing 'setterless' property (\""+getName()+"\"): no way to handle typed deser with setterless yet");
=======
            throw JsonMappingException.from(p,
                    "Problem deserializing 'setterless' property (\""+getName()+"\"): no way to handle typed deser with setterless yet");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
            _throwAsIOE(e);
=======
            _throwAsIOE(p, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
            throw new JsonMappingException("Problem deserializing 'setterless' property '"+getName()+"': get method returned null");
=======
            throw JsonMappingException.from(p,
                    "Problem deserializing 'setterless' property '"+getName()+"': get method returned null");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
        _valueDeserializer.deserialize(jp, ctxt, toModify);
=======
        _valueDeserializer.deserialize(p, ctxt, toModify);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
    public Object deserializeSetAndReturn(JsonParser jp,
    		DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException
=======
    public Object deserializeSetAndReturn(JsonParser p,
    		DeserializationContext ctxt, Object instance) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
        deserializeAndSet(jp, ctxt, instance);
=======
        deserializeAndSet(p, ctxt, instance);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java;<<<<<<< MINE
    
=======

    /**
     * Allow access to the resolver in case anybody wants to use it directly, for
     * examples from 
     * {@link com.fasterxml.jackson.databind.deser.DefaultDeserializationContext#tryToResolveUnresolvedObjectId}.
     *
     * @return The registered resolver
     * 
     * @since 2.7
     */
    public ObjectIdResolver getResolver() {
        return _resolver;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java;<<<<<<< MINE
     * 
     * @since 2.0
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java;<<<<<<< MINE
=======


    public abstract JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException;

    /**
     * @since 2.7
     */
    public abstract JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt,
            ReferenceType type, BeanDescription beanDesc)
        throws JsonMappingException;
    
    /**
     * Method called to create and return a deserializer that can construct
     * JsonNode(s) from JSON content.
     */
    public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java;<<<<<<< MINE
    
    public abstract JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java;<<<<<<< MINE
     * Method called to create and return a deserializer that can construct
     * JsonNode(s) from JSON content.
     */
    public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException;

    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java;<<<<<<< MINE
        ReadableObjectId entry = new ReadableObjectId(key);
=======
        ReadableObjectId entry = createReadableObjectId(key);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java;<<<<<<< MINE
    
=======

    /**
     * Overridable factory method to create a new instance of ReadableObjectId or its
     * subclass. It is meant to be overridden when custom ReadableObjectId is
     * needed for {@link #tryToResolveUnresolvedObjectId}.
     * Default implementation simply constructs default {@link ReadableObjectId} with
     * given <code>key</code>.
     * 
     * @param key The key to associate with the new ReadableObjectId
     * @return New ReadableObjectId instance
     *
     * @since 2.7
     */
    protected ReadableObjectId createReadableObjectId(IdKey key) {
        return new ReadableObjectId(key);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java;<<<<<<< MINE
                exception = new UnresolvedForwardReference("Unresolved forward references for: ");
=======
                exception = new UnresolvedForwardReference(getParser(), "Unresolved forward references for: ");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
    public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,
=======
    public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
            set(instance, propName, deserialize(jp, ctxt));
=======
            set(instance, propName, deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
                throw JsonMappingException.from(jp, "Unresolved forward reference but no identity info.", reference);
=======
                throw JsonMappingException.from(p, "Unresolved forward reference but no identity info.", reference);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
        JsonToken t = jp.getCurrentToken();
=======
        JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
            return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);
=======
            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
        return _valueDeserializer.deserialize(jp, ctxt);
=======
        return _valueDeserializer.deserialize(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
            throw new JsonMappingException(msg.toString(), null, e);
=======
            throw new JsonMappingException(null, msg.toString(), e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java;<<<<<<< MINE
        throw new JsonMappingException(t.getMessage(), null, t);
=======
        throw new JsonMappingException(null, t.getMessage(), t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.type.ReferenceType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java;<<<<<<< MINE
=======
     * @since 2.2
     */
    public JsonDeserializer<?> modifyEnumDeserializer(DeserializationConfig config,
            JavaType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {
        return deserializer;
    }

    /**
     * @since 2.7
     */
    public JsonDeserializer<?> modifyReferenceDeserializer(DeserializationConfig config,
            ReferenceType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {
        return deserializer;
    }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java;<<<<<<< MINE
     * @since 2.2
     */
    public JsonDeserializer<?> modifyEnumDeserializer(DeserializationConfig config,
            JavaType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {
        return deserializer;
    }
    
    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // then 1.6 types:
        /* 17-May-2013, tatu: [Issue#216] Should be fine to use straight Class references EXCEPT
         *   that some godforsaken platforms (... looking at you, Android) do not
=======
        // then JDK 1.6 types:
        /* 17-May-2013, tatu: [databind#216] Should be fine to use straight Class references EXCEPT
         *   that some god-forsaken platforms (... looking at you, Android) do not
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                    throw new JsonMappingException("Broken registered ValueInstantiators (of type "
                            +insts.getClass().getName()+"): returned null ValueInstantiator");
=======
                    throw JsonMappingException.from(ctxt.getParser(),
                            "Broken registered ValueInstantiators (of type "+insts.getClass().getName()+"): returned null ValueInstantiator");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        boolean fixAccess = ctxt.canOverrideAccessModifiers();
        CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);
=======
        CreatorCollector creators =  new CreatorCollector(beanDesc, ctxt.getConfig());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            
        JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());
=======
        // 15-Oct-2015, tatu: Not 100% if context needed; removing it does not make any
        //    existing unit tests fail. Still seems like the right thing to do.
        JavaType t0 = beanDesc.resolveType(param.getParameterType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:
=======
        // Then optional type info: if type has been resolved, we may already know type deserializer:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                    // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled
=======
                    // [databind#292]: Actually, may be fine, but only if polymorphich deser enabled
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                    // [Issue#161]: No default constructor for ArrayBlockingQueue...
=======
                    // [databind#161]: No default constructor for ArrayBlockingQueue...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);
=======
                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:
=======
                // Can use more optimal deserializer if content type is String, so:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // and then new with 2.2: ability to post-process it too (Issue#120)
=======
        // allow post-processing it too
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    /* JsonDeserializerFactory impl: Enum deserializers
=======
    /* JsonDeserializerFactory impl: other types
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            // [JACKSON-193] May have @JsonCreator for static factory method:
=======
            // May have @JsonCreator for static factory method:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            // [JACKSON-749] Also, need to consider @JsonValue, if one found
=======
            // Need to consider @JsonValue if one found
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // and then new with 2.2: ability to post-process it too (Issue#120)
=======
        // and then post-process it too
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    
    /*
    /**********************************************************
    /* JsonDeserializerFactory impl: Tree deserializers
    /**********************************************************
     */
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    
=======

    @Override
    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt,
            ReferenceType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        JavaType contentType = type.getContentType();
        // Very first thing: is deserializer hard-coded for elements?
        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();
        final DeserializationConfig config = ctxt.getConfig();

        // Then optional type info: if type has been resolved, we may already know type deserializer:
        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();
        if (contentTypeDeser == null) { // or if not, may be able to find:
            contentTypeDeser = findTypeDeserializer(config, contentType);
        }
        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,
                contentTypeDeser, contentDeser);
        if (deser == null) {
            // Just one referential type as of JDK 1.7 / Java 7: AtomicReference (Java 8 adds Optional)
            if (AtomicReference.class.isAssignableFrom(type.getRawClass())) {
                JavaType referencedType = type.getReferencedType();
                /*
                TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);
                BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);
                JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());
                */
                return new AtomicReferenceDeserializer(referencedType, contentTypeDeser, deser);
            }
        }
        if (deser != null) {
            // and then post-process
            if (_factoryConfig.hasDeserializerModifiers()) {
                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                    deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);
                }
            }
        }
        return deser;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-505]: May need to figure out default implementation, if none found yet
=======
        // May need to figure out default implementation, if none found yet
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-193] May have @JsonCreator for static factory method:
=======
        // May have @JsonCreator for static factory method:
        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {
=======
            if (ai.hasCreatorAnnotation(factory)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                        if (factory.getGenericParameterType(0) != String.class) {
=======
                        if (factory.getRawParameterType(0) != String.class) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                            ClassUtil.checkAndFixAccess(factory.getMember());
=======
                            ClassUtil.checkAndFixAccess(factory.getMember(),
                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        
        if (type.isReferenceType()) {
            JavaType referencedType = type.getReferencedType();
            if (AtomicReference.class.isAssignableFrom(rawType)) {
                TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);
                BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);
                JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());
                return new AtomicReferenceDeserializer(referencedType, vts, deser);
            }
            // Hmmh. Should we continue here for unknown referential types?
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,
=======
    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException
    {
        for (Deserializers d  : _factoryConfig.deserializers()) {
            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);
            if (deser != null) {
                return deser;
            }
        }
        return null;
    }

    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
=======
            TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,
                    beanDesc, elementTypeDeserializer, elementDeserializer);
=======
            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,
                    contentTypeDeserializer, contentDeserializer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
=======
    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,
            DeserializationConfig config, BeanDescription beanDesc,
            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
        throws JsonMappingException
    {
        for (Deserializers d  : _factoryConfig.deserializers()) {
            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,
                    beanDesc, elementTypeDeserializer, elementDeserializer);
            if (deser != null) {
                return deser;
            }
        }
        return null;
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException
    {
        for (Deserializers d  : _factoryConfig.deserializers()) {
            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);
            if (deser != null) {
                return deser;
            }
        }
        return null;
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // first: let's check class for the instance itself:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        Class<?> subclass = intr.findDeserializationType(a, type);
        if (subclass != null) {
            try {
                type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method '"+a.getName()+"': "+iae.getMessage(), null, iae);
            }
=======
        if (intr == null) {
            return type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapLikeType)) {
                    throw new JsonMappingException("Illegal key-type annotation: type "+type+" is not a Map(-like) type");
                }
                try {
                    type = (T) ((MapLikeType) type).narrowKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException("Failed to narrow key type "+type+" with key-type annotation ("+keyClass.getName()+"): "+iae.getMessage(), null, iae);
                }
            }
=======
        // First, deserializers for key/value types?
        if (type.isMapLikeType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
             *   (not 100% why or how, but this does seem to get called more than once, which
             *   is not good: for now, let's just avoid errors)
             */
=======
            // 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
            //  (not 100% why or how, but this does seem to get called more than once, which
            //   is not good: for now, let's just avoid errors)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
           
           // and finally content class; only applicable to structured types
           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
           if (cc != null) {
               try {
                   type = (T) type.narrowContentsBy(cc);
               } catch (IllegalArgumentException iae) {
                   throw new JsonMappingException("Failed to narrow content type "+type+" with content-type annotation ("+cc.getName()+"): "+iae.getMessage(), null, iae);
               }
           }
=======
        }
        JavaType contentType = type.getContentType();
        if (contentType != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
           JavaType contentType = type.getContentType();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
=======
        // then: type refinement(s)?
        type = (T) intr.refineDeserializationType(ctxt.getConfig(), a, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-154]: Also need to handle keyUsing, contentUsing
        if (type.isContainerType()) {
            AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
=======
        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
        if (intr == null) {
            return type;
        }
        
        // Also need to handle keyUsing, contentUsing

        if (type.isMapLikeType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
            // and all container types have content types...
=======
        }

        if (type.getContentType() != null) { // container type or reference type
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(accessor);
=======
                ClassUtil.checkAndFixAccess(accessor, config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-212]: may need to use Enum.toString()
=======
        // May need to use Enum.toString()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
                deser = _handleUnknownValueDeserializer(propertyType);
=======
                deser = _handleUnknownValueDeserializer(ctxt, propertyType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            return _handleUnknownKeyDeserializer(type);
=======
            return _handleUnknownKeyDeserializer(ctxt, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            throw new JsonMappingException(iae.getMessage(), null, iae);
=======
            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
=======
        if (type.isReferenceType()) {
            return factory.createReferenceDeserializer(ctxt, (ReferenceType) type, beanDesc);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        // first: let's check class for the instance itself:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        Class<?> subclass = intr.findDeserializationType(a, type);
        if (subclass != null) {
            try {
                type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException("Failed to narrow type "+type+" with concrete-type annotation (value "+subclass.getName()+"), method '"+a.getName()+"': "+iae.getMessage(), null, iae);
            }
=======
        if (intr == null) {
            return type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapLikeType)) {
                    throw new JsonMappingException("Illegal key-type annotation: type "+type+" is not a Map(-like) type");
                }
                try {
                    type = ((MapLikeType) type).narrowKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException("Failed to narrow key type "+type+" with key-type annotation ("+keyClass.getName()+"): "+iae.getMessage(), null, iae);
                }
            }
=======
        // First things first: find explicitly annotated deserializer(s)

        // then key/value handlers  (annotated deserializers)?
        if (type.isMapLikeType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
             *   (not 100% why or how, but this does seem to get called more than once, which
             *   is not good: for now, let's just avoid errors)
             */
=======
            // 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
            //   (not 100% why or how, but this does seem to get called more than once, which
            //   is not good: for now, let's just avoid errors)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            
            // and finally content class; only applicable to structured types
            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
            if (cc != null) {
                try {
                    type = type.narrowContentsBy(cc);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException("Failed to narrow content type "+type+" with content-type annotation ("+cc.getName()+"): "+iae.getMessage(), null, iae);
                }
            }
            // ... as well as deserializer for contents:
            JavaType contentType = type.getContentType();
=======
        }
        JavaType contentType = type.getContentType();
        if (contentType != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
=======

        // And after handlers, possible type refinements
        // (note: could possibly avoid this if explicit deserializer was invoked?)
        type = intr.refineDeserializationType(ctxt.getConfig(), a, type);
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)
        throws JsonMappingException
=======
    // NOTE: changed 2.6 -> 2.7 to pass context; no way to make backwards compatible
    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type)
            throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
            throw new JsonMappingException("Can not find a Value deserializer for abstract type "+type);
=======
            throw JsonMappingException.from(ctxt, "Can not find a Value deserializer for abstract type "+type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        throw new JsonMappingException("Can not find a Value deserializer for type "+type);
=======
        throw JsonMappingException.from(ctxt, "Can not find a Value deserializer for type "+type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)
=======
    protected KeyDeserializer _handleUnknownKeyDeserializer(DeserializationContext ctxt, JavaType type)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        throw new JsonMappingException("Can not find a (Map) Key deserializer for type "+type);
=======
        throw JsonMappingException.from(ctxt, "Can not find a (Map) Key deserializer for type "+type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
     * For 2.7?
=======
     * For 2.8?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
        JsonToken t = p.getCurrentToken();
        return _deserializeOther(p, ctxt, t);
=======
        return _deserializeOther(p, ctxt, p.getCurrentToken());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
=======

        case VALUE_NULL:
            return deserializeFromNull(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            throw ctxt.mappingException(handledType());
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
=======
        throw ctxt.mappingException(handledType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
=======
    /**
     * Helper method called for rare case of pointing to {@link JsonToken#VALUE_NULL}
     * token. While this is most often an erroneous condition, there is one specific
     * case with XML handling where polymorphic type with no properties is exposed
     * as such, and should be handled same as empty Object.
     *
     * @since 2.7
     */
    protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic
        //   "empty" POJOs deserialized from XML, where empty XML tag synthesizes a
        //   `VALUE_NULL` token.
        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...
            @SuppressWarnings("resource")
            TokenBuffer tb = new TokenBuffer(p, ctxt);
            tb.writeEndObject();
            JsonParser p2 = tb.asParser(p);
            p2.nextToken(); // to point to END_OBJECT
            // note: don't have ObjectId to consider at this point, so:
            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)
                    : deserializeFromObject(p2, ctxt);
            p2.close();
            return ob;
        }
        throw ctxt.mappingException(handledType());
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            // ignorable things should be ignored
=======
            // Things marked as ignorable should not be passed to any setter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE

            /* As per [JACKSON-313], things marked as ignorable should not be
             * passed to any setter
             */
=======
            // Things marked as ignorable should not be passed to any setter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            /* As per [JACKSON-313], things marked as ignorable should not be
             * passed to any setter
             */
=======
            // Things marked as ignorable should not be passed to any setter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java;<<<<<<< MINE
=======
     * Method that can be called to check whether a array-delegate-based creator
     * (single-arg constructor or factory method)
     * is available for this instantiator
     */
    public boolean canCreateUsingArrayDelegate() { return false; }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java;<<<<<<< MINE
=======

    /**
     * Method that can be used to determine what is the type of array delegate
     * type to use, if any; if no delegates are used, will return null. If
     * non-null type is returned, deserializer will bind JSON into specified
     * type (using standard deserializer for that type), and pass that to
     * instantiator.
     */
    public JavaType getArrayDelegateType(DeserializationConfig config) { return null; }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java;<<<<<<< MINE
=======
    /**
     * Method to called to create value instance from JSON Array using
     * an intermediate "delegate" value to pass to createor method
     */
    public Object createUsingArrayDelegate(DeserializationContext ctxt, Object delegate) throws IOException {
        throw ctxt.mappingException("Can not instantiate value of type %s using delegate",
                getValueTypeDesc());
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java;<<<<<<< MINE
=======
     * static factory method) that is used as the "array delegate creator".
     * Note that implementations not required to return actual object
     * they use (or, they may use some other instantiation) method.
     * That is, even if {@link #canCreateUsingArrayDelegate()} returns true,
     * this method may return null .
     */
    public AnnotatedWithParams getArrayDelegateCreator() { return null; }

    /**
     * Method that can be called to try to access member (constructor,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.JsonParser.NumberType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    
=======

    /**
     * Deserializer that is used iff array-delegate-based creator
     * is to be used for deserializing from JSON Object.
     */
    protected JsonDeserializer<Object> _arrayDelegateDeserializer;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                // [Issue#125]: allow use of converters
=======
                // [databind#125]: allow use of converters
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();
            // Need to create a temporary property to allow contextual deserializers:
            BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME,
                    delegateType, null, _classAnnotations, delegateCreator,
                    PropertyMetadata.STD_OPTIONAL);

            TypeDeserializer td = delegateType.getTypeHandler();
            if (td == null) {
                td = ctxt.getConfig().findTypeDeserializer(delegateType);
            }
            JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);
            if (td != null) {
                td = td.forProperty(property);
                dd = new TypeWrappedDeserializer(td, dd);
=======
            _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,
                    _valueInstantiator.getDelegateCreator());
        }

        // and array-delegate-based constructor:
        if (_valueInstantiator.canCreateUsingArrayDelegate()) {
            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());
            if (delegateType == null) {
                throw new IllegalArgumentException("Invalid array-delegate-creator definition for "+_beanType
                        +": value instantiator ("+_valueInstantiator.getClass().getName()
                        +") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            _delegateDeserializer = dd;
=======
            _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,
                    _valueInstantiator.getArrayDelegateCreator());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
=======
    private JsonDeserializer<Object> _findDelegateDeserializer(DeserializationContext ctxt, JavaType delegateType,
            AnnotatedWithParams delegateCreator) throws JsonMappingException {
        // Need to create a temporary property to allow contextual deserializers:
        BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME,
                delegateType, null, _classAnnotations, delegateCreator,
                PropertyMetadata.STD_OPTIONAL);

        TypeDeserializer td = delegateType.getTypeHandler();
        if (td == null) {
            td = ctxt.getConfig().findTypeDeserializer(delegateType);
        }
        JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);
        if (td != null) {
            td = td.forProperty(property);
            return new TypeWrappedDeserializer(td, dd);
        }
        return dd;
    }


>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                            if (ctxt.getConfig().canOverrideAccessModifiers()) {
                                ClassUtil.checkAndFixAccess(ctor);
=======
                            if (ctxt.canOverrideAccessModifiers()) {
                                ClassUtil.checkAndFixAccess(ctor, ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                if (t == JsonToken.FIELD_NAME && _objectIdReader.maySerializeAsObject()
=======
                if ((t == JsonToken.FIELD_NAME) && _objectIdReader.maySerializeAsObject()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object _handleTypedObjectId(JsonParser jp, DeserializationContext ctxt,
=======
    protected Object _handleTypedObjectId(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        /* 07-Aug-2013, tatu: One more challenge: type of id may not be type
         *   of property we are expecting later on; specifically, numeric ids
         *   vs Strings.
         */
=======
        // One more challenge: type of id may not be type of property we are expecting
        // later on; specifically, numeric ids vs Strings.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            id = _convertObjectId(jp, ctxt, rawId, idDeser);
=======
            id = _convertObjectId(p, ctxt, rawId, idDeser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {
        return deserializeFromObject(jp, ctxt);
=======
    protected Object deserializeWithObjectId(JsonParser p, DeserializationContext ctxt) throws IOException {
        return deserializeFromObject(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected Object deserializeFromObjectId(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        Object id = _objectIdReader.readObjectReference(jp, ctxt);
=======
        Object id = _objectIdReader.readObjectReference(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            throw new UnresolvedForwardReference("Could not resolve Object Id ["+id+"] (for "
                    +_beanType+").", jp.getCurrentLocation(), roid);
=======
            throw new UnresolvedForwardReference(p,
                    "Could not resolve Object Id ["+id+"] (for "+_beanType+").",
                    p.getCurrentLocation(), roid);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,
=======
    protected Object deserializeFromObjectUsingNonDefault(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                    _delegateDeserializer.deserialize(jp, ctxt));
=======
                    _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return _deserializeUsingPropertyBased(jp, ctxt);
=======
            return _deserializeUsingPropertyBased(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            throw JsonMappingException.from(jp, "Can not instantiate abstract type "+_beanType
=======
            throw JsonMappingException.from(p, "Can not instantiate abstract type "+_beanType
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throw JsonMappingException.from(jp, "No suitable constructor found for type "
=======
        throw JsonMappingException.from(p, "No suitable constructor found for type "
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected abstract Object _deserializeUsingPropertyBased(final JsonParser jp,
=======
    protected abstract Object _deserializeUsingPropertyBased(final JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return deserializeFromObjectId(jp, ctxt);
=======
            return deserializeFromObjectId(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        switch (jp.getNumberType()) {
=======
        switch (p.getNumberType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));
=======
                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return _valueInstantiator.createFromInt(ctxt, jp.getIntValue());
=======
            return _valueInstantiator.createFromInt(ctxt, p.getIntValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));
=======
                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return _valueInstantiator.createFromLong(ctxt, jp.getLongValue());
=======
            return _valueInstantiator.createFromLong(ctxt, p.getLongValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));
=======
            Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        switch (p.getNumberType()) {
        case FLOAT: // no separate methods for taking float...
        case DOUBLE:
=======
        NumberType t = p.getNumberType();
        // no separate methods for taking float...
        if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
=======
        if (_arrayDelegateDeserializer != null) {
            try {
                Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt));
                if (_injectables != null) {
                    injectValues(ctxt, bean);
                }
                return bean;
            } catch (Exception e) {
                wrapInstantiationProblem(e, ctxt);
            }
        }
        // fallback to non-array delegate
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
=======
                Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    public Object deserializeFromEmbedded(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    public Object deserializeFromEmbedded(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            return deserializeFromObjectId(jp, ctxt);
=======
            return deserializeFromObjectId(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        return jp.getEmbeddedObject();
=======
        return p.getEmbeddedObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected void handleUnknownVanilla(JsonParser jp, DeserializationContext ctxt,
=======
    protected void handleUnknownVanilla(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            handleIgnoredProperty(jp, ctxt, bean, propName);
=======
            handleIgnoredProperty(p, ctxt, bean, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);
=======
                _anySetter.deserializeAndSet(p, ctxt, bean, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            handleUnknownProperty(jp, ctxt, bean, propName);         
=======
            handleUnknownProperty(p, ctxt, bean, propName);         
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt,
=======
    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            jp.skipChildren();
=======
            p.skipChildren();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            handleIgnoredProperty(jp, ctxt, beanOrClass, propName);
=======
            handleIgnoredProperty(p, ctxt, beanOrClass, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        super.handleUnknownProperty(jp, ctxt, beanOrClass, propName);
=======
        super.handleUnknownProperty(p, ctxt, beanOrClass, propName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected void handleIgnoredProperty(JsonParser jp, DeserializationContext ctxt,
=======
    protected void handleIgnoredProperty(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            throw IgnoredPropertyException.from(jp, beanOrClass, propName, getKnownPropertyNames());
=======
            throw IgnoredPropertyException.from(p, beanOrClass, propName, getKnownPropertyNames());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        jp.skipChildren();
=======
        p.skipChildren();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
     * @param jp (optional) If not null, parser that has more properties to handle
=======
     * @param p (optional) If not null, parser that has more properties to handle
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt,                                          
=======
    protected Object handlePolymorphic(JsonParser p, DeserializationContext ctxt,                                          
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
            if (jp != null) {
                bean = subDeser.deserialize(jp, ctxt, bean);
=======
            if (p != null) {
                bean = subDeser.deserialize(p, ctxt, bean);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        if (jp != null) {
            bean = deserialize(jp, ctxt, bean);
=======
        if (p != null) {
            bean = deserialize(p, ctxt, bean);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
 * Unlike with {@link com.fasterxml.jackson.databind.ser.Serializers},
 * multiple different methods are used since different kinds of types typically
 * require different kinds of inputs.
=======
 * It is <b>strongly recommended</b> that implementations always extend {@link Deserializers.Base}
 * and NOT just implement {@link Deserializers}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
=======
    // // // Scalar types first:

    /**
     * Method called to locate deserializer for specified {@link java.lang.Enum} type.
     * 
     * @param type Type of {@link java.lang.Enum} instances to deserialize
     * @param config Configuration in effect
     * @param beanDesc Definition of the enumeration type that contains class annotations and
     *    other information typically needed for building deserializers
     * 
     * @return Deserializer to use for the type; or null if this provider does not know how to construct it
     */
    public JsonDeserializer<?> findEnumDeserializer(Class<?> type,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException;

    /**
     * Method called to locate deserializer for specified JSON tree node type.
     * 
     * @param nodeType Specific type of JSON tree nodes to deserialize
     *  (subtype of {@link com.fasterxml.jackson.databind.JsonNode})
     * @param config Configuration in effect
     * 
     * @return Deserializer to use for the type; or null if this provider does not know how to construct it
     */
    public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException;

    /**
     * Method called to locate deserializer for specified value type which does not belong to any other
     * category (not an Enum, Collection, Map, Array, reference value or tree node)
     * 
     * @param type Bean type to deserialize
     * @param config Configuration in effect
     * @param beanDesc Definition of the enumeration type that contains class annotations and
     *    other information typically needed for building deserializers
     * 
     * @return Deserializer to use for the type; or null if this provider does not know how to construct it
     */
    public JsonDeserializer<?> findBeanDeserializer(JavaType type,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException;
    
    // // // Then container types
    
    /**
     * Method called to locate deserializer for value that is of referential
     * type,
     * 
     * @param refType Specific referential type to deserialize
     * @param config Configuration in effect
     * @param beanDesc Definition of the reference type that contains class annotations and
     *    other information typically needed for building deserializers
     * @param contentTypeDeserializer Possible type deserializer for referenced value
     * @param contentDeserializer Value deserializer to use for referenced value, if indicated
     *    by property annotation
     * 
     * @return Deserializer to use for the type; or null if this provider does not know how to construct it
     */
    public JsonDeserializer<?> findReferenceDeserializer(ReferenceType refType,
            DeserializationConfig config, BeanDescription beanDesc,
            TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer)
        throws JsonMappingException;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
    
    /**
     * Method called to locate deserializer for specified {@link java.lang.Enum} type.
     * 
     * @param type Type of {@link java.lang.Enum} instances to deserialize
     * @param config Configuration in effect
     * @param beanDesc Definition of the enumeration type that contains class annotations and
     *    other information typically needed for building deserializers
     * 
     * @return Deserializer to use for the type; or null if this provider does not know how to construct it
     */
    public JsonDeserializer<?> findEnumDeserializer(Class<?> type,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
    
    /**
     * Method called to locate deserializer for specified JSON tree node type.
     * 
     * @param nodeType Specific type of JSON tree nodes to deserialize
     *  (subtype of {@link com.fasterxml.jackson.databind.JsonNode})
     * @param config Configuration in effect
     * 
     * @return Deserializer to use for the type; or null if this provider does not know how to construct it
     */
    public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException;
    
    /**
     * Method called to locate deserializer for specified value type which does not belong to any other
     * category (not an Enum, Collection, Map, Array or tree node)
     * 
     * @param type Bean type to deserialize
     * @param config Configuration in effect
     * @param beanDesc Definition of the enumeration type that contains class annotations and
     *    other information typically needed for building deserializers
     * 
     * @return Deserializer to use for the type; or null if this provider does not know how to construct it
     */
    public JsonDeserializer<?> findBeanDeserializer(JavaType type,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findArrayDeserializer(ArrayType type,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
=======
        public JsonDeserializer<?> findEnumDeserializer(Class<?> type,
                DeserializationConfig config, BeanDescription beanDesc)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE

=======
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findCollectionDeserializer(CollectionType type,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
=======
        public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
                DeserializationConfig config, BeanDescription beanDesc)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
=======
        @Override // since 2.7
        public JsonDeserializer<?> findReferenceDeserializer(ReferenceType refType,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer)
            throws JsonMappingException {
            // 21-Oct-2015, tatu: For backwards compatibility, let's delegate to "bean" variant,
            //    for 2.7 -- remove work-around from 2.8 or later
            return findBeanDeserializer(refType, config, beanDesc);
        }
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
=======
        public JsonDeserializer<?> findBeanDeserializer(JavaType type,
                DeserializationConfig config, BeanDescription beanDesc)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE

=======
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findMapDeserializer(MapType type,
=======
        public JsonDeserializer<?> findArrayDeserializer(ArrayType type,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
                KeyDeserializer keyDeserializer,
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type,
=======
        public JsonDeserializer<?> findCollectionDeserializer(CollectionType type,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
                KeyDeserializer keyDeserializer,
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findEnumDeserializer(Class<?> type,
                DeserializationConfig config, BeanDescription beanDesc)
=======
        public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type,
                DeserializationConfig config, BeanDescription beanDesc,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
                DeserializationConfig config, BeanDescription beanDesc)
=======
        public JsonDeserializer<?> findMapDeserializer(MapType type,
                DeserializationConfig config, BeanDescription beanDesc,
                KeyDeserializer keyDeserializer,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
        public JsonDeserializer<?> findBeanDeserializer(JavaType type,
                DeserializationConfig config, BeanDescription beanDesc)
=======
        public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type,
                DeserializationConfig config, BeanDescription beanDesc,
                KeyDeserializer keyDeserializer,
                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
import java.lang.reflect.Type;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        if (type.isAbstract()) {
            // [JACKSON-41] (v1.6): Let's make it possible to materialize abstract types.
=======
        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
        //    not something we could materialize anything for
        if (type.isAbstract() && !type.isPrimitive()) {
            // Let's make it possible to materialize abstract types.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        final JavaType abstractType = beanDesc.getType();
        // [JACKSON-502]: Now it is possible to have multiple resolvers too,
        //   as they are registered via module interface.
=======
        // May have multiple resolvers, call in precedence order until one returns non-null
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), abstractType);
=======
            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            	ClassUtil.checkAndFixAccess(buildMethod.getMember());
=======
            	ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                    am.getGenericParameterType(0));
=======
                    am.getParameterType(0));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                 *   to set (with new 1.9 code)... but let's replace it just in case,
=======
                 *   to set... but let's replace it just in case,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-794]: JDK 7 also added "getSuppressed", skip if we have such data:
=======
        // Java 7 also added "getSuppressed", skip if we have such data:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-440]: update builder now that all information is in?
=======
        // update builder now that all information is in?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:
=======
        // may have modifier(s) that wants to modify or replace serializer we just built:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
             *   we need to do linkage (as per [Issue#318]), and so need to start with
=======
             *   we need to do linkage (as per [databind#318]), and so need to start with
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                Type propertyType = propDef.getSetter().getGenericParameterType(0);
=======
                JavaType propertyType = propDef.getSetter().getParameterType(0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                Type propertyType = propDef.getField().getGenericType();
=======
                JavaType propertyType = propDef.getField().getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                /* As per [JACKSON-88], may also need to consider getters
=======
                /* May also need to consider getters
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                Type genericType;
=======
                JavaType type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                    genericType = ((AnnotatedMethod) m).getGenericParameterType(0);
=======
                    type = ((AnnotatedMethod) m).getParameterType(0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                    genericType = m.getRawType();
=======
                    type = m.getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                        ctxt, beanDesc, propDef, genericType));
=======
                        ctxt, beanDesc, propDef, type));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
=======
            boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                    m.fixAccess(); // to ensure we can call it
=======
                    m.fixAccess(forceAccess); // to ensure we can call it
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                        beanDesc.resolveType(m.getGenericType()),
=======
                        m.getType(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            setter.fixAccess(); // to ensure we can call it
=======
            setter.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); // to ensure we can call it
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        JavaType type = beanDesc.bindingsForBeanType().resolveType(setter.getGenericParameterType(1));
=======
        JavaType type = setter.getParameterType(1);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            Type jdkType)
=======
            JavaType propType0)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            mutator.fixAccess();
=======
            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        JavaType t0 = beanDesc.resolveType(jdkType);

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
                t0, propDef.getWrapperName(),
=======
                propType0, propDef.getWrapperName(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        JavaType type = resolveType(ctxt, beanDesc, t0, mutator);
=======
        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        if (type != t0) {
=======
        if (type != propType0) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
            getter.fixAccess();
=======
            getter.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE

        /* 26-Jan-2012, tatu: Alas, this complication is still needed to handle
         *   (or at least work around) local type declarations...
         */
        JavaType type = getter.getType(beanDesc.bindingsForBeanType());
        /* First: does the Method specify the deserializer to use?
         * If so, let's use it.
         */
=======
        JavaType type = getter.getType();
        // First: does the Method specify the deserializer to use? If so, let's use it.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
import com.fasterxml.jackson.annotation.JsonFormat;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.introspect.ConcreteBeanPropertyBase;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    implements BeanProperty,
        java.io.Serializable
=======
    extends ConcreteBeanPropertyBase
    implements java.io.Serializable
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    /**
     * Additional optional property metadata, such as whether
     * property is required, and whether there is additional
     * human-readable description
     * 
     * @since 2.3
     */
    protected final PropertyMetadata _metadata;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(metadata);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(metadata);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = src._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = src._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    @Deprecated // since 2.3
    protected SettableBeanProperty(SettableBeanProperty src, String newName) {
        this(src, new PropertyName(newName));
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = src._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    
    @Override
    public boolean isRequired() { return _metadata.isRequired(); }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    public PropertyMetadata getMetadata() { return _metadata; }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    public JsonFormat.Value findFormatOverrides(AnnotationIntrospector intr) {
        if (intr != null) {
            AnnotatedMember m = getMember();
            if (m != null) {
                return intr.findFormat(m);
            }
        }
        return null;
    }

    @Override
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)
=======
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    protected void _throwAsIOE(Exception e, Object value) throws IOException
=======
    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
            throw new JsonMappingException(msg.toString(), null, e);
=======
            throw JsonMappingException.from(p, msg.toString(), e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _throwAsIOE(e);
=======
        _throwAsIOE(p, e);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE

    protected IOException _throwAsIOE(Exception e) throws IOException
=======
    
    /**
     * @since 2.7
     */
    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        throw new JsonMappingException(th.getMessage(), null, th);
=======
        throw JsonMappingException.from(p, th.getMessage(), th);
    }

    @Deprecated // since 2.7
    protected IOException _throwAsIOE(Exception e) throws IOException {
        return _throwAsIOE((JsonParser) null, e);
    }

    // 10-Oct-2015, tatu: _Should_ be deprecated, too, but its remaining
    //   callers can not actually provide a JsonParser
    protected void _throwAsIOE(Exception e, Object value) throws IOException {
        _throwAsIOE((JsonParser) null, e, value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        throws IOException, JsonProcessingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
            JsonToken t = jp.getCurrentToken();
            // should be good enough check; we only care about Strings, integral numbers:
            if (t != null && t.isScalarValue()) {
                return _deserializeFromObjectId(jp, ctxt);
=======
            JsonToken t = p.getCurrentToken();
            if (t != null) {
                // Most commonly, a scalar (int id, uuid String, ...)
                if (t.isScalarValue()) {
                    return _deserializeFromObjectId(p, ctxt);
                }
                // but, with 2.5+, a simple Object-wrapped value also legal:
                if (t == JsonToken.START_OBJECT) {
                    t = p.nextToken();
                }
                if ((t == JsonToken.FIELD_NAME) && _objectIdReader.maySerializeAsObject()
                        && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {
                    return _deserializeFromObjectId(p, ctxt);
                }
            
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        Object result = _deserializeIfNatural(jp, ctxt);
=======
        Object result = _deserializeIfNatural(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);
=======
        return typeDeserializer.deserializeTypedFromObject(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
    public Object deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException
=======
    public Object deserialize(JsonParser p, DeserializationContext ctxt)
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected Object _deserializeIfNatural(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        /* As per [JACKSON-417], there is a chance we might be "natural" types
=======
        /* There is a chance we might be "natural" types
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        switch (jp.getCurrentTokenId()) {
=======
        switch (p.getCurrentTokenId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
                return jp.getText();
=======
                return p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
                return jp.getIntValue();
=======
                return p.getIntValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
                return Double.valueOf(jp.getDoubleValue());
=======
                return Double.valueOf(p.getDoubleValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException
=======
    protected Object _deserializeFromObjectId(JsonParser p, DeserializationContext ctxt) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
        Object id = _objectIdReader.readObjectReference(jp, ctxt);
=======
        Object id = _objectIdReader.readObjectReference(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java;<<<<<<< MINE
            throw new UnresolvedForwardReference("Could not resolve Object Id ["+id+"] -- unresolved forward-reference?", jp.getCurrentLocation(), roid);
=======
            throw new UnresolvedForwardReference(p,
                    "Could not resolve Object Id ["+id+"] -- unresolved forward-reference?", p.getCurrentLocation(), roid);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.JsonParser;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java;<<<<<<< MINE
public final class UnresolvedForwardReference extends JsonMappingException {
=======
public class UnresolvedForwardReference extends JsonMappingException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java;<<<<<<< MINE
    public UnresolvedForwardReference(String msg, JsonLocation loc, ReadableObjectId roid)
    {
=======
    /**
     * @since 2.7
     */
    public UnresolvedForwardReference(JsonParser p, String msg, JsonLocation loc, ReadableObjectId roid) {
        super(p, msg, loc);
        _roid = roid;
    }

    /**
     * @since 2.7
     */
    public UnresolvedForwardReference(JsonParser p, String msg) {
        super(p, msg);
        _unresolvedIds = new ArrayList<UnresolvedId>();
    }

    /**
     * @deprecated Since 2.7
     */
    @Deprecated // since 2.7
    public UnresolvedForwardReference(String msg, JsonLocation loc, ReadableObjectId roid) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java;<<<<<<< MINE
    public UnresolvedForwardReference(String msg)
    {
=======
    /**
     * @deprecated Since 2.7
     */
    @Deprecated // since 2.7
    public UnresolvedForwardReference(String msg) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java;<<<<<<< MINE
    // ******************************
    // ****** Accessor methods ******
    // ******************************
=======
    /*
    /**********************************************************
    /* Accessor methods
    /**********************************************************
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java;<<<<<<< MINE
=======
        String[] names = ai.findEnumValues(enumCls, enumValues, new String[enumValues.length]);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java;<<<<<<< MINE
        for (Enum<?> e : enumValues) {
            map.put(ai.findEnumValue(e), e);
=======
        for (int i = 0, len = enumValues.length; i < len; ++i) {
            String name = names[i];
            if (name == null) {
                name = enumValues[i].name();
            }
            map.put(name, enumValues[i]);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        Package pkg = compType.getPackage();
        if (pkg != null) {
            String pname = pkg.getName();
            if (pname.contains(".cglib")) {
                if (pname.startsWith("net.sf.cglib")
=======
        String pkgName = ClassUtil.getPackageName(compType);
        if (pkgName != null) {
            if (pkgName.contains(".cglib")) {
                if (pkgName.startsWith("net.sf.cglib")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
                    || pname.startsWith("org.hibernate.repackage.cglib")
=======
                    || pkgName.startsWith("org.hibernate.repackage.cglib")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
                    || pname.startsWith("org.springframework.cglib")
=======
                    || pkgName.startsWith("org.springframework.cglib")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        Package pkg = argType.getPackage();
        if (pkg != null && pkg.getName().startsWith("groovy.lang")) {
=======
        String pkgName = ClassUtil.getPackageName(argType);
        if (pkgName != null && pkgName.startsWith("groovy.lang")) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        Package pkg = rt.getPackage();
        if (pkg != null && pkg.getName().startsWith("groovy.lang")) {
=======
        String pkgName = ClassUtil.getPackageName(rt);
        if (pkgName != null && pkgName.startsWith("groovy.lang")) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        // otherwise, lower case initial chars
        StringBuilder sb = null;
        for (int i = offset; i < end; ++i) {
            char upper = basename.charAt(i);
            char lower = Character.toLowerCase(upper);
            if (upper == lower) {
=======
        // next check: is the first character upper case? If not, return as is
        char c = basename.charAt(offset);
        char d = Character.toLowerCase(c);
        
        if (c == d) {
            return basename.substring(offset);
        }
        // otherwise, lower case initial chars. Common case first, just one char
        StringBuilder sb = new StringBuilder(end - offset);
        sb.append(d);
        int i = offset+1;
        for (; i < end; ++i) {
            c = basename.charAt(i);
            d = Character.toLowerCase(c);
            if (c == d) {
                sb.append(basename, i, end);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
            if (sb == null) {
                int l = end-offset;
                sb = new StringBuilder(l);
                sb.append(basename, offset, end);
            }
            sb.setCharAt(i-offset, lower);
=======
            sb.append(d);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java;<<<<<<< MINE
        return (sb == null) ? basename.substring(offset) : sb.toString();
=======
        return sb.toString();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======
import java.lang.annotation.Annotation;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.JavaType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======
    private final static Class<?> CLS_OBJECT = Object.class;

    /*
    /**********************************************************
    /* Simple factory methods
    /**********************************************************
     */

    /**
     * @since 2.7
     */
    public static <T> Iterator<T> emptyIterator() {
        return Collections.emptyIterator();
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======
    public static List<JavaType> findSuperTypes(JavaType type, Class<?> endBefore,
            boolean addClassItself) {
        if ((type == null) || type.hasRawClass(endBefore) || type.hasRawClass(Object.class)) {
            return Collections.emptyList();
        }
        List<JavaType> result = new ArrayList<JavaType>(8);
        _addSuperTypes(type, endBefore, result, addClassItself);
        return result;
    }

    /**
     * @since 2.7
     */
    public static List<Class<?>> findRawSuperTypes(Class<?> cls, Class<?> endBefore, boolean addClassItself) {
        if ((cls == null) || (cls == endBefore) || (cls == Object.class)) {
            return Collections.emptyList();
        }
        List<Class<?>> result = new ArrayList<Class<?>>(8);
        _addRawSuperTypes(cls, endBefore, result, addClassItself);
        return result;
    }

    /**
     * Method for finding all super classes (but not super interfaces) of given class,
     * starting with the immediate super class and ending in the most distant one.
     * Class itself is included if <code>addClassItself</code> is true.
     *
     * @since 2.7
     */
    public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore,
            boolean addClassItself) {
        List<Class<?>> result = new LinkedList<Class<?>>();
        if ((cls != null) && (cls != endBefore))  {
            if (addClassItself) {
                result.add(cls);
            }
            while ((cls = cls.getSuperclass()) != null) {
                if (cls == endBefore) {
                    break;
                }
                result.add(cls);
            }
        }
        return result;
    }

    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    
=======

    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        _addSuperTypes(cls, endBefore, result, false);
=======
        _addRawSuperTypes(cls, endBefore, result, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    
    private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) {
=======

    private static void _addSuperTypes(JavaType type, Class<?> endBefore, Collection<JavaType> result,
            boolean addClassItself)
    {
        if (type == null) {
            return;
        }
        final Class<?> cls = type.getRawClass();
        if (cls == endBefore || cls == Object.class) { return; }
        if (addClassItself) {
            if (result.contains(type)) { // already added, no need to check supers
                return;
            }
            result.add(type);
        }
        for (JavaType intCls : type.getInterfaces()) {
            _addSuperTypes(intCls, endBefore, result, true);
        }
        _addSuperTypes(type.getSuperClass(), endBefore, result, true);
    }

    private static void _addRawSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        for (Class<?> intCls : cls.getInterfaces()) {
            _addSuperTypes(intCls, endBefore, result, true);
=======
        for (Class<?> intCls : _interfaces(cls)) {
            _addRawSuperTypes(intCls, endBefore, result, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        _addSuperTypes(cls.getSuperclass(), endBefore, result, true);
=======
        _addRawSuperTypes(cls.getSuperclass(), endBefore, result, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
            if (type.getEnclosingMethod() != null) {
=======
            if (hasEnclosingMethod(type)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
                if (type.getEnclosingClass() != null) {
                    if (!Modifier.isStatic(type.getModifiers())) {
=======
                if (!Modifier.isStatic(type.getModifiers())) {
                    if (getEnclosingClass(type) != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
            if (type.getEnclosingMethod() != null) {
=======
            if (hasEnclosingMethod(type)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
                return type.getEnclosingClass();
=======
                return getEnclosingClass(type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        catch (NullPointerException e) { }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        // As per [Issue#57], should NOT disqualify JDK proxy:
=======
        // As per [databind#57], should NOT disqualify JDK proxy:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======

    /*
    /**********************************************************
    /* Caching access to class metadata, added in 2.7
    /**********************************************************
     */

    /* 17-Sep-2015, tatu: Although access methods should not be significant
     *   problems for most proper usage, they may become problematic if
     *   ObjectMapper has to be re-created; and especially so on Android.
     *   So let's do somewhat aggressive caching.
     */

    private final static LRUMap<Class<?>,ClassMetadata> sCached = new LRUMap<Class<?>,ClassMetadata>(48, 48);    

    /**
     * @since 2.7
     */
    public static String getPackageName(Class<?> cls) {
        return _getMetadata(cls).getPackageName();
    }

    /**
     * @since 2.7
     */
    public static boolean hasEnclosingMethod(Class<?> cls) {
        return _getMetadata(cls).hasEnclosingMethod();
    }

    /**
     * @since 2.7
     */
    public static Field[] getDeclaredFields(Class<?> cls) {
        return _getMetadata(cls).getDeclaredFields();
    }

    /**
     * @since 2.7
     */
    public static Method[] getDeclaredMethods(Class<?> cls) {
        return _getMetadata(cls).getDeclaredMethods();
    }

    /**
     * @since 2.7
     */
    public static Annotation[] findClassAnnotations(Class<?> cls) {
        return _getMetadata(cls).getDeclaredAnnotations();
    }

    /**
     * @since 2.7
     */
    public static Ctor[] getConstructors(Class<?> cls) {
        return _getMetadata(cls).getConstructors();
    }

    // // // Then methods that do NOT cache access but were considered
    // // // (and could be added to do caching if it was proven effective)

    /**
     * @since 2.7
     */
    public static Class<?> getDeclaringClass(Class<?> cls) {
        // Caching does not seem worthwhile, as per profiling
        return isObjectOrPrimitive(cls) ? null : cls.getDeclaringClass();
    }

    /**
     * @since 2.7
     */
    public static Type getGenericSuperclass(Class<?> cls) {
        return cls.getGenericSuperclass();
    }

    /**
     * @since 2.7
     */
    public static Type[] getGenericInterfaces(Class<?> cls) {
        return _getMetadata(cls).getGenericInterfaces();
    }
    
    /**
     * @since 2.7
     */
    public static Class<?> getEnclosingClass(Class<?> cls) {
        // Caching does not seem worthwhile, as per profiling
        return isObjectOrPrimitive(cls) ? null : cls.getEnclosingClass();
    }

    
    private static Class<?>[] _interfaces(Class<?> cls) {
        return _getMetadata(cls).getInterfaces();
    }

    private static ClassMetadata _getMetadata(Class<?> cls)
    {
        ClassMetadata md = sCached.get(cls);
        if (md == null) {
            md = new ClassMetadata(cls);
            // tiny optimization, but in case someone concurrently constructed it,
            // let's use that instance, to reduce extra concurrent work.
            ClassMetadata old = sCached.putIfAbsent(cls, md);
            if (old != null) {
                md = old;
            }
        }
        return md;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    
=======

    /**
     * Method that can be used to find primitive type for given class if (but only if)
     * it is either wrapper type or primitive type; returns `null` if type is neither.
     *
     * @since 2.7
     */
    public static Class<?> primitiveType(Class<?> type)
    {
        if (type.isPrimitive()) {
            return type;
        }
        
        if (type == Integer.class) {
            return Integer.TYPE;
        }
        if (type == Long.class) {
            return Long.TYPE;
        }
        if (type == Boolean.class) {
            return Boolean.TYPE;
        }
        if (type == Double.class) {
            return Double.TYPE;
        }
        if (type == Float.class) {
            return Float.TYPE;
        }
        if (type == Byte.class) {
            return Byte.TYPE;
        }
        if (type == Short.class) {
            return Short.TYPE;
        }
        if (type == Character.class) {
            return Character.TYPE;
        }
        return null;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
     * Method called to check if we can use the passed method or constructor
     * (wrt access restriction -- public methods can be called, others
     * usually not); and if not, if there is a work-around for
     * the problem.
=======
     * Equivalent to call:
     *<pre>
     *   checkAndFixAccess(member, false);
     *</pre>
     *
     * @deprecated Since 2.7 call variant that takes boolean flag.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    public static void checkAndFixAccess(Member member)
=======
    @Deprecated
    public static void checkAndFixAccess(Member member) {
        checkAndFixAccess(member, false);
    }

    /**
     * Method that is called if a {@link Member} may need forced access,
     * to force a field, method or constructor to be accessible: this
     * is done by calling {@link AccessibleObject#setAccessible(boolean)}.
     * 
     * @param member Accessor to call <code>setAccessible()</code> on.
     * @param force Whether to always try to make accessor accessible (true),
     *   or only if needed as per access rights (false)
     *
     * @since 2.7
     */
    public static void checkAndFixAccess(Member member, boolean force)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
            ao.setAccessible(true);
=======
            if (force || 
                    (!Modifier.isPublic(member.getModifiers())
                            || !Modifier.isPublic(member.getDeclaringClass().getModifiers()))) {
                ao.setAccessible(true);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE

=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
	public static Class<? extends Enum<?>> findEnumType(Enum<?> en)
=======
    public static Class<? extends Enum<?>> findEnumType(Enum<?> en)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        return (cls.getEnclosingClass() != null)
                && !Modifier.isStatic(cls.getModifiers());
=======
        return !Modifier.isStatic(cls.getModifiers())
                && (getEnclosingClass(cls) != null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    
=======

    /**
     * @since 2.7
     */
    public static boolean isObjectOrPrimitive(Class<?> cls) {
        return (cls == CLS_OBJECT) || cls.isPrimitive();
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    	    Field[] fields = fromClass.getDeclaredFields();
=======
    	    Field[] fields = getDeclaredFields(fromClass);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======

    /*
    /**********************************************************
    /* Helper classed used for caching
    /**********************************************************
     */

    /**
     * @since 2.7
     */
    private final static class ClassMetadata
    {
        private final static Annotation[] NO_ANNOTATIONS = new Annotation[0];
        private final static Ctor[] NO_CTORS = new Ctor[0];

        private final Class<?> _forClass;

        private String _packageName;
        private Boolean _hasEnclosingMethod;

        private Class<?>[] _interfaces;
        private Type[] _genericInterfaces;

        private Annotation[] _annotations;
        private Ctor[] _constructors;
        private Field[] _fields;
        private Method[] _methods;

        public ClassMetadata(Class<?> forClass) {
            _forClass = forClass;
        }

        public String getPackageName() {
            String name = _packageName;
            if (name == null) {
                Package pkg = _forClass.getPackage();
                name = (pkg == null) ? null : pkg.getName();
                if (name == null) {
                    name = "";
                }
                _packageName = name;
            }
            return (name == "") ? null : name;
        }

        // 19-Sep-2015, tatu: Bit of performance improvement, after finding this
        //   in profile; maybe 5% in "wasteful" deserialization case
        public Class<?>[] getInterfaces() {
            Class<?>[] result = _interfaces;
            if (result == null) {
                result = _forClass.getInterfaces();
                _interfaces = result;
            }
            return result;
        }

        // 30-Oct-2015, tatu: Minor performance boost too (5% or less)
        public Type[] getGenericInterfaces() {
            Type[] result = _genericInterfaces;
            if (result == null) {
                result = _forClass.getGenericInterfaces();
                _genericInterfaces = result;
            }
            return result;
        }

        // 19-Sep-2015, tatu: Modest performance improvement, after finding this
        //   in profile; maybe 2-3% in "wasteful" deserialization case
        public Annotation[] getDeclaredAnnotations() {
            Annotation[] result = _annotations;
            if (result == null) {
                result = isObjectOrPrimitive() ? NO_ANNOTATIONS : _forClass.getDeclaredAnnotations();
                _annotations = result;
            }
            return result;
        }

        // 19-Sep-2015, tatu: Some performance improvement, after finding this
        //   in profile; maybe 8-10% in "wasteful" deserialization case
        public Ctor[] getConstructors() {
            Ctor[] result = _constructors;
            if (result == null) {
                // Note: can NOT skip abstract classes as they may be used with mix-ins
                // and for regular use shouldn't really matter.
                if (_forClass.isInterface() || isObjectOrPrimitive()) {
                    result = NO_CTORS;
                } else {
                    Constructor<?>[] rawCtors = _forClass.getDeclaredConstructors();
                    final int len = rawCtors.length;
                    result = new Ctor[len];
                    for (int i = 0; i < len; ++i) {
                        result[i] = new Ctor(rawCtors[i]);
                    }
                }
                _constructors = result;
            }
            return result;
        }

        // 21-Spe-2015, tatu: Surprisingly significant improvement (+10%)...
        public Field[] getDeclaredFields() {
            Field[] fields = _fields;
            if (fields == null) {
                fields = _forClass.getDeclaredFields();
                _fields = fields;
            }
            return fields;
        }

        // 21-Spe-2015, tatu: Surprisingly significant improvement (+30%)...
        public Method[] getDeclaredMethods() {
            Method[] methods = _methods;
            if (methods == null) {
                methods = _forClass.getDeclaredMethods();
                _methods = methods;
            }
            return methods;
        }

        // Prominently listed on profiling when not cached, improvement
        // modest, 1-2% range; but at least is measurable so keep it
        public boolean hasEnclosingMethod() {
            Boolean b = _hasEnclosingMethod;
            if (b == null) {
                b = isObjectOrPrimitive() ? Boolean.FALSE : Boolean.valueOf(_forClass.getEnclosingMethod() != null);
                _hasEnclosingMethod = b;
            }
            return b.booleanValue();
        }

        private boolean isObjectOrPrimitive() {
            return (_forClass == CLS_OBJECT) || _forClass.isPrimitive();
        }

        /* And then we have a bunch of accessors that did show up in profiling
         * of "wasteful" cases, but for which caching did not yield non-trivial
         * improvements (for tests less than 1% improvement)
         */

        // Caching does not seem worthwhile, as per profiling
//        public Type getGenericSuperclass();
//        public Class<?> getDeclaringClass();
//        public Class<?> getEnclosingClass();
    }

    /**
     * Value class used for caching Constructor declarations; used because
     * caching done by JDK appears to be somewhat inefficient for some use cases.
     *
     * @since 2.7
     */
    public final static class Ctor
    {
        public final Constructor<?> _ctor;

        private Annotation[] _annotations;

        private  Annotation[][] _paramAnnotations;
        
        private int _paramCount = -1;
        
        public Ctor(Constructor<?> ctor) {
            _ctor = ctor;
        }

        public Constructor<?> getConstructor() {
            return _ctor;
        }

        public int getParamCount() {
            int c = _paramCount;
            if (c < 0) {
                c = _ctor.getParameterTypes().length;
                _paramCount = c;
            }
            return c;
        }

        public Class<?> getDeclaringClass() {
            return _ctor.getDeclaringClass();
        }

        // Modest boost: maybe 1%?
        public Annotation[] getDeclaredAnnotations() {
            Annotation[] result = _annotations;
            if (result == null) {
                result = _ctor.getDeclaredAnnotations();
                _annotations = result;
            }
            return result;
        }

        // Modest boost: maybe 1%?
        public  Annotation[][] getParameterAnnotations() {
            Annotation[][] result = _paramAnnotations;
            if (result == null) {
                result = _ctor.getParameterAnnotations();
                _paramAnnotations = result;
            }
            return result;
        }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======
import java.text.ParseException;
import java.text.ParsePosition;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
import java.text.ParsePosition;
import java.text.ParseException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
    /**
     * ID to represent the 'GMT' string
     */
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * @since 2.6
=======
     * ID to represent the 'UTC' string, default timezone since Jackson 2.7
     * 
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
//    private static final String UTC_ID = "UTC";
=======
    private static final String UTC_ID = "UTC";
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======
     * 
     * @deprecated Since 2.7 use {@link #TIMEZONE_UTC} instead
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * @since 2.6
=======
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
//    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);
=======
    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * Timezone we use for 'Z' in ISO-8601 date/time values.
=======
     * Timezone we use for 'Z' in ISO-8601 date/time values: since 2.7
     * {@link #TIMEZONE_UTC}; with earlier versions up to 2.7 was {@link #TIMEZONE_GMT}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
    private static final TimeZone TIMEZONE_Z = TIMEZONE_GMT;
=======
    private static final TimeZone TIMEZONE_Z = TIMEZONE_UTC;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)
=======
     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
        return format(date, false, TIMEZONE_GMT);
=======
        return format(date, false, TIMEZONE_UTC);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
        return format(date, millis, TIMEZONE_GMT);
=======
        return format(date, millis, TIMEZONE_UTC);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
     * @param tz timezone to use for the formatting (GMT will produce 'Z')
=======
     * @param tz timezone to use for the formatting (UTC will produce 'Z')
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======
                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
                            milliseconds = parseInt(date, offset += 1, offset += 3);
=======
                            offset += 1;
                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
                            int fraction = parseInt(date, offset, parseEndOffset);
                            // compensate for "missing" digits
                            switch (parseEndOffset - offset) { // number of digits parsed
                            case 2:
                                milliseconds = fraction * 10;
                                break;
                            case 1:
                                milliseconds = fraction * 100;
                                break;
                            default:
                                milliseconds = fraction;
                            }
                            offset = endOffset;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
                    //    not sure why, but it is what it is.
                    String timezoneId = GMT_ID + timezoneOffset;
=======
                    //    not sure why, but that's the way it looks. Further, Javadocs for
                    //    `java.util.TimeZone` specifically instruct use of GMT as base for
                    //    custom timezones... odd.
                    String timezoneId = "GMT" + timezoneOffset;
//                    String timezoneId = "UTC" + timezoneOffset;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======

    /**
     * Returns the index of the first character in the string that is not a digit, starting at offset.
     */
    private static int indexOfNonDigit(String string, int offset) {
        for (int i = offset; i < string.length(); i++) {
            char c = string.charAt(i);
            if (c < '0' || c > '9') return i;
        }
        return string.length();
    }

    public static void main(String[] args)
    {
        final int REPS = 250000;
        while (true) {
            long start = System.currentTimeMillis();
            int resp = test1(REPS, 3);
            long msecs = System.currentTimeMillis() - start;
            System.out.println("Pow ("+resp+") -> "+msecs+" ms");

            start = System.currentTimeMillis();
            resp = test2(REPS, 3);
            msecs = System.currentTimeMillis() - start;
            System.out.println("Iter ("+resp+") -> "+msecs+" ms");
        }
    }

    static int test1(int reps, int pow)
    {
        int resp = 3;
        while (--reps >= 0) {
            resp = (int) Math.pow(10, pow);
        }
        return resp;
    }

    static int test2(int reps, int pow)
    {
        int resp = 3;
        while (--reps >= 0) {
            resp = 10;
            int p = pow;

            while (--p > 0) {
                resp *= 10;
            }
        }
        return resp;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
	protected final AnnotationIntrospector _introspector;
=======
    protected final AnnotationIntrospector _introspector;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
	/**
=======
    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
    protected final JsonInclude.Include _inclusion;
=======
    protected final JsonInclude.Value _inclusion;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
    /**
     * @since 2.2 Use {@link #construct} instead
     */
    @Deprecated
    public SimpleBeanPropertyDefinition(AnnotatedMember member) {
        this(member, member.getName(), null);
=======
    protected SimpleBeanPropertyDefinition(AnnotatedMember member, PropertyName fullName,
            AnnotationIntrospector intr, PropertyMetadata metadata,
            JsonInclude.Include inclusion)
    {
        this(member, fullName, intr, metadata,
                ((inclusion == null) || (inclusion == JsonInclude.Include.USE_DEFAULTS)
                        ? EMPTY_INCLUDE : JsonInclude.Value.construct(inclusion, null)));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE

    /**
     * @since 2.2 Use {@link #construct} instead
     */
    @Deprecated
    public SimpleBeanPropertyDefinition(AnnotatedMember member, String name) {
        this(member, new PropertyName(name), null, null, null);
    }

=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
            JsonInclude.Include inclusion)
=======
            JsonInclude.Value inclusion)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
        this(member, new PropertyName(name), intr, null, null);
=======
        this(member, new PropertyName(name), intr, null, EMPTY_INCLUDE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
                        null, null);
=======
                        null, EMPTY_INCLUDE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
                        null, null);
=======
                        null, EMPTY_INCLUDE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
        return construct(config, member, name, null, null);
=======
        return construct(config, member, name, null, EMPTY_INCLUDE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
=======
    
    /**
     * @since 2.7
     */
    public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,
            AnnotatedMember member, PropertyName name, PropertyMetadata metadata,
            JsonInclude.Value inclusion) {
          return new SimpleBeanPropertyDefinition(member, name,
                  (config == null) ? null : config.getAnnotationIntrospector(),
                          metadata, inclusion);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
    public BeanPropertyDefinition withInclusion(JsonInclude.Include inclusion) {
=======
    public BeanPropertyDefinition withInclusion(JsonInclude.Value inclusion) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
    public JsonInclude.Include findInclusion() {
=======
    public JsonInclude.Value findInclusion() {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java;<<<<<<< MINE
            return EmptyIterator.instance();
=======
            return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java;<<<<<<< MINE
        Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass);
        Enum<?>[] values = cls.getEnumConstants();
        if (values != null) {
            SerializableString[] textual = new SerializableString[values.length];
            for (Enum<?> en : values) {
                String value = config.getAnnotationIntrospector().findEnumValue(en);
                textual[en.ordinal()] = config.compileString(value);
=======
        Class<? extends Enum<?>> enumCls = ClassUtil.findEnumType(enumClass);
        Enum<?>[] enumValues = enumCls.getEnumConstants();
        if (enumValues == null) {
            throw new IllegalArgumentException("Can not determine enum constants for Class "+enumClass.getName());
        }
        String[] names = config.getAnnotationIntrospector().findEnumValues(enumCls, enumValues, new String[enumValues.length]);
        SerializableString[] textual = new SerializableString[enumValues.length];
        for (int i = 0, len = enumValues.length; i < len; ++i) {
            Enum<?> en = enumValues[i];
            String name = names[i];
            if (name == null) {
                name = en.name();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java;<<<<<<< MINE
            return new EnumValues(enumClass, textual);
=======
            textual[en.ordinal()] = config.compileString(name);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java;<<<<<<< MINE
        throw new IllegalArgumentException("Can not determine enum constants for Class "+enumClass.getName());
=======
        return new EnumValues(enumClass, textual);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE
     * Do we currnetly have a native type or object id buffered?
=======
     * Do we currently have a native type or object id buffered?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE
                        throw new JsonGenerationException("Unrecognized value type for VALUE_NUMBER_FLOAT: "+n.getClass().getName()+", can not serialize");
=======
                        throw new JsonGenerationException(String.format(
                                "Unrecognized value type for VALUE_NUMBER_FLOAT: %s, can not serialize",
                                n.getClass().getName()), gen);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE
    
=======

    @Override
    public JsonGenerator overrideStdFeatures(int values, int mask) {
        int oldState = getFeatureMask();
        _generatorFeatures = (oldState & ~mask) | (values & mask);
        return this;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdConverter.java;<<<<<<< MINE
    public JavaType getInputType(TypeFactory typeFactory)
    {
        JavaType[] types = typeFactory.findTypeParameters(getClass(), Converter.class);
        if (types == null || types.length < 2) {
            throw new IllegalStateException("Can not find OUT type parameter for Converter of type "+getClass().getName());
        }
        return types[0];
=======
    public JavaType getInputType(TypeFactory typeFactory) {
        return _findConverterType(typeFactory).containedType(0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdConverter.java;<<<<<<< MINE
    public JavaType getOutputType(TypeFactory typeFactory)
    {
        JavaType[] types = typeFactory.findTypeParameters(getClass(), Converter.class);
        if (types == null || types.length < 2) {
=======
    public JavaType getOutputType(TypeFactory typeFactory) {
        return _findConverterType(typeFactory).containedType(1);
    }

    protected JavaType _findConverterType(TypeFactory tf) {
        JavaType thisType = tf.constructType(getClass());
        JavaType convType = thisType.findSuperType(Converter.class);
        if (convType == null || convType.containedTypeCount() < 2) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdConverter.java;<<<<<<< MINE
        return types[1];
=======
        return convType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    protected final static String DATE_FORMAT_STR_ISO8601 = "yyyy-MM-dd'T'HH:mm:ss.SSSZ";
=======
    public final static String DATE_FORMAT_STR_ISO8601 = "yyyy-MM-dd'T'HH:mm:ss.SSSZ";
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
     * (or "GMT")
=======
     * (or "UTC")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
     * By default we use GMT for everything.
=======
     * By default we use UTC for everything, with Jackson 2.7 and later
     * (2.6 and earlier relied on GMT)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        DEFAULT_TIMEZONE = TimeZone.getTimeZone("GMT");
=======
        DEFAULT_TIMEZONE = TimeZone.getTimeZone("UTC"); // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        /* Another important thing: let's force use of GMT for
=======
        /* Another important thing: let's force use of default timezone for
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======

    /**
     * Explicit override for leniency, if specified.
     *<p>
     * Can not be `final` because {@link #setLenient(boolean)} returns
     * `void`.
     *
     * @since 2.7
     */
    protected Boolean _lenient;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    /**
     * @deprecated Since 2.4, use variant that also takes Locale
     */
    @Deprecated // since 2.4
    public StdDateFormat(TimeZone tz) {
        this(tz, DEFAULT_LOCALE);
    }
    
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {
        _timezone = tz;
        _locale = loc;
        _lenient = lenient;
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return new StdDateFormat(tz, _locale);
=======
        return new StdDateFormat(tz, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return new StdDateFormat(_timezone, loc);
=======
        return new StdDateFormat(_timezone, loc, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return new StdDateFormat(_timezone, _locale);
    }

    /**
     * Method for getting the globally shared DateFormat instance
     * that uses GMT timezone and can handle simple ISO-8601
     * compliant date format.
     * 
     * @deprecated Since 2.4 not to be used.
     */
    @Deprecated
    public static DateFormat getBlueprintISO8601Format() {
        return DATE_FORMAT_ISO8601;
=======
        return new StdDateFormat(_timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc);
    }
    
    /**
     * Method for getting the globally shared DateFormat instance
     * that uses GMT timezone and can handle RFC-1123
     * compliant date format.
     * 
     * @deprecated Since 2.4 not to be used.
     */
    @Deprecated
    public static DateFormat getBlueprintRFC1123Format() {
        return DATE_FORMAT_RFC1123;
=======
        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc);
=======
        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                tz, loc, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    /* Public API
=======
    /* Public API, configuration
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            _formatRFC1123 = null;
            _formatISO8601 = null;
            _formatISO8601_z = null;
            _formatPlain = null;
=======
            _clearFormats();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    
=======

    /**
     * Need to override since we need to keep track of leniency locally,
     * and not via underlying {@link Calendar} instance like base class
     * does.
     */
    @Override // since 2.7
    public void setLenient(boolean enabled) {
        Boolean newValue = enabled;
        if (_lenient != newValue) {
            _lenient = newValue;
            // and since leniency settings may have been used:
            _clearFormats();
        }
    }

    @Override // since 2.7
    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }

    /*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        Date result = parse(dateStr, pos);
        if (result != null) {
            return result;
=======

        Date dt;

        if (looksLikeISO8601(dateStr)) { // also includes "plain"
            dt = parseAsISO8601(dateStr, pos, true);
        } else {
            // Also consider "stringified" simple time stamp
            int i = dateStr.length();
            while (--i >= 0) {
                char ch = dateStr.charAt(i);
                if (ch < '0' || ch > '9') {
                    // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                    if (i > 0 || ch != '-') {
                        break;
                    }
                }
            }
            if ((i < 0)
                // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
                dt = new Date(Long.parseLong(dateStr));
            } else {
                // Otherwise, fall back to using RFC 1123
                dt = parseAsRFC1123(dateStr, pos);
            }
        }
        if (dt != null) {
            return dt;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            return parseAsISO8601(dateStr, pos);
=======
            try {
                return parseAsISO8601(dateStr, pos, false);
            } catch (ParseException e) { // will NOT be thrown due to false but is declared...
                return null;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also
         *   consider "stringified" simple time stamp
         */
=======
        // Also consider "stringified" simple time stamp
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                // 07-Aug-2013, tatu: And #267 points out that negative numbers should also work
=======
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Public API, writing
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
=======
            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,
                    _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    protected Date parseAsISO8601(String dateStr, ParsePosition pos)
=======
    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)
            throws ParseException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        /* First: do we have "zulu" format ('Z' == "GMT")? If yes, that's
=======
        /* First: do we have "zulu" format ('Z' == "UTC")? If yes, that's
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
         * GMT, and hence can just strip out 'Z' altogether
=======
         * UTC, and hence can just strip out 'Z' altogether
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
        String formatStr;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        // [JACKSON-200]: need to support "plain" date...
=======
        // Need to support "plain" date...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
            formatStr = DATE_FORMAT_STR_PLAIN;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
=======
                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,
                        _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
=======
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
                        _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            // [JACKSON-334]: may be missing milliseconds... if so, add
=======
            // may be missing milliseconds... if so, add
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
                formatStr = DATE_FORMAT_STR_ISO8601;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
=======
                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,
                            _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
                formatStr = DATE_FORMAT_STR_ISO8601_Z;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,
                            _timezone, _locale);
=======
                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
                            _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
        return df.parse(dateStr, pos);
=======
        Date dt = df.parse(dateStr, pos);
        // 22-Dec-2015, tatu: With non-lenient, may get null
        if (dt == null) {
            throw new ParseException
            (String.format("Can not parse date \"%s\": while it seems to fit format '%s', parsing fails (leniency? %s)",
                           dateStr, formatStr, _lenient),
               pos.getErrorIndex());
        }
        return dt;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);
=======
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                    _timezone, _locale, _lenient);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            TimeZone tz, Locale loc)
=======
            TimeZone tz, Locale loc, Boolean lenient)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
        if (lenient != null) {
            df.setLenient(lenient.booleanValue());
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======

    protected void _clearFormats() {
        _formatRFC1123 = null;
        _formatISO8601 = null;
        _formatISO8601_z = null;
        _formatPlain = null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
    public final <A extends Annotation> boolean hasAnnotation(Class<A> acls) {
        return getAnnotation(acls) != null;
    }
=======
    public abstract boolean hasAnnotation(Class<?> acls);

    /**
     * @since 2.7
     */
    public abstract boolean hasOneOf(Class<? extends Annotation>[] annoClasses);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
=======
     *
     * @since 2.7
     */
    public abstract JavaType getType();

    /**
     * @deprecated Since 2.7 Use {@link #getType()} instead. To be removed from 2.8.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
    public JavaType getType(TypeBindings context) {
        return context.resolveType(getGenericType());
=======
    @Deprecated
    public final JavaType getType(TypeBindings bogus) {
        return getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
=======
     *
     * @deprecated Since 2.7 should instead use {@link #getType()}. To be removed from 2.8
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
    public abstract Type getGenericType();
=======
    @Deprecated
    public Type getGenericType() {
        return getRawType();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.type.TypeBindings;
import com.fasterxml.jackson.databind.type.TypeFactory;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
    implements TypeResolutionContext
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    final protected JavaType _type;

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     * Type bindings to use for members of {@link #_class}.
     *
     * @since 2.7
     */
    final protected TypeBindings _bindings;

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: changed in 2.7 from List of <code>Class</code>es to List of {@link JavaType}s.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    final protected List<Class<?>> _superTypes;
=======
    final protected List<JavaType> _superTypes;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    final protected TypeFactory _typeFactory;
    
    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes,
            AnnotationIntrospector aintr, MixInResolver mir,
=======
    private AnnotatedClass(JavaType type, Class<?> rawType, TypeBindings bindings,
            List<JavaType> superTypes,
            AnnotationIntrospector aintr, MixInResolver mir, TypeFactory tf,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _class = cls;
=======
        _type = type;
        _class = rawType;
        _bindings = bindings;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
        _typeFactory = tf;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedClass(_class, _superTypes,
                _annotationIntrospector, _mixInResolver, ann);
=======
        return new AnnotatedClass(_type, _class, _bindings, _superTypes,
                _annotationIntrospector, _mixInResolver, _typeFactory, ann);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     * 
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    public static AnnotatedClass construct(Class<?> cls,
            AnnotationIntrospector aintr, MixInResolver mir)
=======
    public static AnnotatedClass construct(JavaType type, MapperConfig<?> config) {
        AnnotationIntrospector intr = config.isAnnotationProcessingEnabled()
                ? config.getAnnotationIntrospector() : null;
        Class<?> raw = type.getRawClass();
        return new AnnotatedClass(type, raw, type.getBindings(),
                ClassUtil.findSuperTypes(type, null, false), intr,
                (MixInResolver) config, config.getTypeFactory(), null);
    }

    /**
     * @since 2.7
     */
    public static AnnotatedClass construct(JavaType type, MapperConfig<?> config,
            MixInResolver mir)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedClass(cls,
                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);
=======
        AnnotationIntrospector intr = config.isAnnotationProcessingEnabled()
                ? config.getAnnotationIntrospector() : null;
        Class<?> raw = type.getRawClass();
        return new AnnotatedClass(type, raw, type.getBindings(),
                ClassUtil.findSuperTypes(type, null, false),
                intr, mir, config.getTypeFactory(), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE

=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls,
            AnnotationIntrospector aintr, MixInResolver mir)
=======
    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, MapperConfig<?> config)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedClass(cls,
                Collections.<Class<?>>emptyList(), aintr, mir, null);
=======
        if (config == null) {
            return new AnnotatedClass(null, cls, TypeBindings.emptyBindings(),
                    Collections.<JavaType>emptyList(), null, null, null, null);
        }
        AnnotationIntrospector intr = config.isAnnotationProcessingEnabled()
                ? config.getAnnotationIntrospector() : null;
        return new AnnotatedClass(null, cls, TypeBindings.emptyBindings(),
                Collections.<JavaType>emptyList(), intr, (MixInResolver) config, config.getTypeFactory(), null);
    }

    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, MapperConfig<?> config,
            MixInResolver mir)
    {
        if (config == null) {
            return new AnnotatedClass(null, cls, TypeBindings.emptyBindings(),
                    Collections.<JavaType>emptyList(), null, null, null, null);
        }
        AnnotationIntrospector intr = config.isAnnotationProcessingEnabled()
                ? config.getAnnotationIntrospector() : null;
        return new AnnotatedClass(null, cls, TypeBindings.emptyBindings(),
                Collections.<JavaType>emptyList(), intr, mir, config.getTypeFactory(), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    
=======

    /*
    /**********************************************************
    /* TypeResolutionContext implementation
    /**********************************************************
     */

    @Override
    public JavaType resolveType(Type type) {
        return _typeFactory.constructType(type, _bindings);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    public <A extends Annotation> A getAnnotation(Class<A> acls)
    {
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations.get(acls);
=======
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _classAnnotations().get(acls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    public Type getGenericType() {
        return _class;
=======
    public boolean hasAnnotation(Class<?> acls) {
        return _classAnnotations().has(acls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
    public boolean hasOneOf(Class<? extends Annotation>[] annoClasses) {
        return _classAnnotations().hasOneOf(annoClasses);
    }
    
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations.annotations();
=======
        return _classAnnotations().annotations();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations;
=======
        return _classAnnotations();
    }

    @Override
    public JavaType getType() {
        return _type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations;
=======
        return _classAnnotations();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (_classAnnotations == null) {
            resolveClassAnnotations();
        }
        return _classAnnotations.size() > 0;
=======
        return _classAnnotations().size() > 0;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
    private AnnotationMap _classAnnotations() {
        AnnotationMap anns = _classAnnotations;
        if (anns == null) {
            // 06-Dec-2015, tatu: yes, double-locking, typically not a good choice.
            //  But for typical usage pattern here (and with JVM 7 and above) is
            //  a reasonable choice to avoid non-common but existing race condition
            //  from root name lookup style usage
            // Also note that race condition stems from caching only used for loading
            // where just class annotations are needed
            synchronized (this) {
                anns = _classAnnotations;
                if (anns == null) {
                    anns = _resolveClassAnnotations();
                    _classAnnotations = anns;
                }
            }
        }
        return anns;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    private void resolveClassAnnotations()
=======
    private AnnotationMap _resolveClassAnnotations()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        // [JACKSON-659] Should skip processing if annotation processing disabled
=======
        // Should skip processing if annotation processing disabled
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            _addAnnotationsIfNotPresent(ca, _class.getDeclaredAnnotations());
=======
            _addAnnotationsIfNotPresent(ca,
                    ClassUtil.findClassAnnotations(_class));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            for (Class<?> cls : _superTypes) {
=======
            for (JavaType type : _superTypes) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                _addClassMixIns(ca, cls);
                _addAnnotationsIfNotPresent(ca, cls.getDeclaredAnnotations());
=======
                _addClassMixIns(ca, type);
                _addAnnotationsIfNotPresent(ca,
                        ClassUtil.findClassAnnotations(type.getRawClass()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _classAnnotations = ca;
=======
        return ca;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();
        for (Constructor<?> ctor : declaredCtors) {
            if (_isIncludableConstructor(ctor)) {
                if (ctor.getParameterTypes().length == 0) {
                    _defaultConstructor = _constructConstructor(ctor, true);
=======
        ClassUtil.Ctor[] declaredCtors = ClassUtil.getConstructors(_class);
        // Constructor also always members of this class, so
        TypeResolutionContext typeContext = this;        
        for (ClassUtil.Ctor ctor : declaredCtors) {
            if (_isIncludableConstructor(ctor.getConstructor())) {
                if (ctor.getParamCount() == 0) {
                    _defaultConstructor = _constructDefaultConstructor(ctor, typeContext);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                    constructors.add(_constructConstructor(ctor, false));
=======
                    constructors.add(_constructNonDefaultConstructor(ctor, typeContext));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:
=======
        // AnnotationIntrospector is null if annotations not enabled; if so, can skip:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            // all factory methods are fine, as per [JACKSON-850]
=======
            // all factory methods are fine:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            creatorMethods.add(_constructCreatorMethod(m));
=======
            creatorMethods.add(_constructCreatorMethod(m, typeContext));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);
        
=======
        _addMemberMethods(_class, this, _memberMethods, _primaryMixIn, mixins);

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Class<?> cls : _superTypes) {
            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         
            _addMemberMethods(cls, _memberMethods, mixin, mixins);
=======
        for (JavaType type : _superTypes) {
            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(type.getRawClass());
            TypeResolutionContext typeContext = new TypeResolutionContext.Basic(_typeFactory,
                    type.getBindings());
            _addMemberMethods(type.getRawClass(), typeContext, _memberMethods, mixin, mixins);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                            AnnotatedMethod am = _constructMethod(m);
=======
                            // Since it's from java.lang.Object, no generics, no need for real type context:
                            AnnotatedMethod am = _constructMethod(m, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        Map<String,AnnotatedField> foundFields = _findFields(_class, null);
=======
        Map<String,AnnotatedField> foundFields = _findFields(_type, this, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)
=======
    protected void _addClassMixIns(AnnotationMap annotations, JavaType target)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
            final Class<?> toMask = target.getRawClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
    protected void _addClassMixIns(AnnotationMap annotations, Class<?> target)
    {
        if (_mixInResolver != null) {
            _addClassMixIns(annotations, target, _mixInResolver.findMixInClassFor(target));
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                                   Class<?> mixin)
=======
            Class<?> mixin)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());
=======
        _addAnnotationsIfNotPresent(annotations, ClassUtil.findClassAnnotations(mixin));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {
            _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations());
=======
        for (Class<?> parent : ClassUtil.findSuperClasses(mixin, toMask, false)) {
            _addAnnotationsIfNotPresent(annotations, ClassUtil.findClassAnnotations(parent));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {
=======
        for (ClassUtil.Ctor ctor0 : ClassUtil.getConstructors(mixin)) {
            Constructor<?> ctor = ctor0.getConstructor();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Method m : mixin.getDeclaredMethods()) {
=======
        for (Method m : ClassUtil.getDeclaredMethods(mixin)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,
=======
    protected void _addMemberMethods(Class<?> cls, TypeResolutionContext typeContext,
            AnnotatedMethodMap methods,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                AnnotatedMethod newM = _constructMethod(m);
=======
                AnnotatedMethod newM = _constructMethod(m, typeContext);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        List<Class<?>> parents = new ArrayList<Class<?>>();
        parents.add(mixInCls);
        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);
=======
//        List<Class<?>> parents = ClassUtil.findSuperClasses(mixInCls, targetClass, true);

        List<Class<?>> parents = ClassUtil.findRawSuperTypes(mixInCls, targetClass, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            for (Method m : mixin.getDeclaredMethods()) {
=======
            for (Method m : ClassUtil.getDeclaredMethods(mixin)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                    // Well, or, as per [Issue#515], multi-level merge within mixins...
=======
                    // Well, or, as per [databind#515], multi-level merge within mixins...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                        mixIns.add(_constructMethod(m));
=======
                        // 03-Nov-2015, tatu: Mix-in method never called, should not need
                        //    to resolve generic types, so this class is fine as context
                        mixIns.add(_constructMethod(m, this));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)
=======
    protected Map<String,AnnotatedField> _findFields(JavaType type,
            TypeResolutionContext typeContext, Map<String,AnnotatedField> fields)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        Class<?> parent = c.getSuperclass();
=======
        JavaType parent = type.getSuperClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
            final Class<?> cls = type.getRawClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            fields = _findFields(parent, fields);
            for (Field f : c.getDeclaredFields()) {
=======
            fields = _findFields(parent,
                    new TypeResolutionContext.Basic(_typeFactory, parent.getBindings()),
                    fields);
            for (Field f : ClassUtil.getDeclaredFields(cls)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                fields.put(f.getName(), _constructField(f));
=======
                fields.put(f.getName(), _constructField(f, typeContext));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                Class<?> mixin = _mixInResolver.findMixInClassFor(c);
=======
                Class<?> mixin = _mixInResolver.findMixInClassFor(cls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                    _addFieldMixIns(parent, mixin, fields);
=======
                    _addFieldMixIns(mixin, cls, fields);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,
=======
    protected void _addFieldMixIns(Class<?> mixInCls, Class<?> targetClass,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        List<Class<?>> parents = new ArrayList<Class<?>>();
        parents.add(mixInCls);
        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);
=======
        List<Class<?>> parents = ClassUtil.findSuperClasses(mixInCls, targetClass, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            for (Field mixinField : mixin.getDeclaredFields()) {
=======
            for (Field mixinField : ClassUtil.getDeclaredFields(mixin)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected AnnotatedMethod _constructMethod(Method m)
=======
    protected AnnotatedMethod _constructMethod(Method m, TypeResolutionContext typeContext)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return new AnnotatedMethod(this, m, _emptyAnnotationMap(), null);
=======
            return new AnnotatedMethod(typeContext, m, _emptyAnnotationMap(), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedMethod(this, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);
=======
        return new AnnotatedMethod(typeContext, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)
=======
    protected AnnotatedConstructor _constructDefaultConstructor(ClassUtil.Ctor ctor,
            TypeResolutionContext typeContext)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return new AnnotatedConstructor(this, ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));
=======
            return new AnnotatedConstructor(typeContext, ctor.getConstructor(), _emptyAnnotationMap(), NO_ANNOTATION_MAPS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        if (defaultCtor) {
            return new AnnotatedConstructor(this, ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);
=======
        return new AnnotatedConstructor(typeContext, ctor.getConstructor(),
                _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), NO_ANNOTATION_MAPS);
    }

    protected AnnotatedConstructor _constructNonDefaultConstructor(ClassUtil.Ctor ctor,
            TypeResolutionContext typeContext)
    {
        final int paramCount = ctor.getParamCount();
        if (_annotationIntrospector == null) { // when annotation processing is disabled
            return new AnnotatedConstructor(typeContext, ctor.getConstructor(),
                    _emptyAnnotationMap(), _emptyAnnotationMaps(paramCount));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        Annotation[][] paramAnns = ctor.getParameterAnnotations();
        int paramCount = ctor.getParameterTypes().length;
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
        if (paramCount == 0) { // no-arg default constructors, can simplify slightly
            return new AnnotatedConstructor(typeContext, ctor.getConstructor(),
                    _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), NO_ANNOTATION_MAPS);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        AnnotationMap[] resolvedAnnotations = null;
=======
        AnnotationMap[] resolvedAnnotations;
        Annotation[][] paramAnns = ctor.getParameterAnnotations();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
            resolvedAnnotations = null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedConstructor(this, ctor,
=======
        return new AnnotatedConstructor(typeContext, ctor.getConstructor(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected AnnotatedMethod _constructCreatorMethod(Method m)
=======
    protected AnnotatedMethod _constructCreatorMethod(Method m, TypeResolutionContext typeContext)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
        final int paramCount = m.getParameterTypes().length;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return new AnnotatedMethod(this, m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));
=======
            return new AnnotatedMethod(typeContext, m, _emptyAnnotationMap(), _emptyAnnotationMaps(paramCount));
        }
        if (paramCount == 0) { // common enough we can slightly optimize
            return new AnnotatedMethod(typeContext, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),
                    NO_ANNOTATION_MAPS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedMethod(this, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),
=======
        return new AnnotatedMethod(typeContext, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    protected AnnotatedField _constructField(Field f)
=======
    protected AnnotatedField _constructField(Field f, TypeResolutionContext typeContext)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return new AnnotatedField(this, f, _emptyAnnotationMap());
=======
            return new AnnotatedField(typeContext, f, _emptyAnnotationMap());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        return new AnnotatedField(this, f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));
=======
        return new AnnotatedField(typeContext, f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        for (Annotation a : bundle.annotationType().getDeclaredAnnotations()) {
=======
        for (Annotation a : ClassUtil.findClassAnnotations(bundle.annotationType())) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            return cls.getDeclaredMethods();
=======
            return ClassUtil.getDeclaredMethods(cls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            if(loader == null){
=======
            if (loader == null){
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                // !!! TODO: 08-May-2015, tatu: Chain appropriately once we have JDK7 as baseline
                //ex.addSuppressed(e); Not until 1.7
=======
                // !!! TODO: 08-May-2015, tatu: Chain appropriately once we have JDK 1.7/Java7 as baseline
                //ex.addSuppressed(e); Not until Jackson 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Member;
import java.lang.reflect.Type;
=======
import java.lang.reflect.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.TypeFactory;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
    protected final Type _type;
=======
    protected final JavaType _type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
    public AnnotatedParameter(AnnotatedWithParams owner, Type type,  AnnotationMap annotations,
=======
    public AnnotatedParameter(AnnotatedWithParams owner, JavaType type,  AnnotationMap annotations,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
        super((owner == null) ? null : owner.getContextClass(), annotations);
=======
        super((owner == null) ? null : owner.getTypeContext(), annotations);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
    /**
     * Accessor for annotations; all annotations associated with parameters
     * are properly passed and accessible.
     */
    @Override
    public <A extends Annotation> A getAnnotation(Class<A> acls)
    {
        return (_annotations == null) ? null : _annotations.get(acls);
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
    public Type getGenericType() {
        return _type;
=======
    public Class<?> getRawType() {
        return _type.getRawClass();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java;<<<<<<< MINE
    public Class<?> getRawType()
    {
        if (_type instanceof Class<?>) {
            return (Class<?>) _type;
        }
        // 14-Mar-2011, tatu: Not optimal, but has to do for now...
        JavaType t = TypeFactory.defaultInstance().constructType(_type);
        return t.getRawClass();
=======
    public JavaType getType() {
        return _typeContext.resolveType(_type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
import java.lang.reflect.TypeVariable;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.TypeBindings;
import com.fasterxml.jackson.databind.type.TypeFactory;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
    protected AnnotatedWithParams(AnnotatedClass ctxt, AnnotationMap annotations, AnnotationMap[] paramAnnotations)
=======
    protected AnnotatedWithParams(TypeResolutionContext ctxt, AnnotationMap annotations, AnnotationMap[] paramAnnotations)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
    }    
=======
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
=======
    /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE

    /*
    /**********************************************************
    /* Partial Annotated impl
    /**********************************************************
     */

    @Override
    public final <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _annotations.get(acls);
    }
=======
    */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
        return new AnnotatedParameter(this, getGenericParameterType(index),
=======
        return new AnnotatedParameter(this, getParameterType(index),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
    public abstract Type getGenericParameterType(int index);
=======
    /**
     * @since 2.7
     */
    public abstract JavaType getParameterType(int index);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
     * Method called to fully resolve type of one of parameters, given
     * specified type variable bindings.
=======
     * @deprecated Since 2.7, remove in 2.8
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
    public final JavaType resolveParameterType(int index, TypeBindings bindings) {
        return bindings.resolveType(getGenericParameterType(index));
=======
    @Deprecated
    public final Type getGenericParameterType(int index) {
        return getRawParameterType(index);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.TypeBindings;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
    public AnnotatedConstructor(AnnotatedClass ctxt, Constructor<?> constructor,
=======
    public AnnotatedConstructor(TypeResolutionContext ctxt, Constructor<?> constructor,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
        return new AnnotatedConstructor(_context, _constructor, ann, _paramAnnotations);
=======
        return new AnnotatedConstructor(_typeContext, _constructor, ann, _paramAnnotations);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
    public Type getGenericType() {
        return getRawType();
=======
    public JavaType getType() {
        return _typeContext.resolveType(getRawType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE

=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
    // note: copied verbatim from AnnotatedMethod; hard to generalize
    /**
     * As per [JACKSON-468], we need to also allow declaration of local
     * type bindings; mostly it will allow defining bounds.
     */
    @Override
    public JavaType getType(TypeBindings bindings)
    {
        return getType(bindings, _constructor.getTypeParameters());
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
    public Type getGenericParameterType(int index)
    {
=======
    public JavaType getParameterType(int index) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
        return (index >= types.length) ? null : types[index];
=======
        if (index >= types.length) {
            return null;
        }
        return _typeContext.resolveType(types[index]);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(ctor);
=======
                ClassUtil.checkAndFixAccess(ctor, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
=======
import java.lang.reflect.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.JavaType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
    public AnnotatedField(AnnotatedClass contextClass, Field field, AnnotationMap annMap)
=======
    public AnnotatedField(TypeResolutionContext contextClass, Field field, AnnotationMap annMap)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
        return new AnnotatedField(_context, _field, ann);
=======
        return new AnnotatedField(_typeContext, _field, ann);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return (_annotations == null) ? null : _annotations.get(acls);
=======
    public Class<?> getRawType() {
        return _field.getType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
    public Type getGenericType() {
        return _field.getGenericType();
=======
    public JavaType getType() {
        return _typeContext.resolveType(_field.getGenericType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
    @Override
    public Class<?> getRawType() {
        return _field.getType();
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(f);
=======
                ClassUtil.checkAndFixAccess(f, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
import java.beans.ConstructorProperties;
import java.beans.Transient;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @SuppressWarnings("unchecked")
    private final static Class<? extends Annotation>[] ANNOTATIONS_TO_INFER_SER = (Class<? extends Annotation>[])
            new Class<?>[] {
        JsonSerialize.class,
        JsonView.class,
        JsonFormat.class,
        JsonTypeInfo.class,
        JsonRawValue.class,
        JsonUnwrapped.class,
        JsonBackReference.class,
        JsonManagedReference.class
    };

    @SuppressWarnings("unchecked")
    private final static Class<? extends Annotation>[] ANNOTATIONS_TO_INFER_DESER = (Class<? extends Annotation>[])
            new Class<?>[] {
        JsonDeserialize.class,
        JsonView.class,
        JsonFormat.class,
        JsonTypeInfo.class,
        JsonUnwrapped.class,
        JsonBackReference.class,
        JsonManagedReference.class
    };

    private static final Java7Support _jdk7Helper;
    static {
        Java7Support x = null;
        try {
            x = Java7Support.class.newInstance();
        } catch (Throwable t) {
            // 24-Nov-2015, tatu: Should we log or not?
            java.util.logging.Logger.getLogger(JacksonAnnotationIntrospector.class.getName())
                .warning("Unable to load JDK7 annotation types; will have to skip");
        }
        _jdk7Helper = x;
    }
    
    /**
     * Since introspection of annotation types is a performance issue in some
     * use cases (rare, but do exist), let's try a simple cache to reduce
     * need for actual meta-annotation introspection.
     *<p>
     * Non-final only because it needs to be re-created after deserialization.
     *
     * @since 2.7
     */
    protected transient LRUMap<Class<?>,Boolean> _annotationsInside = new LRUMap<Class<?>,Boolean>(48, 48);
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    protected Object readResolve() {
        if (_annotationsInside == null) {
            _annotationsInside = new LRUMap<Class<?>,Boolean>(48, 48);
        }
        return this;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;
=======
        // 22-Sep-2015, tatu: Caching here has modest effect on JavaSE, and only
        //   mostly in degenerate cases where introspection used more often than
        //   it should (like recreating ObjectMapper once per read/write).
        //   But it may be more beneficial on platforms like Android (should verify)
        Class<?> type = ann.annotationType();
        Boolean b = _annotationsInside.get(type);
        if (b == null) {
            b = type.getAnnotation(JacksonAnnotationsInside.class) != null;
            _annotationsInside.putIfAbsent(type, b);
        }
        return b.booleanValue();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Override // since 2.7
    public String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {
        HashMap<String,String> expl = null;
        for (Field f : ClassUtil.getDeclaredFields(enumType)) {
            if (!f.isEnumConstant()) {
                continue;
            }
            JsonProperty prop = f.getAnnotation(JsonProperty.class);
            if (prop == null) {
                continue;
            }
            String n = prop.value();
            if (n.isEmpty()) {
                continue;
            }
            if (expl == null) {
                expl = new HashMap<String,String>();
            }
            expl.put(f.getName(), n);
        }
        // and then stitch them together if and as necessary
        if (expl != null) {
            for (int i = 0, end = enumValues.length; i < end; ++i) {
                String defName = enumValues[i].name();
                names[i] = expl.get(defName);
            }
        }
        return names;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE

    /**
     * @deprecated (since 2.3) Use {@link #findFilterId(Annotated)} instead
     */
    @Deprecated
    @Override
    public Object findFilterId(AnnotatedClass ac) {
        return _findFilterId(ac);
    }
    
=======
 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return _findFilterId(a);
    }

    protected final Object _findFilterId(Annotated a)
    {
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    } 
=======
    }

    @Override
    public String findClassDescription(AnnotatedClass ac) {
        JsonClassDescription ann = _findAnnotation(ac, JsonClassDescription.class);
        return (ann == null) ? null : ann.value();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Override // since 2.7
    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config,
            AnnotatedMethod setter1, AnnotatedMethod setter2)
    {
        Class<?> cls1 = setter1.getRawParameterType(0);
        Class<?> cls2 = setter2.getRawParameterType(0);
        
        // First: prefer primitives over non-primitives
        // 11-Dec-2015, tatu: TODO, perhaps consider wrappers for primitives too?
        if (cls1.isPrimitive()) {
            if (!cls2.isPrimitive()) {
                return setter1;
            }
        } else if (cls2.isPrimitive()) {
            return setter2;
        }
        
        if (cls1 == String.class) {
            if (cls2 != String.class) {
                return setter1;
            }
        } else if (cls2 == String.class) {
            return setter2;
        }

        return null;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        if (!containerType.isContainerType()) {
            throw new IllegalArgumentException("Must call method with a container type (got "+containerType+")");
=======
        if (containerType.getContentType() == null) {
            throw new IllegalArgumentException("Must call method with a container or reference type (got "+containerType+")");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        String name = null;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
            name = jg.value();
        } else {
            JsonProperty pann = _findAnnotation(a, JsonProperty.class);
            if (pann != null) {
                name = pann.value();
                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but
                 *   it's actually bit tricky to do it more efficiently (meta-annotations
                 *   add more lookups; AnnotationMap costs etc)
                 */
            } else if (_hasAnnotation(a, JsonSerialize.class)
                    || _hasAnnotation(a, JsonView.class)
                    || _hasAnnotation(a, JsonRawValue.class)
                    || _hasAnnotation(a, JsonUnwrapped.class)
                    || _hasAnnotation(a, JsonBackReference.class)
                    || _hasAnnotation(a, JsonManagedReference.class)) {
                name = "";
            } else {
                return null;
            }
=======
            return PropertyName.construct(jg.value());
        }
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            return PropertyName.construct(pann.value());
        }
        PropertyName ctorName = _findConstructorName(a);
        if (ctorName != null) {
            return ctorName;
        }
        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_SER)) {
            return PropertyName.USE_DEFAULT;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return PropertyName.construct(name);
=======
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {
        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.as());
=======
    public Object findDeserializationConverter(Annotated a)
    {
        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {
        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.keyAs());
=======
    public Object findDeserializationContentConverter(AnnotatedMember a)
    {
        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Deserialization: type modifications
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE

=======
    
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    public Object findDeserializationConverter(Annotated a)
    {
        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);
=======
    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {
        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.as());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
    public Object findDeserializationContentConverter(AnnotatedMember a)
    {
        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);
=======
    @Deprecated
    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {
        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.keyAs());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE

=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        String name;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
            name = js.value();
        } else {
            JsonProperty pann = _findAnnotation(a, JsonProperty.class);
            if (pann != null) {
                name = pann.value();
                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but
                 *   it's actually bit tricky to do it more efficiently (meta-annotations
                 *   add more lookups; AnnotationMap costs etc)
                 */
            } else if (_hasAnnotation(a, JsonDeserialize.class)
                    || _hasAnnotation(a, JsonView.class)
                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]
                    || _hasAnnotation(a, JsonBackReference.class)
                    || _hasAnnotation(a, JsonManagedReference.class)) {
                    name = "";
            } else {
                return null;
            }
=======
            return PropertyName.construct(js.value());
        }
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            return PropertyName.construct(pann.value());
        }
        PropertyName ctorName = _findConstructorName(a);
        if (ctorName != null) {
            return ctorName;
        }
        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_DESER)) {
            return PropertyName.USE_DEFAULT;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return PropertyName.construct(name);
=======
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);
=======
         if (ann != null) {
             return (ann.mode() != JsonCreator.Mode.DISABLED);
         }
         if (a instanceof AnnotatedConstructor) {
             if (_jdk7Helper != null) {
                 Boolean b = _jdk7Helper.hasCreatorAnnotation(a);
                 if (b != null) {
                     return b.booleanValue();
                 }
             }
         }
         return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return (ann != null && ann.value());
=======
        if (ann != null) {
            return ann.value();
        }
        if (_jdk7Helper != null) {
            Boolean b = _jdk7Helper.findTransient(a);
            if (b != null) {
                return b.booleanValue();
            }
        }
        return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    protected PropertyName _findConstructorName(Annotated a)
    {
        if (a instanceof AnnotatedParameter) {
            AnnotatedParameter p = (AnnotatedParameter) a;
            AnnotatedWithParams ctor = p.getOwner();

            if (ctor != null) {
                if (_jdk7Helper != null) {
                    PropertyName name = _jdk7Helper.findConstructorName(p);
                    if (name != null) {
                        return name;
                    }
                }
            }
        }
        return null;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======

    /*
    /**********************************************************
    /* Helper classes
    /**********************************************************
     */

    /**
     * To support Java7-incomplete platforms, we will offer support for JDK 7
     * annotations through this class, loaded dynamically; if loading fails,
     * support will be missing.
     */
    private static class Java7Support
    {
        @SuppressWarnings("unused") // compiler warns, just needed side-effects
        private final Class<?> _bogus;

        @SuppressWarnings("unused") // compiler warns; called via Reflection
        public Java7Support() {
            // Trigger loading of annotations that only JDK 7 has...
            Class<?> cls = Transient.class;
            cls = ConstructorProperties.class;
            _bogus = cls;
        }
        
        public Boolean findTransient(Annotated a) {
            Transient t = a.getAnnotation(Transient.class);
            if (t != null) {
                return t.value();
            }
            return null;
        }

        public Boolean hasCreatorAnnotation(Annotated a) {
            ConstructorProperties props = a.getAnnotation(ConstructorProperties.class);
            // 08-Nov-2015, tatu: One possible check would be to ensure there is at least
            //    one name iff constructor has arguments. But seems unnecessary for now.
            if (props != null) {
                return Boolean.TRUE;
            }
            return null;
        }

        public PropertyName findConstructorName(AnnotatedParameter p)
        {
            AnnotatedWithParams ctor = p.getOwner();
            if (ctor != null) {
                ConstructorProperties props = ctor.getAnnotation(ConstructorProperties.class);
                if (props != null) {
                    String[] names = props.value();
                    int ix = p.getIndex();
                    if (ix < names.length) {
                        return PropertyName.construct(names[ix]);
                    }
                }
            }
            return null;
        }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/ConcreteBeanPropertyBase.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.introspect;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.AnnotationIntrospector;
import com.fasterxml.jackson.databind.BeanProperty;
import com.fasterxml.jackson.databind.PropertyMetadata;
import com.fasterxml.jackson.databind.cfg.MapperConfig;

/**
 * Intermediate {@link BeanProperty} class shared by concrete readable- and
 * writable property implementations for sharing common functionality.
 *
 * @since 2.7
 */
public abstract class ConcreteBeanPropertyBase
    implements BeanProperty, java.io.Serializable
{
    private static final long serialVersionUID = 1;

    /**
     * Additional information about property
     *
     * @since 2.3
     */
    protected final PropertyMetadata _metadata;
    
    /**
     * Lazily accessed value for per-property format override definition.
     * 
     * @since 2.6
     */
    protected transient JsonFormat.Value _format;

    protected ConcreteBeanPropertyBase(PropertyMetadata md) {
        _metadata = (md == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL : md;
    }

    protected ConcreteBeanPropertyBase(ConcreteBeanPropertyBase src) {
        _metadata = src._metadata;
        _format = src._format;
    }

    @Override
    public boolean isRequired() { return _metadata.isRequired(); }

    @Override
    public PropertyMetadata getMetadata() { return _metadata; }
    
    @Override
    public boolean isVirtual() { return false; }

    @Override
    @Deprecated
    public final JsonFormat.Value findFormatOverrides(AnnotationIntrospector intr) {
        JsonFormat.Value f = _format;
        if (f == null) { // not yet looked up, do that
            if (intr != null) {
                AnnotatedMember member = getMember();
                if (member != null) {
                    f = intr.findFormat(member);
                }
            }
            if (f == null) {
                f = EMPTY_FORMAT;
            }
        }
        return f;
    }

    @Override
    public JsonFormat.Value findPropertyFormat(MapperConfig<?> config, Class<?> baseType)
    {
        // 08-Oct-2015, tatu: Unlike with Format, let's not cache locally here, for now?
        JsonFormat.Value v0 = config.getDefaultPropertyFormat(baseType);
        AnnotationIntrospector intr = config.getAnnotationIntrospector();
        AnnotatedMember member = getMember();
        if ((intr == null) || (member == null)) {
            return v0;
        }
        JsonFormat.Value v = intr.findFormat(member);
        if (v == null) {
            return v0;
        }
        return v0.withOverrides(v);
    }

    @Override
    public JsonInclude.Value findPropertyInclusion(MapperConfig<?> config, Class<?> baseType)
    {
        JsonInclude.Value v0 = config.getDefaultPropertyInclusion(baseType);
        AnnotationIntrospector intr = config.getAnnotationIntrospector();
        AnnotatedMember member = getMember();
        if ((intr == null) || (member == null)) {
            return v0;
        }
        JsonInclude.Value v = intr.findPropertyInclusion(member);
        if (v == null) {
            return v0;
        }
        return v0.withOverrides(v);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
                 *   use serialization annotation (@JsonSerializer) when serializing
=======
                 *   use serialization annotation (@JsonSerialize) when serializing
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
            // As per [#428](https://github.com/FasterXML/jackson-databind/issues/428) need
            // to skip renaming if property has explicitly defined name
            if (!prop.isExplicitlyNamed()) {
=======
            // As per [databind#428] need to skip renaming if property has
            // explicitly defined name, unless feature  is enabled
            if (!prop.isExplicitlyNamed() || _config.isEnabled(MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
            /* As per [Issue#311], this is bit delicate; but if alphabetic ordering
=======
            /* As per [databind#311], this is bit delicate; but if alphabetic ordering
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java;<<<<<<< MINE
            prop = new POJOPropertyBuilder(PropertyName.construct(implName),
                    _annotationIntrospector, _forSerialization);
=======
            prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,
                    PropertyName.construct(implName));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
     * Class that was resolved to produce this member instance; either class that declared
     * the member, or one of its subtypes that inherited it.
     * 
     * @since 2.5
=======
     * Context object needed for resolving generic type associated with this
     * member (method parameter or return value, or field type).
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
    protected final transient AnnotatedClass _context;
=======
    protected final transient TypeResolutionContext _typeContext;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
    /*
    @Deprecated // since 2.5
    protected AnnotatedMember(AnnotationMap annotations) {
        this(null, annotations);
    }
    */

    protected AnnotatedMember(AnnotatedClass ctxt, AnnotationMap annotations) {
=======
    protected AnnotatedMember(TypeResolutionContext ctxt, AnnotationMap annotations) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
        _context = ctxt;
=======
        _typeContext = ctxt;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
        _context = base._context;
=======
        _typeContext = base._typeContext;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
     * Note that this may be different from what {@link #getContextClass()} returns;
     * "owner" may be a sub-type of "declaring class".
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
     * Accessor for {@link AnnotatedClass} that was the type that was resolved
     * and that contains this member: this is either the {@link java.lang.Class}
     * in which member was declared, or one of its super types. If distinction
     * between result type, and actual class in which declaration was found matters,
     * you can compare return value to that of {@link #getDeclaringClass()}.
     * The main use for this accessor is (usually) to access class annotations.
     *<p>
     * Also note that owner property is NOT (JDK-)serialized; this should usually not
     * matter, but means that while it is accessible during construction of various
     * (de)serializers, it may not be available on per-call basis, if (but only if)
     * <code>ObjectMapper</code> (etc) has been serialized/deserialized.
=======
     * Accessor for {@link TypeResolutionContext} that is used for resolving
     * full generic type of this member.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
     * @since 2.5
=======
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
    public AnnotatedClass getContextClass() {
        return _context;
=======
    public TypeResolutionContext getTypeContext() {
        return _typeContext;
    }

    @Override
    public final <A extends Annotation> A getAnnotation(Class<A> acls) {
        if (_annotations == null) {
            return null;
        }
        return _annotations.get(acls);
    }

    @Override
    public final boolean hasAnnotation(Class<?> acls) {
        if (_annotations == null) {
            return false;
        }
        return _annotations.has(acls);
    }

    @Override
    public boolean hasOneOf(Class<? extends Annotation>[] annoClasses) {
        if (_annotations == null) {
            return false;
        }
        return _annotations.hasOneOf(annoClasses);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
=======
     *<p>
     * Note that caller should verify that
     * {@link com.fasterxml.jackson.databind.MapperFeature#CAN_OVERRIDE_ACCESS_MODIFIERS}
     * is enabled before calling this method; as well as pass
     * <code>force</code> flag appropriately.
     * 
     * @since 2.7
     */
    public final void fixAccess(boolean force) {
        ClassUtil.checkAndFixAccess(getMember(), force);
    }
    
    /**
     * @deprecated Since 2.7 use {@link #fixAccess(boolean)} instead
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
        ClassUtil.checkAndFixAccess(getMember());
=======
//        fixAccess(false);
        fixAccess(true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
import java.lang.annotation.Annotation;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.JavaType;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
    public VirtualAnnotatedMember(AnnotatedClass contextClass, Class<?> declaringClass,
=======
    public VirtualAnnotatedMember(TypeResolutionContext typeContext, Class<?> declaringClass,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
        super(contextClass, /* AnnotationMap*/ null);
=======
        super(typeContext, /* AnnotationMap*/ null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return null;
=======
    public Class<?> getRawType() {
        return _rawType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
    public Type getGenericType() {
        return _rawType;
=======
    public JavaType getType() {
        return _typeContext.resolveType(_rawType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java;<<<<<<< MINE
    @Override
    public Class<?> getRawType() {
        return _rawType;
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
    @Deprecated
    @Override
    public Object findFilterId(AnnotatedClass ac)
    {
        Object id = _primary.findFilterId(ac);
        if (id == null) {
            id = _secondary.findFilterId(ac);
        }
        return id;
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Override
    public String findClassDescription(AnnotatedClass ac) {
        String str = _primary.findClassDescription(ac);
        if ((str == null) || str.isEmpty()) {
            str = _secondary.findClassDescription(ac);
        }
        return str;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
        defValue = _secondary.findSerializationInclusion(a, defValue);
        defValue = _primary.findSerializationInclusion(a, defValue);
=======
        defValue = _secondary.findSerializationInclusionForContent(a, defValue);
        defValue = _primary.findSerializationInclusionForContent(a, defValue);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
    public JsonInclude.Value findPropertyInclusion(Annotated a) {
=======
    public JsonInclude.Value findPropertyInclusion(Annotated a)
    {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
        JsonInclude.Value v1 = _secondary.findPropertyInclusion(a);
=======
        JsonInclude.Value v1 = _primary.findPropertyInclusion(a);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
    public Class<?> findSerializationType(Annotated a) {
        Class<?> r = _primary.findSerializationType(a);
        return (r == null) ? _secondary.findSerializationType(a) : r;
    }

    @Override
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {
        Class<?> r = _primary.findSerializationKeyType(am, baseType);
        return (r == null) ? _secondary.findSerializationKeyType(am, baseType) : r;
    }

    @Override
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {
        Class<?> r = _primary.findSerializationContentType(am, baseType);
        return (r == null) ? _secondary.findSerializationContentType(am, baseType) : r;
    }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
        JsonFormat.Value r = _primary.findFormat(ann);
        return (r == null) ? _secondary.findFormat(ann) : r;
=======
        JsonFormat.Value v1 = _primary.findFormat(ann);
        JsonFormat.Value v2 = _secondary.findFormat(ann);
        if (v2 == null) { // shouldn't occur but just in case
            return v1;
        }
        return v2.withOverrides(v1);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Override // since 2.7
    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config,
            AnnotatedMethod setter1, AnnotatedMethod setter2)
    {
        AnnotatedMethod res = _primary.resolveSetterConflict(config, setter1, setter2);
        if (res == null) {
            res = _secondary.resolveSetterConflict(config, setter1, setter2);
        }
        return res;
    }

    // // // Serialization: type refinements

    @Override // since 2.7
    public JavaType refineSerializationType(MapperConfig<?> config,
            Annotated a, JavaType baseType) throws JsonMappingException
    {
        JavaType t = _secondary.refineSerializationType(config, a, baseType);
        return _primary.refineSerializationType(config, a, t);
    }
    
    @Override
    @Deprecated
    public Class<?> findSerializationType(Annotated a) {
        Class<?> r = _primary.findSerializationType(a);
        return (r == null) ? _secondary.findSerializationType(a) : r;
    }

    @Override
    @Deprecated
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {
        Class<?> r = _primary.findSerializationKeyType(am, baseType);
        return (r == null) ? _secondary.findSerializationKeyType(am, baseType) : r;
    }

    @Override
    @Deprecated
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {
        Class<?> r = _primary.findSerializationContentType(am, baseType);
        return (r == null) ? _secondary.findSerializationContentType(am, baseType) : r;
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Override
    public  String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {
        // reverse order to give _primary higher precedence
        names = _secondary.findEnumValues(enumType, enumValues, names);
        names = _primary.findEnumValues(enumType, enumValues, names);
        return names;
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======

    @Override
    public Object findDeserializationConverter(Annotated a) {
        Object ob = _primary.findDeserializationConverter(a);
        return (ob == null) ? _secondary.findDeserializationConverter(a) : ob;
    }

    @Override
    public Object findDeserializationContentConverter(AnnotatedMember a) {
        Object ob = _primary.findDeserializationContentConverter(a);
        return (ob == null) ? _secondary.findDeserializationContentConverter(a) : ob;
    }

    // // // Deserialization: type refinements

    // since 2.7
    @Override
    public JavaType refineDeserializationType(MapperConfig<?> config,
            Annotated a, JavaType baseType) throws JsonMappingException
    {
        JavaType t = _secondary.refineDeserializationType(config, a, baseType);
        return _primary.refineDeserializationType(config, a, t);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE

    @Override
    public Object findDeserializationConverter(Annotated a) {
        Object ob = _primary.findDeserializationConverter(a);
        return (ob == null) ? _secondary.findDeserializationConverter(a) : ob;
    }

    @Override
    public Object findDeserializationContentConverter(AnnotatedMember a) {
        Object ob = _primary.findDeserializationContentConverter(a);
        return (ob == null) ? _secondary.findDeserializationContentConverter(a) : ob;
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.util.EmptyIterator;
=======
import com.fasterxml.jackson.databind.util.ClassUtil;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java;<<<<<<< MINE
=======
    protected final static JsonInclude.Value EMPTY_INCLUDE = JsonInclude.Value.empty();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java;<<<<<<< MINE
    public JsonInclude.Include findInclusion() {
        return null;
=======
    public JsonInclude.Value findInclusion() {
        return EMPTY_INCLUDE;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
    public TypeBindings bindingsForBeanType()
    {
        if (_bindings == null) {
            _bindings = new TypeBindings(_config.getTypeFactory(), _type);
        }
        return _bindings;
=======
    @Deprecated // since 2.7
    public TypeBindings bindingsForBeanType() {
        return _type.getBindings();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
        return bindingsForBeanType().resolveType(jdkType);
=======
        return _config.getTypeFactory().constructType(jdkType, _type.getBindings());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
    public Object instantiateBean(boolean fixAccess)
    {
=======
    public Object instantiateBean(boolean fixAccess) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
            ac.fixAccess();
=======
            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
    public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue) {
        if (_annotationIntrospector == null) {
            return defValue;
=======
    public JsonInclude.Value findPropertyInclusion(JsonInclude.Value defValue) {
        if (_annotationIntrospector != null) {
            JsonInclude.Value incl = _annotationIntrospector.findPropertyInclusion(_classInfo);
            if (incl != null) {
                return defValue.withOverrides(incl);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
        return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue);
=======
        return defValue;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
    @Override
    public JsonInclude.Include findSerializationInclusionForContent(JsonInclude.Include defValue) {
        if (_annotationIntrospector == null) {
            return defValue;
        }
        return _annotationIntrospector.findSerializationInclusionForContent(_classInfo, defValue);
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java;<<<<<<< MINE
=======
    @Override
    public String findClassDescription() {
        return (_annotationIntrospector == null) ?
                null : _annotationIntrospector.findClassDescription(_classInfo);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.util.EmptyIterator;
=======
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import com.fasterxml.jackson.databind.util.ClassUtil;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
    protected final MapperConfig<?> _config;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai,
            boolean forSerialization) {
        this(internalName, internalName, ai, forSerialization);
=======
    public POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai,
            boolean forSerialization, PropertyName internalName) {
        this(config, ai, forSerialization, internalName, internalName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    protected POJOPropertyBuilder(PropertyName internalName, PropertyName name,
            AnnotationIntrospector annotationIntrospector, boolean forSerialization)
=======
    protected POJOPropertyBuilder(MapperConfig<?> config, AnnotationIntrospector ai,
            boolean forSerialization, PropertyName internalName, PropertyName name)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
        _config = config;
        _annotationIntrospector = ai;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        _annotationIntrospector = annotationIntrospector;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
        _config = src._config;
        _annotationIntrospector = src._annotationIntrospector;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        _annotationIntrospector = src._annotationIntrospector;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
            /* [JACKSON-255] Allow masking, i.e. do not report exception if one
             *   is in super-class from the other
             */
=======
            // Allow masking, i.e. do not fail if one is in super-class from the other
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
            AnnotatedMethod nextM = next.value;
            AnnotatedMethod currM = curr.value;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
            int priNext = _setterPriority(next.value);
            int priCurr = _setterPriority(curr.value);
=======
            int priNext = _setterPriority(nextM);
            int priCurr = _setterPriority(currM);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
            // 11-Dec-2015, tatu: As per [databind#1033] allow pluggable conflict resolution
            if (_annotationIntrospector != null) {
                AnnotatedMethod pref = _annotationIntrospector.resolveSetterConflict(_config,
                        currM, nextM);
                
                // note: should be one of nextM/currM; but no need to check
                if (pref == currM) {
                    continue;
                }
                if (pref == nextM) {
                    curr = next;
                    continue;
                }
            }
            
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
            return EmptyIterator.instance();
=======
            return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        // [#238]: Also, regular getters have precedence over "is-getters"
=======
        // [databind#238]: Also, regular getters have precedence over "is-getters"
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    public JsonInclude.Include findInclusion() {
        if (_annotationIntrospector == null) {
            return null;
=======
    public JsonInclude.Value findInclusion() {
        if (_annotationIntrospector != null) {
            AnnotatedMember a = getAccessor();
            JsonInclude.Value v =  _annotationIntrospector.findPropertyInclusion(a);
            if (v != null) {
                return v;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        AnnotatedMember am = getAccessor();
        return _annotationIntrospector.findSerializationInclusion(am, null);
=======
        return JsonInclude.Value.empty();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
    private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes)
=======
    private AnnotationMap _mergeAnnotations(int index,
            Linked<? extends AnnotatedMember>... nodes)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        ++index;
        for (; index < nodes.length; ++index) {
=======
        while (++index < nodes.length) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
                // [Issue#541] ... but only as long as it's visible
=======
                // [databind#541] ... but only as long as it's visible
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
                prop = new POJOPropertyBuilder(_internalName, name, _annotationIntrospector, _forSerialization);
=======
                prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,
                        _internalName, name);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java;<<<<<<< MINE
    protected HashMap<Class<? extends Annotation>,Annotation> _annotations;
=======
    protected HashMap<Class<?>,Annotation> _annotations;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java;<<<<<<< MINE
    private AnnotationMap(HashMap<Class<? extends Annotation>,Annotation> a) {
=======
    private AnnotationMap(HashMap<Class<?>,Annotation> a) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java;<<<<<<< MINE
=======
    public boolean has(Class<?> cls)
    {
        if (_annotations == null) {
            return false;
        }
        return _annotations.containsKey(cls);
    }

    /**
     * Helper method that can be used for a "bulk" check to see if at least
     * one of given annotation types is included within this map.
     *
     * @since 2.7
     */
    public boolean hasOneOf(Class<? extends Annotation>[] annoClasses) {
        if (_annotations != null) {
            for (int i = 0, end = annoClasses.length; i < end; ++i) {
                if (_annotations.containsKey(annoClasses[i])) {
                    return true;
                }
            }
        }
        return false;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java;<<<<<<< MINE
        HashMap<Class<? extends Annotation>,Annotation> annotations
            = new HashMap<Class<? extends Annotation>,Annotation>();
=======
        HashMap<Class<?>,Annotation> annotations = new HashMap<Class<?>,Annotation>();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java;<<<<<<< MINE
            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();
=======
            _annotations = new HashMap<Class<?>,Annotation>();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.util.ClassUtil;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(String.class, null, null);
=======
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(String.class, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Boolean.TYPE, null, null);
=======
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Boolean.TYPE, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Integer.TYPE, null, null);
=======
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Integer.TYPE, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Long.TYPE, null, null);
=======
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Long.TYPE, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            desc = _findStdJdkCollectionDesc(cfg, type, r);
=======
            desc = _findStdJdkCollectionDesc(cfg, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            desc = _findStdJdkCollectionDesc(cfg, type, r);
=======
            desc = _findStdJdkCollectionDesc(cfg, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            desc = _findStdJdkCollectionDesc(cfg, type, r);
=======
            desc = _findStdJdkCollectionDesc(cfg, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
    public BasicBeanDescription forClassAnnotations(MapperConfig<?> cfg,
=======
    public BasicBeanDescription forClassAnnotations(MapperConfig<?> config,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
                boolean useAnnotations = cfg.isAnnotationProcessingEnabled();
                AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),
                        (useAnnotations ? cfg.getAnnotationIntrospector() : null), r);
                desc = BasicBeanDescription.forOtherUse(cfg, type, ac);
=======
                AnnotatedClass ac = AnnotatedClass.construct(type, config, r);
                desc = BasicBeanDescription.forOtherUse(config, type, ac);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
    public BasicBeanDescription forDirectClassAnnotations(MapperConfig<?> cfg,
=======
    public BasicBeanDescription forDirectClassAnnotations(MapperConfig<?> config,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            boolean useAnnotations = cfg.isAnnotationProcessingEnabled();
            AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();
            AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),
                    (useAnnotations ? ai : null), r);
            desc = BasicBeanDescription.forOtherUse(cfg, type, ac);
=======
            AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(), config, r);
            desc = BasicBeanDescription.forOtherUse(config, type, ac);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
        boolean useAnnotations = config.isAnnotationProcessingEnabled();
        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),
                (useAnnotations ? config.getAnnotationIntrospector() : null), r);
=======
        AnnotatedClass ac = AnnotatedClass.construct(type, config, r);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), ai, r);
=======
        AnnotatedClass ac = AnnotatedClass.construct(type, config, r);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
        Package pkg = raw.getPackage();
        if (pkg != null) {
            String pkgName = pkg.getName();
=======
        String pkgName = ClassUtil.getPackageName(raw);
        if (pkgName != null) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
    protected BasicBeanDescription _findStdJdkCollectionDesc(MapperConfig<?> cfg,
            JavaType type, MixInResolver r)
=======
    protected BasicBeanDescription _findStdJdkCollectionDesc(MapperConfig<?> cfg, JavaType type)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java;<<<<<<< MINE
            AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),
                    (cfg.isAnnotationProcessingEnabled() ? cfg.getAnnotationIntrospector() : null), r);
=======
            AnnotatedClass ac = AnnotatedClass.construct(type, cfg);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/TypeResolutionContext.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.introspect;

import java.lang.reflect.Type;

import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.type.TypeBindings;
import com.fasterxml.jackson.databind.type.TypeFactory;

/**
 * Interface that defines API used by members (like {@link AnnotatedMethod})
 * to dynamically resolve types they have.
 *
 * @since 2.7
 */
public interface TypeResolutionContext {
    public JavaType resolveType(Type t);

    public static class Basic
        implements TypeResolutionContext
    {
        private final TypeFactory _typeFactory;
        private final TypeBindings _bindings;

        public Basic(TypeFactory tf, TypeBindings b) {
            _typeFactory = tf;
            _bindings = b;
        }

        @Override
        public JavaType resolveType(Type type) {
            return _typeFactory.constructType(type, _bindings);
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.TypeBindings;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    public AnnotatedMethod(AnnotatedClass ctxt, Method method,
=======
    public AnnotatedMethod(TypeResolutionContext ctxt, Method method,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
        return new AnnotatedMethod(_context, m, _annotations, _paramAnnotations);
=======
        return new AnnotatedMethod(_typeContext, m, _annotations, _paramAnnotations);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
        return new AnnotatedMethod(_context, _method, ann, _paramAnnotations);
=======
        return new AnnotatedMethod(_typeContext, _method, ann, _paramAnnotations);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    public Type getGenericType() {
        return _method.getGenericReturnType();
=======
    public JavaType getType() {
        return _typeContext.resolveType(_method.getGenericReturnType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    /**
     * As per [JACKSON-468], we need to also allow declaration of local
     * type bindings; mostly it will allow defining bounds.
     */
    @Override
    public JavaType getType(TypeBindings bindings) {
        return getType(bindings, _method.getTypeParameters());
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    public Type getGenericParameterType(int index)
    {
=======
    public JavaType getParameterType(int index) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
        return (index >= types.length) ? null : types[index];
=======
        if (index >= types.length) {
            return null;
        }
        return _typeContext.resolveType(types[index]);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    
    public Type getGenericReturnType() {
        return _method.getGenericReturnType();
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java;<<<<<<< MINE
                ClassUtil.checkAndFixAccess(m);
=======
                ClassUtil.checkAndFixAccess(m, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java;<<<<<<< MINE
    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,
=======
    public void serializeWithType(JsonGenerator g, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java;<<<<<<< MINE
        jg.writeNull();
=======
        g.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
        throw new JsonParseException(base, JsonLocation.NA);
=======
        throw new JsonParseException(null, base, JsonLocation.NA);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
        throw new JsonParseException("Unexpected end-of-String when base64 content", JsonLocation.NA);
=======
        throw new JsonParseException(null, "Unexpected end-of-String when base64 content");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java;<<<<<<< MINE
    private final List<JsonNode> _children = new ArrayList<JsonNode>();
=======
    private final List<JsonNode> _children;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java;<<<<<<< MINE
    public ArrayNode(JsonNodeFactory nc) { super(nc); }
=======
    public ArrayNode(JsonNodeFactory nf) {
        super(nf);
        _children = new ArrayList<JsonNode>();
    }

    /**
     * @since 2.7
     */
    public ArrayNode(JsonNodeFactory nf, List<JsonNode> children) {
        super(nf);
        _children = children;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java;<<<<<<< MINE
    private static final long serialVersionUID = -3006673354353448880L;
=======
    private static final long serialVersionUID = 1L;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java;<<<<<<< MINE
=======
    public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException
    {
        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(nodeType));
    }
    
    @Override
    public JsonDeserializer<?> findReferenceDeserializer(ReferenceType refType,
            DeserializationConfig config, BeanDescription beanDesc,
            TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer)
        throws JsonMappingException {
        // 21-Oct-2015, tatu: Unlikely this will really get used (reference types need more
        //    work, simple registration probably not sufficient). But whatever.
        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(refType.getRawClass()));
    }
    
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java;<<<<<<< MINE
    
    @Override
    public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException
    {
        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(nodeType));
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
=======
import java.util.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonSerializable;
import com.fasterxml.jackson.databind.SerializerProvider;
=======
import com.fasterxml.jackson.databind.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    private static final long serialVersionUID = -3581199092426900829L;
=======
    private static final long serialVersionUID = 1;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
=======
    private final static TypeBindings NO_BINDINGS = TypeBindings.emptyBindings();
    private final static JavaType[] NO_TYPES = new JavaType[0];

    protected final JavaType _superClass;

    protected final JavaType[] _superInterfaces;
    
    /**
     * Bindings in effect for this type instance; possibly empty.
     * Needed when resolving types declared in members of this type
     * (if any).
     *
     * @since 2.7
     */
    protected final TypeBindings _bindings;
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
     * @deprecated Since 2.2 use method that takes 'asStatic' argument
=======
     * Main constructor to use by extending classes.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    @Deprecated
    protected TypeBase(Class<?> raw, int hash,
            Object valueHandler, Object typeHandler)
=======
    protected TypeBase(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInts,
            int hash,
            Object valueHandler, Object typeHandler, boolean asStatic)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
        this(raw, hash, valueHandler, typeHandler, false);
=======
        super(raw, hash, valueHandler, typeHandler, asStatic);
        _bindings = (bindings == null) ? NO_BINDINGS : bindings;
        _superClass = superClass;
        _superInterfaces = superInts;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
     * Main constructor to use by extending classes.
=======
     * Copy-constructor used when refining/upgrading type instances.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    protected TypeBase(Class<?> raw, int hash,
            Object valueHandler, Object typeHandler, boolean asStatic)
    {
        super(raw, hash, valueHandler, typeHandler, asStatic);
=======
    protected TypeBase(TypeBase base) {
        super(base);
        _superClass = base._superClass;
        _superInterfaces = base._superInterfaces;
        _bindings = base._bindings;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    
    protected abstract String buildCanonicalName();
=======

    protected String buildCanonicalName() {
        return _class.getName();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
=======

    @Override
    public TypeBindings getBindings() {
        return _bindings;
    }

    @Override
    public int containedTypeCount() {
        return _bindings.size();
    }

    @Override
    public JavaType containedType(int index) {
        return _bindings.getBoundType(index);
    }

    @Override
    @Deprecated
    public String containedTypeName(int index) {
        return _bindings.getBoundName(index);
    }

    @Override
    public JavaType getSuperClass() {
        return _superClass;
    }

    @Override
    public List<JavaType> getInterfaces() {
        if (_superInterfaces == null) {
            return Collections.emptyList();
        }
        switch (_superInterfaces.length) {
        case 0:
            return Collections.emptyList();
        case 1:
            return Collections.singletonList(_superInterfaces[0]);
        }
        return Arrays.asList(_superInterfaces);
    }

    @Override
    public final JavaType findSuperType(Class<?> rawTarget)
    {
        if (rawTarget == _class) {
            return this;
        }
        // Check super interfaces first:
        if (rawTarget.isInterface() && (_superInterfaces != null)) {
            for (int i = 0, count = _superInterfaces.length; i < count; ++i) {
                JavaType type = _superInterfaces[i].findSuperType(rawTarget);
                if (type != null) {
                    return type;
                }
            }
        }
        // and if not found, super class and its supertypes
        if (_superClass != null) {
            JavaType type = _superClass.findSuperType(rawTarget);
            if (type != null) {
                return type;
            }
        }
        return null;
    }

    @Override
    public JavaType[] findTypeParameters(Class<?> expType)
    {
        JavaType match = findSuperType(expType);
        if (match == null) {
            return NO_TYPES;
        }
        return match.getBindings().typeParameterArray();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    /* JsonSerializableWithType base implementation
=======
    /* JsonSerializable base implementation
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    public void serializeWithType(JsonGenerator jgen, SerializerProvider provider,
=======
    public void serializeWithType(JsonGenerator gen, SerializerProvider provider,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
        typeSer.writeTypePrefixForScalar(this, jgen);
        this.serialize(jgen, provider);
        typeSer.writeTypeSuffixForScalar(this, jgen);
=======
        typeSer.writeTypePrefixForScalar(this, gen);
        this.serialize(gen, provider);
        typeSer.writeTypeSuffixForScalar(this, gen);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    public void serialize(JsonGenerator jgen, SerializerProvider provider)
=======
    public void serialize(JsonGenerator gen, SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
        jgen.writeString(toCanonical());
=======
        gen.writeString(toCanonical());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java;<<<<<<< MINE
=======

    /**
     * Internal helper method used to figure out nominal super-class for
     * deprecated factory methods / constructors, where we are not given
     * properly resolved supertype hierarchy.
     * Will basically give `JavaType` for `java.lang.Object` for classes
     * other than `java.lafgn.Object`; null for others.
     *
     * @since 2.7
     */
    protected static JavaType _bogusSuperClass(Class<?> cls) {
        Class<?> parent = cls.getSuperclass();
        if (parent == null) {
            return null;
        }
        return TypeFactory.unknownType();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
=======
import java.lang.reflect.TypeVariable;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
 * Type that represents Map-like types; things that consist of key/value pairs but that
 * do not necessarily implement {@link java.util.Map}, but that do not have enough
 * introspection functionality to allow for some level of generic handling.
 * This specifically allows framework to check for configuration and annotation
 * settings used for Map types, and pass these to custom handlers that may be more
 * familiar with actual type.
=======
 * Type that represents Map-like types; things that consist of key/value pairs
 * but that do not necessarily implement {@link java.util.Map}, but that do not
 * have enough introspection functionality to allow for some level of generic
 * handling. This specifically allows framework to check for configuration and
 * annotation settings used for Map types, and pass these to custom handlers
 * that may be more familiar with actual type.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
public class MapLikeType extends TypeBase
{
=======
public class MapLikeType extends TypeBase {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**********************************************************
    /* Life-cycle
    /**********************************************************
=======
     * /********************************************************** /* Life-cycle
     * /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    protected MapLikeType(Class<?> mapType, JavaType keyT, JavaType valueT,
            Object valueHandler, Object typeHandler, boolean asStatic)
    {
        super(mapType, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);
=======
    protected MapLikeType(Class<?> mapType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType keyT,
            JavaType valueT, Object valueHandler, Object typeHandler,
            boolean asStatic) {
        super(mapType, bindings, superClass, superInts, keyT.hashCode()
                ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    
    public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT)
    {
        // nominally component types will be just Object.class
        return new MapLikeType(rawType, keyT, valueT, null, null, false);
=======

    /**
     * @since 2.7
     */
    protected MapLikeType(TypeBase base, JavaType keyT, JavaType valueT) {
        super(base);
        _keyType = keyT;
        _valueType = valueT;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return new MapLikeType(subclass, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
=======
    /**
     * Factory method that can be used to "upgrade" a basic type into
     * collection-like one; usually done via {@link TypeModifier}
     *
     * @since 2.7
     */
    public static MapLikeType upgradeFrom(JavaType baseType, JavaType keyT,
            JavaType valueT) {
        // 19-Oct-2015, tatu: Not sure if and how other types could be used as
        // base;
        // will cross that bridge if and when need be
        if (baseType instanceof TypeBase) {
            return new MapLikeType((TypeBase) baseType, keyT, valueT);
        }
        throw new IllegalArgumentException(
                "Can not upgrade from an instance of " + baseType.getClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    @Override
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _valueType.getRawClass()) {
            return this;
=======
    @Deprecated
    // since 2.7; remove from 2.8
    public static MapLikeType construct(Class<?> rawType, JavaType keyT,
            JavaType valueT) {
        // First: may need to fabricate TypeBindings (needed for refining into
        // concrete collection types, as per [databind#1102])
        TypeVariable<?>[] vars = rawType.getTypeParameters();
        TypeBindings bindings;
        if ((vars == null) || (vars.length != 2)) {
            bindings = TypeBindings.emptyBindings();
        } else {
            bindings = TypeBindings.create(rawType, keyT, valueT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType, _valueType.narrowBy(contentClass),
               _valueHandler, _typeHandler, _asStatic);
=======
        return new MapLikeType(rawType, bindings, _bogusSuperClass(rawType),
                null, keyT, valueT, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
=======
    @Deprecated
    // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        if (contentClass == _valueType.getRawClass()) {
            return this;
        }
        return new MapLikeType(_class, _keyType, _valueType.widenBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
    protected JavaType _narrow(Class<?> subclass) {
        return new MapLikeType(subclass, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType, _valueHandler,
                _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    
    public JavaType narrowKey(Class<?> keySubclass)
    {
        // Can do a quick check first:
        if (keySubclass == _keyType.getRawClass()) {
=======

    /**
     * @since 2.7
     */
    public MapLikeType withKeyType(JavaType keyType) {
        if (keyType == _keyType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType.narrowBy(keySubclass), _valueType,
                _valueHandler, _typeHandler, _asStatic);
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, keyType, _valueType, _valueHandler,
                _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public JavaType widenKey(Class<?> keySubclass)
    {
        // Can do a quick check first:
        if (keySubclass == _keyType.getRawClass()) {
=======
    @Override
    public JavaType withContentType(JavaType contentType) {
        if (_valueType == contentType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType.widenBy(keySubclass), _valueType,
                _valueHandler, _typeHandler, _asStatic);
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, contentType, _valueHandler,
                _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public MapLikeType withTypeHandler(Object h)
    {
        return new MapLikeType(_class, _keyType, _valueType, _valueHandler, h, _asStatic);
=======
    public MapLikeType withTypeHandler(Object h) {
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType, _valueHandler, h,
                _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public MapLikeType withContentTypeHandler(Object h)
    {
        return new MapLikeType(_class, _keyType, _valueType.withTypeHandler(h),
=======
    public MapLikeType withContentTypeHandler(Object h) {
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType, _valueType, h, _typeHandler, _asStatic);
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType, h, _typeHandler,
                _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType, _valueType.withValueHandler(h),
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType, _valueType.withStaticTyping(),
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType, _valueType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
=======
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return new MapLikeType(rawType, bindings, superClass, superInterfaces,
                _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
 
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**********************************************************
    /* Public API
    /**********************************************************
=======
     * /********************************************************** /* Public API
     * /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public boolean isContainerType() { return true; }
=======
    public boolean isContainerType() {
        return true;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public boolean isMapLikeType() { return true; }
    
    @Override
    public JavaType getKeyType() { return _keyType; }
=======
    public boolean isMapLikeType() {
        return true;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public JavaType getContentType() { return _valueType; }
=======
    public JavaType getKeyType() {
        return _keyType;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public int containedTypeCount() { return 2; }
    
    @Override
    public JavaType containedType(int index) {
        if (index == 0) return _keyType;
        if (index == 1) return _valueType;
        return null;
=======
    public JavaType getContentType() {
        return _valueType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**
     * Not sure if we should count on this, but type names
     * for core interfaces are "K" and "V" respectively.
     * For now let's assume this should work.
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public String containedTypeName(int index) {
        if (index == 0) return "K";
        if (index == 1) return "V";
        return null;
=======
    public Object getContentValueHandler() {
        return _valueType.getValueHandler();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    // TODO: should allow construction of instances that do refer
    //  to parameterization, since it is NOT Map
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public Class<?> getParameterSource() {
        return null;
=======
    public Object getContentTypeHandler() {
        return _valueType.getTypeHandler();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public StringBuilder getGenericSignature(StringBuilder sb)
    {
=======
    public StringBuilder getGenericSignature(StringBuilder sb) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
 
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**********************************************************
    /* Extended API
    /**********************************************************
=======
     * /********************************************************** /* Extended
     * API /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public MapLikeType withKeyTypeHandler(Object h)
    {
        return new MapLikeType(_class, _keyType.withTypeHandler(h), _valueType,
=======
    public MapLikeType withKeyTypeHandler(Object h) {
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType.withTypeHandler(h), _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return new MapLikeType(_class, _keyType.withValueHandler(h), _valueType,
=======
        return new MapLikeType(_class, _bindings, _superClass,
                _superInterfaces, _keyType.withValueHandler(h), _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
     * Method that can be used for checking whether this type is a
     * "real" Collection type; meaning whether it represents a parameterized
     * subtype of {@link java.util.Collection} or just something that acts
     * like one.
=======
     * Method that can be used for checking whether this type is a "real"
     * Collection type; meaning whether it represents a parameterized subtype of
     * {@link java.util.Collection} or just something that acts like one.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**********************************************************
    /* Standard methods
    /**********************************************************
=======
     * /********************************************************** /* Standard
     * methods /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public String toString()
    {
        return "[map-like type; class "+_class.getName()+", "+_keyType+" -> "+_valueType+"]";
=======
    public String toString() {
        return "[map-like type; class " + _class.getName() + ", " + _keyType
                + " -> " + _valueType + "]";
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    public boolean equals(Object o)
    {
        if (o == this) return true;
        if (o == null) return false;
        if (o.getClass() != getClass()) return false;
=======
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (o == null)
            return false;
        if (o.getClass() != getClass())
            return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
        return (_class == other._class)
            && _keyType.equals(other._keyType)
            && _valueType.equals(other._valueType);
=======
        return (_class == other._class) && _keyType.equals(other._keyType)
                && _valueType.equals(other._valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
=======
import java.lang.reflect.TypeVariable;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    private MapType(Class<?> mapType, JavaType keyT, JavaType valueT,
=======
    private MapType(Class<?> mapType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType keyT, JavaType valueT,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        super(mapType, keyT, valueT, valueHandler, typeHandler, asStatic);
    }
    
    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {
        // nominally component types will be just Object.class
        return new MapType(rawType, keyT, valueT, null, null, false);
=======
        super(mapType, bindings, superClass, superInts,
                keyT, valueT, valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return new MapType(subclass, _keyType, _valueType,
                _valueHandler, _typeHandler, _asStatic);
=======
    /**
     * @since 2.7
     */
    protected MapType(TypeBase base, JavaType keyT, JavaType valueT) {
        super(base, keyT, valueT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    @Override
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _valueType.getRawClass()) {
            return this;
=======
    /**
     * @since 2.7
     */
    public static MapType construct(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts,
            JavaType keyT, JavaType valueT) {
        return new MapType(rawType, bindings, superClass, superInts, keyT, valueT, null, null, false);
    }
    
    @Deprecated // since 2.7
    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)
    {
        // First: may need to fabricate TypeBindings (needed for refining into
        // concrete collection types, as per [databind#1102])
        TypeVariable<?>[] vars = rawType.getTypeParameters();
        TypeBindings bindings;
        if ((vars == null) || (vars.length != 2)) {
            bindings = TypeBindings.emptyBindings();
        } else {
            bindings = TypeBindings.create(rawType, keyT, valueT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType.narrowBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
        // !!! TODO: Wrong, does have supertypes
        return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,
                keyT, valueT, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        if (contentClass == _valueType.getRawClass()) {
            return this;
        }
        return new MapType(_class, _keyType, _valueType.widenBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
    }
    
    @Override
    public JavaType narrowKey(Class<?> keySubclass)
    {
        // Can do a quick check first:
        if (keySubclass == _keyType.getRawClass()) {
            return this;
        }
        return new MapType(_class, _keyType.narrowBy(keySubclass), _valueType,
=======
    protected JavaType _narrow(Class<?> subclass) {
        return new MapType(subclass, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    public JavaType widenKey(Class<?> keySubclass)
    {
        // Can do a quick check first:
        if (keySubclass == _keyType.getRawClass()) {
            return this;
        }
        return new MapType(_class, _keyType.widenBy(keySubclass), _valueType,
                _valueHandler, _typeHandler, _asStatic);
    }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType, _valueHandler, h, _asStatic);
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType.withTypeHandler(h),
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType, h, _typeHandler, _asStatic);
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType, h, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType, _valueType.withValueHandler(h),
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType, _valueType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType.withStaticTyping(), _valueType.withStaticTyping(),
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType.withStaticTyping(), _valueType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Overridden accessors
    /**********************************************************
     */
=======
    @Override
    public JavaType withContentType(JavaType contentType) {
        if (_valueType == contentType) {
            return this;
        }
        return new MapType(_class, _bindings, _superClass, _superInterfaces,
                _keyType, contentType, _valueHandler, _typeHandler, _asStatic);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    public Class<?> getParameterSource() {
        return java.util.Map.class;
=======
    public MapType withKeyType(JavaType keyType) {
        if (keyType == _keyType) {
            return this;
        }
        return new MapType(_class, _bindings, _superClass, _superInterfaces,
                keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
=======
    @Override
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return new MapType(rawType, bindings,
                superClass, superInterfaces, _keyType, _valueType,
                _valueHandler, _typeHandler, _asStatic);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType.withTypeHandler(h), _valueType,
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType.withTypeHandler(h), _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
        return new MapType(_class, _keyType.withValueHandler(h), _valueType,
=======
        return new MapType(_class, _bindings,
                _superClass, _superInterfaces, _keyType.withValueHandler(h), _valueType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ClassStack.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.type;

import java.util.ArrayList;

import com.fasterxml.jackson.databind.JavaType;

/**
 * Simple helper class used to keep track of 'call stack' for classes being referenced
 * (as well as unbound variables)
 *
 * @since 2.7
 */
public final class ClassStack
{
    protected final ClassStack _parent;
    protected final Class<?> _current;

    private ArrayList<ResolvedRecursiveType> _selfRefs;

    public ClassStack(Class<?> rootType) {
        this(null, rootType);
    }

    private ClassStack(ClassStack parent, Class<?> curr) {
        _parent = parent;
        _current = curr;
    }

    /**
     * @return New stack frame, if addition is ok; null if not
     */
    public ClassStack child(Class<?> cls) {
        return new ClassStack(this, cls);
    }

    /**
     * Method called to indicate that there is a self-reference from
     * deeper down in stack pointing into type this stack frame represents.
     */
    public void addSelfReference(ResolvedRecursiveType ref)
    {
        if (_selfRefs == null) {
            _selfRefs = new ArrayList<ResolvedRecursiveType>();
        }
        _selfRefs.add(ref);
    }

    /**
     * Method called when type that this stack frame represents is
     * fully resolved, allowing self-references to be completed
     * (if there are any)
     */
    public void resolveSelfReferences(JavaType resolved)
    {
        if (_selfRefs != null) {
            for (ResolvedRecursiveType ref : _selfRefs) {
                ref.setReference(resolved);
            }
        }
    }

    public ClassStack find(Class<?> cls)
    {
        if (_current == cls) return this;
        for (ClassStack curr = _parent; curr != null; curr = curr._parent) {
            if (curr._current == cls) {
                return curr;
            }
        }
        return null;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[ClassStack (self-refs: ")
            .append((_selfRefs == null) ? "0" : String.valueOf(_selfRefs.size()))
            .append(')')
                    ;
        for (ClassStack curr = this; curr != null; curr = curr._parent) {
            sb.append(' ').append(curr._current.getName());
        }
        sb.append(']');
        return sb.toString();
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
 * 
 * @author tatu
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
    public JavaType parse(String canonical)
        throws IllegalArgumentException
=======
    public JavaType parse(String canonical) throws IllegalArgumentException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
                return _factory._fromParameterizedClass(base, parseTypes(tokens));
=======
                List<JavaType> parameterTypes = parseTypes(tokens);
                TypeBindings b = TypeBindings.create(base, parameterTypes);
                return _factory._fromClass(null, base, b);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
        return _factory._fromClass(base, null);
=======
        return _factory._fromClass(null, base, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    protected ReferenceType(Class<?> cls, JavaType refType,
=======
    protected ReferenceType(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType refType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        super(cls, refType.hashCode(),
=======
        super(cls, bindings, superClass, superInts, refType.hashCode(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    public static ReferenceType construct(Class<?> cls, JavaType refType,
            Object valueHandler, Object typeHandler)
=======
    /**
     * @since 2.7
     */
    protected ReferenceType(TypeBase base, JavaType refType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(cls, refType, null, null, false);
    }                                   
    
=======
        super(base);
        _referencedType = refType;
    }

    /**
     * Factory method that can be used to "upgrade" a basic type into collection-like
     * one; usually done via {@link TypeModifier}
     *
     * @since 2.7
     */
    public static ReferenceType upgradeFrom(JavaType baseType, JavaType refType) {
        if (refType == null) {
            throw new IllegalArgumentException("Missing referencedType");
        }
        // 19-Oct-2015, tatu: Not sure if and how other types could be used as base;
        //    will cross that bridge if and when need be
        if (baseType instanceof TypeBase) {
            return new ReferenceType((TypeBase) baseType, refType);
        }
        throw new IllegalArgumentException("Can not upgrade from an instance of "+baseType.getClass());
    }

    /**
     * @since 2.7
     */
    public static ReferenceType construct(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType refType)
    {
        return new ReferenceType(cls, bindings, superClass, superInts,
                refType, null, null, false);
    }

    @Deprecated // since 2.7
    public static ReferenceType construct(Class<?> cls, JavaType refType) {
        return new ReferenceType(cls, TypeBindings.emptyBindings(),
                // !!! TODO: missing supertypes
                null, null, refType, null, null, false);
    }

    @Override
    public JavaType withContentType(JavaType contentType) {
        if (_referencedType == contentType) {
            return this;
        }
        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,
                contentType, _valueHandler, _typeHandler, _asStatic);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType, _valueHandler, h, _asStatic);
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType.withTypeHandler(h),
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType, h, _typeHandler,_asStatic);
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType, h, _typeHandler,_asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType.withValueHandler(h),
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(_class, _referencedType.withStaticTyping(),
=======
        return new ReferenceType(_class, _bindings,
                _superClass, _superInterfaces, _referencedType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
=======
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return new ReferenceType(rawType, _bindings,
                superClass, superInterfaces, _referencedType,
                _valueHandler, _typeHandler, _asStatic);
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
        return new ReferenceType(subclass, _referencedType,
=======
        return new ReferenceType(subclass, _bindings,
                _superClass, _superInterfaces, _referencedType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    /* Extended API
=======
    /* Public API overrides
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
=======

    @Override
    public JavaType getContentType() {
        return _referencedType;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    
    /*
    /**********************************************************
    /* Public API overrides
    /**********************************************************
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    public int containedTypeCount() {
        return 1;
    }

    @Override
    public JavaType containedType(int index) {
        return (index == 0) ? _referencedType : null;
    }

    @Override
    public String containedTypeName(int index) {
        return (index == 0) ? "T" : null;
    }

    @Override
    public Class<?> getParameterSource() {
        // Hmmh. For now, assume it's the raw type
        return _class;
    }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
=======
import java.lang.reflect.TypeVariable;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    protected CollectionLikeType(Class<?> collT, JavaType elemT,
=======
    protected CollectionLikeType(Class<?> collT, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        super(collT, elemT.hashCode(), valueHandler, typeHandler, asStatic);
=======
        super(collT, bindings, superClass, superInts,
                elemT.hashCode(), valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return new CollectionLikeType(subclass, _elementType,
                _valueHandler, _typeHandler, _asStatic);
=======

    /**
     * @since 2.7
     */
    protected CollectionLikeType(TypeBase base, JavaType elemT)
    {
        super(base);
        _elementType = elemT;
    }

    /**
     * @since 2.7
     */
    public static CollectionLikeType construct(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT) {
        return new CollectionLikeType(rawType, bindings, superClass, superInts, elemT,
                null, null, false);
    }

    /**
     * @deprecated Since 2.7, use {@link #upgradeFrom} for constructing instances, given
     *    pre-resolved {@link SimpleType}.
     */
    @Deprecated // since 2.7
    public static CollectionLikeType construct(Class<?> rawType, JavaType elemT) {
        // First: may need to fabricate TypeBindings (needed for refining into
        // concrete collection types, as per [databind#1102])
        TypeVariable<?>[] vars = rawType.getTypeParameters();
        TypeBindings bindings;
        if ((vars == null) || (vars.length != 1)) {
            bindings = TypeBindings.emptyBindings();
        } else {
            bindings = TypeBindings.create(rawType, elemT);
        }
        return new CollectionLikeType(rawType, bindings,
                _bogusSuperClass(rawType), null,
                elemT, null, null, false);
    }

    /**
     * Factory method that can be used to "upgrade" a basic type into collection-like
     * one; usually done via {@link TypeModifier}
     *
     * @since 2.7
     */
    public static CollectionLikeType upgradeFrom(JavaType baseType, JavaType elementType) {
        // 19-Oct-2015, tatu: Not sure if and how other types could be used as base;
        //    will cross that bridge if and when need be
        if (baseType instanceof TypeBase) {
            return new CollectionLikeType((TypeBase) baseType, elementType);
        }
        throw new IllegalArgumentException("Can not upgrade from an instance of "+baseType.getClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _elementType.getRawClass()) {
            return this;
        }
        return new CollectionLikeType(_class, _elementType.narrowBy(contentClass),
=======
    @Deprecated // since 2.7
    protected JavaType _narrow(Class<?> subclass) {
        return new CollectionLikeType(subclass, _bindings,
                _superClass, _superInterfaces, _elementType,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _elementType.getRawClass()) {
=======
    public JavaType withContentType(JavaType contentType) {
        if (_elementType == contentType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType.widenBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
        return new CollectionLikeType(_class, _bindings, _superClass, _superInterfaces,
                contentType, _valueHandler, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public static CollectionLikeType construct(Class<?> rawType, JavaType elemT)
    {
        // nominally component types will be just Object.class
        return new CollectionLikeType(rawType, elemT, null, null, false);
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public CollectionLikeType withTypeHandler(Object h)
    {
        return new CollectionLikeType(_class, _elementType, _valueHandler, h, _asStatic);
=======
    public CollectionLikeType withTypeHandler(Object h) {
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType.withTypeHandler(h),
=======
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType, h, _typeHandler, _asStatic);
=======
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType.withValueHandler(h),
=======
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
        return new CollectionLikeType(_class, _elementType.withStaticTyping(),
=======
        return new CollectionLikeType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
=======
    @Override
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return new CollectionLikeType(rawType, bindings,
                superClass, superInterfaces, _elementType,
                _valueHandler, _typeHandler, _asStatic);
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public int containedTypeCount() { return 1; }

    @Override
    public JavaType containedType(int index) {
            return (index == 0) ? _elementType : null;
=======
    public Object getContentValueHandler() {
        return _elementType.getValueHandler();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    /**
     * Not sure if we should count on this, but type names
     * for core interfaces use "E" for element type
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    public String containedTypeName(int index) {
        if (index == 0) return "E";
        return null;
    }
=======
    public Object getContentTypeHandler() {
        return _elementType.getTypeHandler();
    }    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    // TODO: should allow construction of instances that do refer
    //  to parameterization, since it is NOT Collection
    @Override
    public Class<?> getParameterSource() {
        return null;
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    /**
     * In case there are resolved type parameters, this field stores reference
     * to that type. It must be {@link #getRawClass()} or its supertype.
     * 
     * @since 2.5
     */
    protected final Class<?> _typeParametersFor;
    
    /**
     * Generic type arguments for this type.
     */
    protected final JavaType[] _typeParameters;

    /**
     * Names of generic type arguments for this type; will
     * match values in {@link #_typeParameters}
     */
    protected final String[] _typeNames;
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
=======
    /**
     * Constructor only used by core Jackson databind functionality;
     * should never be called by application code.
     *<p>
     * As with other direct construction that by-passes {@link TypeFactory},
     * no introspection occurs with respect to super-types; caller must be
     * aware of consequences if using this method.
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        this(cls, null, null, null, null, false, null);
=======
        this(cls, TypeBindings.emptyBindings(), null, null);
    }

    protected SimpleType(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts) {
        this(cls, bindings, superClass, superInts, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
     * @deprecated Since 2.5 use variant that takes one more argument
=======
     * Simple copy-constructor, usually used when upgrading/refining a simple type
     * into more specialized type.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    @Deprecated
    protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams,
            Object valueHandler, Object typeHandler, boolean asStatic)
    {
        this(cls, typeNames, typeParams, valueHandler, typeHandler, asStatic, null);
=======
    protected SimpleType(TypeBase base) {
        super(base);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    /**
     * 
     * @param parametersFrom Interface or abstract class implemented by this type,
     *   and for which type parameters apply. It may be <code>cls</code> itself,
     *   but more commonly it is one of its supertypes.
     */
    protected SimpleType(Class<?> cls,
            String[] typeNames, JavaType[] typeParams,
            Object valueHandler, Object typeHandler, boolean asStatic,
            Class<?> parametersFrom)
=======
    protected SimpleType(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts,
            Object valueHandler, Object typeHandler, boolean asStatic)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        super(cls, 0, valueHandler, typeHandler, asStatic);
        if (typeNames == null || typeNames.length == 0) {
            _typeNames = null;
            _typeParameters = null;
        } else {
            _typeNames = typeNames;
            _typeParameters = typeParams;
        }
        _typeParametersFor = parametersFrom;
=======
        super(cls, bindings, superClass, superInts,
                0, valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    protected SimpleType(Class<?> cls, int extraHash,
=======
    protected SimpleType(Class<?> cls, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, int extraHash,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        super(cls, extraHash, valueHandler, typeHandler, asStatic);
        _typeNames = null;
        _typeParameters = null;
        _typeParametersFor = cls;
=======
        super(cls, bindings, superClass, superInts, 
                extraHash, valueHandler, typeHandler, asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
     * Method used by core Jackson classes: NOT to be used by application code.
=======
     * Method used by core Jackson classes: NOT to be used by application code:
     * it does NOT properly handle inspection of super-types, so neither parent
     * Classes nor implemented Interfaces are accessible with resulting type
     * instance.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return new SimpleType(raw, null, null, null, null, false, null);
=======
        return new SimpleType(raw, null,
                // 18-Oct-2015, tatu: Should be ok to omit possible super-types, right?
                null, null, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    @Override
    protected JavaType _narrow(Class<?> subclass)
    {
        // Should we check that there is a sub-class relationship?
        return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler,
                _asStatic, _typeParametersFor);
    }

    @Override
    public JavaType narrowContentsBy(Class<?> subclass)
    {
        // should never get called
        throw new IllegalArgumentException("Internal error: SimpleType.narrowContentsBy() should never be called");
    }

    @Override
    public JavaType widenContentsBy(Class<?> subclass)
    {
        // should never get called
        throw new IllegalArgumentException("Internal error: SimpleType.widenContentsBy() should never be called");
    }
    
=======
    /**
     * Method that should NOT to be used by application code:
     * it does NOT properly handle inspection of super-types, so neither parent
     * Classes nor implemented Interfaces are accessible with resulting type
     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>
     * methods which handle introspection appropriately.
     *<p>
     * Note that prior to 2.7, method usage was not limited and would typically
     * have worked acceptably: the problem comes from inability to resolve super-type
     * information, for which {@link TypeFactory} is needed.
     * 
     * @deprecated Since 2.7
     */
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return new SimpleType(cls);
=======
        TypeBindings b = TypeBindings.emptyBindings();
        return new SimpleType(cls, b,
                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    public SimpleType withTypeHandler(Object h)
=======
    @Deprecated
    protected JavaType _narrow(Class<?> subclass)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic, _typeParametersFor);
=======
        if (_class == subclass) {
            return this;
        }
        // Should we check that there is a sub-class relationship?
        // 15-Jan-2016, tatu: Almost yes, but there are some complications with
        //    placeholder values, so no.
        /*
        if (!_class.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException("Class "+subclass.getName()+" not sub-type of "
                    +_class.getName());
        }
        */
        // 15-Jan-2015, tatu: Not correct; should really re-resolve...
        return new SimpleType(subclass, _bindings, this, _superInterfaces,
                _valueHandler, _typeHandler, _asStatic);
    }
    
    @Override
    public JavaType withContentType(JavaType contentType) {
        throw new IllegalArgumentException("Simple types have no content types; can not call withContentType()");
    }
    
    @Override
    public SimpleType withTypeHandler(Object h) {
        if (_typeHandler == h) {
            return this;
        }
        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic, _typeParametersFor);
=======
        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, h, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        return _asStatic ? this : new SimpleType(_class,
                _typeNames, _typeParameters, _valueHandler, _typeHandler, true, _typeParametersFor);
=======
        return _asStatic ? this : new SimpleType(_class, _bindings,
                _superClass, _superInterfaces, _valueHandler, _typeHandler, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
=======
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        // SimpleType means something not-specialized, so:
        return null;
    }
    
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        if (_typeParameters != null && _typeParameters.length > 0) {
=======

        final int count = _bindings.size();
        if (count > 0) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
            boolean first = true;
            for (JavaType t : _typeParameters) {
                if (first) {
                    first = false;
                } else {
=======
            for (int i = 0; i < count; ++i) {
                JavaType t = containedType(i);
                if (i > 0) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    
    @Override
    public int containedTypeCount() {
        return (_typeParameters == null) ? 0 : _typeParameters.length;
    }

    @Override
    public JavaType containedType(int index)
    {
        if (index < 0 || _typeParameters == null || index >= _typeParameters.length) {
            return null;
        }
        return _typeParameters[index];
    }

    @Override
    public String containedTypeName(int index)
    {
        if (index < 0 || _typeNames == null || index >= _typeNames.length) {
            return null;
        }
        return _typeNames[index];
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    public Class<?> getParameterSource() {
        return _typeParametersFor;
    }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        if (_typeParameters != null) {
=======

        final int count = _bindings.size();
        if (count > 0) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
            for (JavaType param : _typeParameters) {
                sb = param.getGenericSignature(sb);
=======
            for (int i = 0; i < count; ++i) {
                sb = containedType(i).getGenericSignature(sb);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
=======
    /* Internal methods
    /**********************************************************
     */

    /**
     * Helper method we need to recursively build skeletal representations
     * of superclasses.
     * 
     * @since 2.7 -- remove when not needed (2.8?)
     */
    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)
    {
        if (superClass == null) {
            return null;
        }
        if (superClass == Object.class) {
            return TypeFactory.unknownType();
        }
        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);
        return new SimpleType(superClass, b,
                superSuper, null, null, null, false);
    }

    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
        JavaType[] p1 = _typeParameters;
        JavaType[] p2 = other._typeParameters;
        if (p1 == null) {
            return (p2 == null) || p2.length == 0;
        }
        if (p2 == null) return false;

        if (p1.length != p2.length) return false;
        for (int i = 0, len = p1.length; i < len; ++i) {
            if (!p1[i].equals(p2[i])) {
                return false;
            }
        }
        return true;
=======
        TypeBindings b1 = _bindings;
        TypeBindings b2 = other._bindings;
        return b1.equals(b2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
@SuppressWarnings({"rawtypes", "unchecked"})
=======
@SuppressWarnings({"rawtypes" })
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

    protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /* Caching
=======
    /* Constants for "well-known" classes
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class);
    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE);
    protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE);
    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE);
=======

    private final static Class<?> CLS_STRING = String.class;
    private final static Class<?> CLS_OBJECT = Object.class;

    private final static Class<?> CLS_COMPARABLE = Comparable.class;
    private final static Class<?> CLS_CLASS = Class.class;
    private final static Class<?> CLS_ENUM = Enum.class;

    private final static Class<?> CLS_BOOL = Boolean.TYPE;
    private final static Class<?> CLS_INT = Integer.TYPE;
    private final static Class<?> CLS_LONG = Long.TYPE;

    /*
    /**********************************************************
    /* Cached pre-constructed JavaType instances
    /**********************************************************
     */

    // note: these are primitive, hence no super types
    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);
    protected final static SimpleType CORE_TYPE_INT = new SimpleType(CLS_INT);
    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(CLS_LONG);

    // and as to String... well, for now, ignore its super types
    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(CLS_STRING);

    // @since 2.7
    protected final static SimpleType CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Since type resolution can be expensive (specifically when resolving
     * actual generic types), we will use small cache to avoid repetitive
     * resolution of core types
=======
     * Cache {@link Comparable} because it is both parameteric (relatively costly to
     * resolve) and mostly useless (no special handling), better handle directly
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);
=======
    protected final static SimpleType CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /*
     * Looks like construction of {@link JavaType} instances can be
     * a bottleneck, esp. for root-level Maps, so we better do bit
     * of low-level component caching here...
=======
    /**
     * Cache {@link Enum} because it is parametric AND self-referential (costly to
     * resolve) and useless in itself (no special handling).
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
    protected final static SimpleType CORE_TYPE_ENUM = new SimpleType(CLS_ENUM);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}
     * to its supertypes.
=======
     * Cache {@link Class} because it is nominally parametric, but has no really
     * useful information.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected transient HierarchicType _cachedHashMapType;
=======
    protected final static SimpleType CORE_TYPE_CLASS = new SimpleType(CLS_CLASS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}
     * to its supertypes.
=======
     * Since type resolution can be expensive (specifically when resolving
     * actual generic types), we will use small cache to avoid repetitive
     * resolution of core types
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected transient HierarchicType _cachedArrayListType;
=======
    protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * ClassLoader used by this factory (Issue #624)
=======
     * ClassLoader used by this factory [databind#624].
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    	return _classLoader;
=======
        return _classLoader;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Shouldbe able to optimize bit more in future...
=======
        // Should be able to optimize bit more in future...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    	return Class.forName(name);
=======
        return Class.forName(name);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        if (baseType.getRawClass() == subclass) {
=======
        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == subclass) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Currently only SimpleType instances can become something else
=======
        
        JavaType newType;

        // also: if we start from untyped, not much to save
        do { // bogus loop to be able to break
            if (rawBase == Object.class) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
                break;
            }
            if (!rawBase.isAssignableFrom(subclass)) {
                throw new IllegalArgumentException(String.format(
                        "Class %s not subtype of %s", subclass.getName(), baseType));
            }
            // A few special cases where we can simplify handling:

            // (1) Original target type has no generics -- just resolve subtype
            if (baseType.getBindings().isEmpty()) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            // (2) A small set of "well-known" List/Map subtypes where can take a short-cut
            if (baseType.isContainerType()) {
                if (baseType.isMapLikeType()) {
                    if ((subclass == HashMap.class)
                            || (subclass == LinkedHashMap.class)
                            || (subclass == EnumMap.class)
                            || (subclass == TreeMap.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                        break;
                    }
                } else if (baseType.isCollectionLikeType()) {
                    if ((subclass == ArrayList.class)
                            || (subclass == LinkedList.class)
                            || (subclass == HashSet.class)
                            || (subclass == TreeSet.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getContentType()));
                        break;
                    }
                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                    //    but they are impl details and we basically do not care...
                    if (rawBase == EnumSet.class) {
                        return baseType;
                    }
                }
            }
            // (3) Sub-class does not take type parameters -- just resolve subtype
            if (subclass.getTypeParameters().length == 0) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }

            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
            // !!! TODO (as of 28-Jan-2016, at least)

            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
            //    a way to fully resolve and merge hierarchies; but that gets expensive
            //    so let's, for now, try to create close-enough approximation that
            //    is not 100% same, structurally, but has equivalent information for
            //    our specific neeeds.
            if (baseType.isInterface()) {
                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null,
                        new JavaType[] { baseType });
            } else {
                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType,
                        NO_TYPES);
            }
            // Only SimpleType returns null, but if so just resolve regularly
            if (newType == null) {
                // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy
                // (hopefully passing null Class for root is ok)
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());        
            }
        } while (false);

        // except possibly handlers
//      newType = newType.withHandlersFrom(baseType);
        return newType;

        // 20-Oct-2015, tatu: Old simplistic approach
        
        /*
        // Currently mostly SimpleType instances can become something else
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));
=======
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
        */
    }

    /**
     * Method similar to {@link #constructSpecializedType}, but that creates a
     * less-specific type of given type. Usually this is as simple as simply
     * finding super-type with type erasure of <code>superClass</code>, but
     * there may be need for some additional work-arounds.
     *
     * @param superClass
     *
     * @since 2.7
     */
    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)
    {
        // simple optimization to avoid costly introspection if type-erased type does NOT differ
        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == superClass) {
            return baseType;
        }
        JavaType superType = baseType.findSuperType(superClass);
        if (superType == null) {
            // Most likely, caller did not verify sub/super-type relationship
            if (!superClass.isAssignableFrom(rawBase)) {
                throw new IllegalArgumentException(String.format(
                        "Class %s not a super-type of %s", superClass.getName(), baseType));
            }
            // 01-Nov-2015, tatu: Should never happen, but ch
            throw new IllegalArgumentException(String.format(
                    "Internal error: class %s not included as super-type for %s",
                    superClass.getName(), baseType));
        }
        return superType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* Tricky part here is that some JavaType instances have been constructed
         * from generic type (usually via TypeReference); and in those case
         * types have been resolved. Alternative is that the leaf type is type-erased
         * class, in which case this has not been done.
         * For now simplest way to handle this is to split processing in two: latter
         * case actually fully works; and former mostly works. In future may need to
         * rewrite former part, which requires changes to JavaType as well.
         */
        if (expType == type.getParameterSource()) {
            // Direct type info; good since we can return it as is
            int count = type.containedTypeCount();
            if (count == 0) return null;
            JavaType[] result = new JavaType[count];
            for (int i = 0; i < count; ++i) {
                result[i] = type.containedType(i);
            }
            return result;
=======
        JavaType match = type.findSuperType(expType);
        if (match == null) {
            return NO_TYPES;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* Otherwise need to go through type-erased class. This may miss cases where
         * we get generic type; ideally JavaType/SimpleType would retain information
         * about generic declaration at main level... but let's worry about that
         * if/when there are problems; current handling is an improvement over earlier
         * code.
         */
        Class<?> raw = type.getRawClass();
        return findTypeParameters(raw, expType, new TypeBindings(this, type));
=======
        return match.getBindings().typeParameterArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @since 2.7
=======
     * @deprecated Since 2.7 resolve raw type first, then find type parameters
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType[] findTypeParameters(JavaType type, Class<?> expType, TypeBindings bindings)
    {
        if (expType == type.getParameterSource()) {
            int count = type.containedTypeCount();
            if (count == 0) return null;
            JavaType[] result = new JavaType[count];
            for (int i = 0; i < count; ++i) {
                result[i] = type.containedType(i);
            }
            return result;
        }
        Class<?> raw = type.getRawClass();
        return findTypeParameters(raw, expType, bindings);
=======
    @Deprecated // since 2.7    
    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) {
        return findTypeParameters(constructType(clz, bindings), expType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE

=======
    
    /**
     * @deprecated Since 2.7 resolve raw type first, then find type parameters
     */
    @Deprecated // since 2.7    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return findTypeParameters(clz, expType, new TypeBindings(this, clz));
    }

    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)
    {
        // First: find full inheritance chain
        HierarchicType subType = _findSuperTypeChain(clz, expType);
        // Caller is supposed to ensure this never happens, so:
        if (subType == null) {
            throw new IllegalArgumentException("Class "+clz.getName()+" is not a subtype of "+expType.getName());
        }
        // Ok and then go to the ultimate super-type:
        HierarchicType superType = subType;
        while (superType.getSuperType() != null) {
            superType = superType.getSuperType();
            Class<?> raw = superType.getRawClass();
            TypeBindings newBindings = new TypeBindings(this, raw);
            if (superType.isGeneric()) { // got bindings, need to resolve
                ParameterizedType pt = superType.asGeneric();
                Type[] actualTypes = pt.getActualTypeArguments();
                TypeVariable<?>[] vars = raw.getTypeParameters();
                int len = actualTypes.length;
                for (int i = 0; i < len; ++i) {
                    String name = vars[i].getName();
                    JavaType type = _constructType(actualTypes[i], bindings);
                    newBindings.addBinding(name, type);
                }
            }
            bindings = newBindings;
        }

        // which ought to be generic (if not, it's raw type)
        if (!superType.isGeneric()) {
            return null;
        }
        return bindings.typesAsArray();
=======
        return findTypeParameters(constructType(clz), expType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return _constructType(type, null);
=======
        return _fromAny(null, type, EMPTY_BINDINGS);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return _constructType(type, bindings);
=======
        return _fromAny(null, type, bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType constructType(TypeReference<?> typeRef) {
        return _constructType(typeRef.getType(), null);
=======
    public JavaType constructType(TypeReference<?> typeRef)
    {
        // 19-Oct-2015, tatu: Simpler variant like so should work
        return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);

        // but if not, due to funky sub-classing, type variables, what follows
        // is a more complete processing a la Java ClassMate.

        /*
        final Class<?> refdRawType = typeRef.getClass();
        JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);
        JavaType genType = type.findSuperType(TypeReference.class);
        if (genType == null) { // sanity check; shouldn't occur
            throw new IllegalArgumentException("Unparameterized GenericType instance ("+refdRawType.getName()+")");
        }
        TypeBindings b = genType.getBindings();
        JavaType[] params = b.typeParameterArray();
        if (params.length == 0) {
            throw new IllegalArgumentException("Unparameterized GenericType instance ("+refdRawType.getName()+")");
        }
        return params[0];
        */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
    public JavaType constructType(Type type, Class<?> context) {
        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);
        return _constructType(type, b);
=======

    /**
     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
     */
    @Deprecated
    public JavaType constructType(Type type, Class<?> contextClass) {
        TypeBindings bindings = (contextClass == null)
                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
        return _fromAny(null, type, bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType constructType(Type type, JavaType context) {
        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);
        return _constructType(type, b);
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Factory method that can be used if type information is passed
     * as Java typing returned from <code>getGenericXxx</code> methods
     * (usually for a return or argument type).
=======
     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _constructType(Type type, TypeBindings context)
    {
        JavaType resultType;

        // simple class?
        if (type instanceof Class<?>) {
            resultType = _fromClass((Class<?>) type, context);
        }
        // But if not, need to start resolving.
        else if (type instanceof ParameterizedType) {
            resultType = _fromParamType((ParameterizedType) type, context);
        }
        else if (type instanceof JavaType) { // [Issue#116]
            return (JavaType) type;
        }
        else if (type instanceof GenericArrayType) {
            resultType = _fromArrayType((GenericArrayType) type, context);
        }
        else if (type instanceof TypeVariable<?>) {
            resultType = _fromVariable((TypeVariable<?>) type, context);
        }
        else if (type instanceof WildcardType) {
            resultType = _fromWildcard((WildcardType) type, context);
        } else {
            // sanity check
            throw new IllegalArgumentException("Unrecognized Type: "+((type == null) ? "[null]" : type.toString()));
        }
        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,
         * for now only call for simple types (i.e. not for arrays, map or collections).
         * Can be changed in future it necessary
         */
        if (_modifiers != null && !resultType.isContainerType()) {
            for (TypeModifier mod : _modifiers) {
                resultType = mod.modifyType(resultType, type, context, this);
            }
        }
        return resultType;
=======
    @Deprecated
    public JavaType constructType(Type type, JavaType contextType) {
        TypeBindings bindings = (contextType == null)
                ? TypeBindings.emptyBindings() : contextType.getBindings();
        return _fromAny(null, type, bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return ArrayType.construct(_constructType(elementType, null), null, null);
=======
        return ArrayType.construct(_fromAny(null, elementType, null), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return ArrayType.construct(elementType, null, null);
=======
        return ArrayType.construct(elementType, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionType.construct(collectionClass, constructType(elementClass));
=======
        return constructCollectionType(collectionClass,
                _fromClass(null, elementClass, EMPTY_BINDINGS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionType.construct(collectionClass, elementType);
=======
        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be
        //    a valid use case here
        return (CollectionType) _fromClass(null, collectionClass,
                TypeBindings.create(collectionClass, elementType));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionLikeType.construct(collectionClass, constructType(elementClass));
=======
        return constructCollectionLikeType(collectionClass,
                _fromClass(null, elementClass, EMPTY_BINDINGS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionLikeType.construct(collectionClass, elementType);
=======
        JavaType type = _fromClass(null, collectionClass,
                TypeBindings.createIfNeeded(collectionClass, elementType));
        if (type instanceof CollectionLikeType) {
            return (CollectionLikeType) type;
        }
        return CollectionLikeType.upgradeFrom(type, elementType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {
        return MapType.construct(mapClass, keyType, valueType);
=======
    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {
        JavaType kt, vt;
        if (mapClass == Properties.class) {
            kt = vt = CORE_TYPE_STRING;
        } else {
            kt = _fromClass(null, keyClass, EMPTY_BINDINGS);
            vt = _fromClass(null, valueClass, EMPTY_BINDINGS);
        }
        return constructMapType(mapClass, kt, vt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {
        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));
=======
    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {
        return (MapType) _fromClass(null, mapClass,
                TypeBindings.create(mapClass, new JavaType[] {
                        keyType, valueType
                }));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {
        return MapLikeType.construct(mapClass, keyType, valueType);
=======
    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {
        return constructMapLikeType(mapClass,
                _fromClass(null, keyClass, EMPTY_BINDINGS),
                _fromClass(null, valueClass, EMPTY_BINDINGS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {
        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));
=======
    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {
        // 19-Oct-2015, tatu: Allow case of no-type-variables, since it seems likely to be
        //    a valid use case here
        JavaType type = _fromClass(null, mapClass,
                TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }));
        if (type instanceof MapLikeType) {
            return (MapLikeType) type;
        }
        return MapLikeType.upgradeFrom(type, keyType, valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * 
     * @deprecated Since 2.5, use variant that takes one more argument
=======
     *<p>
     * NOTE: was briefly deprecated for 2.6.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    @Deprecated
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return constructSimpleType(rawType, rawType, parameterTypes);
=======
        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
     *
     * @since 2.6
     *
     * @deprecated Since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Quick sanity check: must match numbers of types with expected...
        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();
        if (typeVars.length != parameterTypes.length) {
            throw new IllegalArgumentException("Parameter type mismatch for "+rawType.getName()
                    +" (and target "+parameterTarget.getName()+"): expected "+typeVars.length
                    +" parameters, was given "+parameterTypes.length);
        }
        String[] names = new String[typeVars.length];
        for (int i = 0, len = typeVars.length; i < len; ++i) {
            names[i] = typeVars[i].getName();
        }
        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);
=======
        return constructSimpleType(rawType, parameterTypes);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType constructReferenceType(Class<?> rawType, JavaType refType)
=======
    public JavaType constructReferenceType(Class<?> rawType, JavaType referredType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return new ReferenceType(rawType, refType, null, null, false);
=======
        return ReferenceType.construct(rawType, null, // no bindings
                null, null, // or super-class, interfaces?
                referredType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return new SimpleType(cls);
=======
        // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here
        return _constructSimple(cls, EMPTY_BINDINGS, null, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * type <code>List&lt;Integer></code>, you could
=======
     * type <code>List&lt;Set&lt;Integer>></code>, you could
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     *  TypeFactory.constructParametrizedType(List.class, List.class, Integer.class);
=======
     *  JavaType inner = TypeFactory.constructParametrizedType(Set.class, Set.class, Integer.class);
     *  return TypeFactory.constructParametrizedType(ArrayList.class, List.class, inner);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * NOTE: type modifiers are NOT called on constructed type itself; but are called
     * when resolving <code>parameterClasses</code> into {@link JavaType}.
=======
     * NOTE: type modifiers are NOT called on constructed type.
     * 
     * @param parametrized Actual full type
     * @param parameterClasses Type parameters to apply
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @param parametrized Type-erased type of instance being constructed
     * @param parametersFor class or interface for which type parameters are applied; either
     *   <code>parametrized</code> or one of its supertypes
     * @param parameterClasses Type parameters to apply
     * 
     * @since 2.5
=======
     * @since 2.5 NOTE: was briefly deprecated for 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,
            Class<?>... parameterClasses)
    {
=======
    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            pt[i] = _fromClass(parameterClasses[i], null);
=======
            pt[i] = _fromClass(null, parameterClasses[i], null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return constructParametrizedType(parametrized, parametersFor, pt);
    }

    /**
     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.
     */
    @Deprecated
    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {
        return constructParametrizedType(parametrized, parametrized, parameterClasses);
=======
        return constructParametricType(parametrized, pt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @param parametrized Actual full type
     * @param parametersFor class or interface for which type parameters are applied; either
     *   <code>parametrized</code> or one of its supertypes
=======
     * @param rawType Actual type-erased type
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @since 2.5
=======
     * @since 2.5 NOTE: was briefly deprecated for 2.6
     */
    public JavaType constructParametricType(Class<?> rawType, JavaType... parameterTypes)
    {
        return _fromClass(null, rawType, TypeBindings.create(rawType, parameterTypes));
    }

    /**
     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType resultType;
        
        // Need to check kind of class we are dealing with...
        if (parametrized.isArray()) {
            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?
            if (parameterTypes.length != 1) {
                throw new IllegalArgumentException("Need exactly 1 parameter type for arrays ("+parametrized.getName()+")");
            }
            resultType = constructArrayType(parameterTypes[0]);
        }
        else if (Map.class.isAssignableFrom(parametrized)) {
            if (parameterTypes.length != 2) {
                throw new IllegalArgumentException("Need exactly 2 parameter types for Map types ("+parametrized.getName()+")");
            }
            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);
        }
        else if (Collection.class.isAssignableFrom(parametrized)) {
            if (parameterTypes.length != 1) {
                throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types ("+parametrized.getName()+")");
            }
            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);
        } else {
            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);
        }
        return resultType;
=======
        return constructParametricType(parametrized, parameterTypes);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.
=======
     * @since 2.5 -- but will probably deprecated in 2.7 or 2.8 (not needed with 2.7)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    @Deprecated
    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {
        return constructParametrizedType(parametrized, parametrized, parameterTypes);
=======
    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,
            Class<?>... parameterClasses)
    {
        return constructParametricType(parametrized, parameterClasses);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionType.construct(collectionClass, unknownType());
=======
        return constructCollectionType(collectionClass, unknownType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionLikeType.construct(collectionClass, unknownType());
=======
        return constructCollectionLikeType(collectionClass, unknownType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return MapType.construct(mapClass, unknownType(), unknownType());
=======
        return constructMapType(mapClass, unknownType(), unknownType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return MapLikeType.construct(mapClass, unknownType(), unknownType());
=======
        return constructMapLikeType(mapClass, unknownType(), unknownType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /* Actual factory methods
=======
    /* Low-level factory methods
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /**
     * @param context Mapping of formal parameter declarations (for generic
     *   types) into actual types
     */
    protected JavaType _fromClass(Class<?> clz, TypeBindings context)
=======
    private JavaType _mapType(Class<?> rawClass, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Very first thing: small set of core types we know well:
        if (clz == String.class) return CORE_TYPE_STRING;
        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;
        if (clz == Integer.TYPE) return CORE_TYPE_INT;
        if (clz == Long.TYPE) return CORE_TYPE_LONG;
=======
        JavaType kt, vt;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Barring that, we may have recently constructed an instance:
        ClassKey key = new ClassKey(clz);
        JavaType result = _typeCache.get(key); // ok, cache object is synced
        if (result != null) {
            return result;
=======
        // 28-May-2015, tatu: Properties are special, as per [databind#810]; fake "correct" parameter sig
        if (rawClass == Properties.class) {
            kt = vt = CORE_TYPE_STRING;
        } else {
            List<JavaType> typeParams = bindings.getTypeParameters();
            // ok to have no types ("raw")
            switch (typeParams.size()) {
            case 0: // acceptable?
                kt = vt = _unknownType();
                break;
            case 2:
                kt = typeParams.get(0);
                vt = typeParams.get(1);
                break;
            default:
                throw new IllegalArgumentException("Strange Map type "+rawClass.getName()+": can not determine type parameters");
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // If context was needed, weed do:
        /*
        if (context == null) {
            context = new TypeBindings(this, cls);
=======
    private JavaType _collectionType(Class<?> rawClass, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
    {
        List<JavaType> typeParams = bindings.getTypeParameters();
        // ok to have no types ("raw")
        JavaType ct;
        if (typeParams.isEmpty()) {
            ct = _unknownType();
        } else if (typeParams.size() == 1) {
            ct = typeParams.get(0);
        } else {
            throw new IllegalArgumentException("Strange Collection type "+rawClass.getName()+": can not determine type parameters");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        */
=======
        return CollectionType.construct(rawClass, bindings, superClass, superInterfaces, ct);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // First: do we have an array type?
        if (clz.isArray()) {
            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);
            /* Also: although enums can also be fully resolved, there's little
             * point in doing so (T extends Enum<T>) etc.
             */
        } else if (clz.isEnum()) {
            result = new SimpleType(clz);
            /* Maps and Collections aren't quite as hot; problem is, due
             * to type erasure we often do not know typing and can only assume
             * base Object.
             */
        } else if (Map.class.isAssignableFrom(clz)) {
            result = _mapType(clz);
        } else if (Collection.class.isAssignableFrom(clz)) {
            result =  _collectionType(clz);
=======
    private JavaType _referenceType(Class<?> rawClass, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
    {
        List<JavaType> typeParams = bindings.getTypeParameters();
        // ok to have no types ("raw")
        JavaType ct;
        if (typeParams.isEmpty()) {
            ct = _unknownType();
        } else if (typeParams.size() == 1) {
            ct = typeParams.get(0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            // 28-Apr-2015, tatu: New class of types, referential...
            if (AtomicReference.class.isAssignableFrom(clz)) {
                
                JavaType[] pts = findTypeParameters(clz, AtomicReference.class);
                JavaType rt = (pts == null || pts.length != 1) ? unknownType() : pts[0];
                result = constructReferenceType(clz, rt);
            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types
            } else if (Map.Entry.class.isAssignableFrom(clz)) {
                JavaType[] pts = findTypeParameters(clz, Map.Entry.class);
                JavaType kt, vt;
                if (pts == null || pts.length != 2) {
                    kt = vt = unknownType();
                } else {
                    kt = pts[0];
                    vt = pts[1];
                }
                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });
            } else {
                result = new SimpleType(clz);
            }
=======
            throw new IllegalArgumentException("Strange Reference type "+rawClass.getName()+": can not determine type parameters");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        _typeCache.put(key, result); // cache object syncs
        return result;
=======
        return ReferenceType.construct(rawClass, bindings, superClass, superInterfaces, ct);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Method used by {@link TypeParser} when generics-aware version
     * is constructed.
=======
     * Factory method to call when no special {@link JavaType} is needed,
     * no generic parameters are passed. Default implementation may check
     * pre-constructed values for "well-known" types, but if none found
     * will simply call {@link #_newSimpleType}
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)
=======
    protected JavaType _constructSimple(Class<?> raw, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        if (clz.isArray()) { // ignore generics (should never have any)
            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);
        }
        if (clz.isEnum()) { // ditto for enums
            return new SimpleType(clz);
        }
        if (Map.class.isAssignableFrom(clz)) {
            // First: if we do have param types, use them
            JavaType keyType, contentType;
            if (paramTypes.size() > 0) {
                keyType = paramTypes.get(0);
                contentType = (paramTypes.size() >= 2) ?
                        paramTypes.get(1) : _unknownType();
                return MapType.construct(clz, keyType, contentType);
            }
            return _mapType(clz);
        }
        if (Collection.class.isAssignableFrom(clz)) {
            if (paramTypes.size() >= 1) {
                return CollectionType.construct(clz, paramTypes.get(0));
=======
        if (bindings.isEmpty()) {
            JavaType result = _findWellKnownSimple(raw);
            if (result != null) {
                return result;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            return _collectionType(clz);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        if (paramTypes.size() == 0) {
            return new SimpleType(clz);
        }
        // Hmmh. Does this actually occur?
        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);
        return constructSimpleType(clz, clz, pt);
=======
        return _newSimpleType(raw, bindings, superClass, superInterfaces);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * This method deals with parameterized types, that is,
     * first class generic classes.
=======
     * Factory method that is to create a new {@link SimpleType} with no
     * checks whatsoever. Default implementation calls the single argument
     * constructor of {@link SimpleType}.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)
=======
    protected JavaType _newSimpleType(Class<?> raw, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* First: what is the actual base type? One odd thing
         * is that 'getRawType' returns Type, not Class<?> as
         * one might expect. But let's assume it is always of
         * type Class: if not, need to add more code to resolve
         * it to Class.
=======
        return new SimpleType(raw, bindings, superClass, superInterfaces);
    }

    protected JavaType _unknownType() {
        /* 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.
         *    This may have been due to potential mutability of the instance; but that
         *    should not be issue any more, and creation is somewhat wasteful. So let's
         *    try reusing singleton/flyweight instance.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        Class<?> rawType = (Class<?>) type.getRawType();
        Type[] args = type.getActualTypeArguments();
        int paramCount = (args == null) ? 0 : args.length;
=======
        return CORE_TYPE_OBJECT;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType[] pt;
        
        if (paramCount == 0) {
            pt = NO_TYPES;
=======
    /**
     * Helper method called to see if requested, non-generic-parameterized
     * type is one of common, "well-known" types, instances of which are
     * pre-constructed and do not need dynamic caching.
     *
     * @since 2.7
     */
    protected JavaType _findWellKnownSimple(Class<?> clz) {
        if (clz.isPrimitive()) {
            if (clz == CLS_BOOL) return CORE_TYPE_BOOL;
            if (clz == CLS_INT) return CORE_TYPE_INT;
            if (clz == CLS_LONG) return CORE_TYPE_LONG;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            pt = new JavaType[paramCount];
            for (int i = 0; i < paramCount; ++i) {
                pt[i] = _constructType(args[i], context);
            }
=======
            if (clz == CLS_STRING) return CORE_TYPE_STRING;
            if (clz == CLS_OBJECT) return CORE_TYPE_OBJECT; // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
        return null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Ok: Map or Collection?
        if (Map.class.isAssignableFrom(rawType)) {
            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails
            JavaType subtype = constructSimpleType(rawType, rawType, pt);
            // 23-Sep-2015, tatu: and why do we not pass 3rd arg of 'context'? Won't help, it seems,
            //   plus causes other issues. Sigh.
            JavaType[] mapParams = findTypeParameters(subtype, Map.class);
            if (mapParams.length != 2) {
                throw new IllegalArgumentException("Could not find 2 type parameters for Map class "+rawType.getName()+" (found "+mapParams.length+")");
            }
            return MapType.construct(rawType, mapParams[0], mapParams[1]);
        }
        if (Collection.class.isAssignableFrom(rawType)) {
            // 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails
            JavaType subtype = constructSimpleType(rawType, rawType, pt);
            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);
            if (collectionParams.length != 1) {
                throw new IllegalArgumentException("Could not find 1 type parameter for Collection class "+rawType.getName()+" (found "+collectionParams.length+")");
            }
            return CollectionType.construct(rawType, collectionParams[0]);
        }
        // 28-Apr-2015, tatu: New class of types, referential...
        if (AtomicReference.class.isAssignableFrom(rawType)) {
            JavaType rt = null;

            if (rawType == AtomicReference.class) {
                if (paramCount == 1) {
                    rt = pt[0];
                }
            } else {
                JavaType subtype = constructSimpleType(rawType, rawType, pt);
                JavaType[] pts = findTypeParameters(subtype, AtomicReference.class, context);
                if (pts != null && pts.length == 1) {
                    rt = pts[0];
                }
=======
    /*
    /**********************************************************
    /* Actual type resolution, traversal
    /**********************************************************
     */

    /**
     * Factory method that can be used if type information is passed
     * as Java typing returned from <code>getGenericXxx</code> methods
     * (usually for a return or argument type).
     */
    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)
    {
        JavaType resultType;

        // simple class?
        if (type instanceof Class<?>) {
            // Important: remove possible bindings since this is type-erased thingy
            resultType = _fromClass(context, (Class<?>) type, EMPTY_BINDINGS);
        }
        // But if not, need to start resolving.
        else if (type instanceof ParameterizedType) {
            resultType = _fromParamType(context, (ParameterizedType) type, bindings);
        }
        else if (type instanceof JavaType) { // [databind#116]
            // no need to modify further if we already had JavaType
            return (JavaType) type;
        }
        else if (type instanceof GenericArrayType) {
            resultType = _fromArrayType(context, (GenericArrayType) type, bindings);
        }
        else if (type instanceof TypeVariable<?>) {
            resultType = _fromVariable(context, (TypeVariable<?>) type, bindings);
        }
        else if (type instanceof WildcardType) {
            resultType = _fromWildcard(context, (WildcardType) type, bindings);
        } else {
            // sanity check
            throw new IllegalArgumentException("Unrecognized Type: "+((type == null) ? "[null]" : type.toString()));
        }
        /* Need to allow TypeModifiers to alter actual type; however,
         * for now only call for simple types (i.e. not for arrays, map or collections).
         * Can be changed in future it necessary
         */
        if (_modifiers != null && !resultType.isContainerType()) {
            TypeBindings b = resultType.getBindings();
            if (b == null) {
                b = EMPTY_BINDINGS;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);
        }
        if (Map.Entry.class.isAssignableFrom(rawType)) {
            JavaType kt = null, vt = null;

            if (rawType == Map.Entry.class) {
                if (paramCount == 2) {
                    kt = pt[0];
                    vt = pt[1];
                }
            } else {
                // 23-Sep-2015, tatu: Must be careful here; type resolution can NOT be done
                //    directly quite yet. Instead, need to do indirectly...
                JavaType subtype = constructSimpleType(rawType, rawType, pt);
                JavaType[] pts = findTypeParameters(subtype, Map.Entry.class, context);
                if (pts != null && pts.length == 2) {
                    kt = pts[0];
                    vt = pts[1];
                }
=======
            for (TypeModifier mod : _modifiers) {
                resultType = mod.modifyType(resultType, type, b, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {
                (kt == null) ? unknownType() : kt,
                (vt == null) ? unknownType() : vt });
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        
        if (paramCount == 0) { // no generics
            return new SimpleType(rawType);
        }
        return constructSimpleType(rawType, pt);
=======
        return resultType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)
=======
    /**
     * @param bindings Mapping of formal parameter declarations (for generic
     *   types) into actual types
     */
    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType compType = _constructType(type.getGenericComponentType(), context);
        return ArrayType.construct(compType, null, null);
    }
=======
        // Very first thing: small set of core types we know well:
        JavaType result = _findWellKnownSimple(rawType);
        if (result != null) {
            return result;
        }
        // Barring that, we may have recently constructed an instance:
        // !!! TODO 16-Oct-2015, tatu: For now let's only cached non-parameterized; otherwise
        //     need better cache key
        boolean cachable = (bindings == null) || bindings.isEmpty();
        if (cachable) {
            result = _typeCache.get(rawType); // ok, cache object is synced
            if (result != null) {
                return result;
            }
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)
    {
        final String name = type.getName();
        // 19-Mar-2015: Without context, all we can check are bounds.
=======
        // 15-Oct-2015, tatu: recursive reference?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            // And to prevent infinite loops, now need this:
            context = new TypeBindings(this, (Class<?>) null);
=======
            context = new ClassStack(rawType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            // Ok: here's where context might come in handy!
            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow
             *   unresolved type variables to handle some cases where bounds
             *   are enough. Let's hope it does not hide real fail cases.
             */
            JavaType actualType = context.findType(name, false);
            if (actualType != null) {
                return actualType;
=======
            ClassStack prev = context.find(rawType);
            if (prev != null) {
                // Self-reference: needs special handling, then...
                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);
                prev.addSelfReference(selfRef);
                return selfRef;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
            // no, but need to update context to allow for proper cycle resolution
            context = context.child(rawType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* 29-Jan-2010, tatu: We used to throw exception here, if type was
         *   bound: but the problem is that this can occur for generic "base"
         *   method, overridden by sub-class. If so, we will want to ignore
         *   current type (for method) since it will be masked.
         */
        Type[] bounds = type.getBounds();
=======
        // First: do we have an array type?
        if (rawType.isArray()) {
            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),
                    bindings);
        } else {
            // If not, need to proceed by first resolving parent type hierarchy
            
            JavaType superClass;
            JavaType[] superInterfaces;

            if (rawType.isInterface()) {
                superClass = null;
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            } else {
                // Note: even Enums can implement interfaces, so can not drop those
                superClass = _resolveSuperClass(context, rawType, bindings);
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            }

            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...
            if (rawType == Properties.class) {
                result = MapType.construct(rawType, bindings, superClass, superInterfaces,
                        CORE_TYPE_STRING, CORE_TYPE_STRING);
            }
            // And then check what flavor of type we got. Start by asking resolved
            // super-type if refinement is all that is needed?
            else if (superClass != null) {
                result = superClass.refine(rawType, bindings, superClass, superInterfaces);
            }
            // if not, perhaps we are now resolving a well-known class or interface?
            if (result == null) {
                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); 
                if (result == null) {
                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);
                    if (result == null) {
                        // but if nothing else, "simple" class for now:
                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);
                    }
                }
            }
        }
        context.resolveSelfReferences(result);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // With type variables we must use bound information.
        // Theoretically this gets tricky, as there may be multiple
        // bounds ("... extends A & B"); and optimally we might
        // want to choose the best match. Also, bounds are optional;
        // but here we are lucky in that implicit "Object" is
        // added as bounds if so.
        // Either way let's just use the first bound, for now, and
        // worry about better match later on if there is need.

        /* 29-Jan-2010, tatu: One more problem are recursive types
         *   (T extends Comparable<T>). Need to add "placeholder"
         *   for resolution to catch those.
         */
        context._addPlaceholder(name);
        return _constructType(bounds[0], context);
=======
        if (cachable) {
            _typeCache.putIfAbsent(rawType, result); // cache object syncs
        }
        return result;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)
=======
    protected JavaType _resolveSuperClass(ClassStack context, Class<?> rawType, TypeBindings parentBindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* Similar to challenges with TypeVariable, we may have
         * multiple upper bounds. But it is also possible that if
         * upper bound defaults to Object, we might want to consider
         * lower bounds instead.
         *
         * For now, we won't try anything more advanced; above is
         * just for future reference.
         */
        return _constructType(type.getUpperBounds()[0], context);
=======
        Type parent = ClassUtil.getGenericSuperclass(rawType);
        if (parent == null) {
            return null;
        }
        return _fromAny(context, parent, parentBindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    private JavaType _mapType(Class<?> rawClass)
=======
    protected JavaType[] _resolveSuperInterfaces(ClassStack context, Class<?> rawType, TypeBindings parentBindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // 28-May-2015, tatu: Properties are special, as per [databind#810]
        if (rawClass == Properties.class) {
            return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING);
=======
        Type[] types = ClassUtil.getGenericInterfaces(rawType);
        if (types == null || types.length == 0) {
            return NO_TYPES;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);
        // ok to have no types ("raw")
        if (typeParams == null) {
            return MapType.construct(rawClass, _unknownType(), _unknownType());
        }
        // but exactly 2 types if any found
        if (typeParams.length != 2) {
            throw new IllegalArgumentException("Strange Map type "+rawClass.getName()+": can not determine type parameters");
=======
        int len = types.length;
        JavaType[] resolved = new JavaType[len];
        for (int i = 0; i < len; ++i) {
            Type type = types[i];
            resolved[i] = _fromAny(context, type, parentBindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return MapType.construct(rawClass, typeParams[0], typeParams[1]);
=======
        return resolved;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    private JavaType _collectionType(Class<?> rawClass)
=======
    /**
     * Helper class used to check whether exact class for which type is being constructed
     * is one of well-known base interfaces or classes that indicates alternate
     * {@link JavaType} implementation.
     */
    protected JavaType _fromWellKnownClass(ClassStack context, Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);
        // ok to have no types ("raw")
        if (typeParams == null) {
            return CollectionType.construct(rawClass, _unknownType());
=======
        // Quite simple when we resolving exact class/interface; start with that
        if (rawType == Map.class) {
            return _mapType(rawType, bindings, superClass, superInterfaces);
        }
        if (rawType == Collection.class) {
            return _collectionType(rawType, bindings, superClass, superInterfaces);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // but exactly 2 types if any found
        if (typeParams.length != 1) {
            throw new IllegalArgumentException("Strange Collection type "+rawClass.getName()+": can not determine type parameters");
=======
        // and since 2.6 one referential type
        if (rawType == AtomicReference.class) {
            return _referenceType(rawType, bindings, superClass, superInterfaces);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return CollectionType.construct(rawClass, typeParams[0]);
    }    
=======
        // 01-Nov-2015, tatu: As of 2.7, couple of potential `CollectionLikeType`s (like
        //    `Iterable`, `Iterator`), and `MapLikeType`s (`Map.Entry`) are not automatically
        //    detected, related to difficulties in propagating type upwards (Iterable, for
        //    example, is a weak, tag-on type). They may be detectable in future.
        return null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)
=======
    protected JavaType _fromWellKnownInterface(ClassStack context, Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // can't resolve raw types; possible to have as-of-yet-unbound types too:
        if (leafType != null && leafType.isGeneric()) {
            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();
            for (int i = 0, len = typeVariables.length; i < len; ++i) {
                TypeVariable<?> tv = typeVariables[i];
                if (variableName.equals(tv.getName())) {
                    // further resolution needed?
                    Type type = leafType.asGeneric().getActualTypeArguments()[i];
                    if (type instanceof TypeVariable<?>) {
                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);
                    }
                    // no we're good for the variable (but it may have parameterization of its own)
                    return _constructType(type, bindings);
                }
=======
        // But that's not all: may be possible current type actually implements an
        // interface type. So...
        final int intCount = superInterfaces.length;

        for (int i = 0; i < intCount; ++i) {
            JavaType result = superInterfaces[i].refine(rawType, bindings, superClass, superInterfaces);
            if (result != null) {
                return result;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return _unknownType();
    }
    
    protected JavaType _unknownType() {
        return new SimpleType(Object.class);
=======
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Helper method used to find inheritance (implements, extends) path
     * between given types, if one exists (caller generally checks before
     * calling this method). Returned type represents given <b>subtype</b>,
     * with supertype linkage extending to <b>supertype</b>.
=======
     * This method deals with parameterized types, that is,
     * first class generic classes.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)
=======
    protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype,
            TypeBindings parentBindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // If super-type is a class (not interface), bit simpler
        if (supertype.isInterface()) {
            return _findSuperInterfaceChain(subtype, supertype);
=======
        // Assumption here is we'll always get Class, not one of other Types
        Class<?> rawType = (Class<?>) ptype.getRawType();

        // 29-Oct-2015, tatu: For performance reasons, let's streamline handling of
        //   couple of not-so-useful parametric types
        if (rawType == CLS_ENUM) {
            return CORE_TYPE_ENUM;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return _findSuperClassChain(subtype, supertype);
    }
=======
        if (rawType == CLS_COMPARABLE) {
            return CORE_TYPE_COMPARABLE;
        }
        if (rawType == CLS_CLASS) {
            return CORE_TYPE_CLASS;
        }

        // First: what is the actual base type? One odd thing is that 'getRawType'
        // returns Type, not Class<?> as one might expect. But let's assume it is
        // always of type Class: if not, need to add more code to resolve it to Class.        
        Type[] args = ptype.getActualTypeArguments();
        int paramCount = (args == null) ? 0 : args.length;
        JavaType[] pt;
        TypeBindings newBindings;        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)
    {
        HierarchicType current = new HierarchicType(currentType);
        Class<?> raw = current.getRawClass();
        if (raw == target) {
            return current;
        }
        // Otherwise, keep on going down the rat hole...
        Type parent = raw.getGenericSuperclass();
        if (parent != null) {
            HierarchicType sup = _findSuperClassChain(parent, target);
            if (sup != null) {
                sup.setSubType(current);
                current.setSuperType(sup);
                return current;
=======
        if (paramCount == 0) {
            newBindings = EMPTY_BINDINGS;
        } else {
            pt = new JavaType[paramCount];
            for (int i = 0; i < paramCount; ++i) {
                pt[i] = _fromAny(context, args[i], parentBindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
            newBindings = TypeBindings.create(rawType, pt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return null;
=======
        return _fromClass(context, rawType, newBindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)
=======
    protected JavaType _fromArrayType(ClassStack context, GenericArrayType type, TypeBindings bindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        HierarchicType current = new HierarchicType(currentType);
        Class<?> raw = current.getRawClass();
        if (raw == target) {
            return new HierarchicType(currentType);
        }
        // Otherwise, keep on going down the rat hole; first implemented interfaces
        /* 16-Aug-2011, tatu: Minor optimization based on profiled hot spot; let's
         *   try caching certain commonly needed cases
         */
        if (raw == HashMap.class) {
            if (target == Map.class) {
                return _hashMapSuperInterfaceChain(current);
            }
        }
        if (raw == ArrayList.class) {
            if (target == List.class) {
                return _arrayListSuperInterfaceChain(current);
            }
        }
        return _doFindSuperInterfaceChain(current, target);
=======
        JavaType elementType = _fromAny(context, type.getGenericComponentType(), bindings);
        return ArrayType.construct(elementType, bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    
    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)
=======

    protected JavaType _fromVariable(ClassStack context, TypeVariable<?> var, TypeBindings bindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        Class<?> raw = current.getRawClass();
        Type[] parents = raw.getGenericInterfaces();
        // as long as there are superclasses
        // and unless we have already seen the type (<T extends X<T>>)
        if (parents != null) {
            for (Type parent : parents) {
                HierarchicType sup = _findSuperInterfaceChain(parent, target);
                if (sup != null) {
                    sup.setSubType(current);
                    current.setSuperType(sup);
                    return current;
                }
            }
=======
        // ideally should find it via bindings:
        final String name = var.getName();
        JavaType type = bindings.findBoundType(name);
        if (type != null) {
            return type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // and then super-class if any
        Type parent = raw.getGenericSuperclass();
        if (parent != null) {
            HierarchicType sup = _findSuperInterfaceChain(parent, target);
            if (sup != null) {
                sup.setSubType(current);
                current.setSuperType(sup);
                return current;
            }
=======
        // but if not, use bounds... note that approach here is simplistic; not taking
        // into account possible multiple bounds, nor consider upper bounds.
        if (bindings.hasUnbound(name)) {
            return CORE_TYPE_OBJECT;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        return null;
=======
        bindings = bindings.withUnboundVariable(name);

        Type[] bounds = var.getBounds();
        return _fromAny(context, bounds[0], bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)
=======
    protected JavaType _fromWildcard(ClassStack context, WildcardType type, TypeBindings bindings)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        if (_cachedHashMapType == null) {
            HierarchicType base = current.deepCloneWithoutSubtype();
            _doFindSuperInterfaceChain(base, Map.class);
            _cachedHashMapType = base.getSuperType();
        }
        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();
        current.setSuperType(t);
        t.setSubType(current);
        return current;
    }

    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)
    {
        if (_cachedArrayListType == null) {
            HierarchicType base = current.deepCloneWithoutSubtype();
            _doFindSuperInterfaceChain(base, List.class);
            _cachedArrayListType = base.getSuperType();
        }
        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();
        current.setSuperType(t);
        t.setSubType(current);
        return current;
=======
        /* Similar to challenges with TypeVariable, we may have multiple upper bounds.
         * But it is also possible that if upper bound defaults to Object, we might
         * want to consider lower bounds instead.
         * For now, we won't try anything more advanced; above is just for future reference.
         */
        return _fromAny(context, type.getUpperBounds()[0], bindings);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
=======
import java.lang.reflect.TypeVariable;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    private CollectionType(Class<?> collT, JavaType elemT,
=======
    private CollectionType(Class<?> collT, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        super(collT,  elemT, valueHandler, typeHandler, asStatic);
=======
        super(collT, bindings, superClass, superInts, elemT, valueHandler, typeHandler, asStatic);
    }

    /**
     * @since 2.7
     */
    protected CollectionType(TypeBase base, JavaType elemT) {
        super(base, elemT);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return new CollectionType(subclass, _elementType, null, null, _asStatic);
=======
    /**
     * @since 2.7
     */
    public static CollectionType construct(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT) {
        return new CollectionType(rawType, bindings, superClass, superInts, elemT,
                null, null, false);
    }

    /**
     * @deprecated Since 2.7, remove from 2.8
     */
    @Deprecated // since 2.7
    public static CollectionType construct(Class<?> rawType, JavaType elemT) {
        // First: may need to fabricate TypeBindings (needed for refining into
        // concrete collection types, as per [databind#1102])
        TypeVariable<?>[] vars = rawType.getTypeParameters();
        TypeBindings bindings;
        if ((vars == null) || (vars.length != 1)) {
            bindings = TypeBindings.emptyBindings();
        } else {
            bindings = TypeBindings.create(rawType, elemT);
        }
        return new CollectionType(rawType, bindings,
                // !!! TODO: Wrong, does have supertypes, but:
                _bogusSuperClass(rawType), null, elemT,
                null, null, false);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _elementType.getRawClass()) {
            return this;
        }
        return new CollectionType(_class, _elementType.narrowBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
    protected JavaType _narrow(Class<?> subclass) {
        return new CollectionType(subclass, _bindings,
                _superClass, _superInterfaces, _elementType, null, null, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _elementType.getRawClass()) {
=======
    public JavaType withContentType(JavaType contentType) {
        if (_elementType == contentType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType.widenBy(contentClass),
                _valueHandler, _typeHandler, _asStatic);
=======
        return new CollectionType(_class, _bindings, _superClass, _superInterfaces,
                contentType, _valueHandler, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    public static CollectionType construct(Class<?> rawType, JavaType elemT)
    {
        // nominally component types will be just Object.class
        return new CollectionType(rawType, elemT, null, null, false);
    }

    // Since 1.7:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType, _valueHandler, h, _asStatic);
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    // Since 1.7:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType.withTypeHandler(h),
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withTypeHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType, h, _typeHandler, _asStatic);
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType, h, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType.withValueHandler(h),
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withValueHandler(h),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
        return new CollectionType(_class, _elementType.withStaticTyping(),
=======
        return new CollectionType(_class, _bindings,
                _superClass, _superInterfaces, _elementType.withStaticTyping(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Overridden accessors
    /**********************************************************
     */
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    public Class<?> getParameterSource() {
        return java.util.Collection.class;
=======
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return new CollectionType(rawType, bindings,
                superClass, superInterfaces, _elementType,
                _valueHandler, _typeHandler, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    protected ArrayType(JavaType componentType, Object emptyInstance,
=======
    protected ArrayType(JavaType componentType, TypeBindings bindings, Object emptyInstance,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        super(emptyInstance.getClass(), componentType.hashCode(),
=======
        // No super-class, interfaces, for now
        super(emptyInstance.getClass(), bindings, null, null,
                componentType.hashCode(),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    public static ArrayType construct(JavaType componentType,
            Object valueHandler, Object typeHandler)
    {
        /* This is bit messy: there is apparently no other way to
         * reconstruct actual concrete/raw array class from component
         * type, than to construct an instance, get class (same is
         * true for GenericArracyType as well; hence we won't bother
         * passing that in).
         */
=======
    public static ArrayType construct(JavaType componentType, TypeBindings bindings) {
        return construct(componentType, bindings, null, null);
    }

    public static ArrayType construct(JavaType componentType, TypeBindings bindings,
            Object valueHandler, Object typeHandler) {
        // Figuring out raw class for generic array is actually bit tricky...
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(componentType, emptyInstance, null, null, false);
    }                                   
    
=======
        return new ArrayType(componentType, bindings, emptyInstance, valueHandler, typeHandler, false);
    }

    @Override
    public JavaType withContentType(JavaType contentType) {
        Object emptyInstance = Array.newInstance(contentType.getRawClass(), 0);
        return new ArrayType(contentType, _bindings, emptyInstance,
                _valueHandler, _typeHandler, _asStatic);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType, _emptyArray, _valueHandler, h, _asStatic);
=======
        return new ArrayType(_componentType, _bindings, _emptyArray, _valueHandler, h, _asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType.withTypeHandler(h), _emptyArray,
=======
        return new ArrayType(_componentType.withTypeHandler(h), _bindings, _emptyArray,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType, _emptyArray, h, _typeHandler,_asStatic);
=======
        return new ArrayType(_componentType, _bindings, _emptyArray, h, _typeHandler,_asStatic);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType.withValueHandler(h), _emptyArray,
=======
        return new ArrayType(_componentType.withValueHandler(h), _bindings, _emptyArray,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
        return new ArrayType(_componentType.withStaticTyping(),
=======
        return new ArrayType(_componentType.withStaticTyping(), _bindings,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    @Override
    protected String buildCanonicalName() {
        return _class.getName();
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    protected JavaType _narrow(Class<?> subclass)
    {
        /* Ok: need a bit of indirection here. First, must replace component
         * type (and check that it is compatible), then re-construct.
         */
        if (!subclass.isArray()) { // sanity check, should never occur
            throw new IllegalArgumentException("Incompatible narrowing operation: trying to narrow "+toString()+" to class "+subclass.getName());
        }
        /* Hmmh. This is an awkward back reference... but seems like the
         * only simple way to do it.
         */
        Class<?> newCompClass = subclass.getComponentType();
        /* 14-Mar-2011, tatu: it gets even worse, as we do not have access to
         *   currently configured TypeFactory. This could theoretically cause
         *   problems (when narrowing from array of Objects, to array of non-standard
         *   Maps, for example); but for now need to defer solving this until
         *   it actually becomes a real problem, not just potential one.
         *   (famous last words?)
         */
        JavaType newCompType = TypeFactory.defaultInstance().constructType(newCompClass);
        return construct(newCompType, _valueHandler, _typeHandler);
=======
    @Deprecated // since 2.7
    protected JavaType _narrow(Class<?> subclass) {
        return _reportUnsupported();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    /**
     * For array types, both main type and content type can be modified;
     * but ultimately they are interchangeable.
     */
=======
    // Should not be called, as array types in Java are not extensible; but
    // let's not freak out even if it is called?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    public JavaType narrowContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _componentType.getRawClass()) {
            return this;
        }
        return construct(_componentType.narrowBy(contentClass),
                _valueHandler, _typeHandler);
=======
    public JavaType refine(Class<?> contentClass, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    @Override
    public JavaType widenContentsBy(Class<?> contentClass)
    {
        // Can do a quick check first:
        if (contentClass == _componentType.getRawClass()) {
            return this;
        }
        return construct(_componentType.widenBy(contentClass),
                _valueHandler, _typeHandler);
=======
    private JavaType _reportUnsupported() {
        throw new UnsupportedOperationException("Can not narrow or widen array types");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    
    /**
     * Not sure what symbolic name is used internally, if any;
     * let's follow naming of Collection types here.
     * Should not really matter since array types have no
     * super types.
     */
    @Override
    public String containedTypeName(int index) {
        if (index == 0) return "E";
        return null;
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    /**
     * No parameterization for array types themselves; element type
     * may obviously have parameterization.
     */
    @Override
    public Class<?> getParameterSource() {
        return null;
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    public int containedTypeCount() { return 1; }
=======
    public Object getContentValueHandler() {
        return _componentType.getValueHandler();
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    public JavaType containedType(int index) {
            return (index == 0) ? _componentType : null;
=======
    public Object getContentTypeHandler() {
        return _componentType.getTypeHandler();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
    implements java.io.Serializable
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
    private static final long serialVersionUID = 1L;

    private final static String[] NO_STRINGS = new String[0];

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    
    /**
     * Marker to use for (temporarily) unbound references.
     */
    public final static JavaType UNBOUND = new SimpleType(Object.class);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**
     * Factory to use for constructing resolved related types.
     */
    protected final TypeFactory _typeFactory;
    
    /**
     * Context type used for resolving all types, if specified. May be null,
     * in which case {@link #_contextClass} is used instead.
     */
    protected final JavaType _contextType;
=======
    private final static TypeBindings EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**
     * Specific class to use for resolving all types, for methods and fields
     * class and its superclasses and -interfaces contain.
     */
    protected final Class<?> _contextClass;
=======
    // // // Pre-resolved instances for minor optimizations
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
    // // // Actual member information
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
     * Lazily-instantiated bindings of resolved type parameters
=======
     * Array of type (type variable) names.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    protected Map<String,JavaType> _bindings;
=======
    private final String[] _names;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
     * Also: we may temporarily want to mark certain named types
     * as resolved (but without exact type); if so, we'll just store
     * names here.
=======
     * Types matching names
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    protected HashSet<String> _placeholders;
=======
    private final JavaType[] _types;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
     * Sometimes it is necessary to allow hierarchic resolution of types: specifically
     * in cases where there are local bindings (for methods, constructors). If so,
     * we'll just use simple delegation model.
=======
     * Names of potentially unresolved type variables.
     *
     * @since 2.3
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    private final TypeBindings _parentBindings;

=======
    private final String[] _unboundVariables;
    
    private final int _hashCode;
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**********************************************************
=======
    /**********************************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**********************************************************
=======
    /**********************************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public TypeBindings(TypeFactory typeFactory, Class<?> cc)
=======
    private TypeBindings(String[] names, JavaType[] types, String[] uvars)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        this(typeFactory, null, cc, null);
=======
        _names = (names == null) ? NO_STRINGS : names;
        _types = (types == null) ? NO_TYPES : types;
        if (_names.length != _types.length) {
            throw new IllegalArgumentException("Mismatching names ("+_names.length+"), types ("+_types.length+")");
        }
        int h = 1;
        for (int i = 0, len = _types.length; i < len; ++i) {
            h += _types[i].hashCode();
        }
        _unboundVariables = uvars;
        _hashCode = h;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public TypeBindings(TypeFactory typeFactory, JavaType type)
    {
        this(typeFactory, null, type.getRawClass(), type);
=======
    public static TypeBindings emptyBindings() {
        return EMPTY;
    }

    // Let's just canonicalize serialized EMPTY back to static instance, if need be
    protected Object readResolve() {
        if ((_names == null) || (_names.length == 0)) {
            return EMPTY;
        }
        return this;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
     * Constructor used to create "child" instances; mostly to
     * allow delegation from explicitly defined local overrides
     * (local type variables for methods, constructors) to
     * contextual (class-defined) ones.
=======
     * Factory method for constructing bindings for given class using specified type
     * parameters.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public TypeBindings childInstance() {
        return new TypeBindings(_typeFactory, this, _contextClass, _contextType);
=======
    public static TypeBindings create(Class<?> erasedType, List<JavaType> typeList)
    {
        JavaType[] types = (typeList == null || typeList.isEmpty()) ?
                NO_TYPES : typeList.toArray(new JavaType[typeList.size()]);
        return create(erasedType, types);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    private TypeBindings(TypeFactory tf, TypeBindings parent,
            Class<?> cc, JavaType type)
=======
    public static TypeBindings create(Class<?> erasedType, JavaType[] types)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        _typeFactory = tf;
        _parentBindings = parent;
        _contextClass = cc;
        _contextType = type;
=======
        if (types == null) {
            types = NO_TYPES;
        } else switch (types.length) {
        case 1:
            return create(erasedType, types[0]);
        case 2:
            return create(erasedType, types[0], types[1]);
        }
        TypeVariable<?>[] vars = erasedType.getTypeParameters();
        String[] names;
        if (vars == null || vars.length == 0) {
            names = NO_STRINGS;
        } else {
            int len = vars.length;
            names = new String[len];
            for (int i = 0; i < len; ++i) {
                names[i] = vars[i].getName();
            }
        }
        // Check here to give better error message
        if (names.length != types.length) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                   +" with "+types.length+" type parameter"
                   +((types.length == 1) ? "" : "s")+": class expects "+names.length);
        }
        return new TypeBindings(names, types, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Pass-through type resolution methods
    /**********************************************************
     */

    public JavaType resolveType(Class<?> cls) {
        return _typeFactory._constructType(cls, this);
=======
    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1)
    {
        // 30-Oct-2015, tatu: Minor optimization for relatively common cases
        TypeVariable<?>[] vars = TypeParamStash.paramsFor1(erasedType);
        int varLen = (vars == null) ? 0 : vars.length;
        if (varLen != 1) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                    +" with 1 type parameter: class expects "+varLen);
        }
        return new TypeBindings(new String[] { vars[0].getName() },
                new JavaType[] { typeArg1 }, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public JavaType resolveType(Type type) {
        return _typeFactory._constructType(type, this);
=======
    public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2)
    {
        // 30-Oct-2015, tatu: Minor optimization for relatively common cases
        TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType);
        int varLen = (vars == null) ? 0 : vars.length;
        if (varLen != 2) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                    +" with 2 type parameters: class expects "+varLen);
        }
        return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() },
                new JavaType[] { typeArg1, typeArg2 }, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Accesors
    /**********************************************************
=======
    /**
     * Alternate factory method that may be called if it is possible that type
     * does or does not require type parameters; this is mostly useful for
     * collection- and map-like types.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE

    public int getBindingCount() {
        if (_bindings == null) {
            _resolve();
=======
    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1)
    {
        TypeVariable<?>[] vars = erasedType.getTypeParameters();
        int varLen = (vars == null) ? 0 : vars.length;
        if (varLen == 0) {
            return EMPTY;
        }
        if (varLen != 1) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                    +" with 1 type parameter: class expects "+varLen);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        return _bindings.size();
=======
        return new TypeBindings(new String[] { vars[0].getName() },
                new JavaType[] { typeArg1 }, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE

    @Deprecated // since 2.6, remove from 2.7
    public JavaType findType(String name) {
        return findType(name, true);
=======
    
    /**
     * Alternate factory method that may be called if it is possible that type
     * does or does not require type parameters; this is mostly useful for
     * collection- and map-like types.
     */
    public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types)
    {
        TypeVariable<?>[] vars = erasedType.getTypeParameters();
        if (vars == null || vars.length == 0) {
            return EMPTY;
        }
        if (types == null) {
            types = NO_TYPES;
        }
        int len = vars.length;
        String[] names = new String[len];
        for (int i = 0; i < len; ++i) {
            names[i] = vars[i].getName();
        }
        // Check here to give better error message
        if (names.length != types.length) {
            throw new IllegalArgumentException("Can not create TypeBindings for class "+erasedType.getName()
                   +" with "+types.length+" type parameter"
                   +((types.length == 1) ? "" : "s")+": class expects "+names.length);
        }
        return new TypeBindings(names, types, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public JavaType findType(String name, boolean mustFind)
=======
    /**
     * Method for creating an instance that has same bindings as this object,
     * plus an indicator for additional type variable that may be unbound within
     * this context; this is needed to resolve recursive self-references.
     */
    public TypeBindings withUnboundVariable(String name)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        if (_bindings == null) {
            _resolve();
        }
        JavaType t = _bindings.get(name);
        if (t != null) {
            return t;
        }
        if (_placeholders != null && _placeholders.contains(name)) {
            return UNBOUND;
        }
        if (_parentBindings != null) {
            return _parentBindings.findType(name);
        }
        // nothing found, so...
        // Should we throw an exception or just return null?
        
        /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within
         *   java.util, such as HashMap$KeySet; so let's punt the problem
         *   (honestly not sure what to do -- they are unbound for good, I think)
         */
        if (_contextClass != null) {
            Class<?> enclosing = _contextClass.getEnclosingClass();
            if (enclosing != null) {
                // [JACKSON-572]: Actually, let's skip this for all non-static inner classes
                //   (which will also cover 'java.util' type cases...
                if (!Modifier.isStatic(_contextClass.getModifiers())) {
                    return UNBOUND;
                }
=======
        int len = (_unboundVariables == null) ? 0 : _unboundVariables.length;
        String[] names =  (len == 0)
                ? new String[1] : Arrays.copyOf(_unboundVariables, len+1);
        names[len] = name;
        return new TypeBindings(_names, _types, names);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                // ... so this piece of code should not be needed any more
                /*
                Package pkg = enclosing.getPackage();
                if (pkg != null) {
                    // as per [JACKSON-533], also include "java.util.concurrent":
                    if (pkg.getName().startsWith("java.util")) {
                        return UNBOUND;
                    }
                }
                */
=======
    /*
    /**********************************************************************
    /* Accessors
    /**********************************************************************
     */
    
    /**
     * Find type bound to specified name, if there is one; returns bound type if so, null if not.
     */
    public JavaType findBoundType(String name)
    {
        for (int i = 0, len = _names.length; i < len; ++i) {
            if (name.equals(_names[i])) {
                return _types[i];
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
        return null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        if (!mustFind) {
=======
    public boolean isEmpty() {
        return (_types.length == 0);
    }
    
    /**
     * Returns number of bindings contained
     */
    public int size() { 
        return _types.length;
    }

    public String getBoundName(int index)
    {
        if (index < 0 || index >= _names.length) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        
        String className;
        if (_contextClass != null) {
            className = _contextClass.getName();
        } else if (_contextType != null) {
            className = _contextType.toString();
        } else {
            className = "UNKNOWN";
        }
        throw new IllegalArgumentException("Type variable '"+name
                +"' can not be resolved (with context of class "+className+")");
        //t = UNBOUND;                
=======
        return _names[index];
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public void addBinding(String name, JavaType type)
=======
    public JavaType getBoundType(int index)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        // note: emptyMap() is unmodifiable, hence second check is needed:
        if (_bindings == null || _bindings.size() == 0) {
            _bindings = new LinkedHashMap<String,JavaType>();
=======
        if (index < 0 || index >= _types.length) {
            return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        _bindings.put(name, type);
=======
        return _types[index];
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public JavaType[] typesAsArray()
=======
    /**
     * Accessor for getting bound types in declaration order
     */
    public List<JavaType> getTypeParameters()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        if (_bindings == null) {
            _resolve();
=======
        if (_types.length == 0) {
            return Collections.emptyList();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        if (_bindings.size() == 0) {
            return NO_TYPES;
=======
        return Arrays.asList(_types);
    }

    /**
     * @since 2.3
     */
    public boolean hasUnbound(String name) {
        if (_unboundVariables != null) {
            for (int i = _unboundVariables.length; --i >= 0; ) {
                if (name.equals(_unboundVariables[i])) {
                    return true;
                }
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        return _bindings.values().toArray(new JavaType[_bindings.size()]);
=======
        return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**********************************************************
    /* Internal methods
    /**********************************************************
=======
    /**********************************************************************
    /* Standard methods
    /**********************************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    protected void _resolve()
=======
    @Override public String toString()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        _resolveBindings(_contextClass);

        // finally: may have root level type info too
        if (_contextType != null) {
            int count = _contextType.containedTypeCount();
            if (count > 0) {
                for (int i = 0; i < count; ++i) {
                    String name = _contextType.containedTypeName(i);
                    JavaType type = _contextType.containedType(i);
                    addBinding(name, type);
                }
=======
        if (_types.length == 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        sb.append('<');
        for (int i = 0, len = _types.length; i < len; ++i) {
            if (i > 0) {
                sb.append(',');
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
//            sb = _types[i].appendBriefDescription(sb);
            String sig = _types[i].getGenericSignature();
            sb.append(sig);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
        sb.append('>');
        return sb.toString();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        // nothing bound? mark with empty map to prevent further calls
        if (_bindings == null) {
            _bindings = Collections.emptyMap();
        }
    }
=======
    @Override public int hashCode() { return _hashCode; }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    public void _addPlaceholder(String name) {
        if (_placeholders == null) {
            _placeholders = new HashSet<String>();
=======
    @Override public boolean equals(Object o)
    {
        if (o == this) return true;
        if (o == null || o.getClass() != getClass()) return false;
        TypeBindings other = (TypeBindings) o;
        int len = _types.length;
        if (len != other.size()) {
            return false;
        }
        JavaType[] otherTypes = other._types;
        for (int i = 0; i < len; ++i) {
            if (!otherTypes[i].equals(_types[i])) {
                return false;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        _placeholders.add(name);
=======
        return true;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    protected void _resolveBindings(Type t)
    {
        if (t == null) return;
=======
    /*
    /**********************************************************************
    /* Package accessible methods
    /**********************************************************************
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        Class<?> raw;
        if (t instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) t;
            Type[] args = pt.getActualTypeArguments();
            if (args  != null && args.length > 0) {
                Class<?> rawType = (Class<?>) pt.getRawType();    
                TypeVariable<?>[] vars = rawType.getTypeParameters();
                if (vars.length != args.length) {
                    throw new IllegalArgumentException("Strange parametrized type (in class "+rawType.getName()+"): number of type arguments != number of type parameters ("+args.length+" vs "+vars.length+")");
                }
                for (int i = 0, len = args.length; i < len; ++i) {
                    TypeVariable<?> var = vars[i];
                    String name = var.getName();
                    if (_bindings == null) {
                        _bindings = new LinkedHashMap<String,JavaType>();
                    } else {
                        /* 24-Mar-2010, tatu: Better ensure that we do not overwrite something
                         *  collected earlier (since we descend towards super-classes):
                         */
                        if (_bindings.containsKey(name)) continue;
                    }
                    // first: add a placeholder to prevent infinite loops
                    _addPlaceholder(name);
                    // then resolve type
                    _bindings.put(name, _typeFactory._constructType(args[i], this));
                }
            }
            raw = (Class<?>)pt.getRawType();
        } else if (t instanceof Class<?>) {
            raw = (Class<?>) t;
            /* [JACKSON-677]: If this is an inner class then the generics are defined on the 
             * enclosing class so we have to check there as well.  We don't
             * need to call getEnclosingClass since anonymous classes declare 
             * generics
             */
            Class<?> decl = raw.getDeclaringClass();
            /* 08-Feb-2013, tatu: Except that if context is also super-class, we must
             *   skip it; context will be checked anyway, and we'd get StackOverflow if
             *   we went there.
             */
            if (decl != null && !decl.isAssignableFrom(raw)) {
                _resolveBindings(raw.getDeclaringClass());
            }

            /* 24-Mar-2010, tatu: Can not have true generics definitions, but can
             *   have lower bounds ("<T extends BeanBase>") in declaration itself
             */
            TypeVariable<?>[] vars = raw.getTypeParameters();
            if (vars != null && vars.length > 0) {
                JavaType[] typeParams = null;
=======
    protected JavaType[] typeParameterArray() {
        return _types;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                if (_contextType != null && raw.isAssignableFrom(_contextType.getRawClass())) {
                    typeParams = _typeFactory.findTypeParameters(_contextType, raw);
                }
=======
    /*
    /**********************************************************************
    /* Helper classes
    /**********************************************************************
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                for (int i = 0; i < vars.length; i++) {
                    TypeVariable<?> var = vars[i];
=======
    // 30-Oct-2015, tatu: Surprising, but looks like type parameters access can be bit of
    //    a hot spot. So avoid for a small number of common generic types. Note that we do
    //    need both common abstract types and concrete ones; latter for specialization
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                    String name = var.getName();
                    Type varType = var.getBounds()[0];
                    if (varType != null) {
                        if (_bindings == null) {
                            _bindings = new LinkedHashMap<String,JavaType>();
                        } else { // and no overwriting...
                            if (_bindings.containsKey(name)) continue;
                        }
                        _addPlaceholder(name); // to prevent infinite loops

                        if (typeParams != null && typeParams.length > i) {
                            _bindings.put(name, typeParams[i]);
                        } else {
                            _bindings.put(name, _typeFactory._constructType(varType, this));
                        }
                    }
                }
=======
    /**
     * Helper class that contains simple logic for avoiding repeated lookups via
     * {@link Class#getTypeParameters()} as that can be a performance issue for
     * some use cases (wasteful, usually one-off or not reusing mapper).
     * Partly isolated to avoid initialization for cases where no generic types are
     * used.
     */
    static class TypeParamStash {
        private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters();

        private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters();

        public static TypeVariable<?>[] paramsFor1(Class<?> erasedType)
        {
            if (erasedType == Collection.class) {
                return VARS_COLLECTION;
            }
            if (erasedType == List.class) {
                return VARS_LIST;
            }
            if (erasedType == ArrayList.class) {
                return VARS_ARRAY_LIST;
            }
            if (erasedType == AbstractList.class) {
                return VARS_ABSTRACT_LIST;
            }
            if (erasedType == Iterable.class) {
                return VARS_ITERABLE;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        } else { // probably can't be any of these... so let's skip for now
            //if (type instanceof GenericArrayType) {
            //if (type instanceof TypeVariable<?>) {
            // if (type instanceof WildcardType) {
            return;
        }
        // but even if it's not a parameterized type, its super types may be:
        _resolveBindings(raw.getGenericSuperclass());
        for (Type intType : raw.getGenericInterfaces()) {
            _resolveBindings(intType);
        }
    }
=======
            return erasedType.getTypeParameters();
        }    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    @Override
    public String toString()
    {
        if (_bindings == null) {
            _resolve();
        }
        StringBuilder sb = new StringBuilder("[TypeBindings for ");
        if (_contextType != null) {
            sb.append(_contextType.toString());
        } else {
            sb.append(_contextClass.getName());
        }
        sb.append(": ").append(_bindings).append("]");
        return sb.toString();
    }
=======
        public static TypeVariable<?>[] paramsFor2(Class<?> erasedType)
        {
            if (erasedType == Map.class) {
                return VARS_MAP;
            }
            if (erasedType == HashMap.class) {
                return VARS_HASH_MAP;
            }
            if (erasedType == LinkedHashMap.class) {
                return VARS_LINKED_HASH_MAP;
            }
            return erasedType.getTypeParameters();
        }    
    }    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.type;

import com.fasterxml.jackson.databind.JavaType;

/**
 * Internal placeholder type used for self-references.
 *
 * @since 2.7
 */
public class ResolvedRecursiveType extends TypeBase
{
    private static final long serialVersionUID = 1L;

    protected JavaType _referencedType;

    public ResolvedRecursiveType(Class<?> erasedType, TypeBindings bindings) {
        super(erasedType, bindings, null, null, 0, null, null, false);
    }

    public void setReference(JavaType ref)
    {
        // sanity check; should not be called multiple times
        if (_referencedType != null) {
            throw new IllegalStateException("Trying to re-set self reference; old value = "+_referencedType+", new = "+ref);
        }
        _referencedType = ref;
    }

    public JavaType getSelfReferencedType() { return _referencedType; }

    @Override
    public StringBuilder getGenericSignature(StringBuilder sb) {
        return _referencedType.getGenericSignature(sb);
    }

    @Override
    public StringBuilder getErasedSignature(StringBuilder sb) {
        return _referencedType.getErasedSignature(sb);
    }

    @Override
    public JavaType withContentType(JavaType contentType) {
        return this;
    }
    
    @Override
    public JavaType withTypeHandler(Object h) {
        return this;
    }

    @Override
    public JavaType withContentTypeHandler(Object h) {
        return this;
    }

    @Override
    public JavaType withValueHandler(Object h) {
        return this;
    }

    @Override
    public JavaType withContentValueHandler(Object h) {
        return this;
    }

    @Override
    public JavaType withStaticTyping() {
        return this;
    }

    @Deprecated // since 2.7
    @Override
    protected JavaType _narrow(Class<?> subclass) {
        return this;
    }

    @Override
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return null;
    }

    @Override
    public boolean isContainerType() {
        return false;
    }

    @Override
    public String toString() {
        return null;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (o == null) return false;
        if (o.getClass() != getClass()) return false;

        return ((ResolvedRecursiveType) o).getSelfReferencedType().equals(getSelfReferencedType());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/PathDeserializer.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.ext;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;

public class PathDeserializer extends StdScalarDeserializer<Path>
{
    private static final long serialVersionUID = 1;

    public PathDeserializer() { super(Path.class); }
    
    @Override
    public Path deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
        JsonToken t= p.getCurrentToken();
        if (t != null) {
            if (t.isScalarValue()) {
                return Paths.get(p.getValueAsString());
            }
            // 16-Oct-2015: should we perhaps allow JSON Arrays (of Strings) as well?
        }
        throw ctxt.mappingException(Path.class, t);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
=======
 *<p>
 * Note that 2.7 changed handling to slightly less dynamic, to avoid having to
 * traverse class hierarchy, which turned to be a performance issue in
 * certain cases. Since DOM classes are assumed to exist on all Java 1.6
 * environments (yes, even on Android/GAE), this part could be simplified by
 * slightly less dynamic lookups.
 *<p>
 * Also with 2.7 we are supporting JDK 1.7/Java 7 type(s).
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
    /* 1.6.1+ To make 2 main "optional" handler groups (javax.xml.stream)
=======
    /* To make 2 main "optional" handler groups (javax.xml.stream)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
    private final static String CLASS_NAME_DOM_NODE = "org.w3c.dom.Node";
    private final static String CLASS_NAME_DOM_DOCUMENT = "org.w3c.dom.Node";
=======
//    private final static String CLASS_NAME_DOM_NODE = "org.w3c.dom.Node";
//    private final static String CLASS_NAME_DOM_DOCUMENT = "org.w3c.dom.Document";
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
=======

    private final static String DESERIALIZER_FOR_PATH = "com.fasterxml.jackson.databind.ext.PathDeserializer";

    // // Since 2.7, we will assume DOM classes are always found, both due to JDK 1.6 minimum
    // // and because Android (and presumably GAE) have these classes

    private final static Class<?> CLASS_DOM_NODE;
    private final static Class<?> CLASS_DOM_DOCUMENT;

    static {
        Class<?> doc = null, node = null;
        try {
            node = org.w3c.dom.Node.class;
            doc = org.w3c.dom.Document.class;
        } catch (Exception e) {
            // not optimal but will do
            System.err.println("WARNING: could not load DOM Node and/or Document classes");
        }
        CLASS_DOM_NODE = node;
        CLASS_DOM_DOCUMENT = doc;
    }

    // // But Java7 type(s) may or may not be; dynamic lookup should be fine, still
    // // (note: also assume it comes from JDK so that ClassLoader issues with OSGi
    // // can, I hope, be avoided?)
    
    private final static Class<?> CLASS_JAVA7_PATH;
    static {
        Class<?> cls = null;
        try {
            cls = Class.forName("java.nio.file.Path");
        } catch (Exception e) {
            // not optimal but will do
            System.err.println("WARNING: could not load Java7 Path class");
        }
        CLASS_JAVA7_PATH = cls;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        Class<?> rawType = type.getRawClass();
=======
        final Class<?> rawType = type.getRawClass();

        if ((CLASS_JAVA7_PATH != null) && CLASS_JAVA7_PATH.isAssignableFrom(rawType)) {
            return ToStringSerializer.instance;
        }
        if ((CLASS_DOM_NODE != null) && CLASS_DOM_NODE.isAssignableFrom(rawType)) {
            return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        
        if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) {
            return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE);
        }
        if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {
=======
        if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSuperClassStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        Class<?> rawType = type.getRawClass();
=======
        final Class<?> rawType = type.getRawClass();

        if ((CLASS_JAVA7_PATH != null) && CLASS_JAVA7_PATH.isAssignableFrom(rawType)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_PATH);
        }
        if ((CLASS_DOM_NODE != null) && CLASS_DOM_NODE.isAssignableFrom(rawType)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE);
        }
        if ((CLASS_DOM_DOCUMENT != null) && CLASS_DOM_DOCUMENT.isAssignableFrom(rawType)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
                || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {
=======
                || hasSuperClassStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT);
        } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
    
    private boolean doesImplement(Class<?> actualType, String classNameToImplement)
    {
        for (Class<?> type = actualType; type != null; type = type.getSuperclass()) {
            if (type.getName().equals(classNameToImplement)) {
                return true;
            }
            // or maybe one of super-interfaces
            if (hasInterface(type, classNameToImplement)) {
                return true;
            }
        }
        return false;
    }
        
    private boolean hasInterface(Class<?> type, String interfaceToImplement)
    {
        Class<?>[] interfaces = type.getInterfaces();
        for (Class<?> iface : interfaces) {
            if (iface.getName().equals(interfaceToImplement)) {
                return true;
            }
        }
        // maybe super-interface?
        for (Class<?> iface : interfaces) {
            if (hasInterface(iface, interfaceToImplement)) {
                return true;
            }
        }
        return false;
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
    private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix)
=======
    /**
     * Since 2.7 we only need to check for class extension, as all implemented
     * types are classes, not interfaces. This has performance implications for
     * some cases, as we do not need to go over interfaces implemented, just
     * superclasses
     * 
     * @since 2.7
     */
    private boolean hasSuperClassStartingWith(Class<?> rawType, String prefix)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        // first, superclasses
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
=======
            if (supertype == Object.class) {
                return false;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        // then interfaces
        for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) {
            if (hasInterfaceStartingWith(cls, prefix)) {
                return true;
            }
        }
        return false;
    }

    private boolean hasInterfaceStartingWith(Class<?> type, String prefix)
    {
        Class<?>[] interfaces = type.getInterfaces();
        for (Class<?> iface : interfaces) {
            if (iface.getName().startsWith(prefix)) {
                return true;
            }
        }
        // maybe super-interface?
        for (Class<?> iface : interfaces) {
            if (hasInterfaceStartingWith(iface, prefix)) {
                return true;
            }
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
            /* [databind#915] 26-Sep-2015, tatu: Should be UTC, plan to change
             * it so for 2.7
=======
            /* [databind#915] 05-Nov-2015, tatu: Changed to UTC, from earlier
             * baseline of GMT (up to 2.6)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
            TimeZone.getTimeZone("GMT");
=======
            TimeZone.getTimeZone("UTC");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
    public abstract ContextAttributes withSharedAttributes(Map<Object,Object> attributes);
=======
    public abstract ContextAttributes withSharedAttributes(Map<?,?> attributes);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        protected final Map<Object,Object> _shared;
=======
        protected final Map<?,?> _shared;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
=======
         *<p>
         * NOTE: typed as Object-to-Object, unlike {@link #_shared}, because
         * we need to be able to modify contents, and wildcard type would
         * complicate that access.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        protected Impl(Map<Object,Object> shared) {
=======
        protected Impl(Map<?,?> shared) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        protected Impl(Map<Object,Object> shared, Map<Object,Object> nonShared) {
=======
        protected Impl(Map<?,?> shared, Map<Object,Object> nonShared) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        public ContextAttributes withSharedAttributes(Map<Object, Object> shared) {
=======
        public ContextAttributes withSharedAttributes(Map<?,?> shared) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
        private Map<Object,Object> _copy(Map<Object,Object> src)
=======
        private Map<Object,Object> _copy(Map<?,?> src)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.TypeBindings;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    protected final static JsonInclude.Value EMPTY_INCLUDE = JsonInclude.Value.empty();

    /**
     * @since 2.7
     */
    protected final static JsonFormat.Value EMPTY_FORMAT = JsonFormat.Value.empty();

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
        return getTypeFactory().constructType(cls, (TypeBindings) null);
=======
        return getTypeFactory().constructType(cls);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
        return getTypeFactory().constructType(valueTypeRef.getType(), (TypeBindings) null);
=======
        return getTypeFactory().constructType(valueTypeRef.getType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
=======
    /* Configuration: default settings with per-type overrides
    /**********************************************************
     */

    /**
     * Accessor for default property inclusion to use for serialization,
     * used unless overridden by per-type or per-property overrides.
     *
     * @since 2.7
     */
    public abstract JsonInclude.Value getDefaultPropertyInclusion();

    /**
     * Accessor for default property inclusion to use for serialization,
     * considering possible per-type override for given base type.
     *
     * @since 2.7
     */
    public abstract JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType);

    /**
     * Accessor for default format settings to use for serialization (and, to a degree
     * deserialization), considering baseline settings and per-type defaults
     * for given base type (if any).
     *
     * @since 2.7
     */
    public abstract JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType);
    
    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java;<<<<<<< MINE
    public T withAttributes(Map<Object,Object> attributes) {
=======
    public T withAttributes(Map<?,?> attributes) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.JsonParser;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java;<<<<<<< MINE
    
    protected PropertyBindingException(String msg, JsonLocation loc,
=======

    /**
     * @since 2.7
     */
    protected PropertyBindingException(JsonParser p, String msg, JsonLocation loc,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java;<<<<<<< MINE
        
        super(msg, loc);
=======
        super(p, msg, loc);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7
     */
    @Deprecated // since 2.7
    protected PropertyBindingException(String msg, JsonLocation loc,
            Class<?> referringClass, String propName,
            Collection<Object> propertyIds)
    {
        this(null, msg, loc, referringClass, propName, propertyIds);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java;<<<<<<< MINE
=======
    public UnrecognizedPropertyException(JsonParser p, String msg, JsonLocation loc,
            Class<?> referringClass, String propName,
            Collection<Object> propertyIds)
    {
        super(p, msg, loc, referringClass, propName, propertyIds);
    }

    /**
     * @deprecated Since 2.7
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java;<<<<<<< MINE
     * @param jp Underlying parser used for reading input being used for data-binding
=======
     * @param p Underlying parser used for reading input being used for data-binding
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java;<<<<<<< MINE
    public static UnrecognizedPropertyException from(JsonParser jp,
=======
    public static UnrecognizedPropertyException from(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java;<<<<<<< MINE
        UnrecognizedPropertyException e = new UnrecognizedPropertyException(msg,
                jp.getCurrentLocation(), ref, propertyName, propertyIds);
=======
        UnrecognizedPropertyException e = new UnrecognizedPropertyException(p, msg,
                p.getCurrentLocation(), ref, propertyName, propertyIds);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java;<<<<<<< MINE

    /**
     * @deprecated Since 2.3, use {@link #getPropertyName} instead.
     */
    @Deprecated // since 2.3
    public String getUnrecognizedPropertyName() {
        return getPropertyName();
    }    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
    
=======

    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser}
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
        super(msg);
=======
        super(null, msg);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser}
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
        super(msg, loc);
=======
        super(null, msg, loc);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
    
    public static InvalidFormatException from(JsonParser jp, String msg,
=======

    /**
     * @since 2.7
     */
    public InvalidFormatException(JsonParser p,
            String msg, Object value, Class<?> targetType)
    {
        super(p, msg);
        _value = value;
        _targetType = targetType;
    }

    public static InvalidFormatException from(JsonParser p, String msg,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
        return new InvalidFormatException(msg, jp.getTokenLocation(),
                value, targetType);
=======
        return new InvalidFormatException(p, msg, value, targetType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java;<<<<<<< MINE
=======
    /**
     * @since 2.7
     */
    public IgnoredPropertyException(JsonParser p, String msg, JsonLocation loc,
            Class<?> referringClass, String propName,
            Collection<Object> propertyIds)
    {
        super(p, msg, loc, referringClass, propName, propertyIds);
    }

    /**
     * @deprecated Since 2.7
     */
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java;<<<<<<< MINE
=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java;<<<<<<< MINE
     * @param jp Underlying parser used for reading input being used for data-binding
=======
     * @param p Underlying parser used for reading input being used for data-binding
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java;<<<<<<< MINE
    public static IgnoredPropertyException from(JsonParser jp,
=======
    public static IgnoredPropertyException from(JsonParser p,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java;<<<<<<< MINE
        IgnoredPropertyException e = new IgnoredPropertyException(msg,
                jp.getCurrentLocation(), ref, propertyName, propertyIds);
=======
        IgnoredPropertyException e = new IgnoredPropertyException(p, msg,
                p.getCurrentLocation(), ref, propertyName, propertyIds);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java;<<<<<<< MINE
    public final boolean isEnabled(MapperFeature feature) {
        return getConfig().isEnabled(feature);
    }
=======
    public abstract boolean isEnabled(MapperFeature feature);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java;<<<<<<< MINE
    public final boolean canOverrideAccessModifiers() {
        return getConfig().canOverrideAccessModifiers();
    }
=======
    public abstract boolean canOverrideAccessModifiers();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java;<<<<<<< MINE
=======
    /**
     * @since 2.7
     */
    public abstract JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType);
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
    
=======

    // !!! 29-Nov-2015, tatu: TODO: mark deprecated in 2.8
    /**
     * Older variant of {@link #resolveAbstractType(DeserializationConfig, BeanDescription)};
     * obsoleted in 2.7, to be deprecated in 2.8
     */
    public JavaType resolveAbstractType(DeserializationConfig config,
            JavaType type) {
        return null;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
=======
     *<p>
     * Default implementation will call obsolete method for Jackson 2.7,
     * to try to keep some level of backwards compatibility.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
     * @param type Type for which materialization maybe needed
=======
     * @param typeDesc Description of the POJO type to resolve
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
     *    null if resolver does not know how to resolve type
=======
     *    null if resolver does not know how to resolve given type
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
            JavaType type) {
        return null;
=======
            BeanDescription typeDesc) {
        return resolveAbstractType(config, typeDesc.getType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.type.MapLikeType;
import com.fasterxml.jackson.databind.type.TypeFactory;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
 * Although default implementations are based on using annotations as the only
 * (or at least main) information source, custom implementations are not limited
 * in such a way, and in fact there is no expectation they should be. So the name
 * is bit of misnomer; this is a general configuration introspection facility.
 *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
    /* Access to possibly chained introspectors (1.7)
=======
    /* Access to possibly chained introspectors
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
        // !!! Change direction in 2.7 or later
        return findPropertiesToIgnore(ac);
=======
        return null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
        return null;
=======
        // Changed in 2.7 to call from old to new; with 2.6 was opposite
        return findPropertiesToIgnore(ac, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
     * @deprecated Since 2.3: use the one that takes generic {@link Annotated}
     */
    @Deprecated
    public Object findFilterId(AnnotatedClass ac) { return findFilterId((Annotated) ac); }

    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
    /**
     * Method used to check whether specified class defines a human-readable
     * description to use for documentation.
     * There are no further definitions for contents; for example, whether
     * these may be marked up using HTML (or something like wiki format like Markup)
     * is not defined.
     * 
     * @return Human-readable description, if any.
     * 
     * @since 2.7
     */
    public String findClassDescription(AnnotatedClass ac) { return null; }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
    /**
     * Method called in cases where a class has two methods eligible to be used
     * for the same logical property, and default logic is not enough to figure
     * out clear precedence. Introspector may try to choose one to use; or, if
     * unable, return `null` to indicate it can not resolve the problem.
     *
     * @since 2.7
     */
    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config,
            AnnotatedMethod setter1, AnnotatedMethod setter2) {
        return null;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
     * Method for accessing annotated type definition that a
     * method/field can have, to be used as the type for serialization
     * instead of the runtime type.
     * Type returned (if any) needs to be widening conversion (super-type).
     * Declared return type of the method is also considered acceptable.
     *
     * @return Class to use instead of runtime type
     */
    public Class<?> findSerializationType(Annotated a) {
        return null;
    }

    /**
     * Method for finding possible widening type definition that a property
     * value can have, to define less specific key type to use for serialization.
     * It should be only be used with {@link java.util.Map} types.
     * 
     * @return Class specifying more general type to use instead of
     *   declared type, if annotation found; null if not
     */
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {
        return null;
    }

    /**
     * Method for finding possible widening type definition that a property
     * value can have, to define less specific key type to use for serialization.
     * It should be only used with structured types (arrays, collections, maps).
     * 
     * @return Class specifying more general type to use instead of
     *   declared type, if annotation found; null if not
     */
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {
        return null;
    }
    
    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
     * 
     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
     * 
     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
    // // // Forwards compatibility: added in 2.6 BUT NOT YET USED until 2.7

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
     * NOTE: introduced in 2.6 but NOT YET USED by core databind until 2.7
=======
     * Method for checking inclusion criteria for a type (Class) or property (yes, method
     * name is bit unfortunate -- not just for properties!).
     * In case of class, acts as the default for properties POJO contains; for properties
     * acts as override for class defaults and possible global defaults.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
        JsonInclude.Include def = JsonInclude.Include.USE_DEFAULTS;
        JsonInclude.Include vi = findSerializationInclusion(a, def);
        JsonInclude.Include ci = findSerializationInclusionForContent(a, def);
        return JsonInclude.Value.construct(vi, ci);
=======
        return JsonInclude.Value.empty();
    }

    /*
    /**********************************************************
    /* Serialization: type refinements
    /**********************************************************
     */

    /**
     * Method for accessing annotated type definition that a
     * method/field can have, to be used as the type for serialization
     * instead of the runtime type.
     * Type returned (if any) needs to be widening conversion (super-type).
     * Declared return type of the method is also considered acceptable.
     *
     * @return Class to use instead of runtime type
     *
     * @deprecated Since 2.7 call {@link #refineSerializationType} instead
     */
    @Deprecated // since 2.7
    public Class<?> findSerializationType(Annotated a) {
        return null;
    }

    /**
     * Method for finding possible widening type definition that a property
     * value can have, to define less specific key type to use for serialization.
     * It should be only be used with {@link java.util.Map} types.
     * 
     * @return Class specifying more general type to use instead of
     *   declared type, if annotation found; null if not
     *
     * @deprecated Since 2.7 call {@link #refineSerializationType} instead
     */
    @Deprecated // since 2.7
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {
        return null;
    }

    /**
     * Method for finding possible widening type definition that a property
     * value can have, to define less specific key type to use for serialization.
     * It should be only used with structured types (arrays, collections, maps).
     * 
     * @return Class specifying more general type to use instead of
     *   declared type, if annotation found; null if not
     *
     * @deprecated Since 2.7 call {@link #refineSerializationType} instead
     */
    @Deprecated // since 2.7
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {
        return null;
    }

    /**
     * Method called to find out possible type refinements to use
     * for deserialization.
     *
     * @since 2.7
     */
    public JavaType refineSerializationType(final MapperConfig<?> config,
            final Annotated a, final JavaType baseType) throws JsonMappingException
    {
        JavaType type = baseType;
        final TypeFactory tf = config.getTypeFactory();
        
        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to
        //    now-deprecated secondary methods; this because while
        //    direct sub-class not yet retrofitted may only override
        //    those methods. With 2.8 or later we may consider removal
        //    of these methods

        
        // Ok: start by refining the main type itself; common to all types
        Class<?> serClass = findSerializationType(a);
        if (serClass != null) {
            if (type.hasRawClass(serClass)) {
                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of
                //    static typing this way
                type = type.withStaticTyping();
            } else {
                try {
                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,
                    //   may be needed here too in future?
                    type = tf.constructGeneralizedType(type, serClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(null,
                            String.format("Failed to widen type %s with annotation (value %s), from '%s': %s",
                                    type, serClass.getName(), a.getName(), iae.getMessage()),
                                    iae);
                }
            }
        }
        // Then further processing for container types

        // First, key type (for Maps, Map-like types):
        if (type.isMapLikeType()) {
            JavaType keyType = type.getKeyType();
            Class<?> keyClass = findSerializationKeyType(a, keyType);
            if (keyClass != null) {
                if (keyType.hasRawClass(keyClass)) {
                    keyType = keyType.withStaticTyping();
                } else {
                    try {
                        keyType = tf.constructGeneralizedType(keyType, keyClass);
                    } catch (IllegalArgumentException iae) {
                        throw new JsonMappingException(null,
                                String.format("Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s",
                                        type, keyClass.getName(), a.getName(), iae.getMessage()),
                                        iae);
                    }
                }
                type = ((MapLikeType) type).withKeyType(keyType);
            }
        }

        JavaType contentType = type.getContentType();
        if (contentType != null) { // collection[like], map[like], array, reference
            // And then value types for all containers:
           Class<?> contentClass = findSerializationContentType(a, contentType);
           if (contentClass != null) {
               if (contentType.hasRawClass(contentClass)) {
                   contentType = contentType.withStaticTyping();
               } else {
                   try {
                       contentType = tf.constructGeneralizedType(contentType, contentClass);
                   } catch (IllegalArgumentException iae) {
                       throw new JsonMappingException(null,
                               String.format("Failed to widen value type of %s with concrete-type annotation (value %s), from '%s': %s",
                                       type, contentClass.getName(), a.getName(), iae.getMessage()),
                                       iae);
                   }
               }
               type = type.withContentType(contentType);
           }
        }
        return type;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
    /**
     * Method for efficiently figuring out which if given set of <code>Enum</code> values
     * have explicitly defined name. Method will overwrite entries in incoming <code>names</code>
     * array with explicit names found, if any, leaving other entries unmodified.
     *<p>
     * Default implementation will simply delegate to {@link #findEnumValue}, which is close
     * enough, although unfortunately NOT 100% equivalent (as it will also consider <code>name()</code>
     * to give explicit value).
     *
     * @since 2.7
     */
    public  String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {
        for (int i = 0, len = enumValues.length; i < len; ++i) {
            names[i] = findEnumValue(enumValues[i]);
        }
        return names;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
     * Method for accessing annotated type definition that a
     * method can have, to be used as the type for serialization
     * instead of the runtime type.
     * Type must be a narrowing conversion
     * (i.e.subtype of declared type).
     * Declared return type of the method is also considered acceptable.
     *
     * @param baseType Assumed type before considering annotations
     *
     * @return Class to use for deserialization instead of declared type
     */
    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {
        return null;
    }

    /**
     * Method for accessing additional narrowing type definition that a
     * method can have, to define more specific key type to use.
     * It should be only be used with {@link java.util.Map} types.
     * 
     * @param baseKeyType Assumed key type before considering annotations
     *
     * @return Class specifying more specific type to use instead of
     *   declared type, if annotation found; null if not
     */
    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {
        return null;
    }

    /**
     * Method for accessing additional narrowing type definition that a
     * method can have, to define more specific content type to use;
     * content refers to Map values and Collection/array elements.
     * It should be only be used with Map, Collection and array types.
     * 
     * @param baseContentType Assumed content (value) type before considering annotations
     *
     * @return Class specifying more specific type to use instead of
     *   declared type, if annotation found; null if not
     */
    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {
        return null;
    }

    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======

    /*
    /**********************************************************
    /* Deserialization: type refinements
    /**********************************************************
     */

    /**
     * Method called to find out possible type refinements to use
     * for deserialization.
     *
     * @since 2.7
     */
    public JavaType refineDeserializationType(final MapperConfig<?> config,
            final Annotated a, final JavaType baseType) throws JsonMappingException
    {
        JavaType type = baseType;
        final TypeFactory tf = config.getTypeFactory();

        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to
        //    now-deprecated secondary methods; this because while
        //    direct sub-class not yet retrofitted may only override
        //    those methods. With 2.8 or later we may consider removal
        //    of these methods

        
        // Ok: start by refining the main type itself; common to all types
        Class<?> valueClass = findDeserializationType(a, type);
        if ((valueClass != null) && !type.hasRawClass(valueClass)) {
            try {
                type = tf.constructSpecializedType(type, valueClass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(null,
                        String.format("Failed to narrow type %s with annotation (value %s), from '%s': %s",
                                type, valueClass.getName(), a.getName(), iae.getMessage()),
                                iae);
            }
        }
        // Then further processing for container types

        // First, key type (for Maps, Map-like types):
        if (type.isMapLikeType()) {
            JavaType keyType = type.getKeyType();
            Class<?> keyClass = findDeserializationKeyType(a, keyType);
            if (keyClass != null) {
                try {
                    keyType = tf.constructSpecializedType(keyType, keyClass);
                    type = ((MapLikeType) type).withKeyType(keyType);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(null,
                            String.format("Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s",
                                    type, keyClass.getName(), a.getName(), iae.getMessage()),
                                    iae);
                }
            }
        }
        JavaType contentType = type.getContentType();
        if (contentType != null) { // collection[like], map[like], array, reference
            // And then value types for all containers:
           Class<?> contentClass = findDeserializationContentType(a, contentType);
           if (contentClass != null) {
               try {
                   contentType = tf.constructSpecializedType(contentType, contentClass);
                   type = type.withContentType(contentType);
               } catch (IllegalArgumentException iae) {
                   throw new JsonMappingException(null,
                           String.format("Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s",
                                   type, contentClass.getName(), a.getName(), iae.getMessage()),
                                   iae);
               }
           }
        }
        return type;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
    /**
     * Method for accessing annotated type definition that a
     * property can have, to be used as the type for deserialization
     * instead of the static (declared) type.
     * Type is usually narrowing conversion (i.e.subtype of declared type).
     * Declared return type of the method is also considered acceptable.
     *
     * @param baseType Assumed type before considering annotations
     *
     * @return Class to use for deserialization instead of declared type
     *
     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead
     */
    @Deprecated
    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {
        return null;
    }
    
    /**
     * Method for accessing additional narrowing type definition that a
     * method can have, to define more specific key type to use.
     * It should be only be used with {@link java.util.Map} types.
     * 
     * @param baseKeyType Assumed key type before considering annotations
     *
     * @return Class specifying more specific type to use instead of
     *   declared type, if annotation found; null if not
     *
     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead
     */
    @Deprecated
    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {
        return null;
    }

    /**
     * Method for accessing additional narrowing type definition that a
     * method can have, to define more specific content type to use;
     * content refers to Map values and Collection/array elements.
     * It should be only be used with Map, Collection and array types.
     * 
     * @param baseContentType Assumed content (value) type before considering annotations
     *
     * @return Class specifying more specific type to use instead of
     *   declared type, if annotation found; null if not
     *
     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead
     */
    @Deprecated
    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {
        return null;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======

    /**
     * Alternative lookup method that is used to see if annotation has at least one of
     * annotations of types listed in second argument.
     *
     * @since 2.7
     */
    protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) {
        return annotated.hasOneOf(annoClasses);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
    public final static JsonFormat.Value EMPTY_FORMAT = new JsonFormat.Value();
    public final static JsonInclude.Value EMPTY_INCLUDE = JsonInclude.Value.empty();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
    /**
     * Accessor for checking whether there is an actual physical property
     * behind this property abstraction or not.
     * 
     * @since 2.7
     */
    public boolean isVirtual();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
     * and specifically does NOT try to find per-type format defaults to merge;
     * use {@link #findPropertyFormat} if such defaults would be useful.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
    /**
     * Helper method used to look up format settings applicable to this property,
     * considering both possible per-type configuration settings
     *
     * @since 2.7
     */
    public JsonFormat.Value findPropertyFormat(MapperConfig<?> config, Class<?> baseType);
    
    /**
     * Convenience method that is roughly equivalent to
     *<pre>
     *   return config.getAnnotationIntrospector().findPropertyInclusion(getMember());
     *</pre>
     * but also considers global default settings for inclusion
     *
     * @since 2.7
     */
    public JsonInclude.Value findPropertyInclusion(MapperConfig<?> config, Class<?> baseType);

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: Starting with 2.7, takes explicit {@link SerializerProvider}
     * argument to reduce the need to rely on provider visitor may or may not
     * have assigned.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
     * @since 2.2
=======
     * @since 2.2 (although signature did change in 2.7)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)
=======
    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
            SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
        @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
            return null;
=======
            if ((_member != null) && (intr != null)) {
                JsonFormat.Value v = intr.findFormat(_member);
                if (v != null) {
                    return v;
                }
            }
            return EMPTY_FORMAT;
        }

        @Override
        public JsonFormat.Value findPropertyFormat(MapperConfig<?> config, Class<?> baseType) {
            JsonFormat.Value v0 = config.getDefaultPropertyFormat(baseType);
            AnnotationIntrospector intr = config.getAnnotationIntrospector();
            if ((intr == null) || (_member == null)) {
                return v0;
            }
            JsonFormat.Value v = intr.findFormat(_member);
            if (v == null) {
                return v0;
            }
            return v0.withOverrides(v);
        }
        
        @Override
        public JsonInclude.Value findPropertyInclusion(MapperConfig<?> config, Class<?> baseType)
        {
            JsonInclude.Value v0 = config.getDefaultPropertyInclusion(baseType);
            AnnotationIntrospector intr = config.getAnnotationIntrospector();
            if ((intr == null) || (_member == null)) {
                return v0;
            }
            JsonInclude.Value v = intr.findPropertyInclusion(_member);
            if (v == null) {
                return v0;
            }
            return v0.withOverrides(v);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
        public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor) {
=======
        public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor,
                SerializerProvider provider) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java;<<<<<<< MINE
    /* Life-cycle, fluent factories for JsonGenerator.Feature
=======
    /* Life-cycle, fluent factories for JsonGenerator.Feature (2.5)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java;<<<<<<< MINE
=======
    /* Life-cycle, fluent factories for FormatFeature (2.7)
    /**********************************************************
     */

    /**
     * @since 2.7
     */
    public ObjectWriter with(FormatFeature feature)  {
        SerializationConfig newConfig = _config.with(feature);
        return (newConfig == _config) ? this : _new(this, newConfig);
    }

    /**
     * @since 2.7
     */
    public ObjectWriter withFeatures(FormatFeature... features) {
        SerializationConfig newConfig = _config.withFeatures(features);
        return (newConfig == _config) ? this : _new(this, newConfig);
    }

    /**
     * @since 2.7
     */
    public ObjectWriter without(FormatFeature feature) {
        SerializationConfig newConfig = _config.without(feature);
        return (newConfig == _config) ? this : _new(this, newConfig);
    }

    /**
     * @since 2.7
     */
    public ObjectWriter withoutFeatures(FormatFeature... features) {
        SerializationConfig newConfig = _config.withoutFeatures(features);
        return (newConfig == _config) ? this : _new(this, newConfig);
    }
    
    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java;<<<<<<< MINE
=======
     * Mutant factory method that allows construction of a new writer instance
     * that uses specified set of default attribute values.
     *
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java;<<<<<<< MINE
    public ObjectWriter withAttributes(Map<Object,Object> attrs) {
=======
    public ObjectWriter withAttributes(Map<?,?> attrs) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======
    public final boolean canOverrideAccessModifiers() {
        return _config.canOverrideAccessModifiers();
    }

    @Override
    public final boolean isEnabled(MapperFeature feature) {
        return _config.isEnabled(feature);
    }

    @Override
    public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {
        return _config.getDefaultPropertyFormat(baseType);
    }
    
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
                String.format("Can not construct instance of %s from String value '%s': %s",
                        instClass.getName(), _desc(value), msg),
=======
                String.format("Can not construct instance of %s from String value (%s): %s",
                        instClass.getName(), _quotedString(value), msg),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
                null, instClass);
=======
                value, instClass);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
                String.format("Can not construct Map key of type %s from String \"%s\": %s",
                        keyClass.getName(), _desc(keyValue), msg),
=======
                String.format("Can not construct Map key of type %s from String (%s): %s",
                        keyClass.getName(), _quotedString(keyValue), msg),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======
        if (desc == null) {
            return "[N/A]";
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======

    // @since 2.7
    protected String _quotedString(String desc) {
        if (desc == null) {
            return "[N/A]";
        }
        // !!! should we quote it? (in case there are control chars, linefeeds)
        if (desc.length() > MAX_ERROR_STR_LEN) {
            return String.format("\"%s]...[%s\"",
                    desc.substring(0, MAX_ERROR_STR_LEN),
                    desc.substring(desc.length() - MAX_ERROR_STR_LEN));
        }
        return "\"" + desc + "\"";
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======

    // since 2.7
    // Default is "USE_DEFAULTS, USE_DEFAULTS"
    protected final static JsonInclude.Value DEFAULT_INCLUSION = JsonInclude.Value.empty();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    /**
     * Set of {@link SerializationFeature}s enabled.
=======
    /*
    /**********************************************************
    /* Configured helper objects
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    
=======

    /*
    /**********************************************************
    /* Serialization features 
    /**********************************************************
     */

    /**
     * Set of {@link SerializationFeature}s enabled.
     */
    protected final int _serFeatures;

    /*
    /**********************************************************
    /* Generator features: generic, format-specific
    /**********************************************************
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE

    /**
     * States of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable.
     *
     * @since 2.7
     */
    protected final int _formatWriteFeatures;

    /**
     * Bitflag of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable
     *
     * @since 2.7
     */
    protected final int _formatWriteFeaturesToChange;
=======

    /**
     * States of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable.
     *
     * @since 2.7
     */
    protected final int _formatWriteFeatures;

    /**
     * Bitflag of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable
     *
     * @since 2.7
     */
    protected final int _formatWriteFeaturesToChange;
    
    /*
    /**********************************************************
    /* Other configuration
    /**********************************************************
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = 0;
        _formatWriteFeaturesToChange = 0;
        _serializationInclusion = DEFAULT_INCLUSION;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
            int generatorFeatures, int generatorFeatureMask)
=======
            int generatorFeatures, int generatorFeatureMask,
            int formatFeatures, int formatFeaturesMask)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = formatFeatures;
        _formatWriteFeaturesToChange = formatFeaturesMask;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)
=======
    private SerializationConfig(SerializationConfig src, JsonInclude.Value incl)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    _generatorFeatures, _generatorFeaturesToChange);
=======
                    _generatorFeatures, _generatorFeaturesToChange,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                        _generatorFeatures, _generatorFeaturesToChange);
=======
                        _generatorFeatures, _generatorFeaturesToChange,
                        _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    /* Factory methods for JsonGenerator.Feature
=======
    /* Factory methods for JsonGenerator.Feature (2.5)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
    }

    /*
    /**********************************************************
    /* Factory methods for FormatFeature (2.7)
    /**********************************************************
     */
    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified feature enabled.
     *
     * @since 2.7
     */
    public SerializationConfig with(FormatFeature feature)
    {
        int newSet = _formatWriteFeatures | feature.getMask();
        int newMask = _formatWriteFeaturesToChange | feature.getMask();
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
=======
                    newSet, newMask,
                    _formatWriteFeatures, _formatWriteFeaturesToChange);
    }

    /*
    /**********************************************************
    /* Factory methods for FormatFeature (2.7)
    /**********************************************************
     */
    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified feature enabled.
     *
     * @since 2.7
     */
    public SerializationConfig with(FormatFeature feature)
    {
        int newSet = _formatWriteFeatures | feature.getMask();
        int newMask = _formatWriteFeaturesToChange | feature.getMask();
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features enabled.
     *
     * @since 2.7
     */
    public SerializationConfig withFeatures(FormatFeature... features)
    {
        int newSet = _formatWriteFeatures;
        int newMask = _formatWriteFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet |= mask;
            newMask |= mask;
        }
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features enabled.
     *
     * @since 2.7
     */
    public SerializationConfig withFeatures(FormatFeature... features)
    {
        int newSet = _formatWriteFeatures;
        int newMask = _formatWriteFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet |= mask;
            newMask |= mask;
        }
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified feature disabled.
     *
     * @since 2.7
     */
    public SerializationConfig without(FormatFeature feature)
    {
        int newSet = _formatWriteFeatures & ~feature.getMask();
        int newMask = _formatWriteFeaturesToChange | feature.getMask();
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features disabled.
     *
     * @since 2.7
     */
    public SerializationConfig withoutFeatures(FormatFeature... features)
    {
        int newSet = _formatWriteFeatures;
        int newMask = _formatWriteFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet &= ~mask;
            newMask |= mask;
        }
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
                    newSet, newMask);
    }
    
=======
    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified feature disabled.
     *
     * @since 2.7
     */
    public SerializationConfig without(FormatFeature feature)
    {
        int newSet = _formatWriteFeatures & ~feature.getMask();
        int newMask = _formatWriteFeaturesToChange | feature.getMask();
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features disabled.
     *
     * @since 2.7
     */
    public SerializationConfig withoutFeatures(FormatFeature... features)
    {
        int newSet = _formatWriteFeatures;
        int newMask = _formatWriteFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet &= ~mask;
            newMask |= mask;
        }
        return ((_formatWriteFeatures == newSet) && (_formatWriteFeaturesToChange == newMask)) ? this :
            new SerializationConfig(this,  _mapperFeatures, _serFeatures,
                    _generatorFeatures, _generatorFeaturesToChange,
                    newSet, newMask);
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7 use {@link #withPropertyInclusion} instead
     */
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
        return (_serializationInclusion == incl) ? this:  new SerializationConfig(this, incl);
=======
        return withPropertyInclusion(DEFAULT_INCLUSION.withValueInclusion(incl));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    public SerializationConfig withPropertyInclusion(JsonInclude.Value incl) {
        if (_serializationInclusion.equals(incl)) {
            return this;
        }
        return new SerializationConfig(this, incl);
    }
    
    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
        if ((_generatorFeaturesToChange != 0) || useBigDec) {
            int orig = g.getFeatureMask();
            int newFlags = (orig & ~_generatorFeaturesToChange) | _generatorFeatures;
=======

        int mask = _generatorFeaturesToChange;
        if ((mask != 0) || useBigDec) {
            int newFlags = _generatorFeatures;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
                newFlags |= JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();
            }
            if (orig != newFlags) {
                g.setFeatureMask(newFlags);
=======
                int f = JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();
                newFlags |= f;
                mask |= f;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
            g.overrideStdFeatures(newFlags, mask);
        }
        if (_formatWriteFeaturesToChange != 0) {
            g.overrideFormatFeatures(_formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    /* MapperConfig implementation/overrides
=======
    /* MapperConfig implementation/overrides: introspection
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    public boolean useRootWrapping()
    {
        if (_rootName != null) { // empty String disables wrapping; non-empty enables
            return !_rootName.isEmpty();
        }
        return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);
    }

    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
    /* Configuration: default settings with per-type overrides
    /**********************************************************
     */
    
    /**
     * @deprecated Since 2.7 use {@link #getDefaultPropertyInclusion} instead
     */
    @Deprecated
    public JsonInclude.Include getSerializationInclusion()
    {
        JsonInclude.Include incl = _serializationInclusion.getValueInclusion();
        return (incl == JsonInclude.Include.USE_DEFAULTS) ? JsonInclude.Include.ALWAYS : incl;
    }

    @Override
    public JsonInclude.Value getDefaultPropertyInclusion() {
        return _serializationInclusion;
    }

    @Override
    public JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {
        // !!! TODO: per-type defaults
        return _serializationInclusion;
    }

    @Override
    public JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {
        // !!! TODO: per-type defaults
        return EMPTY_FORMAT;
    }
    
    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
    @Override
    public boolean useRootWrapping()
    {
        if (_rootName != null) { // empty String disables wrapping; non-empty enables
            return !_rootName.isEmpty();
        }
        return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    public JsonInclude.Include getSerializationInclusion()
    {
        if (_serializationInclusion != null) {
            return _serializationInclusion;
        }
        return JsonInclude.Include.ALWAYS;
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);
=======
    // 19-Oct-2015, tatu: Not sure if this is really safe to do; let's at least allow
    //   some amount of introspection
    private final static JavaType JSON_NODE_TYPE =
            SimpleType.constructUnsafe(JsonNode.class);
//            TypeFactory.defaultInstance().constructType(JsonNode.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * Method for setting specific {@link SerializerProvider} to use
     * for handling caching of {@link JsonSerializer} instances.
=======
     * Method for setting "blueprint" {@link SerializerProvider} instance
     * to use as the base for actual provider instances to use for handling
     * caching of {@link JsonSerializer} instances.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
    /**
     * Accessor for the "blueprint" (or, factory) instance, from which instances
     * are created by calling {@link DefaultSerializerProvider#createInstance}.
     * Note that returned instance can not be directly used as it is not properly
     * configured: to get a properly configured instance to call, use
     * {@link #getSerializerProviderInstance()} instead.
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
    /**
     * Accessor for constructing and returning a {@link SerializerProvider}
     * instance that may be used for accessing serializers. This is same as
     * calling {@link #getSerializerProvider}, and calling <code>createInstance</code>
     * on it.
     *
     * @since 2.7
     */
    public SerializerProvider getSerializerProviderInstance() {
        return _serializerProvider(_serializationConfig);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    
=======

    /**
     * Convenience method, equivalent to calling:
     *<pre>
     *  setPropertyInclusion(JsonInclude.Value.construct(incl, Include.ALWAYS));
     *</pre>
     */
    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {
        setPropertyInclusion(JsonInclude.Value.construct(incl, JsonInclude.Include.USE_DEFAULTS));
        return this;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {
        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);
=======
    public ObjectMapper setPropertyInclusion(JsonInclude.Value incl) {
        _serializationConfig = _serializationConfig.withPropertyInclusion(incl);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
     * Convenience method, equivalent in function to:
     *<pre>
     *   readerFor(valueType).readValues(p);
     *</pre>
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * In either case {@link JsonParser} must point to the first token of
=======
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather
     * to the token following it.
=======
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType)
=======
    public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        return readValues(jp, (JavaType) valueType);
=======
        return readValues(p, (JavaType) valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.
=======
     * Convenience method, equivalent in function to:
     *<pre>
     *   readerFor(valueType).readValues(p);
     *</pre>
     *<p>
     * Type-safe overload of {@link #readValues(JsonParser, ResolvedType)}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)
            throws IOException, JsonProcessingException
=======
    public <T> MappingIterator<T> readValues(JsonParser p, JavaType valueType)
        throws IOException, JsonProcessingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        DeserializationContext ctxt = createDeserializationContext(jp, config);
=======
        DeserializationContext ctxt = createDeserializationContext(p, config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        return new MappingIterator<T>(valueType, jp, ctxt, deser,
=======
        return new MappingIterator<T>(valueType, p, ctxt, deser,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.
=======
     * Convenience method, equivalent in function to:
     *<pre>
     *   readerFor(valueType).readValues(p);
     *</pre>
     *<p>
     * Type-safe overload of {@link #readValues(JsonParser, ResolvedType)}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType)
=======
    public <T> MappingIterator<T> readValues(JsonParser p, Class<T> valueType)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        return readValues(jp, _typeFactory.constructType(valueType));
=======
        return readValues(p, _typeFactory.constructType(valueType));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)
=======
    public <T> MappingIterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        return readValues(jp, _typeFactory.constructType(valueTypeRef));
=======
        return readValues(p, _typeFactory.constructType(valueTypeRef));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        // also, as per [Issue-11], consider case for simple cast
=======
        // also, as per [databind#11], consider case for simple cast
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
     *    (which under the hood calls {@link #acceptJsonFormatVisitor(JavaType, JsonFormatVisitorWrapper)})
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7, not used internally any more
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        throws IOException, JsonGenerationException, JsonMappingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
            /* Need to close both generator and value, as long as they haven't yet
             * been closed
             */
=======
            // Need to close both generator and value, as long as they haven't yet been closed
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
        throws IOException, JsonGenerationException, JsonMappingException
=======
        throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
                /* [JACKSON-546] Throw mapping exception, since it's failure to map,
                 *   not an actual parsing problem
                 */
=======
                // Throw mapping exception, since it's failure to map,
                //   not an actual parsing problem
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
            throw new JsonMappingException("Can not find a deserializer for type "+valueType);
=======
            throw JsonMappingException.from(ctxt,
                    "Can not find a deserializer for type "+valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.util.EmptyIterator;
=======
import com.fasterxml.jackson.databind.util.ClassUtil;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java;<<<<<<< MINE
     * as <code>START-ARRAY></code>/<code>END-ARRAY</code> and
     * <code>START-OBJECT></code>/<code>END-OBJECT</code> pairs
=======
     * as <code>START-ARRAY</code>/<code>END-ARRAY</code> and
     * <code>START-OBJECT</code>/<code>END-OBJECT</code> pairs
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java;<<<<<<< MINE
     *   will be removed from 2.7
=======
     *   will be removed from 2.8
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
=======
import java.io.IOException;
import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

import com.fasterxml.jackson.annotation.JsonFormat;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonProcessingException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.ser.ContextualSerializer;
import com.fasterxml.jackson.databind.ser.FilterProvider;
import com.fasterxml.jackson.databind.ser.ResolvableSerializer;
import com.fasterxml.jackson.databind.ser.SerializerCache;
import com.fasterxml.jackson.databind.ser.SerializerFactory;
=======
import com.fasterxml.jackson.databind.ser.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
import java.io.IOException;
import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
     * @since 2.5.0
=======
     * @since 2.5
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
=======
    @Override
    public final boolean canOverrideAccessModifiers() {
        return _config.canOverrideAccessModifiers();
    }

    @Override
    public final boolean isEnabled(MapperFeature feature) {
        return _config.isEnabled(feature);
    }

    @Override
    public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {
        return _config.getDefaultPropertyFormat(baseType);
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
     * Note that starting with version 1.5, serializers should also be type-aware
     * if they handle polymorphic types. That means that it may be necessary
     * to also use a {@link TypeSerializer} based on declared (static) type
     * being serializer (whereas actual data may be serialized using dynamic
     * type)
=======
     * Note that serializers produced should NOT handle polymorphic serialization
     * aspects; separate {@link TypeSerializer} is to be constructed by caller
     * if and as necessary.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
     * Method called to get a Typeserialize to use for accessing Type Information for a given Java class
=======
     * Method called to get the {@link TypeSerializer} to use for including Type Id necessary
     * for serializing for the given Java class.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
=======
     *
     * @since 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
    public final void defaultSerializeValue(Object value, JsonGenerator jgen) throws IOException
=======
    public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                jgen.writeNull();
=======
                gen.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                _nullValueSerializer.serialize(null, jgen, this);
=======
                _nullValueSerializer.serialize(null, gen, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            findTypedValueSerializer(cls, true, null).serialize(value, jgen, this);
=======
            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
    public final void defaultSerializeField(String fieldName, Object value, JsonGenerator jgen)
=======
    public final void defaultSerializeField(String fieldName, Object value, JsonGenerator gen)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        jgen.writeFieldName(fieldName);
=======
        gen.writeFieldName(fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                jgen.writeNull();
=======
                gen.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                _nullValueSerializer.serialize(null, jgen, this);
=======
                _nullValueSerializer.serialize(null, gen, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            findTypedValueSerializer(cls, true, null).serialize(value, jgen, this);
=======
            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        return new JsonMappingException(message);
=======
        return JsonMappingException.from(this, message);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
    protected void _reportIncompatibleRootType(Object value, JavaType rootType)
        throws IOException, JsonProcessingException
=======
    protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        /* 07-Jan-2010, tatu: As per [JACKSON-456] better handle distinction between wrapper types,
         *    primitives
         */
=======
        // One special case: allow primitive/wrapper type coercion
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        throw new JsonMappingException("Incompatible types: declared root type ("+rootType+") vs "
=======
        throw JsonMappingException.from(this,
                "Incompatible types: declared root type ("+rootType+") vs "
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
        JavaType type = _config.constructType(rawType);
=======
        JavaType fullType = _config.constructType(rawType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            ser = _createUntypedSerializer(type);
=======
            ser = _createUntypedSerializer(fullType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(iae.getMessage(), null, iae);
=======
            throw JsonMappingException.from(this, iae.getMessage(), iae);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);
=======
            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key
            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
            throw new JsonMappingException(iae.getMessage(), null, iae);
=======
            throw JsonMappingException.from(this, iae.getMessage(), iae);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
=======
            // 21-Dec-2015, tatu: Should we also cache using raw key?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
=======
     *
     * @deprecated Since 2.7, use {@link #resolveType(java.lang.reflect.Type)} instead.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
   
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
    public abstract JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue);

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
     * @since 2.5
=======
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
    public abstract JsonInclude.Include findSerializationInclusionForContent(JsonInclude.Include defValue);
    
=======
    public abstract JsonInclude.Value findPropertyInclusion(JsonInclude.Value defValue);

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
=======
    /**
     * Accessor for possible description for the bean type, used for constructing
     * documentation.
     *
     * @since 2.7
     */
    public String findClassDescription() { return null; }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
import java.util.List;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.type.TypeBindings;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    
=======

    /**
     * Copy-constructor used when refining/upgrading type instances.
     *
     * @since 2.7
     */
    protected JavaType(JavaType base) 
    {
        _class = base._class;
        _hash = base._hash;
        _valueHandler = base._valueHandler;
        _typeHandler = base._typeHandler;
        _asStatic = base._asStatic;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * "Copy method" that will construct a new instance that is identical to
     * this instance, except that its content type will have specified
     * type handler assigned.
=======
     * Mutant factory method that will construct a new instance that is identical to
     * this instance, except that it will have specified content type (element type
     * for arrays, value type for Maps and so forth) handler assigned.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * @return Newly created type instance
=======
     * @return Newly created type instance, with given 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * "Copy method" that will construct a new instance that is identical to
=======
     * Mutant factory method that will construct a new instance that is identical to
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * "Copy method" that will construct a new instance that is identical to
=======
     * Mutant factory method that will construct a new instance that is identical to
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
     * Mutant factory method that may be called on structured types
     * that have a so-called content type (element of arrays, value type
     * of Maps, referenced type of referential types),
     * and will construct a new instance that is identical to
     * this instance, except that it has specified content type, instead of current
     * one. If content type is already set to given type, <code>this</code> is returned.
     * If type does not have a content type (which is the case with
     * <code>SimpleType</code>), {@link IllegalArgumentException}
     * will be thrown.
     * 
     * @return Newly created type instance
     *
     * @since 2.7
     */
    public abstract JavaType withContentType(JavaType contentType);

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * Method that can be called to do a "narrowing" conversions; that is,
     * to return a type with a raw class that is assignable to the raw
     * class of this type. If this is not possible, an
     * {@link IllegalArgumentException} is thrown.
     * If class is same as the current raw class, instance itself is
     * returned.
=======
     * Mutant factory method that will try to create and return a sub-type instance
     * for known parameterized types; for other types will return `null` to indicate
     * that no just refinement makes necessary sense, without trying to detect
     * special status through implemented interfaces.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    public JavaType narrowBy(Class<?> subclass)
    {
        // First: if same raw class, just return this instance
        if (subclass == _class) { return this; }
        // Otherwise, ensure compatibility
        _assertSubclass(subclass, _class);
        
        JavaType result = _narrow(subclass);
        
        // TODO: these checks should NOT actually be needed; above should suffice:
        if (_valueHandler != result.<Object>getValueHandler()) {
            result = result.withValueHandler(_valueHandler);
        }
        if (_typeHandler != result.<Object>getTypeHandler()) {
            result = result.withTypeHandler(_typeHandler);
        }
        return result;
    }

=======
    public abstract JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces);
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * More efficient version of {@link #narrowBy}, called by
     * internal framework in cases where compatibility checks
     * are to be skipped.
=======
     * Legacy method used for forcing sub-typing of this type into
     * type specified by specific type erasure.
     * Deprecated as of 2.7 as such specializations really ought to
     * go through {@link TypeFactory}, not directly via {@link JavaType}.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    /**
     * Method that can be called to do a "widening" conversions; that is,
     * to return a type with a raw class that could be assigned from this
     * type.
     * If such conversion is not possible, an
     * {@link IllegalArgumentException} is thrown.
     * If class is same as the current raw class, instance itself is
     * returned.
     */
    public JavaType widenBy(Class<?> superclass) {
        // First: if same raw class, just return this instance
        if (superclass == _class) { return this; }
        // Otherwise, ensure compatibility
        _assertSubclass(_class, superclass);
        return _widen(superclass);
    }

=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    /**
     *<p>
     * Default implementation is just to call {@link #_narrow}, since
     * underlying type construction is usually identical
     */
    protected JavaType _widen(Class<?> superclass) { return _narrow(superclass); }

    public abstract JavaType narrowContentsBy(Class<?> contentClass);

    public abstract JavaType widenContentsBy(Class<?> contentClass);
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    public int containedTypeCount() { return 0; }
=======
    public abstract int containedTypeCount();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    public JavaType containedType(int index) { return null; }
=======
    public abstract JavaType containedType(int index);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    public String containedTypeName(int index) { return null; }
=======
    public abstract String containedTypeName(int index);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    public abstract Class<?> getParameterSource();
    
=======
    public Class<?> getParameterSource() {
        return null;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
    /**
     * @since 2.7
     */
    public abstract TypeBindings getBindings();

    /**
     * Method that may be called to find representation of given type
     * within type hierarchy of this type: either this type (if this
     * type has given erased type), one of its supertypes that has the
     * erased types, or null if target is neither this type or any of its
     * supertypes.
     *
     * @since 2.7
     */
    public abstract JavaType findSuperType(Class<?> erasedTarget);

    /**
     * Accessor for finding fully resolved parent class of this type,
     * if it has one; null if not.
     *
     * @since 2.7
     */
    public abstract JavaType getSuperClass();

    /**
     * Accessor for finding fully resolved interfaces this type implements,
     * if any; empty array if none.
     *
     * @since 2.7
     */
    public abstract List<JavaType> getInterfaces();

    /**
     * Method that may be used to find paramaterization this type has for
     * given type-erased generic target type.
     *
     * @since 2.7
     */
    public abstract JavaType[] findTypeParameters(Class<?> expType);

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    public Object getContentValueHandler() { return null; }

    /**
     * @since 2.7
     */
    public Object getContentTypeHandler() { return null; }    

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    
    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    protected void _assertSubclass(Class<?> subclass, Class<?> superClass) {
        if (!_class.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException("Class "+subclass.getName()+" is not assignable to "+_class.getName());
        }
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    /**
     * Set of {@link DeserializationFeature}s enabled.
=======
    /*
    /**********************************************************
    /* Configured helper objects
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    protected final int _deserFeatures;

=======
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Deserialization features 
    /**********************************************************
     */

    /**
     * Set of {@link DeserializationFeature}s enabled.
     */
    protected final int _deserFeatures;
    
    /*
    /**********************************************************
    /* Parser features: generic, format-specific
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
    /**
     * States of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable.
     *
     * @since 2.7
     */
    protected final int _formatReadFeatures;

    /**
     * Bitflag of {@link com.fasterxml.jackson.core.FormatFeature}s to enable/disable
     *
     * @since 2.7
     */
    protected final int _formatReadFeaturesToChange;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = 0;
        _formatReadFeaturesToChange = 0;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
            int parserFeatures, int parserFeatureMask)
=======
            int parserFeatures, int parserFeatureMask,
            int formatFeatures, int formatFeatureMask)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = formatFeatures;
        _formatReadFeaturesToChange = formatFeatureMask;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    /**
     * @since 2.3
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    /**
     * @since 2.1
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    _parserFeatures, _parserFeaturesToChange);
=======
                    _parserFeatures, _parserFeaturesToChange,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
                    newSet, newMask);
=======
                    newSet, newMask,
                    _formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
                    newSet, newMask,
                    _formatReadFeatures, _formatReadFeaturesToChange);
    }

    /*
    /**********************************************************
    /* Life-cycle, JsonParser.FormatFeature-based factory methods
    /**********************************************************
     */

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features enabled.
     *
     * @since 2.7
     */
    public DeserializationConfig with(FormatFeature feature)
    {
        int newSet = _formatReadFeatures | feature.getMask();
        int newMask = _formatReadFeaturesToChange | feature.getMask();
        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :
            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,
                    _parserFeatures, _parserFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features enabled.
     *
     * @since 2.7
     */
    public DeserializationConfig withFeatures(FormatFeature... features)
    {
        int newSet = _formatReadFeatures;
        int newMask = _formatReadFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet |= mask;
            newMask |= mask;
        }
        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :
            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,
                    _parserFeatures, _parserFeaturesToChange,
                    newSet, newMask);
    }
    
    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified feature disabled.
     *
     * @since 2.7
     */
    public DeserializationConfig without(FormatFeature feature)
    {
        int newSet = _formatReadFeatures & ~feature.getMask();
        int newMask = _formatReadFeaturesToChange | feature.getMask();
        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :
            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,
                    _parserFeatures, _parserFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features disabled.
     *
     * @since 2.7
     */
    public DeserializationConfig withoutFeatures(FormatFeature... features)
    {
        int newSet = _formatReadFeatures;
        int newMask = _formatReadFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet &= ~mask;
            newMask |= mask;
        }
        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :
            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,
                    _parserFeatures, _parserFeaturesToChange,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
            int orig = p.getFeatureMask();
            int newFlags = (orig & ~_parserFeaturesToChange) | _parserFeatures;
            if (orig != newFlags) {
                p.setFeatureMask(newFlags);
            }
=======
            p.overrideStdFeatures(_parserFeatures, _parserFeaturesToChange);
        }
        if (_formatReadFeaturesToChange != 0) {
            p.overrideFormatFeatures(_formatReadFeatures, _formatReadFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    /* MapperConfig implementation
=======
    /* MapperConfig implementation/overrides: introspection
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    @Override
    public boolean useRootWrapping()
    {
        if (_rootName != null) { // empty String disables wrapping; non-empty enables
            return !_rootName.isEmpty();
        }
        return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Configuration: default settings with per-type overrides
    /**********************************************************
     */
    
    // property inclusion not used on deserialization yet (2.7): may be added in future
    @Override
    public JsonInclude.Value getDefaultPropertyInclusion() {
        return EMPTY_INCLUDE;
    }

    @Override
    public JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {
        return EMPTY_INCLUDE;
    }

    @Override
    public JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {
        // !!! TODO: per-type defaults
        return EMPTY_FORMAT;
    }

    /*
    /**********************************************************
    /* MapperConfig implementation/overrides: other
    /**********************************************************
     */

    @Override
    public boolean useRootWrapping()
    {
        if (_rootName != null) { // empty String disables wrapping; non-empty enables
            return !_rootName.isEmpty();
        }
        return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
     * may be called to enable access to otherwise unaccessible
     * objects.
=======
     * may be called to enable access to otherwise unaccessible objects.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
     * Note that this setting usually has significant performance implications,
=======
     * Note that this setting may have significant performance implications,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
     * Especially on standard JavaSE platforms difference is significant.
=======
     * Also note that performance effects vary between Java platforms
     * (JavaSE vs Android, for example), as well as JDK versions: older
     * versions seemed to have more significant performance difference.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
=======
     * Feature that determines that forces call to
     * {@link java.lang.reflect.AccessibleObject#setAccessible} even for
     * <code>public</code> accessors -- that is, even if no such call is
     * needed from functionality perspective -- if call is allowed
     * (that is, {@link #CAN_OVERRIDE_ACCESS_MODIFIERS} is set to true).
     * The main reason to enable this feature is possible performance
     * improvement as JDK does not have to perform access checks; these
     * checks are otherwise made for all accessors, including public ones,
     * and may result in slower Reflection calls. Exact impact (if any)
     * depends on Java platform (Java SE, Android) as well as JDK version.
     *<p>
     * Feature is enabled by default, for legacy reasons (it was the behavior
     * until 2.6)
     *
     * @since 2.7
     */
    OVERRIDE_PUBLIC_ACCESS_MODIFIERS(true),

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
=======
    /**
     * Feature that when enabled will allow explicitly named properties (i.e., fields or methods
     * annotated with {@link com.fasterxml.jackson.annotation.JsonProperty}("explicitName")) to
     * be re-named by a {@link PropertyNamingStrategy}, if one is configured.
     * <p>
     * Feature is disabled by default.
     *
     * @since 2.7
     */
    ALLOW_EXPLICIT_PROPERTY_RENAMING(false),

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
 * Default implementation returns suggested ("default") name unmodified.
=======
 * Default (empty) implementation returns suggested ("default") name unmodified.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
public abstract class PropertyNamingStrategy
=======
public class PropertyNamingStrategy // NOTE: was abstract until 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
     * See {@link LowerCaseWithUnderscoresStrategy} for details.
=======
     * Naming convention used in languages like C, where words are in lower-case
     * letters, separated by underscores.
     * See {@link SnakeCaseStrategy} for details.
     *
     * @since 2.7 (was formerly called {@link #CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES})
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
    public static final PropertyNamingStrategy CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES =
        new LowerCaseWithUnderscoresStrategy();
=======
    public static final PropertyNamingStrategy SNAKE_CASE = new SnakeCaseStrategy();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
=======
     * Naming convention used in languages like Pascal, where words are capitalized
     * and no separator is used between words.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
     * 
     * @since 2.1
=======
     *
     * @since 2.7 (was formerly called {@link #PASCAL_CASE_TO_CAMEL_CASE})
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
    public static final PropertyNamingStrategy PASCAL_CASE_TO_CAMEL_CASE =
        new PascalCaseStrategy();
=======
    public static final PropertyNamingStrategy UPPER_CAMEL_CASE = new UpperCamelCaseStrategy();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
=======
     * Naming convention used in Java, where words other than first are capitalized
     * and no separator is used between words. Since this is the native Java naming convention,
     * naming strategy will not do any transformation between names in data (JSON) and
     * POJOS.
     *
     * @since 2.7 (was formerly called {@link #PASCAL_CASE_TO_CAMEL_CASE})
     */
    public static final PropertyNamingStrategy LOWER_CAMEL_CASE = new PropertyNamingStrategy();
    
    /**
     * Naming convention in which all words of the logical name are in lower case, and
     * no separator is used between words.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
    
=======

    /**
     * Naming convention used in languages like Lisp, where words are in lower-case
     * letters, separated by hyphens.
     * See {@link KebabCaseStrategy} for details.
     * 
     * @since 2.7
     */
    public static final PropertyNamingStrategy KEBAB_CASE = new KebabCaseStrategy();

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
=======
     *
     * @since 2.7 (was previously called }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
    public static class LowerCaseWithUnderscoresStrategy extends PropertyNamingStrategyBase
=======
    public static class SnakeCaseStrategy extends PropertyNamingStrategyBase
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
     * @since 2.1
=======
     * @since 2.7 (was formerly called {@link PascalCaseStrategy})
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
    public static class PascalCaseStrategy extends PropertyNamingStrategyBase
=======
    public static class UpperCamelCaseStrategy extends PropertyNamingStrategyBase
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
=======

    /**
     * Naming strategy similar to {@link SnakeCaseStrategy}, but instead of underscores
     * as separators, uses hyphens. Naming convention traditionally used for languages
     * like Lisp.
     *
     * @since 2.7
     */
    public static class KebabCaseStrategy extends PropertyNamingStrategyBase
    {
        @Override
        public String translate(String input)
        {
            if (input == null) return input; // garbage in, garbage out
            int length = input.length();
            if (length == 0) {
                return input;
            }

            StringBuilder result = new StringBuilder(length + (length >> 1));

            int upperCount = 0;

            for (int i = 0; i < length; ++i) {
                char ch = input.charAt(i);
                char lc = Character.toLowerCase(ch);
                
                if (lc == ch) { // lower-case letter means we can get new word
                    // but need to check for multi-letter upper-case (acronym), where assumption
                    // is that the last upper-case char is start of a new word
                    if (upperCount > 1) {
                        // so insert hyphen before the last character now
                        result.insert(result.length() - 1, '-');
                    }
                    upperCount = 0;
                } else {
                    // Otherwise starts new word, unless beginning of string
                    if ((upperCount == 0) && (i > 0)) {
                        result.append('-');
                    }
                    ++upperCount;
                }
                result.append(lc);
            }
            return result.toString();
        }
    }
    
    /*
    /**********************************************************
    /* Deprecated variants, aliases
    /**********************************************************
     */
    
    /**
     * @deprecated Since 2.7 use {@link #SNAKE_CASE} instead;
     */
    @Deprecated // since 2.7
    public static final PropertyNamingStrategy CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES = SNAKE_CASE;

    /**
     * @deprecated Since 2.7 use {@link #UPPER_CAMEL_CASE} instead;
     */
    @Deprecated // since 2.7
    public static final PropertyNamingStrategy PASCAL_CASE_TO_CAMEL_CASE = UPPER_CAMEL_CASE;

    /**
     * @deprecated In 2.7 use {@link SnakeCaseStrategy} instead
     */
    @Deprecated
    public static class LowerCaseWithUnderscoresStrategy extends SnakeCaseStrategy {}

    /**
     * @deprecated In 2.7 use {@link SnakeCaseStrategy} instead
     */
    @Deprecated
    public static class PascalCaseStrategy extends UpperCamelCaseStrategy {}
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java;<<<<<<< MINE
    public <C extends Collection<?>> SequenceWriter writeAll(C container) throws IOException
    {
=======
    // NOTE: redundant wrt variant that takes Iterable, but can not remove or even
    // deprecate due to backwards-compatibility needs
    public <C extends Collection<?>> SequenceWriter writeAll(C container) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java;<<<<<<< MINE
=======
    /**
     * @since 2.7
     */
    public SequenceWriter writeAll(Iterable<?> iterable) throws IOException
    {
        for (Object value : iterable) {
            write(value);
        }
        return this;
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
=======
import java.io.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;
=======
import java.util.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
import com.fasterxml.jackson.core.Base64Variant;
import com.fasterxml.jackson.core.FormatSchema;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonLocation;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.core.Versioned;
=======
import com.fasterxml.jackson.core.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
    /* Life-cycle, fluent factory methods for FormatFeature (2.7)
    /**********************************************************
     */

    /**
     * Method for constructing a new reader instance that is configured
     * with specified feature enabled.
     *
     * @since 2.7
     */
    public ObjectReader with(FormatFeature feature) {
        return _with(_config.with(feature));
    }

    /**
     * Method for constructing a new reader instance that is configured
     * with specified features enabled.
     *
     * @since 2.7
     */
    public ObjectReader withFeatures(FormatFeature... features) {
        return _with(_config.withFeatures(features));
    }    

    /**
     * Method for constructing a new reader instance that is configured
     * with specified feature disabled.
     *
     * @since 2.7
     */
    public ObjectReader without(FormatFeature feature) {
        return _with(_config.without(feature)); 
    }

    /**
     * Method for constructing a new reader instance that is configured
     * with specified features disabled.
     *
     * @since 2.7
     */
    public ObjectReader withoutFeatures(FormatFeature... features) {
        return _with(_config.withoutFeatures(features));
    }
    
    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
    /**
     * Mutant factory method that will construct a new instance that has
     * specified underlying {@link DeserializationConfig}.
     *<p>
     * NOTE: use of this method is not recommended, as there are many other
     * re-configuration methods available.
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public ObjectReader withAttributes(Map<Object,Object> attrs) {
=======
    public ObjectReader withAttributes(Map<?,?> attrs) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp)
        throws IOException, JsonProcessingException
=======
    public <T> T readValue(JsonParser p) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        return (T) _bind(jp, _valueToUpdate);
=======
        return (T) _bind(p, _valueToUpdate);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp, Class<T> valueType)
        throws IOException, JsonProcessingException
=======
    public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        return (T) forType(valueType).readValue(jp);
=======
        return (T) forType(valueType).readValue(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)
        throws IOException, JsonProcessingException
=======
    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        return (T) forType(valueTypeRef).readValue(jp);
=======
        return (T) forType(valueTypeRef).readValue(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {
        return (T) forType((JavaType)valueType).readValue(jp);
=======
    public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
        return (T) forType((JavaType)valueType).readValue(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {
        return (T) forType(valueType).readValue(jp);
=======
    public <T> T readValue(JsonParser p, JavaType valueType) throws IOException {
        return (T) forType(valueType).readValue(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
     *   withType(valueType).readValues(jp);
=======
     *   withType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
     * Method reads a sequence of Objects from parser stream.
     * Sequence can be either root-level "unwrapped" sequence (without surrounding
     * JSON array), or a sequence contained in a JSON Array.
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
     * the first element, OR not point to any token (in which case it is advanced
     * to the next token). This means, specifically, that for wrapped sequences,
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)
        throws IOException, JsonProcessingException {
        return forType(valueType).readValues(jp);
=======
    public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException {
        return forType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
     *   withType(valueTypeRef).readValues(jp);
=======
     *   withType(valueTypeRef).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
     * Method reads a sequence of Objects from parser stream.
     * Sequence can be either root-level "unwrapped" sequence (without surrounding
     * JSON array), or a sequence contained in a JSON Array.
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
     * the first element, OR not point to any token (in which case it is advanced
     * to the next token). This means, specifically, that for wrapped sequences,
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)
        throws IOException, JsonProcessingException {
        return forType(valueTypeRef).readValues(jp);
=======
    public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException {
        return forType(valueTypeRef).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
     *   withType(valueType).readValues(jp);
=======
     *   withType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
     * Method reads a sequence of Objects from parser stream.
     * Sequence can be either root-level "unwrapped" sequence (without surrounding
     * JSON array), or a sequence contained in a JSON Array.
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
     * the first element, OR not point to any token (in which case it is advanced
     * to the next token). This means, specifically, that for wrapped sequences,
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType)
        throws IOException, JsonProcessingException {
        return readValues(jp, (JavaType) valueType);
=======
    public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException {
        return readValues(p, (JavaType) valueType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
     *   withType(valueType).readValues(jp);
=======
     *   withType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
     * Method reads a sequence of Objects from parser stream.
     * Sequence can be either root-level "unwrapped" sequence (without surrounding
     * JSON array), or a sequence contained in a JSON Array.
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
     * the first element, OR not point to any token (in which case it is advanced
     * to the next token). This means, specifically, that for wrapped sequences,
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType)
        throws IOException, JsonProcessingException {
        return forType(valueType).readValues(jp);
=======
    public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException {
        return forType(valueType).readValues(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    public <T extends TreeNode> T readTree(JsonParser jp)
            throws IOException, JsonProcessingException
    {
        return (T) _bindAsTree(jp);
=======
    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {
        return (T) _bindAsTree(p);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        throw new JsonParseException("Can not detect format from input, does not look like any of detectable formats "
                +detector.toString(),
                JsonLocation.NA);
=======
        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:
        throw new JsonParseException(null, "Can not detect format from input, does not look like any of detectable formats "
                +detector.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
        throw new JsonParseException("Can not use source of type "
                +src.getClass().getName()+" with format auto-detection: must be byte- not char-based",
                JsonLocation.NA);
=======
        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:
        throw new JsonParseException(null, "Can not use source of type "
                +src.getClass().getName()+" with format auto-detection: must be byte- not char-based");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
            throw new JsonMappingException("No value type configured for ObjectReader");
=======
            throw JsonMappingException.from(ctxt, "No value type configured for ObjectReader");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
            throw new JsonMappingException("Can not find a deserializer for type "+t);
=======
            throw JsonMappingException.from(ctxt, "Can not find a deserializer for type "+t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
                throw new JsonMappingException("Can not find a deserializer for type "+JSON_NODE_TYPE);
=======
                throw JsonMappingException.from(ctxt,
                        "Can not find a deserializer for type "+JSON_NODE_TYPE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======
import java.io.Closeable;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.util.ClassUtil;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
 * content.
=======
 * content, distinct from low-level I/O problems (signaled using
 * simple {@link java.io.IOException}s) or data encoding/decoding
 * problems (signaled with {@link com.fasterxml.jackson.core.JsonParseException},
 * {@link com.fasterxml.jackson.core.JsonGenerationException}).
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
            Package pkg = cls.getPackage();
            if (pkg != null) {
                sb.append(pkg.getName());
=======
            String pkgName = ClassUtil.getPackageName(cls);
            if (pkgName != null) {
                sb.append(pkgName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======
    /**
     * Underlying processor ({@link JsonParser} or {@link JsonGenerator}),
     * if known.
     *
     * @since 2.7
     */
    protected Closeable _processor;
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser} instead
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======

    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser} instead
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======

    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser} instead
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======

    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser} instead
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
    public static JsonMappingException from(JsonParser jp, String msg) {
        return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation()));
=======
    /**
     * @since 2.7
     */
    public JsonMappingException(Closeable processor, String msg) {
        super(msg);
        _processor = processor;
        if (processor instanceof JsonParser) {
            // 17-Aug-2015, tatu: Use of token location makes some sense from databinding,
            //   since actual parsing (current) location is typically only needed for low-level
            //   parsing exceptions.
            _location = ((JsonParser) processor).getTokenLocation();
        }
    }

    /**
     * @since 2.7
     */
    public JsonMappingException(Closeable processor, String msg, Throwable problem) {
        super(msg, problem);
        _processor = processor;
        if (processor instanceof JsonParser) {
            _location = ((JsonParser) processor).getTokenLocation();
        }
    }

    /**
     * @since 2.7
     */
    public JsonMappingException(Closeable processor, String msg, JsonLocation loc) {
        super(msg, loc);
        _processor = processor;
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(JsonParser p, String msg) {
        return new JsonMappingException(p, msg);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
    public static JsonMappingException from(JsonParser jp, String msg, Throwable problem) {
        return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation()), problem);
=======
    /**
     * @since 2.7
     */
    public static JsonMappingException from(JsonParser p, String msg, Throwable problem) {
        return new JsonMappingException(p, msg, problem);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(JsonGenerator g, String msg) {
        return new JsonMappingException(g, msg, (Throwable) null);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(JsonGenerator g, String msg, Throwable problem) {
        return new JsonMappingException(g, msg, problem);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(DeserializationContext ctxt, String msg) {
        return new JsonMappingException(ctxt.getParser(), msg);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(DeserializationContext ctxt, String msg, Throwable t) {
        return new JsonMappingException(ctxt.getParser(), msg, t);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(SerializerProvider ctxt, String msg) {
        /* 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as
         *   SerializerProvider instance does not currently hold on to generator...
         */
        JsonGenerator g = null;
        return new JsonMappingException(g, msg);
    }

    /**
     * @since 2.7
     */
    public static JsonMappingException from(SerializerProvider ctxt, String msg, Throwable problem) {
        /* 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as
         *   SerializerProvider instance does not currently hold on to generator...
         */
        JsonGenerator g = null;
        return new JsonMappingException(g, msg, problem);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
        return new JsonMappingException("Unexpected IOException (of type "
                +src.getClass().getName()+"): "+src.getMessage(), (JsonLocation)null, src);
=======
        return new JsonMappingException(null,
                String.format("Unexpected IOException (of type %s): %s",
                        src.getClass().getName(), src.getMessage()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======
    @SuppressWarnings("resource")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
            /* Related to [JACKSON-62], let's use a more meaningful placeholder
             * if all we have is null
             */
=======
            // Let's use a more meaningful placeholder if all we have is null
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
            jme = new JsonMappingException(msg, null, src);
=======
            // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along
            Closeable proc = null;
            if (src instanceof JsonProcessingException) {
                Object proc0 = ((JsonProcessingException) src).getProcessor();
                if (proc0 instanceof Closeable) {
                    proc = (Closeable) proc0;
                }
            }
            jme = new JsonMappingException(proc, msg, src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
    // generated for Jackson 2.1.0
    private static final long serialVersionUID = -6744103724013275513L;
=======
    private static final long serialVersionUID = -1; // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
          setCodec(new ObjectMapper(this));
=======
            setCodec(new ObjectMapper(this));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
     * Sub-classes need to override this method (as of 1.8)
=======
     * Sub-classes need to override this method
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java;<<<<<<< MINE
     * Sub-classes need to override this method (as of 1.8)
=======
     * Sub-classes need to override this method
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.util.EmptyIterator;
=======
import com.fasterxml.jackson.databind.util.ClassUtil;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
        return EmptyIterator.instance();
=======
        return ClassUtil.emptyIterator();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
=======
     * Method that will produce developer-readable representation of the
     * node; which may <b>or may not</b> be as valid JSON.
     * If you want valid JSON output (or output formatted using one of
     * other Jackson supported data formats) make sure to use
     * {@link ObjectMapper} or {@link ObjectWriter} to serialize an
     * instance, for example:
     *<pre>
     *   String json = objectMapper.writeValueAsString(rootNode);
     *</pre>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
     * Note: marked as abstract to ensure all implementation
     * classes define it properly.
=======
     * Note: method defined as abstract to ensure all implementation
     * classes explicitly implement method, instead of relying
     * on {@link Object#toString()} definition.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TransientTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.introspect;

import java.beans.Transient;

import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.databind.*;

/**
 * Tests for both `transient` keyword and JDK 7
 * {@link java.beans.Transient} annotation.
 */
public class TransientTest extends BaseMapTest
{
    // for [databind#296]
    @JsonPropertyOrder({ "x" })
    static class ClassyTransient
    {
        public transient int value = 3;

        public int getValue() { return value; }

        public int getX() { return 42; }
    }

    // for [databind#857]
    static class BeanTransient {
        @Transient
        public int getX() { return 3; }

        public int getY() { return 4; }
    }

    /*
    /**********************************************************
    /* Unit tests
    /**********************************************************
     */

    private final ObjectMapper MAPPER = objectMapper();

    // for [databind#296]
    public void testTransientFieldHandling() throws Exception
    {
        // default handling: remove transient field but do not propagate
        assertEquals(aposToQuotes("{'x':42,'value':3}"),
                MAPPER.writeValueAsString(new ClassyTransient()));

        // but may change that
        ObjectMapper m = new ObjectMapper()
            .enable(MapperFeature.PROPAGATE_TRANSIENT_MARKER);
        assertEquals(aposToQuotes("{'x':42}"),
                m.writeValueAsString(new ClassyTransient()));
    }

    // for [databind#857]
    public void testBeanTransient() throws Exception
    {
        assertEquals(aposToQuotes("{'y':4}"),
                MAPPER.writeValueAsString(new BeanTransient()));
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/BeanDescriptionTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.introspect;

import com.fasterxml.jackson.annotation.JsonClassDescription;
import com.fasterxml.jackson.databind.*;

public class BeanDescriptionTest extends BaseMapTest
{
    private final ObjectMapper MAPPER = objectMapper();

    private final static String CLASS_DESC = "Description, yay!";
    
    @JsonClassDescription(CLASS_DESC)
    static class DocumentedBean {
        public int x;
    }
    
    public void testClassDesc() throws Exception
    {
        BeanDescription beanDesc = MAPPER.getDeserializationConfig().introspect(MAPPER.constructType(DocumentedBean.class));
        assertEquals(CLASS_DESC, beanDesc.findClassDescription());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/SetterConflictTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.introspect;

import com.fasterxml.jackson.databind.*;

// mostly for [databind#1033]
public class SetterConflictTest extends BaseMapTest
{
    // Should prefer primitives over Strings, more complex types, by default
    static class Issue1033Bean {
        public int value;

        public void setValue(int v) { value = v; }
        public void setValue(Issue1033Bean foo) {
            throw new Error("Should not get called");
        }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */
    
    private final ObjectMapper MAPPER = objectMapper();

    public void testSetterPriority() throws Exception
    {
        Issue1033Bean bean = MAPPER.readValue(aposToQuotes("{'value':42}"),
                Issue1033Bean.class);
        assertEquals(42, bean.value);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/IntrospectorPairTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.introspect;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.databind.*;

// started with [databind#1025] in mind
@SuppressWarnings("serial")
public class IntrospectorPairTest extends BaseMapTest
{
    static class Introspector1 extends AnnotationIntrospector {
        @Override
        public Version version() {
            return Version.unknownVersion();
        }

        @Override
        public JsonInclude.Value findPropertyInclusion(Annotated a) {
            return JsonInclude.Value.empty()
                    .withContentInclusion(JsonInclude.Include.ALWAYS)
                    .withValueInclusion(JsonInclude.Include.NON_ABSENT);
        }
    }

    static class Introspector2 extends AnnotationIntrospector {
        @Override
        public Version version() {
            return Version.unknownVersion();
        }

        @Override
        public JsonInclude.Value findPropertyInclusion(Annotated a) {
            return JsonInclude.Value.empty()
                    .withContentInclusion(JsonInclude.Include.NON_EMPTY)
                    .withValueInclusion(JsonInclude.Include.USE_DEFAULTS);
        }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final AnnotationIntrospectorPair introPair12
        = new AnnotationIntrospectorPair(new Introspector1(), new Introspector2());

    private final AnnotationIntrospectorPair introPair21
        = new AnnotationIntrospectorPair(new Introspector2(), new Introspector1());
    
    // for [databind#1025]
    public void testInclusionMerging() throws Exception
    {
        // argument is ignored by test introspectors, may be null
        JsonInclude.Value v12 = introPair12.findPropertyInclusion(null);
        JsonInclude.Value v21 = introPair21.findPropertyInclusion(null);

        assertEquals(JsonInclude.Include.ALWAYS, v12.getContentInclusion());
        assertEquals(JsonInclude.Include.NON_ABSENT, v12.getValueInclusion());

        assertEquals(JsonInclude.Include.NON_EMPTY, v21.getContentInclusion());
        assertEquals(JsonInclude.Include.NON_ABSENT, v21.getValueInclusion());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    // For [JACKSON-694]: error message for conflicting getters sub-optimal
=======
    // error message for conflicting getters sub-optimal
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    // [Issue#238]
=======
    // [databind#238]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    // For [Issue#541]
=======
    // For [databind#541]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
     
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    
    // for [JACKSON-694]
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    // [Issue#238]: ok to have getter, "isGetter"
=======
    // [databind#238]: ok to have getter, "isGetter"
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
import org.junit.Test;
=======
import com.fasterxml.jackson.annotation.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
=======
import com.fasterxml.jackson.databind.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
 * Unit tests to verify functioning of 
 * {@link PropertyNamingStrategy#CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES} 
 * and
 * {@link PropertyNamingStrategy#PASCAL_CASE_TO_CAMEL_CASE } 
 * inside the context of an ObjectMapper.
 * PASCAL_CASE_TO_CAMEL_CASE was added in Jackson 2.1,
 * as per [JACKSON-63].
=======
 * Unit tests to verify functioning of standard {@link PropertyNamingStrategy}
 * implementations Jackson includes out of the box.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    
=======

    static class FirstNameBean {
        public String firstName;

        protected FirstNameBean() { }
        public FirstNameBean(String n) { firstName = n; }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    public static List<Object[]> NAME_TRANSLATIONS = Arrays.asList(new Object[][] {
=======
    public static List<Object[]> SNAKE_CASE_NAME_TRANSLATIONS = Arrays.asList(new Object[][] {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        _lcWithUndescoreMapper.setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);
=======
        _lcWithUndescoreMapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    /* Test methods for CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES
=======
    /* Test methods for SNAKE_CASE
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
     * {@link PropertyNamingStrategy#CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES} 
=======
     * {@link PropertyNamingStrategy#SNAKE_CASE} 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
     * CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES was added in Jackson 1.9, 
     * as per [JACKSON-598].
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    @Test
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        for (Object[] pair : NAME_TRANSLATIONS) {
            String translatedJavaName = PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES.nameForField(null, null,
=======
        for (Object[] pair : SNAKE_CASE_NAME_TRANSLATIONS) {
            String translatedJavaName = PropertyNamingStrategy.SNAKE_CASE.nameForField(null, null,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    /* Test methods for PASCAL_CASE_TO_CAMEL_CASE (added in 2.1)
=======
    /* Test methods for UPPER_CAMEL_CASE
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
     * {@link PropertyNamingStrategy#PASCAL_CASE_TO_CAMEL_CASE } 
=======
     * {@link PropertyNamingStrategy#UPPER_CAMEL_CASE } 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
     * PASCAL_CASE_TO_CAMEL_CASE was added in Jackson 2.1.0, 
     * as per [JACKSON-63].
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        String translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField
=======
        String translatedJavaName = PropertyNamingStrategy.UPPER_CAMEL_CASE.nameForField
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField
=======
        translatedJavaName = PropertyNamingStrategy.UPPER_CAMEL_CASE.nameForField
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField
=======
        translatedJavaName = PropertyNamingStrategy.UPPER_CAMEL_CASE.nameForField
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField
=======
        translatedJavaName = PropertyNamingStrategy.UPPER_CAMEL_CASE.nameForField
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
                            .setPropertyNamingStrategy(PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)
=======
                            .setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Test methods for LOWER_CASE
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Test methods for KEBAB_CASE
    /**********************************************************
     */
    
    public void testKebabCaseStrategyStandAlone()
    {
        assertEquals("some-value",
                PropertyNamingStrategy.KEBAB_CASE.nameForField(null, null, "someValue"));
        assertEquals("some-value",
                PropertyNamingStrategy.KEBAB_CASE.nameForField(null, null, "SomeValue"));
        assertEquals("url",
                PropertyNamingStrategy.KEBAB_CASE.nameForField(null, null, "URL"));
        assertEquals("url-stuff",
                PropertyNamingStrategy.KEBAB_CASE.nameForField(null, null, "URLStuff"));
        assertEquals("some-url-stuff",
                PropertyNamingStrategy.KEBAB_CASE.nameForField(null, null, "SomeURLStuff"));
    }
    
    public void testSimpleKebabCase() throws Exception
    {
        final FirstNameBean input = new FirstNameBean("Bob");
        ObjectMapper m = new ObjectMapper()
                .setPropertyNamingStrategy(PropertyNamingStrategy.KEBAB_CASE);

        assertEquals(aposToQuotes("{'first-name':'Bob'}"), m.writeValueAsString(input));

        FirstNameBean result = m.readValue(aposToQuotes("{'first-name':'Billy'}"),
                FirstNameBean.class);
        assertEquals("Billy", result.firstName);
    }

    /*
    /**********************************************************
    /* Test methods, other
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        ObjectMapper m = new ObjectMapper();
        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
=======
        ObjectMapper m = new ObjectMapper()
            .setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
=======
    public void testExplicitRename() throws Exception
    {
      ObjectMapper m = new ObjectMapper();
      m.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
      m.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
      // by default, renaming will not take place on explicitly named fields
      assertEquals(aposToQuotes("{'firstName':'Peter','lastName':'Venkman','user_age':'35'}"),
          m.writeValueAsString(new ExplicitBean()));

      m = new ObjectMapper();
      m.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
      m.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
      m.enable(MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING);
      // w/ feature enabled, ALL property names should get re-written
      assertEquals(aposToQuotes("{'first_name':'Peter','last_name':'Venkman','user_age':'35'}"),
          m.writeValueAsString(new ExplicitBean()));

      // test deserialization as well
      ExplicitBean bean =
          m.readValue(aposToQuotes("{'first_name':'Egon','last_name':'Spengler','user_age':'32'}"),
              ExplicitBean.class);

      assertNotNull(bean);
      assertEquals("Egon", bean.userFirstName);
      assertEquals("Spengler", bean.userLastName);
      assertEquals("32", bean.userAge);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
        public String findEnumValue(Enum<?> value)
        {
=======
        public String findEnumValue(Enum<?> value) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
=======

        @Override
        public  String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {
            // kinda sorta wrong, but for testing's sake...
            for (int i = 0, len = enumValues.length; i < len; ++i) {
                names[i] = enumValues[i].name().toLowerCase();
            }
            return names;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
        ObjectMapper mapper = new ObjectMapper();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(TypeResolverBean.class, ai, null);
=======
        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(TypeResolverBean.class, mapper.getSerializationConfig());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
        ObjectMapper mapper = new ObjectMapper();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
    }    

    /**
     * Tests to ensure that {@link JsonIgnoreType} is detected as expected
     * by the standard introspector.
     * 
     * @since 1.7
     */
    public void testIgnoredType() throws Exception
    {
        JacksonAnnotationIntrospector ai = new JacksonAnnotationIntrospector();
        AnnotatedClass ac = AnnotatedClass.construct(IgnoredType.class, ai, null);
        assertEquals(Boolean.TRUE, ai.isIgnorableType(ac));

        // also, should inherit as expected
        ac = AnnotatedClass.construct(IgnoredSubType.class, ai, null);
        assertEquals(Boolean.TRUE, ai.isIgnorableType(ac));
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/Objecid1083Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.objectid;

import java.util.*;

import com.fasterxml.jackson.annotation.*;

import com.fasterxml.jackson.databind.*;

public class Objecid1083Test extends BaseMapTest
{
    public static class JsonRoot {
        public final List<JsonSchema> schemas = new ArrayList<JsonSchema>();
      }

      @JsonTypeInfo(
          use = JsonTypeInfo.Id.NAME,
          property = "type",
          defaultImpl = JsonMapSchema.class)
      @JsonSubTypes({
          @JsonSubTypes.Type(value = JsonMapSchema.class, name = "map"),
          @JsonSubTypes.Type(value = JsonJdbcSchema.class, name = "jdbc") })
      public static abstract class JsonSchema {
        public String name;
      }

      static class JsonMapSchema extends JsonSchema { }

      static class JsonJdbcSchema extends JsonSchema { }

      /*
      /*****************************************************
      /* Unit tests, external id deserialization
      /*****************************************************
       */

      public void testSimple() throws Exception {
          final ObjectMapper mapper = new ObjectMapper();
          final String json = aposToQuotes("{'schemas': [{\n"
              + "  'name': 'FoodMart'\n"
              + "}]}\n");
          mapper.readValue(json, JsonRoot.class);
      }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/JSOGDeserialize622Test.java;<<<<<<< MINE
              throw new JsonMappingException("Could not find key '"+REF_KEY
=======
              throw JsonMappingException.from(jp, "Could not find key '"+REF_KEY
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectId.java;<<<<<<< MINE
=======
    @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@id")
    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")
    public static class BaseEntity {  }

    public static class Foo extends BaseEntity {
        public BaseEntity ref;
    }

    public static class Bar extends BaseEntity
    {
        public Foo next;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectId.java;<<<<<<< MINE
=======

    public void testObjectAndTypeId() throws Exception
    {
        final ObjectMapper mapper = new ObjectMapper();

        Bar inputRoot = new Bar();
        Foo inputChild = new Foo();
        inputRoot.next = inputChild;
        inputChild.ref = inputRoot;

        String json = mapper.writerWithDefaultPrettyPrinter()
                .writeValueAsString(inputRoot);
        
        BaseEntity resultRoot = mapper.readValue(json, BaseEntity.class);
        assertNotNull(resultRoot);
        assertTrue(resultRoot instanceof Bar);
        Bar first = (Bar) resultRoot;

        assertNotNull(first.next);
        assertTrue(first.next instanceof Foo);
        Foo second = (Foo) first.next;
        assertNotNull(second.ref);
        assertSame(first, second.ref);
    }    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java;<<<<<<< MINE
=======
    @JsonIdentityInfo(generator=ObjectIdGenerators.StringIdGenerator.class, property="id")
    static class StringIdentifiable
    {
        public int value;

        public StringIdentifiable next;
        
        public StringIdentifiable() { this(0); }
        public StringIdentifiable(int v) {
            value = v;
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java;<<<<<<< MINE
    // [Issue#370]
=======
    // [databind#370]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java;<<<<<<< MINE
    // [Issue#370]
=======
    // [databind#370]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java;<<<<<<< MINE
=======
    public void testSerializeWithOpaqueStringId() throws Exception
    {
        StringIdentifiable ob1 = new StringIdentifiable(12);
        StringIdentifiable ob2 = new StringIdentifiable(34);
        ob1.next = ob2;
        ob2.next = ob1;

        // first just verify we get some output
        String json = MAPPER.writeValueAsString(ob1);
        assertNotNull(json);

        // then get them back
        StringIdentifiable output = MAPPER.readValue(json, StringIdentifiable.class);
        assertNotNull(output);
        assertEquals(12, output.value);
        assertNotNull(output.next);
        assertEquals(34, output.next.value);
        assertSame(output.next.next, output);

        String json2 = aposToQuotes("{'id':'foobar','value':3, 'next':{'id':'barf','value':5,'next':'foobar'}}");
        output = MAPPER.readValue(json2, StringIdentifiable.class);
        assertNotNull(output);
        assertEquals(3, output.value);
        assertNotNull(output.next);
        assertEquals(5, output.next.value);
        assertSame(output.next.next, output);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdWithEquals.java;<<<<<<< MINE
=======
import java.net.URI;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdWithEquals.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.type.TypeReference;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdWithEquals.java;<<<<<<< MINE
=======
    // for [databind#1002]
    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "uri")
    static class Element {
        public URI uri;
        public String name;

        @Override
        public boolean equals(Object object) {
            if (object == this) {
                return true;
            } else if (object == null || !(object instanceof Element)) {
                return false;
            } else {
                Element element = (Element) object;
                if (element.uri.toString().equalsIgnoreCase(this.uri.toString())) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public int hashCode() {
            return uri.hashCode();
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdWithEquals.java;<<<<<<< MINE
=======

    public void testEqualObjectIdsExternal() throws Exception
    {
        Element element = new Element();
        element.uri = URI.create("URI");
        element.name = "Element1";

        Element element2 = new Element();
        element2.uri = URI.create("URI");
        element2.name = "Element2";

        // 12-Nov-2015, tatu: array works fine regardless of Type Erasure, but if using List,
        //   must provide additional piece of type info
//        Element[] input = new Element[] { element, element2 };
        List<Element> input = Arrays.asList(element, element2);

        ObjectMapper mapper = new ObjectMapper();
        mapper.enable(SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID);

//        String json = mapper.writeValueAsString(input);
        String json = mapper.writerFor(new TypeReference<List<Element>>() { })
                .writeValueAsString(input);

        Element[] output = mapper.readValue(json, Element[].class);
        assertNotNull(output);
        assertEquals(2, output.length);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/ObjectId825BTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.objectid;

import java.util.ArrayList;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.*;

@SuppressWarnings("serial")
public class ObjectId825BTest extends BaseMapTest
{
    static abstract class AbstractAct extends AbstractEntity {
        protected java.util.ArrayList<Tr> outTr;

        public java.util.ArrayList<Tr> getOutTr() {
            return this.outTr;
        }
        public void setOutTr(java.util.ArrayList<Tr> outTr) {
            this.outTr = outTr;
        }
    }

    static abstract class AbstractCond extends AbstractAct { }

    static abstract class AbstractData extends AbstractSym { }

    static abstract class AbstractDec extends AbstractAct {
        protected java.util.ArrayList<Dec> dec;

        public java.util.ArrayList<Dec> getDec() {
            return this.dec;
        }
        public void setDec(java.util.ArrayList<Dec> dec) {
            this.dec = dec;
        }
    }

    @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="oidString")
    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")
    static abstract class AbstractEntity implements java.io.Serializable {
        public String oidString;

        protected AbstractEntity() { }

        public String getOidString() {
            return oidString;
        }

        public void setOidString(String oidString) {
            this.oidString = oidString;
        }
    }

    static abstract class AbstractSym extends AbstractEntity { }

    static class Ch extends AbstractEntity {
        protected java.util.ArrayList<? extends AbstractAct> act;

        public java.util.ArrayList<? extends AbstractAct> getAct() {
            return this.act;
        }

        public void setAct(java.util.ArrayList<? extends AbstractAct> act) {
            this.act = act;
        }
    }

    static class CTC extends AbstractEntity {
        protected java.util.ArrayList<CTV> var;

        public CTC() { }

        public java.util.ArrayList<CTV> getVar() {
            if (var == null) {
                var = new ArrayList<CTV>();
            }
            return new ArrayList<CTV>(var);
        }

        public void setVar(java.util.ArrayList<CTV> var) {
            this.var = var;
        }
    }

    static class CTD extends AbstractDec { }

    static class CTV extends AbstractEntity {
        protected Ch ch;
        protected java.util.ArrayList<? extends AbstractData> locV;

        public Ch getCh() {
            return this.ch;
        }

        public void setCh(Ch ch) {
            this.ch = ch;
        }


        public java.util.ArrayList<? extends AbstractData> getLocV() {
            return this.locV;
        }

        public void setLocV(java.util.ArrayList<? extends AbstractData> locV) {
            this.locV = locV;
        }
    }

    static class Dec extends AbstractCond { }

    static class Ti extends AbstractAct {
        protected AbstractData timer;

        public AbstractData getTimer() {
            return this.timer;
        }

        public void setTimer(AbstractData timer) {
            this.timer = timer;
        }
    }

    static class Tr extends AbstractEntity {
        protected AbstractAct target;

        public AbstractAct getTarget() {
            return this.target;
        }

        public void setTarget(AbstractAct target) {
            this.target = target;
        }
    }

    static class V extends AbstractData {
        private static final long serialVersionUID = 1L;
    }    

    public void testFull825() throws Exception
    {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);
        mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);

        String INPUT = aposToQuotes(
"{\n"+
"    '@class': '_PKG_CTC',\n"+
"     'var': [{\n"+
"      'ch': {\n"+
"        '@class': '_PKG_Ch',\n"+
"         'act': [{\n"+
"            '@class': '_PKG_CTD',\n"+
"            'oidString': 'oid1',\n"+
"            'dec': [{\n"+
"              '@class': '_PKG_Dec',\n"+
"                'oidString': 'oid2',\n"+
"                'outTr': [{\n"+
"                  '@class': '_PKG_Tr',\n"+
"                  'target': {\n"+
"                    '@class': '_PKG_Ti',\n"+
"                    'oidString': 'oid3',\n"+
"                    'timer': 'problemoid',\n"+
"                    'outTr': [{\n"+
"                      '@class': '_PKG_Tr',\n"+
"                      'target': {\n"+
"                        '@class': '_PKG_Ti',\n"+
"                        'oidString': 'oid4',\n"+
"                        'timer': {\n"+
"                          '@class': '_PKG_V',\n"+
"                          'oidString': 'problemoid'\n"+
"                        }\n"+
"                      }\n"+
"                    }]\n"+
"                  }\n"+
"                }]\n"+
"              }]\n"+
"         }],\n"+
"         'oidString': 'oid5'\n"+
"      },\n"+
"       '@class': '_PKG_CTV',\n"+
"       'oidString': 'oid6',\n"+
"       'locV': ['problemoid']\n"+
"    }],\n"+
"     'oidString': 'oid7'\n"+
"}\n"
                );

        // also replace package
        final String newPkg = getClass().getName() + "\\$";
        INPUT = INPUT.replaceAll("_PKG_", newPkg);
        
        CTC result = mapper.readValue(INPUT, CTC.class);
        assertNotNull(result);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/objectid/ReferentialWithObjectIdTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.objectid;

import java.util.concurrent.atomic.AtomicReference;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;

import com.fasterxml.jackson.databind.*;

public class ReferentialWithObjectIdTest extends BaseMapTest
{
    public static class EmployeeList {
        public AtomicReference<Employee> first;
    }

    @JsonIdentityInfo(property="id", generator=ObjectIdGenerators.PropertyGenerator.class)
    public static class Employee {
        public int id;
        public String name;
        public AtomicReference<Employee> next;

        public Employee next(Employee n) {
            next = new AtomicReference<Employee>(n);
            return this;
        }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();
    
    public void testAtomicWithObjectId() throws Exception
    {
        Employee first = new Employee();
        first.id = 1;
        first.name = "Alice";

        Employee second = new Employee();
        second.id = 2;
        second.name = "Bob";

        first.next(second);
        second.next(first);

        EmployeeList input = new EmployeeList();
        input.first = new AtomicReference<Employee>(first);

        String json = MAPPER.writeValueAsString(input);

        // and back
 
        EmployeeList result = MAPPER.readValue(json, EmployeeList.class);
        Employee firstB = result.first.get();
        assertNotNull(firstB);
        assertEquals("Alice", firstB.name);
        Employee secondB = firstB.next.get();
        assertNotNull(secondB);
        assertEquals("Bob", secondB.name);
        assertNotNull(secondB.next.get());
        assertSame(firstB, secondB.next.get());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    // Also test via Field
=======
    // for [jackson-databind#1023]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
=======
    // for [jackson-databind#1023]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    final static class IterableWrapper
        implements Iterable<Integer>
    {
        List<Integer> _ints = new ArrayList<Integer>();

        public IterableWrapper(int[] values) {
            for (int i : values) {
                _ints.add(Integer.valueOf(i));
            }
        }

        @Override
        public Iterator<Integer> iterator() {
            return _ints.iterator();
        }
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
        public void serialize(List<String> value,
                              JsonGenerator jgen,
                              SerializerProvider provider)
=======
        public void serialize(List<String> value, JsonGenerator gen, SerializerProvider provider)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
            jgen.writeString(value.toString());
=======
            gen.writeString(value.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    // [JACKSON-689]
    static class BeanWithIterable {
        private final ArrayList<String> values = new ArrayList<String>();
        {
            values.add("value");
        }

        public Iterable<String> getValues() { return values; }
    }

    static class IntIterable implements Iterable<Integer>
    {
        @Override
        public Iterator<Integer> iterator() {
            return new IntIterator(1, 3);
        }
    }

    static class IntIterator implements Iterator<Integer> {
        int i;
        final int last;

        public IntIterator(int first, int last) {
            i = first;
            this.last = last;
        }

        @Override
        public boolean hasNext() {
            return i <= last;
        }

        @Override
        public Integer next() {
            return i++;
        }

        @Override
        public void remove() { }

        public int getX() { return 13; }
    }

    // [Issue#358]
    static class A {
        public String unexpected = "Bye.";
    }

    static class B {
        @JsonSerialize(as = Iterable.class, contentUsing = ASerializer.class)
        public List<A> list = Arrays.asList(new A());
    }
    static class ASerializer extends JsonSerializer<A> {
        @Override
        public void serialize(A a, JsonGenerator jsonGenerator, SerializerProvider provider) throws IOException {
            jsonGenerator.writeStartArray();
            jsonGenerator.writeString("Hello world.");
            jsonGenerator.writeEndArray();
        }
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testCollections()
        throws IOException
=======
    public void testCollections() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testBigCollection()
        throws IOException
=======
    public void testBigCollection() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testEnumMap()
        throws IOException
=======
    public void testEnumMap() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testIterator()
        throws IOException
    {
        StringWriter sw = new StringWriter();
        ArrayList<Integer> l = new ArrayList<Integer>();
        l.add(1);
        l.add(-9);
        l.add(0);
        MAPPER.writeValue(sw, l.iterator());
        assertEquals("[1,-9,0]", sw.toString().trim());
    }

    public void testIterable()
        throws IOException
    {
        StringWriter sw = new StringWriter();
        MAPPER.writeValue(sw, new IterableWrapper(new int[] { 1, 2, 3 }));
        assertEquals("[1,2,3]", sw.toString().trim());
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testEmptyBeanCollection()
        throws IOException
=======
    public void testEmptyBeanCollection() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testEmptyBeanEnumMap()
        throws IOException
=======
    public void testEmptyBeanEnumMap() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    public void testNullBeanEnumMap()
        throws IOException
=======
    public void testNullBeanEnumMap() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java;<<<<<<< MINE
    
    // [JACKSON-689], [JACKSON-876]
    public void testWithIterable() throws IOException
    {
        // 689:
        assertEquals("{\"values\":[\"value\"]}",
                MAPPER.writeValueAsString(new BeanWithIterable()));
        // 876:
        assertEquals("[1,2,3]",
                MAPPER.writeValueAsString(new IntIterable()));
    }
    
    // [Issue#358]
    public void testIterable358() throws Exception {
        String json = MAPPER.writeValueAsString(new B());
        assertEquals("{\"list\":[[\"Hello world.\"]]}", json);
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java;<<<<<<< MINE
            POJOPropertyBuilder prop = new POJOPropertyBuilder(new PropertyName("bogus"), null, true);
=======
            POJOPropertyBuilder prop = new POJOPropertyBuilder(config, null, true, new PropertyName("bogus"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestIterable.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.ser;

import java.io.IOException;
import java.io.StringWriter;
import java.util.*;

import com.fasterxml.jackson.core.JsonGenerator;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

public class TestIterable extends BaseMapTest
{
    final static class IterableWrapper
        implements Iterable<Integer>
    {
        List<Integer> _ints = new ArrayList<Integer>();
    
        public IterableWrapper(int[] values) {
            for (int i : values) {
                _ints.add(Integer.valueOf(i));
            }
        }
    
        @Override
        public Iterator<Integer> iterator() {
            return _ints.iterator();
        }
    }
    // [JACKSON-689]
    static class BeanWithIterable {
        private final ArrayList<String> values = new ArrayList<String>();
        {
            values.add("value");
        }

        public Iterable<String> getValues() { return values; }
    }

    static class IntIterable implements Iterable<Integer>
    {
        @Override
        public Iterator<Integer> iterator() {
            return new IntIterator(1, 3);
        }
    }

    static class IntIterator implements Iterator<Integer> {
        int i;
        final int last;

        public IntIterator(int first, int last) {
            i = first;
            this.last = last;
        }

        @Override
        public boolean hasNext() {
            return i <= last;
        }

        @Override
        public Integer next() {
            return i++;
        }

        @Override
        public void remove() { }

        public int getX() { return 13; }
    }
 
    // [databind#358]
    static class A {
        public String unexpected = "Bye.";
    }

    static class B {
        @JsonSerialize(as = Iterable.class,
                contentUsing = ASerializer.class)
        public List<A> list = Arrays.asList(new A());
    }

    static class ASerializer extends JsonSerializer<A> {
        @Override
        public void serialize(A a, JsonGenerator jsonGenerator, SerializerProvider provider) throws IOException {
            jsonGenerator.writeStartArray();
            jsonGenerator.writeString("Hello world.");
            jsonGenerator.writeEndArray();
        }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final static ObjectMapper MAPPER = new ObjectMapper();
    
    public void testIterator() throws IOException
    {
        StringWriter sw = new StringWriter();
        ArrayList<Integer> l = new ArrayList<Integer>();
        l.add(1);
        l.add(-9);
        l.add(0);
        MAPPER.writeValue(sw, l.iterator());
        assertEquals("[1,-9,0]", sw.toString().trim());
    }

    public void testIterable() throws IOException
    {
        StringWriter sw = new StringWriter();
        MAPPER.writeValue(sw, new IterableWrapper(new int[] { 1, 2, 3 }));
        assertEquals("[1,2,3]", sw.toString().trim());
    }

    // [JACKSON-689], [JACKSON-876]
    public void testWithIterable() throws IOException
    {
        // 689:
        assertEquals("{\"values\":[\"value\"]}",
                MAPPER.writeValueAsString(new BeanWithIterable()));
        // 876:
        assertEquals("[1,2,3]",
                MAPPER.writeValueAsString(new IntIterable()));
    }
    
    // [databind#358]
    public void testIterable358() throws Exception {
        String json = MAPPER.writeValueAsString(new B());
        assertEquals("{\"list\":[[\"Hello world.\"]]}", json);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize2.java;<<<<<<< MINE
    static class NonEmptyString {
        @JsonInclude(JsonInclude.Include.NON_EMPTY)
        public String value;

        public NonEmptyString(String v) { value = v; }
    }

    static class NonEmptyInt {
        @JsonInclude(JsonInclude.Include.NON_EMPTY)
        public int value;

        public NonEmptyInt(int v) { value = v; }
    }

    static class NonEmptyDouble {
        @JsonInclude(JsonInclude.Include.NON_EMPTY)
        public double value;

        public NonEmptyDouble(double v) { value = v; }
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize2.java;<<<<<<< MINE
    public void testEmptyInclusionScalars() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));
        assertEquals("{}", inclMapper.writeValueAsString(str));
        assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));

        assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));
        assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));

        // Then numbers
        assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));
        assertEquals("{}", defMapper.writeValueAsString(new NonEmptyInt(0)));

        assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));
        assertEquals("{}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));

        IntWrapper zero = new IntWrapper(0);
        assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));
        assertEquals("{}", inclMapper.writeValueAsString(zero));
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/DateSerializationTest.java;<<<<<<< MINE
=======
    static class DateAsDefaultStringBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING)
        public Date date;
        public DateAsDefaultStringBean(long l) { date = new java.util.Date(l); }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/DateSerializationTest.java;<<<<<<< MINE
=======

        // and with default (ISO8601) format (databind#1109)
        json = mapper.writeValueAsString(new DateAsDefaultStringBean(0L));
        assertEquals("{\"date\":\"1970-01-01T00:00:00.000+0000\"}", json);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
import java.util.concurrent.atomic.AtomicReference;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
                              JsonGenerator jgen,
                              SerializerProvider provider)
            throws IOException
=======
                JsonGenerator gen, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
            jgen.writeString(value.toString());
=======
            gen.writeString(value.toString());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // [#335]
=======
    // [databind#335]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // [Databind#565]: Support ser/deser of Map.Entry
=======
    // [databind#565]: Support ser/deser of Map.Entry
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    
    // [databind#527]
    static class NoNullValuesMapContainer {
        @JsonInclude(content=JsonInclude.Include.NON_NULL)
        public Map<String,String> stuff = new LinkedHashMap<String,String>();
        
        public NoNullValuesMapContainer add(String key, String value) {
            stuff.put(key, value);
            return this;
        }
    }

    // [databind#527]
    @JsonInclude(content=JsonInclude.Include.NON_NULL)
    static class NoNullsStringMap extends LinkedHashMap<String,String> {
        public NoNullsStringMap add(String key, String value) {
            put(key, value);
            return this;
        }
    }

    @JsonInclude(content=JsonInclude.Include.NON_ABSENT)
    static class NoAbsentStringMap extends LinkedHashMap<String, AtomicReference<?>> {
        public NoAbsentStringMap add(String key, Object value) {
            put(key, new AtomicReference<Object>(value));
            return this;
        }
    }
    
    @JsonInclude(content=JsonInclude.Include.NON_EMPTY)
    static class NoEmptyStringsMap extends LinkedHashMap<String,String> {
        public NoEmptyStringsMap add(String key, String value) {
            put(key, value);
            return this;
        }
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // Test [JACKSON-220]
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // Test [JACKSON-314]
    public void testMapNullSerialization() throws IOException
    {
        ObjectMapper m = new ObjectMapper();
        Map<String,String> map = new HashMap<String,String>();
        map.put("a", null);
        // by default, should output null-valued entries:
        assertEquals("{\"a\":null}", m.writeValueAsString(map));
        // but not if explicitly asked not to (note: config value is dynamic here)
        m.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);
        assertEquals("{}", m.writeValueAsString(map));
    }

    // [JACKSON-499], problems with map entries, values
=======
    // problems with map entries, values
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    }        
    
    // [databind#527]
    public void testNonNullValueMap() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoNullsStringMap()
            .add("a", "foo")
            .add("b", null)
            .add("c", "bar"));
        assertEquals(aposToQuotes("{'a':'foo','c':'bar'}"), json);
    }

    // [databind#527]
    public void testNonEmptyValueMap() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoEmptyStringsMap()
            .add("a", "foo")
            .add("b", "bar")
            .add("c", ""));
        assertEquals(aposToQuotes("{'a':'foo','b':'bar'}"), json);
    }

    public void testNonAbsentValueMap() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoAbsentStringMap()
            .add("a", "foo")
            .add("b", null));
        assertEquals(aposToQuotes("{'a':'foo'}"), json);
    }
    
    // [databind#527]
    public void testNonNullValueMapViaProp() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoNullValuesMapContainer()
            .add("a", "foo")
            .add("b", null)
            .add("c", "bar"));
        assertEquals(aposToQuotes("{'stuff':{'a':'foo','c':'bar'}}"), json);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======
        ObjectNode nestedObject1 = MAPPER.createObjectNode();
        nestedObject1.put("value", 6);
        ArrayNode nestedArray1 = MAPPER.createArrayNode();
        nestedArray1.add(7);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======
        root1.set("nested_object", nestedObject1);
        root1.set("nested_array", nestedArray1);

        ObjectNode nestedObject2 = MAPPER.createObjectNode();
        nestedObject2.put("value", 6.9);
        ArrayNode nestedArray2 = MAPPER.createArrayNode();
        nestedArray2.add(7.0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======
        root2.set("nested_object", nestedObject2);
        root2.set("nested_array", nestedArray2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======
                if (o1 instanceof ContainerNode || o2 instanceof ContainerNode) {
                    fail("container nodes should be traversed, comparator should not be invoked");
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        System.out.println("json: "+json);
=======
//        System.out.println("json: "+json);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        System.out.println("Deserialized to ObjectNode: "+de1);
=======
//        System.out.println("Deserialized to ObjectNode: "+de1);
        assertNotNull(de1);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java;<<<<<<< MINE
        System.out.println("Deserialized to MyValue: "+de2);
=======
//        System.out.println("Deserialized to MyValue: "+de2);
        assertNotNull(de2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestFieldDeserialization.java;<<<<<<< MINE
 * deserialized (since version 1.1) as well as
 * setter-accessible properties.
=======
 * deserialized as well as setter-accessible properties.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestFieldDeserialization.java;<<<<<<< MINE
=======
        @SuppressWarnings("hiding")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestObjectOrArrayDeserialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TestObjectOrArrayDeserialization extends BaseMapTest
{
    public static class SomeObject {
        public String someField;
    }

    public static class ArrayOrObject {
        private final List<SomeObject> objects;
        private final SomeObject object;

        @JsonCreator
        public ArrayOrObject(List<SomeObject> objects) {
            this.objects = objects;
            this.object = null;
        }

        @JsonCreator
        public ArrayOrObject(SomeObject object) {
            this.objects = null;
            this.object = object;
        }
    }

    public void testObjectCase() throws Exception {
        ArrayOrObject arrayOrObject = new ObjectMapper().readValue("{}", ArrayOrObject.class);
        assertNull("expected objects field to be null", arrayOrObject.objects);
        assertNotNull("expected object field not to be null", arrayOrObject.object);
    }

    public void testEmptyArrayCase() throws Exception {
        ArrayOrObject arrayOrObject = new ObjectMapper().readValue("[]", ArrayOrObject.class);
        assertNotNull("expected objects field not to be null", arrayOrObject.objects);
        assertTrue("expected objects field to be an empty list", arrayOrObject.objects.isEmpty());
        assertNull("expected object field to be null", arrayOrObject.object);
    }

    public void testNotEmptyArrayCase() throws Exception {
        ArrayOrObject arrayOrObject = new ObjectMapper().readValue("[{}, {}]", ArrayOrObject.class);
        assertNotNull("expected objects field not to be null", arrayOrObject.objects);
        assertEquals("expected objects field to have size 2", 2, arrayOrObject.objects.size());
        assertNull("expected object field to be null", arrayOrObject.object);
    }

}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // Testing [JACKSON-526], "implicit JSON array" for single-element arrays,
=======
    // Testing "implicit JSON array" for single-element arrays,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // [Issue#161]
=======
    // [databind#161]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // [Issue#199]
=======
    // [databind#199]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // for [Issue#506]
=======
    // for [databind#506]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
    // for [Issue#828]
=======
    // for [databind#828]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE
=======
import java.io.IOException;
import java.util.Map;

import org.junit.Test;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.BaseMapTest;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE
import org.junit.Test;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE
import java.io.IOException;
import java.util.Map;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

/**
 *
 */
public class ExceptionFromCustomEnumKeyDeserializerTest {
=======
@SuppressWarnings("serial")
public class ExceptionFromCustomEnumKeyDeserializerTest
    extends BaseMapTest
{
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE

=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE
        /**
         * Register a Jackson module for Rosette's top-level enums an {@link ObjectMapper}.
         * @param mapper the mapper.
         * @return the same mapper, for convenience.
         */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE
    public void lostMessage() {
=======
    public void testLostMessage() {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestJDKAtomicTypes.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.concurrent.atomic.*;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;

public class TestJDKAtomicTypes
    extends com.fasterxml.jackson.databind.BaseMapTest
{
    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME)
    @JsonSubTypes({ @JsonSubTypes.Type(Impl.class) })
    static abstract class Base { }

    @JsonTypeName("I")
    static class Impl extends Base {
        public int value;

        public Impl() { }
        public Impl(int v) { value = v; }
    }

    static class RefWrapper
    {
        public AtomicReference<Base> w;

        public RefWrapper() { }
        public RefWrapper(Base b) {
            w = new AtomicReference<Base>(b);
        }
        public RefWrapper(int i) {
            w = new AtomicReference<Base>(new Impl(i));
        }
    }

    static class SimpleWrapper {
        public AtomicReference<Object> value;

        public SimpleWrapper() { }
        public SimpleWrapper(Object o) { value = new AtomicReference<Object>(o); }
    }

    static class RefiningWrapper {
        @JsonDeserialize(contentAs=BigDecimal.class)
        public AtomicReference<Serializable> value;
    }

    // Additional tests for improvements with [databind#932]

    static class UnwrappingRefParent {
        @JsonUnwrapped(prefix = "XX.")
        public AtomicReference<Child> child = new AtomicReference<Child>(new Child());
    }

    static class Child {
        public String name = "Bob";
    }

    static class Parent {
        private Child child = new Child();

        @JsonUnwrapped
        public Child getChild() {
             return child;
        }
    }

    static class WrappedString {
        String value;

        public WrappedString(String s) { value = s; }
    }

    static class AtomicRefReadWrapper {
        @JsonDeserialize(contentAs=WrappedString.class)
        public AtomicReference<Object> value;
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final ObjectMapper MAPPER = objectMapper();
    
    public void testAtomicBoolean() throws Exception
    {
        AtomicBoolean b = MAPPER.readValue("true", AtomicBoolean.class);
        assertTrue(b.get());
    }

    public void testAtomicInt() throws Exception
    {
        AtomicInteger value = MAPPER.readValue("13", AtomicInteger.class);
        assertEquals(13, value.get());
    }

    public void testAtomicLong() throws Exception
    {
        AtomicLong value = MAPPER.readValue("12345678901", AtomicLong.class);
        assertEquals(12345678901L, value.get());
    }

    public void testAtomicReference() throws Exception
    {
        AtomicReference<long[]> value = MAPPER.readValue("[1,2]",
                new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { });
        Object ob = value.get();
        assertNotNull(ob);
        assertEquals(long[].class, ob.getClass());
        long[] longs = (long[]) ob;
        assertNotNull(longs);
        assertEquals(2, longs.length);
        assertEquals(1, longs[0]);
        assertEquals(2, longs[1]);
    }

    // for [databind#811]
    public void testAbsentExclusion() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);
        assertEquals(aposToQuotes("{'value':true}"),
                mapper.writeValueAsString(new SimpleWrapper(Boolean.TRUE)));
        assertEquals(aposToQuotes("{}"),
                mapper.writeValueAsString(new SimpleWrapper(null)));
    }

    // [databind#340]
    public void testPolymorphicAtomicReference() throws Exception
    {
        RefWrapper input = new RefWrapper(13);
        String json = MAPPER.writeValueAsString(input);
        
        RefWrapper result = MAPPER.readValue(json, RefWrapper.class);
        assertNotNull(result.w);
        Object ob = result.w.get();
        assertEquals(Impl.class, ob.getClass());
        assertEquals(13, ((Impl) ob).value);
    }

    // [databind#740]
    public void testFilteringOfAtomicReference() throws Exception
    {
        SimpleWrapper input = new SimpleWrapper(null);
        ObjectMapper mapper = MAPPER;

        // by default, include as null
        assertEquals("{\"value\":null}", mapper.writeValueAsString(input));

        // ditto with "no nulls"
        mapper = new ObjectMapper().setSerializationInclusion(JsonInclude
                .Include.NON_NULL);
        assertEquals("{\"value\":null}", mapper.writeValueAsString(input));

        // but not with "non empty"
        mapper = new ObjectMapper().setSerializationInclusion(JsonInclude
                .Include.NON_EMPTY);
        assertEquals("{}", mapper.writeValueAsString(input));
    }

    public void testTypeRefinement() throws Exception
    {
        RefiningWrapper input = new RefiningWrapper();
        BigDecimal bd = new BigDecimal("0.25");
        input.value = new AtomicReference<Serializable>(bd);
        String json = MAPPER.writeValueAsString(input);

        // so far so good. But does it come back as expected?
        RefiningWrapper result = MAPPER.readValue(json, RefiningWrapper.class);
        assertNotNull(result.value);
        Object ob = result.value.get();
        assertEquals(BigDecimal.class, ob.getClass());
        assertEquals(bd, ob);
    }

    // [databind#882]: verify `@JsonDeserialize(contentAs=)` works with AtomicReference
    public void testDeserializeWithContentAs() throws Exception
    {
        AtomicRefReadWrapper result = MAPPER.readValue(aposToQuotes("{'value':'abc'}"),
                AtomicRefReadWrapper.class);
         Object v = result.value.get();
         assertNotNull(v);
         assertEquals(WrappedString.class, v.getClass());
         assertEquals("abc", ((WrappedString)v).value);
    }
    
    // [databind#932]: support unwrapping too
    public void testWithUnwrapping() throws Exception
    {
         String jsonExp = aposToQuotes("{'XX.name':'Bob'}");
         String jsonAct = MAPPER.writeValueAsString(new UnwrappingRefParent());
         assertEquals(jsonExp, jsonAct);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomFactory.java;<<<<<<< MINE
                    throw new JsonParseException("expecting number got "+ t, jp.getCurrentLocation());
=======
                    throw new JsonParseException(jp, "expecting number got "+ t);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java;<<<<<<< MINE
            verifyException(jme, "is not assignable to");
=======
            verifyException(jme, "not subtype of");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java;<<<<<<< MINE
            verifyException(jme, "is not assignable to");
=======
            verifyException(jme, "not subtype of");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/filter/JsonIncludeTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.filter;

import java.io.IOException;
import java.util.*;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

/**
 * Unit tests for checking that alternative settings for
 * {@link JsonSerialize#include} annotation property work
 * as expected.
 */
public class JsonIncludeTest
    extends BaseMapTest
{
    static class SimpleBean
    {
        public String getA() { return "a"; }
        public String getB() { return null; }
    }
    
    @JsonInclude(JsonInclude.Include.ALWAYS) // just to ensure default
    static class NoNullsBean
    {
        @JsonInclude(JsonInclude.Include.NON_NULL)
        public String getA() { return null; }

        public String getB() { return null; }
    }

    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
    static class NonDefaultBean
    {
        String _a = "a", _b = "b";

        NonDefaultBean() { }

        public String getA() { return _a; }
        public String getB() { return _b; }
    }

    // [databind#998]: Do not require no-arg constructor; but if not, defaults check
    //    has weaker interpretation
    @JsonPropertyOrder({ "x", "y", "z" })
    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
    static class NonDefaultBeanXYZ
    {
        public int x;
        public int y = 3;
        public int z = 7;

        NonDefaultBeanXYZ(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }
    
    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
    static class MixedBean
    {
        String _a = "a", _b = "b";

        MixedBean() { }

        public String getA() { return _a; }

        @JsonInclude(JsonInclude.Include.NON_NULL)
        public String getB() { return _b; }
    }

    // to ensure that default values work for collections as well
    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
    static class ListBean {
        public List<String> strings = new ArrayList<String>();
    }

    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
    static class ArrayBean {
        public int[] ints = new int[] { 1, 2 };
    }

    // Test to ensure that default exclusion works for fields too
    @JsonPropertyOrder({ "i1", "i2" })
    static class DefaultIntBean {
        @JsonInclude(JsonInclude.Include.NON_DEFAULT)
        public int i1;

        @JsonInclude(JsonInclude.Include.NON_DEFAULT)
        public Integer i2;

        public DefaultIntBean(int i1, Integer i2) {
            this.i1 = i1;
            this.i2 = i2;
        }
    }

    static class NonEmptyString {
        @JsonInclude(JsonInclude.Include.NON_EMPTY)
        public String value;

        public NonEmptyString(String v) { value = v; }
    }

    static class NonEmptyInt {
        @JsonInclude(JsonInclude.Include.NON_EMPTY)
        public int value;

        public NonEmptyInt(int v) { value = v; }
    }

    static class NonEmptyDouble {
        @JsonInclude(JsonInclude.Include.NON_EMPTY)
        public double value;

        public NonEmptyDouble(double v) { value = v; }
    }
    
    /*
    /**********************************************************
    /* Unit tests
    /**********************************************************
     */

    final private ObjectMapper MAPPER = new ObjectMapper();

    public void testGlobal() throws IOException
    {
        Map<String,Object> result = writeAndMap(MAPPER, new SimpleBean());
        assertEquals(2, result.size());
        assertEquals("a", result.get("a"));
        assertNull(result.get("b"));
        assertTrue(result.containsKey("b"));
    }

    public void testNonNullByClass() throws IOException
    {
        Map<String,Object> result = writeAndMap(MAPPER, new NoNullsBean());
        assertEquals(1, result.size());
        assertFalse(result.containsKey("a"));
        assertNull(result.get("a"));
        assertTrue(result.containsKey("b"));
        assertNull(result.get("b"));
    }

    public void testNonDefaultByClass() throws IOException
    {
        NonDefaultBean bean = new NonDefaultBean();
        // need to change one of defaults
        bean._a = "notA";
        Map<String,Object> result = writeAndMap(MAPPER, bean);
        assertEquals(1, result.size());
        assertTrue(result.containsKey("a"));
        assertEquals("notA", result.get("a"));
        assertFalse(result.containsKey("b"));
        assertNull(result.get("b"));
    }

    // [databind#998]
    public void testNonDefaultByClassNoCtor() throws IOException
    {
        NonDefaultBeanXYZ bean = new NonDefaultBeanXYZ(1, 2, 0);
        String json = MAPPER.writeValueAsString(bean);
        assertEquals(aposToQuotes("{'x':1,'y':2}"), json);
    }
    
    public void testMixedMethod() throws IOException
    {
        MixedBean bean = new MixedBean();
        bean._a = "xyz";
        bean._b = null;
        Map<String,Object> result = writeAndMap(MAPPER, bean);
        assertEquals(1, result.size());
        assertEquals("xyz", result.get("a"));
        assertFalse(result.containsKey("b"));

        bean._a = "a";
        bean._b = "b";
        result = writeAndMap(MAPPER, bean);
        assertEquals(1, result.size());
        assertEquals("b", result.get("b"));
        assertFalse(result.containsKey("a"));
    }

    public void testDefaultForEmptyList() throws IOException
    {
        assertEquals("{}", MAPPER.writeValueAsString(new ListBean()));
    }

    // NON_DEFAULT shoud work for arrays too
    public void testNonEmptyDefaultArray() throws IOException
    {
        assertEquals("{}", MAPPER.writeValueAsString(new ArrayBean()));
    }

    public void testDefaultForIntegers() throws IOException
    {
        assertEquals("{}", MAPPER.writeValueAsString(new DefaultIntBean(0, Integer.valueOf(0))));
        assertEquals("{\"i2\":1}", MAPPER.writeValueAsString(new DefaultIntBean(0, Integer.valueOf(1))));
        assertEquals("{\"i1\":3}", MAPPER.writeValueAsString(new DefaultIntBean(3, Integer.valueOf(0))));
    }

    public void testEmptyInclusionScalars() throws IOException
    {
        ObjectMapper defMapper = MAPPER;
        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);

        // First, Strings
        StringWrapper str = new StringWrapper("");
        assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));
        assertEquals("{}", inclMapper.writeValueAsString(str));
        assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));

        assertEquals("{\"value\":\"x\"}", defMapper.writeValueAsString(new NonEmptyString("x")));
        assertEquals("{}", defMapper.writeValueAsString(new NonEmptyString("")));

        // Then numbers
        // 11-Nov-2015, tatu: As of Jackson 2.7, scalars should NOT be considered empty,
        //   except for wrappers if they are `null`
        assertEquals("{\"value\":12}", defMapper.writeValueAsString(new NonEmptyInt(12)));
        assertEquals("{\"value\":0}", defMapper.writeValueAsString(new NonEmptyInt(0)));

        assertEquals("{\"value\":1.25}", defMapper.writeValueAsString(new NonEmptyDouble(1.25)));
        assertEquals("{\"value\":0.0}", defMapper.writeValueAsString(new NonEmptyDouble(0.0)));

        
        IntWrapper zero = new IntWrapper(0);
        assertEquals("{\"i\":0}", defMapper.writeValueAsString(zero));
        assertEquals("{\"i\":0}", inclMapper.writeValueAsString(zero));
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/filter/MapInclusionTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.filter;

import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.*;

public class MapInclusionTest extends BaseMapTest
{
    static class NoEmptiesMapContainer {
        @JsonInclude(value=JsonInclude.Include.NON_EMPTY,
                content=JsonInclude.Include.NON_EMPTY)
        public Map<String,String> stuff = new LinkedHashMap<String,String>();

        public NoEmptiesMapContainer add(String key, String value) {
            stuff.put(key, value);
            return this;
        }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    final private ObjectMapper MAPPER = objectMapper();

    // [databind#588]
    public void testNonNullValueMapViaProp() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoEmptiesMapContainer()
            .add("a", null)
            .add("b", ""));
        assertEquals(aposToQuotes("{}"), json);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/filter/NullSerializationTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.filter;

import java.io.*;

import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;
import com.fasterxml.jackson.databind.ser.SerializerFactory;

public class NullSerializationTest
    extends BaseMapTest
{
    static class NullSerializer extends JsonSerializer<Object>
    {
        @Override
        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider)
            throws IOException
        {
            gen.writeString("foobar");
        }
    }

    static class Bean1 {
        public String name = null;
    }

    static class Bean2 {
        public String type = null;
    }
    
    @SuppressWarnings("serial")
    static class MyNullProvider extends DefaultSerializerProvider
    {
        public MyNullProvider() { super(); }
        public MyNullProvider(MyNullProvider base, SerializationConfig config, SerializerFactory jsf) {
            super(base, config, jsf);
        }

        // not really a proper impl, but has to do
        @Override
        public DefaultSerializerProvider copy() {
            return this;
        }
        
        @Override
        public DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) {
            return new MyNullProvider(this, config, jsf);
        }

        @Override
        public JsonSerializer<Object> findNullValueSerializer(BeanProperty property)
            throws JsonMappingException
        {
            if ("name".equals(property.getName())) {
                return new NullSerializer();
            }
            return super.findNullValueSerializer(property);
        }
    }

    static class BeanWithNullProps
    {
        @JsonSerialize(nullsUsing=NullSerializer.class)
        public String a = null;
    }

/*
    @JsonSerialize(nullsUsing=NullSerializer.class)
    static class NullValuedType { }
*/
    
    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final ObjectMapper MAPPER = objectMapper();
    
    public void testSimple() throws Exception
    {
        assertEquals("null", MAPPER.writeValueAsString(null));
    }

    public void testOverriddenDefaultNulls() throws Exception
    {
        DefaultSerializerProvider sp = new DefaultSerializerProvider.Impl();
        sp.setNullValueSerializer(new NullSerializer());
        ObjectMapper m = new ObjectMapper();
        m.setSerializerProvider(sp);
        assertEquals("\"foobar\"", m.writeValueAsString(null));
    }

    public void testCustomNulls() throws Exception
    {
        ObjectMapper m = new ObjectMapper();
        m.setSerializerProvider(new MyNullProvider());
        assertEquals("{\"name\":\"foobar\"}", m.writeValueAsString(new Bean1()));
        assertEquals("{\"type\":null}", m.writeValueAsString(new Bean2()));
    }

    // #281
    public void testCustomNullForTrees() throws Exception
    {
        ObjectNode root = MAPPER.createObjectNode();
        root.putNull("a");

        // by default, null is... well, null
        assertEquals("{\"a\":null}", MAPPER.writeValueAsString(root));

        // but then we can customize it:
        DefaultSerializerProvider prov = new MyNullProvider();
        prov.setNullValueSerializer(new NullSerializer());
        ObjectMapper m = new ObjectMapper();
        m.setSerializerProvider(prov);
        assertEquals("{\"a\":\"foobar\"}", m.writeValueAsString(root));
    }

    /* 14-Oct-2013, tatu: Support for annotating classes is not
     *   implemented yet.
     */
/*    
    public void testNullSerializerViaClass() throws Exception
    {
        assertEquals("[\"foobar\"]",
                MAPPER.writeValueAsString(new NullValuedType[] { new NullValuedType() }));
    }
    */

    public void testNullSerializerForProperty() throws Exception
    {
        assertEquals("{\"a\":\"foobar\"}", MAPPER.writeValueAsString(new BeanWithNullProps()));
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.BaseMapTest;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java;<<<<<<< MINE

import com.fasterxml.jackson.databind.BaseMapTest;
=======
import java.util.concurrent.TimeUnit;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java;<<<<<<< MINE
=======

    public void testParseRfc3339Examples() throws java.text.ParseException {
        // Two digit milliseconds.
        Date d = ISO8601Utils.parse("1985-04-12T23:20:50.52Z", new ParsePosition(0));
        assertEquals(newDate(1985, 4, 12, 23, 20, 50, 520, 0), d);

        d = ISO8601Utils.parse("1996-12-19T16:39:57-08:00", new ParsePosition(0));
        assertEquals(newDate(1996, 12, 19, 16, 39, 57, 0, -8 * 60), d);

        // Truncated leap second.
        d = ISO8601Utils.parse("1990-12-31T23:59:60Z", new ParsePosition(0));
        assertEquals(newDate(1990, 12, 31, 23, 59, 59, 0, 0), d);

        // Truncated leap second.
        d = ISO8601Utils.parse("1990-12-31T15:59:60-08:00", new ParsePosition(0));
        assertEquals(newDate(1990, 12, 31, 15, 59, 59, 0, -8 * 60), d);

        // Two digit milliseconds.
        d = ISO8601Utils.parse("1937-01-01T12:00:27.87+00:20", new ParsePosition(0));
        assertEquals(newDate(1937, 1, 1, 12, 0, 27, 870, 20), d);
    }

    public void testFractionalSeconds() throws java.text.ParseException {
        Date d = ISO8601Utils.parse("1970-01-01T00:00:00.9Z", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 900, 0), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.09Z", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 90, 0), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.009Z", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 9, 0), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.0009Z", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 0, 0), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.2147483647Z", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 214, 0), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.2147483648Z", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 214, 0), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.9+02:00", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 900, 2 * 60), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.09+02:00", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 90, 2 * 60), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.009+02:00", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 9, 2 * 60), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.0009+02:00", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 0, 2 * 60), d);

        d = ISO8601Utils.parse("1970-01-01T00:00:00.2147483648+02:00", new ParsePosition(0));
        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 214, 2 * 60), d);
    }

    public void testDecimalWithoutDecimalPointButNoFractionalSeconds() throws java.text.ParseException {
        try {
            ISO8601Utils.parse("1970-01-01T00:00:00.Z", new ParsePosition(0));
            fail();
        } catch (ParseException expected) {
        }
    }

    private Date newDate(int year, int month, int day, int hour,
                         int minute, int second, int millis, int timezoneOffsetMinutes) {
        Calendar calendar = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
        calendar.set(year, month - 1, day, hour, minute, second);
        calendar.set(Calendar.MILLISECOND, millis);
        return new Date(calendar.getTimeInMillis() - TimeUnit.MINUTES.toMillis(timezoneOffsetMinutes));
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/util/TestClassUtil.java;<<<<<<< MINE
import static org.junit.Assert.*;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/util/TestClassUtil.java;<<<<<<< MINE
    public void testSuperTypes()
    {
        Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null);
        Class<?>[] classes = result.toArray(new Class<?>[result.size()]);
        Class<?>[] exp = new Class[] {
            SubInt.class, BaseInt.class,
            BaseClass.class,
            Comparable.class
        };
        assertArrayEquals(exp, classes);
    }

    public void testSuperInterfaces()
    {
        Collection<Class<?>> result = ClassUtil.findSuperTypes(SubInt.class, null);
        Class<?>[] classes = result.toArray(new Class<?>[result.size()]);
        Class<?>[] exp = new Class[] {
            BaseInt.class
        };
        assertArrayEquals(exp, classes);
    }
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestScalars.java;<<<<<<< MINE
=======
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestScalars.java;<<<<<<< MINE
=======

    static class ScalarList {
        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)
        public List<Object> values = new ArrayList<Object>();

        public ScalarList() { }

        public ScalarList add(Object v) {
            values.add(v);
            return this;
        }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestScalars.java;<<<<<<< MINE
=======

    final ObjectMapper MAPPER = new ObjectMapper();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestScalars.java;<<<<<<< MINE
        ObjectMapper m = new ObjectMapper();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestScalars.java;<<<<<<< MINE
=======
        ObjectMapper m = MAPPER;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestScalars.java;<<<<<<< MINE
        ObjectMapper m = new ObjectMapper();
=======
        ObjectMapper m = MAPPER;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestScalars.java;<<<<<<< MINE
=======

    // Test inspired by [databind#1104]
    public void testHeterogenousStringScalars() throws Exception
    {
        final UUID NULL_UUID = UUID.fromString("00000000-0000-0000-0000-000000000000");
        ScalarList input = new ScalarList()
                .add("Test")
                .add(java.lang.Object.class)
                .add(NULL_UUID)
                ;
        String json = MAPPER.writeValueAsString(input);

        ScalarList result = MAPPER.readValue(json, ScalarList.class);
        assertNotNull(result.values);
        assertEquals(3, result.values.size());
        assertEquals("Test", result.values.get(0));
        assertEquals(Object.class, result.values.get(1));
        assertEquals(NULL_UUID, result.values.get(2));
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java;<<<<<<< MINE
    static class CustomResolver extends CustomResolverBase {
=======
    static class CustomResolver extends TestCustomResolverBase {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java;<<<<<<< MINE
    static class ExtResolver extends CustomResolverBase {
=======
    static class ExtResolver extends TestCustomResolverBase {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java;<<<<<<< MINE
    static class CustomResolverBase extends TypeIdResolverBase
=======
    static class TestCustomResolverBase extends TypeIdResolverBase
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java;<<<<<<< MINE
        public CustomResolverBase(Class<?> baseType, Class<?> implType) {
=======
        public TestCustomResolverBase(Class<?> baseType, Class<?> implType) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/misc/TestJSONP.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.type.TypeFactory;
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/misc/TestJSONP.java;<<<<<<< MINE
        JavaType type = TypeFactory.defaultInstance().uncheckedSimpleType(Base.class);
=======
        JavaType type = m.constructType(Base.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/creators/DelegatingExternalProperty1003Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.creators;

import com.fasterxml.jackson.annotation.*;

import com.fasterxml.jackson.databind.*;

public class DelegatingExternalProperty1003Test extends BaseMapTest
{
    static class HeroBattle {

        private final Hero hero;

        private HeroBattle(Hero hero) {
            if (hero == null) throw new Error();
            this.hero = hero;
        }

        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "heroType")
        public Hero getHero() {
            return hero;
        }

        @JsonCreator
        static HeroBattle fromJson(Delegate json) {
            return new HeroBattle(json.hero);
        }
    }

    static class Delegate {
        @JsonProperty
        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "heroType")
        public Hero hero;
    }

    public interface Hero { }

    static class Superman implements Hero {
        String name = "superman";

        public String getName() {
            return name;
        }
    }    

    public void testExtrnalPropertyDelegatingCreator() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();

        final String json = mapper.writeValueAsString(new HeroBattle(new Superman()));

        final HeroBattle battle = mapper.readValue(json, HeroBattle.class);

        assertTrue(battle.getHero() instanceof Superman);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorWithNamingStrategy556.java;<<<<<<< MINE
            .setPropertyNamingStrategy(PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)
=======
            .setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/struct/FormatFeaturesTest.java;<<<<<<< MINE
=======
    static class StringArrayWrapper {
        @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
        public String[] values;
    }

    static class IntArrayWrapper {
        @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
        public int[] values;
    }
    static class LongArrayWrapper {
        @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
        public long[] values;
    }

    
    static class StringListWrapper {
        @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
        public List<String> values;
    }

    static class EnumSetWrapper {
        @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
        public EnumSet<ABC> values;
    }
    
    static class RolesInArray {
        @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
        public Role[] roles;
    }

    static class RolesInList {
        @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
        public List<Role> roles;
    }
    
    static class Role {
        public String ID;
        public String Name;
    }

    /*
    /**********************************************************
    /* Test methods, writing with single-element unwrapping
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/struct/FormatFeaturesTest.java;<<<<<<< MINE
=======

    /*
    /**********************************************************
    /* Test methods, reading with single-element unwrapping
    /**********************************************************
     */

    public void testSingleStringArrayRead() throws Exception {
        String json = aposToQuotes(
                "{ 'values': 'first' }");
        StringArrayWrapper result = MAPPER.readValue(json, StringArrayWrapper.class);
        assertNotNull(result.values);
        assertEquals(1, result.values.length);
        assertEquals("first", result.values[0]);
    }

    public void testSingleIntArrayRead() throws Exception {
        String json = aposToQuotes(
                "{ 'values': 123 }");
        IntArrayWrapper result = MAPPER.readValue(json, IntArrayWrapper.class);
        assertNotNull(result.values);
        assertEquals(1, result.values.length);
        assertEquals(123, result.values[0]);
    }

    public void testSingleLongArrayRead() throws Exception {
        String json = aposToQuotes(
                "{ 'values': -205 }");
        LongArrayWrapper result = MAPPER.readValue(json, LongArrayWrapper.class);
        assertNotNull(result.values);
        assertEquals(1, result.values.length);
        assertEquals(-205L, result.values[0]);
    }

    public void testSingleElementArrayRead() throws Exception {
        String json = aposToQuotes(
                "{ 'roles': { 'Name': 'User', 'ID': '333' } }");
        RolesInArray response = MAPPER.readValue(json, RolesInArray.class);
        assertNotNull(response.roles);
        assertEquals(1, response.roles.length);
        assertEquals("333", response.roles[0].ID);
    }
    
    public void testSingleStringListRead() throws Exception {
        String json = aposToQuotes(
                "{ 'values': 'first' }");
        StringListWrapper result = MAPPER.readValue(json, StringListWrapper.class);
        assertNotNull(result.values);
        assertEquals(1, result.values.size());
        assertEquals("first", result.values.get(0));
    }

    public void testSingleElementListRead() throws Exception {
        String json = aposToQuotes(
                "{ 'roles': { 'Name': 'User', 'ID': '333' } }");
        RolesInList response = MAPPER.readValue(json, RolesInList.class);
        assertNotNull(response.roles);
        assertEquals(1, response.roles.size());
        assertEquals("333", response.roles.get(0).ID);
    }

    public void testSingleEnumSetRead() throws Exception {
        String json = aposToQuotes("{ 'values': 'B' }");
        EnumSetWrapper result = MAPPER.readValue(json, EnumSetWrapper.class);
        assertNotNull(result.values);
        assertEquals(1, result.values.size());
        assertEquals(ABC.B, result.values.iterator().next());
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java;<<<<<<< MINE
=======
    // [databind#357]
    static class Value { }

    static class ListWrapper {
        @JsonSerialize(contentConverter = ValueToStringListConverter.class)
        public List<Value> list = Arrays.asList(new Value());
    }

    static class ValueToStringListConverter extends StdConverter<Value, List<String>> {
        @Override
        public List<String> convert(Value value) {
            return Arrays.asList("Hello world!");
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java;<<<<<<< MINE
    // [Issue#359]
=======
    // [databind#359]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java;<<<<<<< MINE
=======

    // [databind#357]
    public void testConverterForList357() throws Exception {
        String json = objectWriter().writeValueAsString(new ListWrapper());
        assertEquals("{\"list\":[[\"Hello world!\"]]}", json);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java;<<<<<<< MINE
            verifyException(e, "from String value 'foobar'");
=======
            verifyException(e, "from String value (\"foobar\")");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
        public JavaType modifyType(JavaType type, Type jdkType, TypeBindings context, TypeFactory typeFactory)
=======
        public JavaType modifyType(JavaType type, Type jdkType, TypeBindings bindings, TypeFactory typeFactory)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
            Class<?> raw = type.getRawClass();
            if (MapMarker.class.isAssignableFrom(raw)) {
                JavaType[] params = typeFactory.findTypeParameters(type, MapMarker.class);
                return typeFactory.constructMapLikeType(raw, params[0], params[1]);
            }
            if (CollectionMarker.class.isAssignableFrom(raw)) {
                JavaType[] params = typeFactory.findTypeParameters(type, CollectionMarker.class);
                return typeFactory.constructCollectionLikeType(raw, params[0]);
=======
            if (!type.isContainerType()) { // not 100% required, minor optimization
                Class<?> raw = type.getRawClass();
                if (raw == MapMarker.class) {
                    return MapLikeType.upgradeFrom(type, type.containedType(0), type.containedType(1));
                }
                if (raw == CollectionMarker.class) {
                    return CollectionLikeType.upgradeFrom(type, type.containedType(0));
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
    public void testLikeTypeConstruction() throws Exception
=======
    public void testMapLikeTypeConstruction() throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
        
        type = mapper.constructType(MyCollectionLikeType.class);
=======
    }
    
    public void testCollectionLikeTypeConstruction() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));

        JavaType type = mapper.constructType(MyCollectionLikeType.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
        param = ((CollectionLikeType) type).getContentType();
=======
        JavaType param = ((CollectionLikeType) type).getContentType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java;<<<<<<< MINE
        public TestEnum deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
            String code = jp.getText();
=======
        public TestEnum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
            String code = p.getText();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestCustomEnumKeyDeserializer.java;<<<<<<< MINE
                throw new InvalidFormatException("Undefined ISO-639 language code", jp.getCurrentLocation(), code, TestEnum.class);
=======
                throw InvalidFormatException.from(p, "Undefined ISO-639 language code",
                        code, TestEnum.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java;<<<<<<< MINE
=======
import java.util.Arrays;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java;<<<<<<< MINE
        .writeAll(new Bean[] { new Bean(3), new Bean(1) });
=======
        .writeAll(new Bean[] { new Bean(3), new Bean(1) })
        .writeAll(Arrays.asList(new Bean(5), new Bean(7)))
        ;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java;<<<<<<< MINE
        assertEquals(aposToQuotes("{'a':13}\n{'a':-6}\n{'a':3}\n{'a':1}"),
=======
        assertEquals(aposToQuotes("{'a':13}\n{'a':-6}\n{'a':3}\n{'a':1}\n{'a':5}\n{'a':7}"),
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ext/TestJdk16Types.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.ext;

import java.util.Deque;
import java.util.NavigableSet;

import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Tests to ensure that we can handle 1.6-only types, even if
 * registrations are done without direct refs
 */
public class TestJdk16Types extends com.fasterxml.jackson.databind.BaseMapTest
{
    // for [databind#216]
    public void test16Types() throws Exception
    {
        final ObjectMapper mapper = new ObjectMapper();
        Deque<?> dq = mapper.readValue("[1]", Deque.class);
        assertNotNull(dq);
        assertEquals(1, dq.size());
        assertTrue(dq instanceof Deque<?>);

        NavigableSet<?> ns = mapper.readValue("[ true ]", NavigableSet.class);
        assertEquals(1, ns.size());
        assertTrue(ns instanceof NavigableSet<?>);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ext/TestJdk7Types.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.ext;

import java.nio.file.Path;
import java.nio.file.Paths;

import com.fasterxml.jackson.databind.*;

/**
 * @since 2.7
 */
public class TestJdk7Types extends BaseMapTest
{
    public void testPathRoundtrip() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
    
        // Start with serialization, actually
        Path input = Paths.get("tmp", "foo.txt");

        String json = mapper.writeValueAsString(input);
        assertNotNull(json);
        
        Path p = mapper.readValue(json, Path.class);
        assertNotNull(p);
        
        assertEquals(input.toUri(), p.toUri());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java;<<<<<<< MINE
    // [Issue-14]
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java;<<<<<<< MINE
        assertTrue(result.containsKey("id"));
        assertTrue(result.containsKey("name"));
=======
        if (!result.containsKey("id")
                || !result.containsKey("name")) {
            fail("Should have both 'id' and 'name', but content = "+result);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/interop/DeprecatedTypeHandling1102Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.interop;

import java.util.*;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.databind.type.MapType;
import com.fasterxml.jackson.databind.type.SimpleType;
import com.fasterxml.jackson.databind.type.TypeFactory;

/**
 * Set of tests to ensure that changes between 2.6 and 2.7 can
 * be handled somewhat gracefully.
 */
public class DeprecatedTypeHandling1102Test extends BaseMapTest
{
    static class Point {
        public int x;

        int _y;

        public void setY(int y0) { _y = y0; }
        public int getY() { return _y; }
    }

    static class Point3D extends Point {
        public int z;
    }
    
    final ObjectMapper MAPPER = objectMapper();

    @SuppressWarnings("deprecation")
    public void testSimplePOJOType() throws Exception
    {
        JavaType elem = SimpleType.construct(Point.class);

        Point p = MAPPER.readValue(aposToQuotes("{'x':1,'y':2}"), elem);
        assertNotNull(p);
        assertEquals(1, p.x);
        assertEquals(2, p.getY());
    }

    @SuppressWarnings("deprecation")
    public void testPOJOSubType() throws Exception
    {
        JavaType elem = SimpleType.construct(Point3D.class);

        Point3D p = MAPPER.readValue(aposToQuotes("{'x':1,'z':3,'y':2}"), elem);
        assertNotNull(p);
        assertEquals(1, p.x);
        assertEquals(2, p.getY());
        assertEquals(3, p.z);
    }
    
    @SuppressWarnings("deprecation")
    public void testExplicitCollectionType() throws Exception
    {
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = CollectionType.construct(List.class, elem);

        final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]");        

        List<Point> l = MAPPER.readValue(json, t);
        assertNotNull(l);
        assertEquals(2, l.size());
        Object ob = l.get(0);
        assertEquals(Point.class, ob.getClass());
        Point p = (Point) ob;
        assertEquals(1, p.x);
        assertEquals(2, p.getY());
    }

    @SuppressWarnings("deprecation")
    public void testExplicitMapType() throws Exception
    {
        JavaType key = SimpleType.construct(String.class);
        JavaType elem = SimpleType.construct(Point.class);
        JavaType t = MapType.construct(Map.class, key, elem);

        final String json = aposToQuotes("{'x':{'x':3,'y':5}}");        

        Map<String,Point> m = MAPPER.readValue(json, t);
        assertNotNull(m);
        assertEquals(1, m.size());
        Object ob = m.values().iterator().next();
        assertEquals(Point.class, ob.getClass());
        Point p = (Point) ob;
        assertEquals(3, p.x);
        assertEquals(5, p.getY());
    }

    @SuppressWarnings("deprecation")
    public void testDeprecatedTypeResolution() throws Exception
    {
        TypeFactory tf = MAPPER.getTypeFactory();

        // first, with real (if irrelevant) context
        JavaType t = tf.constructType(Point.class, getClass());
        assertEquals(Point.class, t.getRawClass());

        // and then missing context
        JavaType t2 = tf.constructType(Point.class, (Class<?>) null);
        assertEquals(Point.class, t2.getRawClass());

        JavaType ctxt = tf.constructType(getClass());
        JavaType t3 = tf.constructType(Point.class, ctxt);
        assertEquals(Point.class, t3.getRawClass());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestGenericsBounded.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.type;

import java.io.Serializable;
import java.util.*;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.*;

@SuppressWarnings("serial")
public class TestGenericsBounded
    extends BaseMapTest
{
    static class Range<E extends Comparable<E>> implements Serializable
    {
         protected E start, end;

         public Range(){ }
         public Range(E start, E end) {
             this.start = start;
             this.end = end;
         }

         public E getEnd() { return end; }
         public void setEnd(E e) { end = e; }

         public E getStart() { return start; }
         public void setStart(E s) {
             start = s;
         }
    }

    static class DoubleRange extends Range<Double> {
        public DoubleRange() { }
        public DoubleRange(Double s, Double e) { super(s, e); }
    }
     
    static class BoundedWrapper<A extends Serializable>
    {
        public List<A> values;
    }

    static class IntBean implements Serializable
    {
        public int x;
    }

    static class IntBeanWrapper<T extends IntBean> {
        public T wrapped;
    }

    // Types for [JACKSON-778]

    static class Document {}
    static class Row {}
    static class RowWithDoc<D extends Document> extends Row {
        @JsonProperty("d") D d;
    }
    static class ResultSet<R extends Row> {
        @JsonProperty("rows") List<R> rows;
    }
    static class ResultSetWithDoc<D extends Document> extends ResultSet<RowWithDoc<D>> {}

    static class MyDoc extends Document {}

    // [databind#537]
    interface AnnotatedValue<E> {
        public String getAnnotation();
        public E getValue();
    }

    static class AnnotatedValueSimple<E>
        implements AnnotatedValue<E>
    {
        protected E value;

        protected AnnotatedValueSimple() { }
        public AnnotatedValueSimple(E v) { value = v; }

        @Override
        public String getAnnotation() { return null; }

        @Override
        public E getValue() { return value; }
    }

    static class CbFailing<E extends AnnotatedValue<ID>, ID>
    {
        private E item;

        public CbFailing(E item) {
            this.item = item;
        }

        public E getItem() {
            return item;
        }

        public ID getId() {
            return item.getValue();
        }
    }

    /*
    /*******************************************************
    /* Unit tests
    /*******************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testLowerBound() throws Exception
    {
        IntBeanWrapper<?> result = MAPPER.readValue("{\"wrapped\":{\"x\":3}}",
                IntBeanWrapper.class);
        assertNotNull(result);
        assertEquals(IntBean.class, result.wrapped.getClass());
        assertEquals(3, result.wrapped.x);
    }
    
    // Test related to type bound handling problem within [JACKSON-190]
    public void testBounded() throws Exception
    {
        BoundedWrapper<IntBean> result = MAPPER.readValue
            ("{\"values\":[ {\"x\":3} ] } ", new TypeReference<BoundedWrapper<IntBean>>() {});
        List<?> list = result.values;
        assertEquals(1, list.size());
        Object ob = list.get(0);
        assertEquals(IntBean.class, ob.getClass());
        assertEquals(3, result.values.get(0).x);
    }

    public void testGenericsComplex() throws Exception
    {
        DoubleRange in = new DoubleRange(-0.5, 0.5);
        String json = MAPPER.writeValueAsString(in);
        DoubleRange out = MAPPER.readValue(json, DoubleRange.class);
        assertNotNull(out);
        assertEquals(-0.5, out.start);
        assertEquals(0.5, out.end);
    }

    public void testIssue778() throws Exception
    {
        String json = "{\"rows\":[{\"d\":{}}]}";

        final TypeReference<?> typeRef = new TypeReference<ResultSetWithDoc<MyDoc>>() {};

        // First, verify type introspection:

        JavaType type = MAPPER.getTypeFactory().constructType(typeRef);
        JavaType resultSetType = type.findSuperType(ResultSet.class);
        assertNotNull(resultSetType);
        assertEquals(1, resultSetType.containedTypeCount());

        JavaType rowType = resultSetType.containedType(0);
        assertNotNull(rowType);
        assertEquals(RowWithDoc.class, rowType.getRawClass());
        
        assertEquals(1, rowType.containedTypeCount());
        JavaType docType = rowType.containedType(0);
        assertEquals(MyDoc.class, docType.getRawClass());

        // type passed is correct, but somehow it gets mangled when passed...
        ResultSetWithDoc<MyDoc> rs = MAPPER.readValue(json, type);
        Document d = rs.rows.iterator().next().d;
    
        assertEquals(MyDoc.class, d.getClass()); //expected MyDoc but was Document
    }

    // [databind#537]
    public void test() throws Exception
    {
        AnnotatedValueSimple<Integer> item = new AnnotatedValueSimple<Integer>(5);
        CbFailing<AnnotatedValueSimple<Integer>, Integer> codebook = new CbFailing<AnnotatedValueSimple<Integer>, Integer>(item);
        String json = MAPPER.writeValueAsString(codebook);
        assertNotNull(json);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
import java.util.*;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE

        /* both narrow and widen just return type itself (exact, not just
         * equal)
         * (also note that widen/narrow wouldn't work on basic simple
         * class type otherwise)
         */
        assertSame(baseType, baseType.narrowBy(BaseType.class));
        assertSame(baseType, baseType.widenBy(BaseType.class));

        // Also: no narrowing for simple types (but should there be?)
        try {
            baseType.narrowBy(SubType.class);
        } catch (IllegalArgumentException e) {
            verifyException(e, "should never be called");
        }

        // Also, let's try assigning bogus handler
        /*
        baseType.setValueHandler("xyz"); // untyped
        assertEquals("xyz", baseType.getValueHandler());
        // illegal to re-set
        try {
            baseType.setValueHandler("foobar");
            fail("Shouldn't allow re-setting value handler");
        } catch (IllegalStateException iae) {
            verifyException(iae, "Trying to reset");
        }
        */
    }

    public void testMapType()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType keyT = tf.constructType(String.class);
        JavaType baseT = tf.constructType(BaseType.class);

        MapType mapT = MapType.construct(Map.class, keyT, baseT);
        assertNotNull(mapT);
        assertTrue(mapT.isContainerType());

        // NOPs:
        assertSame(mapT, mapT.narrowContentsBy(BaseType.class));
        assertSame(mapT, mapT.narrowKey(String.class));

        assertTrue(mapT.equals(mapT));
        assertFalse(mapT.equals(null));
        assertFalse(mapT.equals("xyz"));

        MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT);
        assertFalse(mapT.equals(mapT2));

        // Also, must use map type constructor, not simple...
        try {
            SimpleType.construct(HashMap.class);
        } catch (IllegalArgumentException e) {
            verifyException(e, "for a Map");
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
        JavaType arrayT = ArrayType.construct(tf.constructType(String.class), null, null);
=======
        JavaType arrayT = ArrayType.construct(tf.constructType(String.class), null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
        // NOPs:
        assertSame(arrayT, arrayT.narrowContentsBy(String.class));

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
        assertTrue(arrayT.equals(ArrayType.construct(tf.constructType(String.class), null, null)));
        assertFalse(arrayT.equals(ArrayType.construct(tf.constructType(Integer.class), null, null)));

        // Also, must NOT try to create using simple type
        try {
            SimpleType.construct(String[].class);
        } catch (IllegalArgumentException e) {
            verifyException(e, "for an array");
        }
    }

    public void testCollectionType()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        // List<String>
        JavaType collectionT = CollectionType.construct(List.class, tf.constructType(String.class));
        assertNotNull(collectionT);
        assertTrue(collectionT.isContainerType());

        // NOPs:
        assertSame(collectionT, collectionT.narrowContentsBy(String.class));

        assertNotNull(collectionT.toString());

        assertTrue(collectionT.equals(collectionT));
        assertFalse(collectionT.equals(null));
        assertFalse(collectionT.equals("xyz"));

        assertTrue(collectionT.equals(CollectionType.construct(List.class, tf.constructType(String.class))));
        assertFalse(collectionT.equals(CollectionType.construct(Set.class, tf.constructType(String.class))));

        // Also, must NOT try to create using simple type
        try {
            SimpleType.construct(ArrayList.class);
        } catch (IllegalArgumentException e) {
            verifyException(e, "for a Collection");
        }
=======
        assertTrue(arrayT.equals(ArrayType.construct(tf.constructType(String.class), null)));
        assertFalse(arrayT.equals(ArrayType.construct(tf.constructType(Integer.class), null)));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
    // [Issue#116]
=======
    // [databind#116]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
=======
import java.io.Serializable;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
=======
    static class Range<E extends Comparable<E>> implements Serializable
    {
         public Range(E start, E end) { }
    }

    static class DoubleRange extends Range<Double> {
        public DoubleRange() { super(null, null); }
        public DoubleRange(Double s, Double e) { super(s, e); }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
    public void testList()
=======
    public void testListViaTypeRef()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
        JavaType t;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
        t = tf.constructType(new TypeReference<MyLongList<Integer>>() {});
=======
        JavaType t = tf.constructType(new TypeReference<MyLongList<Integer>>() {});
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
=======
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
        t = tf.constructType(LongList.class);
        type = (CollectionType) t;
=======
    public void testListViaClass()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(LongList.class);
        JavaType type = (CollectionType) t;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
=======

    public void testGeneric()
    {
        TypeFactory tf = TypeFactory.defaultInstance();

        // First, via simple sub-class
        JavaType t = tf.constructType(DoubleRange.class);
        JavaType rangeParams = t.findSuperType(Range.class);
        assertEquals(1, rangeParams.containedTypeCount());
        assertEquals(Double.class, rangeParams.containedType(0).getRawClass());

        // then using TypeRef
        t = tf.constructType(new TypeReference<DoubleRange>() { });
        rangeParams = t.findSuperType(Range.class);
        assertEquals(1, rangeParams.containedTypeCount());
        assertEquals(Double.class, rangeParams.containedType(0).getRawClass());
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeBindings.java;<<<<<<< MINE
    
    public void testAbstract() throws Exception
    {
        /* Abstract type does declare type parameters, but they are only
         * known as 'Object.class' (via lower bound)
         */
        TypeFactory tf = TypeFactory.defaultInstance();
        TypeBindings b = new TypeBindings(tf, AbstractType.class);
        assertEquals(2, b.getBindingCount());
        JavaType obType = tf.constructType(Object.class);
        assertEquals(obType, b.findType("A", true));
        assertEquals(obType, b.findType("B", true));
    }

    public void testSimple() throws Exception
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        // concrete class does have bindings however
        TypeBindings b = new TypeBindings(tf, LongStringType.class);
        assertEquals(2, b.getBindingCount());
        assertEquals(tf.constructType(Long.class), b.findType("A", true));
        assertEquals(tf.constructType(String.class), b.findType("B", true));
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestAnnotatedClass.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.BaseMapTest;
=======
import com.fasterxml.jackson.databind.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestAnnotatedClass.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestAnnotatedClass.java;<<<<<<< MINE
=======
    private final ObjectMapper MAPPER = new ObjectMapper();
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestAnnotatedClass.java;<<<<<<< MINE
        // null -> no mix-in annotations
        AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null);
=======
        SerializationConfig config = MAPPER.getSerializationConfig();
        JavaType t = MAPPER.constructType(FieldBean.class);
        AnnotatedClass ac = AnnotatedClass.construct(t, config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestAnnotatedClass.java;<<<<<<< MINE
        AnnotatedClass ac = AnnotatedClass.construct(bean.getClass(),
                new JacksonAnnotationIntrospector(), null);
=======
        SerializationConfig config = MAPPER.getSerializationConfig();
        JavaType t = MAPPER.constructType(bean.getClass());
        AnnotatedClass ac = AnnotatedClass.construct(t, config);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/JavaType76Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.type;

import java.util.*;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.type.TypeFactory;

/**
 * Failing test related to [databind#76]
 */
public class JavaType76Test extends BaseMapTest
{
    @SuppressWarnings("serial")
    static class HashTree<K, V> extends HashMap<K, HashTree<K, V>> { }

    public void testRecursiveType()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType type = tf.constructType(HashTree.class);
        assertNotNull(type);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TypeAliasesTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.type;

import java.util.*;

import com.fasterxml.jackson.databind.*;

/**
 * Unit tests for more complicated type definitions where type name
 * aliasing can confuse naive resolution algorithms.
 */
public class TypeAliasesTest
    extends BaseMapTest
{
    public static abstract class Base<T> {
        public T inconsequential = null;
    }

    public static abstract class BaseData<T> {
        public T dataObj;
    }
   
    public static class Child extends Base<Long> {
        public static class ChildData extends BaseData<List<String>> { }
    }

    /*
    /*******************************************************
    /* Unit tests
    /*******************************************************
     */

    // Reproducing [databind#743]
    public void testAliasResolutionIssue743() throws Exception
    {
        String s3 = "{\"dataObj\" : [ \"one\", \"two\", \"three\" ] }";
        ObjectMapper m = new ObjectMapper();
   
        Child.ChildData d = m.readValue(s3, Child.ChildData.class);
        assertNotNull(d.dataObj);
        assertEquals(3, d.dataObj.size());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/PolymorphicList036Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.type;

import java.util.*;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.databind.*;

// For [databind#936], losing parametric type information it seems
public class PolymorphicList036Test extends BaseMapTest
{
    // note: would prefer using CharSequence, but while abstract, that's deserialized
    // just fine as ... String
    static class StringyList<T extends java.io.Serializable> implements Collection<T> {
        private Collection<T> _stuff;

        @JsonCreator
        public StringyList(Collection<T> src) {
            _stuff = new ArrayList<T>(src);
        }

        public StringyList() {
            _stuff = new ArrayList<T>();
        }
        
        @Override
        public boolean add(T arg) {
            return _stuff.add(arg);
        }

        @Override
        public boolean addAll(Collection<? extends T> args) {
            return _stuff.addAll(args);
        }

        @Override
        public void clear() {
            _stuff.clear();
        }

        @Override
        public boolean contains(Object arg) {
            return _stuff.contains(arg);
        }

        @Override
        public boolean containsAll(Collection<?> args) {
            return _stuff.containsAll(args);
        }

        @Override
        public boolean isEmpty() {
            return _stuff.isEmpty();
        }

        @Override
        public Iterator<T> iterator() {
            return _stuff.iterator();
        }

        @Override
        public boolean remove(Object arg) {
            return _stuff.remove(arg);
        }

        @Override
        public boolean removeAll(Collection<?> args) {
            return _stuff.removeAll(args);
        }

        @Override
        public boolean retainAll(Collection<?> args) {
            return _stuff.retainAll(args);
        }

        @Override
        public int size() {
            return _stuff.size();
        }

        @Override
        public Object[] toArray() {
            return _stuff.toArray();
        }

        @Override
        public <X> X[] toArray(X[] arg) {
            return _stuff.toArray(arg);
        }
    }

    private final ObjectMapper MAPPER = new ObjectMapper();
    
    public void testPolymorphicWithOverride() throws Exception
    {
        JavaType type = MAPPER.getTypeFactory().constructCollectionType(StringyList.class, String.class);
        
        StringyList<String> list = new StringyList<String>();
        list.add("value 1");
        list.add("value 2");
        
        String serialized = MAPPER.writeValueAsString(list);
//        System.out.println(serialized);
        
        StringyList<String> deserialized = MAPPER.readValue(serialized, type);
//        System.out.println(deserialized);
        
        assertNotNull(deserialized);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======

    static class CollectionLike<E> { }
    static class MapLike<K,V> { }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    public void testCollections()
    {
        // Ok, first: let's test what happens when we pass 'raw' Collection:
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType t = tf.constructType(ArrayList.class);
        assertEquals(CollectionType.class, t.getClass());
        assertSame(ArrayList.class, t.getRawClass());

        // And then the proper way
        t = tf.constructType(new TypeReference<ArrayList<String>>() { });
        assertEquals(CollectionType.class, t.getClass());
        assertSame(ArrayList.class, t.getRawClass());

        JavaType elemType = ((CollectionType) t).getContentType();
        assertNotNull(elemType);
        assertSame(SimpleType.class, elemType.getClass());
        assertSame(String.class, elemType.getRawClass());

        // And alternate method too
        t = tf.constructCollectionType(ArrayList.class, String.class);
        assertEquals(CollectionType.class, t.getClass());
        assertSame(String.class, ((CollectionType) t).getContentType().getRawClass());
    }

    public void testMaps()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        // Ok, first: let's test what happens when we pass 'raw' Map:
        JavaType t = tf.constructType(HashMap.class);
        assertEquals(MapType.class, t.getClass());
        assertSame(HashMap.class, t.getRawClass());

        // Then explicit construction
        t = tf.constructMapType(TreeMap.class, String.class, Integer.class);
        assertEquals(MapType.class, t.getClass());
        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());
        assertSame(Integer.class, ((MapType) t).getContentType().getRawClass());

        // And then with TypeReference
        t = tf.constructType(new TypeReference<HashMap<String,Integer>>() { });
        assertEquals(MapType.class, t.getClass());
        assertSame(HashMap.class, t.getRawClass());
        MapType mt = (MapType) t;
        assertEquals(tf.constructType(String.class), mt.getKeyType());
        assertEquals(tf.constructType(Integer.class), mt.getContentType());

        t = tf.constructType(new TypeReference<LongValuedMap<Boolean>>() { });
        assertEquals(MapType.class, t.getClass());
        assertSame(LongValuedMap.class, t.getRawClass());
        mt = (MapType) t;
        assertEquals(tf.constructType(Boolean.class), mt.getKeyType());
        assertEquals(tf.constructType(Long.class), mt.getContentType());
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
        MapType mt = (MapType) t;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());
        assertSame(String.class, ((MapType) t).getContentType().getRawClass());
=======
        assertSame(String.class, mt.getKeyType().getRawClass());
        assertSame(String.class, mt.getContentType().getRawClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
    @SuppressWarnings("deprecation")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
            verifyException(e, "Need exactly 2 parameter types for Map types");
=======
            verifyException(e, "Can not create TypeBindings for class java.util.Map");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
            verifyException(e, "expected 1 parameters, was given 2");
=======
            verifyException(e, "Can not create TypeBindings for class ");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    /* Unit tests: low-level inheritance resolution
=======
    /* Unit tests: collection type parameter resolution
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    public void testSuperTypeDetectionClass()
=======
    public void testCollections()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
        // Ok, first: let's test what happens when we pass 'raw' Collection:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        HierarchicType sub = tf._findSuperTypeChain(MyStringIntMap.class, HashMap.class);
        assertNotNull(sub);
        assertEquals(2, _countSupers(sub));
        assertSame(MyStringIntMap.class, sub.getRawClass());
        HierarchicType sup = sub.getSuperType();
        assertSame(MyStringXMap.class, sup.getRawClass());
        HierarchicType sup2 = sup.getSuperType();
        assertSame(HashMap.class, sup2.getRawClass());
        assertNull(sup2.getSuperType());
=======
        JavaType t = tf.constructType(ArrayList.class);
        assertEquals(CollectionType.class, t.getClass());
        assertSame(ArrayList.class, t.getRawClass());

        // And then the proper way
        t = tf.constructType(new TypeReference<ArrayList<String>>() { });
        assertEquals(CollectionType.class, t.getClass());
        assertSame(ArrayList.class, t.getRawClass());

        JavaType elemType = ((CollectionType) t).getContentType();
        assertNotNull(elemType);
        assertSame(SimpleType.class, elemType.getClass());
        assertSame(String.class, elemType.getRawClass());

        // And alternate method too
        t = tf.constructCollectionType(ArrayList.class, String.class);
        assertEquals(CollectionType.class, t.getClass());
        assertSame(String.class, ((CollectionType) t).getContentType().getRawClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE

    public void testSuperTypeDetectionInterface()
=======
    
    // since 2.7
    public void testCollectionTypesRefined()
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        // List first
        TypeFactory tf = TypeFactory.defaultInstance();
        HierarchicType sub = tf._findSuperTypeChain(MyList.class, List.class);
        assertNotNull(sub);
        assertEquals(2, _countSupers(sub));
        assertSame(MyList.class, sub.getRawClass());
        HierarchicType sup = sub.getSuperType();
        assertSame(IntermediateList.class, sup.getRawClass());
        HierarchicType sup2 = sup.getSuperType();
        assertSame(List.class, sup2.getRawClass());
        assertNull(sup2.getSuperType());
        
        // Then Map
        sub = tf._findSuperTypeChain(MyMap.class, Map.class);
        assertNotNull(sub);
        assertEquals(2, _countSupers(sub));
        assertSame(MyMap.class, sub.getRawClass());
        sup = sub.getSuperType();
        assertSame(IntermediateMap.class, sup.getRawClass());
        sup2 = sup.getSuperType();
        assertSame(Map.class, sup2.getRawClass());
        assertNull(sup2.getSuperType());
    }

    private int _countSupers(HierarchicType t)
    {
        int depth = 0;
        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {
            ++depth;
        }
        return depth;
=======
        TypeFactory tf = newTypeFactory();
        JavaType type = tf.constructType(new TypeReference<List<Long>>() { });
        assertEquals(List.class, type.getRawClass());
        assertEquals(Long.class, type.getContentType().getRawClass());
        // No super-class, since it's an interface:
        assertNull(type.getSuperClass());

        // But then refine to reflect sub-classing
        JavaType subtype = tf.constructSpecializedType(type, ArrayList.class);
        assertEquals(ArrayList.class, subtype.getRawClass());
        assertEquals(Long.class, subtype.getContentType().getRawClass());

        // but with refinement, should have non-null super class
        // 20-Oct-2015, tatu: For now refinement does not faithfully replicate the
        //    structure, it only retains most important information. Here it means
        //    that actually existing super-classes are skipped, and only original
        //    type is linked as expected
        /*
        JavaType superType = subtype.getSuperClass();
        assertNotNull(superType);
        assertEquals(AbstractList.class, superType.getRawClass());
        */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    /* Unit tests: map/collection type parameter resolution
=======
    /* Unit tests: map type parameter resolution
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
    
    public void testMaps()
    {
        TypeFactory tf = newTypeFactory();

        // Ok, first: let's test what happens when we pass 'raw' Map:
        JavaType t = tf.constructType(HashMap.class);
        assertEquals(MapType.class, t.getClass());
        assertSame(HashMap.class, t.getRawClass());

        // Then explicit construction
        t = tf.constructMapType(TreeMap.class, String.class, Integer.class);
        assertEquals(MapType.class, t.getClass());
        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());
        assertSame(Integer.class, ((MapType) t).getContentType().getRawClass());

        // And then with TypeReference
        t = tf.constructType(new TypeReference<HashMap<String,Integer>>() { });
        assertEquals(MapType.class, t.getClass());
        assertSame(HashMap.class, t.getRawClass());
        MapType mt = (MapType) t;
        assertEquals(tf.constructType(String.class), mt.getKeyType());
        assertEquals(tf.constructType(Integer.class), mt.getContentType());

        t = tf.constructType(new TypeReference<LongValuedMap<Boolean>>() { });
        assertEquals(MapType.class, t.getClass());
        assertSame(LongValuedMap.class, t.getRawClass());
        mt = (MapType) t;
        assertEquals(tf.constructType(Boolean.class), mt.getKeyType());
        assertEquals(tf.constructType(Long.class), mt.getContentType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    public void testMapTypesSimple()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
    // since 2.7
    public void testMapTypesRefined()
    {
        TypeFactory tf = newTypeFactory();
        JavaType type = tf.constructType(new TypeReference<Map<String,List<Integer>>>() { });
        MapType mapType = (MapType) type;
        assertEquals(Map.class, mapType.getRawClass());
        assertEquals(String.class, mapType.getKeyType().getRawClass());
        assertEquals(List.class, mapType.getContentType().getRawClass());
        assertEquals(Integer.class, mapType.getContentType().getContentType().getRawClass());
        // No super-class, since it's an interface:
        assertNull(type.getSuperClass());
        
        // But then refine to reflect sub-classing
        JavaType subtype = tf.constructSpecializedType(type, LinkedHashMap.class);
        assertEquals(LinkedHashMap.class, subtype.getRawClass());
        assertEquals(String.class, subtype.getKeyType().getRawClass());
        assertEquals(List.class, subtype.getContentType().getRawClass());
        assertEquals(Integer.class, subtype.getContentType().getContentType().getRawClass());

        // but with refinement, should have non-null super class
        // 20-Oct-2015, tatu: For now refinement does not faithfully replicate the
        //    structure, it only retains most important information. Here it means
        //    that actually existing super-classes are skipped, and only original
        //    type is linked as expected

        /*
        JavaType superType = subtype.getSuperClass();
        assertNotNull(superType);
        assertEquals(HashMap.class, superType.getRawClass());
        // which also should have proper typing
        assertEquals(String.class, superType.getKeyType().getRawClass());
        assertEquals(List.class, superType.getContentType().getRawClass());
        assertEquals(Integer.class, superType.getContentType().getContentType().getRawClass());
        */
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE

=======
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    public void testAtomicArrayRefParameterDetection()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType type = tf.constructType(new TypeReference<AtomicReference<long[]>>() { });
        HierarchicType sub = tf._findSuperTypeChain(type.getRawClass(), AtomicReference.class);
        assertNotNull(sub);
        assertEquals(0, _countSupers(sub));
        assertTrue(AtomicReference.class.isAssignableFrom(type.getRawClass()));
        assertNull(sub.getSuperType());
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        assertTrue(t.hasGenericTypes());
        assertEquals(2, t.containedTypeCount());
        assertEquals(String.class, t.containedType(0).getRawClass());
        assertEquals(Integer.class, t.containedType(1).getRawClass());
        // NOTE: no key/content types, at least not as of 2.5
=======
        JavaType mapEntryType = t.findSuperType(Map.Entry.class);
        assertNotNull(mapEntryType);
        assertTrue(mapEntryType.hasGenericTypes());
        assertEquals(2, mapEntryType.containedTypeCount());
        assertEquals(String.class, mapEntryType.containedType(0).getRawClass());
        assertEquals(Integer.class, mapEntryType.containedType(1).getRawClass());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
        type = tf.constructRawCollectionLikeType(CollectionLike.class); // must have type vars
        assertTrue(type.isCollectionLikeType());
        assertEquals(TypeFactory.unknownType(), type.getContentType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        type = tf.constructRawCollectionLikeType(String.class); // class doesn't really matter
=======
        // actually, should also allow "no type vars" case
        type = tf.constructRawCollectionLikeType(String.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        type = tf.constructRawMapLikeType(String.class); // class doesn't really matter
=======
        type = tf.constructRawMapLikeType(MapLike.class); // must have type vars
        assertTrue(type.isMapLikeType());
        assertEquals(TypeFactory.unknownType(), type.getKeyType());
        assertEquals(TypeFactory.unknownType(), type.getContentType());

        // actually, should also allow "no type vars" case
        type = tf.constructRawMapLikeType(String.class);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    // [Issue#489]
=======
    // [databind#489]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        assertEquals(1, tf._typeCache.size());
=======
        // 19-Oct-2015, tatu: This is pretty fragile but
        assertEquals(6, tf._typeCache.size());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/views/ViewsWithSchemaTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.views;

import java.util.*;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.jsonFormatVisitors.*;

public class ViewsWithSchemaTest extends BaseMapTest
{
    interface ViewBC { }
    interface ViewAB { }

    @JsonPropertyOrder({ "a", "b", "c" })
    static class POJO {
        @JsonView({ ViewAB.class })
        public int a;

        @JsonView({ ViewAB.class, ViewBC.class })
        public int b;
        
        @JsonView({ ViewBC.class })
        public int c;
    }

    static class ListingVisitor extends JsonFormatVisitorWrapper.Base
    {
        public final List<String> names = new ArrayList<String>();

        @Override
        public JsonObjectFormatVisitor expectObjectFormat(JavaType type) {
            return new JsonObjectFormatVisitor.Base() {
                @Override
                public void optionalProperty(BeanProperty writer) {
                    names.add(writer.getName());
                }

                @Override
                public void optionalProperty(String name,
                        JsonFormatVisitable handler, JavaType propertyTypeHint) {
                    names.add(name);
                }
            };
        }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */
    
    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testSchemaWithViews() throws Exception
    {
        ListingVisitor v = new ListingVisitor();
        MAPPER.writerWithView(ViewBC.class)
            .acceptJsonFormatVisitor(POJO.class, v);
        assertEquals(Arrays.asList("b", "c"), v.names);

        v = new ListingVisitor();
        MAPPER.writerWithView(ViewAB.class)
            .acceptJsonFormatVisitor(POJO.class, v);
        assertEquals(Arrays.asList("a", "b"), v.names);
    }

    public void testSchemaWithoutViews() throws Exception
    {
        ListingVisitor v = new ListingVisitor();
        MAPPER.acceptJsonFormatVisitor(POJO.class, v);
        assertEquals(Arrays.asList("a", "b", "c"), v.names);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java;<<<<<<< MINE
    public void test() throws IOException
=======
    public void test868() throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
=======
import java.math.BigDecimal;
import java.math.BigInteger;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
=======

    @JsonPropertyOrder({ "dec", "bigInt" })
    static class Numbers {
        public BigDecimal dec;
        public BigInteger bigInt;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
    public void testGeneratingJsonSchema()
        throws Exception
=======
    public void testOldSchemaGeneration() throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
    public void testSchemaSerialization()
            throws Exception
=======
    public void testSchemaSerialization() throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
	Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);
	assertNotNull(result);
	// no need to check out full structure, just basics...
	assertEquals("object", result.get("type"));
	// only add 'required' if it is true...
	assertNull(result.get("required"));
	assertNotNull(result.get("properties"));
    }

    public void testInvalidCall()
        throws Exception
    {
        // not ok to pass null
        try {
            MAPPER.generateJsonSchema(null);
            fail("Should have failed");
        } catch (IllegalArgumentException iae) {
            verifyException(iae, "class must be provided");
        }
=======
        Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);
        assertNotNull(result);
        // no need to check out full structure, just basics...
        assertEquals("object", result.get("type"));
        // only add 'required' if it is true...
        assertNull(result.get("required"));
        assertNotNull(result.get("properties"));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
    /**
     * Test for [JACKSON-454]
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
    // [Issue#271]
=======
    // [databind#271]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
=======
    // 
    public void testNumberTypes()  throws Exception
    {
        JsonSchema jsonSchema = MAPPER.generateJsonSchema(Numbers.class);
        String json = quotesToApos(jsonSchema.toString());
        String EXP = "{'type':'object',"
                +"'properties':{'dec':{'type':'number'},"
                +"'bigInt':{'type':'integer'}}}";
        assertEquals(EXP, json);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/NewSchemaTest.java;<<<<<<< MINE
=======
import java.math.BigDecimal;
import java.math.BigInteger;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/NewSchemaTest.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/NewSchemaTest.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.core.JsonParser.NumberType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/NewSchemaTest.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;
=======
import com.fasterxml.jackson.databind.jsonFormatVisitors.*;
import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/NewSchemaTest.java;<<<<<<< MINE
=======
    @JsonPropertyOrder({ "dec", "bigInt" })
    static class Numbers {
        public BigDecimal dec;
        public BigInteger bigInt;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/NewSchemaTest.java;<<<<<<< MINE
=======

    // [2.7]: Ensure JsonValueFormat serializes/deserializes as expected
    public void testJsonValueFormatHandling() throws Exception
    {
        // first: serialize using 'toString()', not name
        final String EXP = quote("host-name");
        assertEquals(EXP, MAPPER.writeValueAsString(JsonValueFormat.HOST_NAME));

        // and second, deserialize ok from that as well
        assertSame(JsonValueFormat.HOST_NAME, MAPPER.readValue(EXP, JsonValueFormat.class));
    }

    // [databind#1045], regression wrt BigDecimal
    public void testSimpleNumbers() throws Exception
    {
        final StringBuilder sb = new StringBuilder();
        
        MAPPER.acceptJsonFormatVisitor(Numbers.class,
                new JsonFormatVisitorWrapper.Base() {
            @Override
            public JsonObjectFormatVisitor expectObjectFormat(final JavaType type) {
                return new JsonObjectFormatVisitor.Base(getProvider()) {
                    @Override
                    public void optionalProperty(BeanProperty prop) throws JsonMappingException {
                        sb.append("[optProp ").append(prop.getName()).append("(");
                        JsonSerializer<Object> ser = null;
                        if (prop instanceof BeanPropertyWriter) {
                            BeanPropertyWriter bpw = (BeanPropertyWriter) prop;
                            ser = bpw.getSerializer();
                        }
                        final SerializerProvider prov = getProvider();
                        if (ser == null) {
                            ser = prov.findValueSerializer(prop.getType(), prop);
                        }
                        ser.acceptJsonFormatVisitor(new JsonFormatVisitorWrapper.Base() {
                            @Override
                            public JsonNumberFormatVisitor expectNumberFormat(
                                    JavaType t) throws JsonMappingException {
                                return new JsonNumberFormatVisitor() {
                                    @Override
                                    public void format(JsonValueFormat format) {
                                        sb.append("[numberFormat=").append(format).append("]");
                                    }

                                    @Override
                                    public void enumTypes(Set<String> enums) { }

                                    @Override
                                    public void numberType(NumberType numberType) {
                                        sb.append("[numberType=").append(numberType).append("]");
                                    }
                                };
                            }

                            @Override
                            public JsonIntegerFormatVisitor expectIntegerFormat(JavaType t) throws JsonMappingException {
                                return new JsonIntegerFormatVisitor() {
                                    @Override
                                    public void format(JsonValueFormat format) {
                                        sb.append("[integerFormat=").append(format).append("]");
                                    }

                                    @Override
                                    public void enumTypes(Set<String> enums) { }

                                    @Override
                                    public void numberType(NumberType numberType) {
                                        sb.append("[numberType=").append(numberType).append("]");
                                    }
                                };
                            }
                        }, prop.getType());

                        sb.append(")]");
                    }
                };
            }
        });
        assertEquals("[optProp dec([numberType=BIG_DECIMAL])][optProp bigInt([numberType=BIG_INTEGER])]",
                sb.toString());
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java;<<<<<<< MINE
    @JsonTypeIdResolver(CustomIdResolver.class)
=======
    @JsonTypeIdResolver(TestCustomIdResolver.class)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java;<<<<<<< MINE
    static class CustomIdResolver extends TypeIdResolverBase
=======
    static class TestCustomIdResolver extends TypeIdResolverBase
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java;<<<<<<< MINE
        public CustomIdResolver(String idForBean) {
=======
        public TestCustomIdResolver(String idForBean) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java;<<<<<<< MINE
            if (resolverClass == CustomIdResolver.class) {
                return new CustomIdResolver("!!!");
=======
            if (resolverClass == TestCustomIdResolver.class) {
                return new TestCustomIdResolver("!!!");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.type.TypeFactory;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java;<<<<<<< MINE
        public ListWrapper(T... values) {
=======
        public ListWrapper(@SuppressWarnings("unchecked") T... values) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java;<<<<<<< MINE
    /* Additional assert methods
=======
    /* Factory methods
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java;<<<<<<< MINE
=======
    // @since 2.7
    protected TypeFactory newTypeFactory() {
        // this is a work-around; no null modifier added
        return TypeFactory.defaultInstance().withModifier(null);
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java;<<<<<<< MINE
=======

    protected static String quotesToApos(String json) {
        return json.replace("\"", "'");
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java;<<<<<<< MINE
=======
import java.text.ParseException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java;<<<<<<< MINE
=======
    // [databind#803
    public void testLenient() throws Exception
    {
        StdDateFormat f = StdDateFormat.instance;

        // default should be lenient
        assertTrue(f.isLenient());

        StdDateFormat f2 = f.clone();
        assertTrue(f2.isLenient());

        f2.setLenient(false);
        assertFalse(f2.isLenient());

        f2.setLenient(true);
        assertTrue(f2.isLenient());

        // and for testing, finally, leave as non-lenient
        f2.setLenient(false);
        assertFalse(f2.isLenient());
        StdDateFormat f3 = f2.clone();
        assertFalse(f3.isLenient());

        // first, legal dates are... legal
        Date dt = f3.parse("2015-11-30");
        assertNotNull(dt);

        // but as importantly, when not lenient, do not allow
        try {
            f3.parse("2015-11-32");
            fail("Should not pass");
        } catch (ParseException e) {
            verifyException(e, "can not parse date");
        }

        // ... yet, with lenient, do allow
        f3.setLenient(true);
        dt = f3.parse("2015-11-32");
        assertNotNull(dt);
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestVersions.java;<<<<<<< MINE
        assertFalse("Should find version information (got "+v+")", v.isUknownVersion());
=======
        assertFalse("Should find version information (got "+v+")", v.isUnknownVersion());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.ObjectMapper;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
    // For [databind#703]
=======
    // For [databind#703], [databind#978]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
        // but this used to pass, incorrectly
=======
        // but this used to pass, incorrectly, second time around
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
=======

        // [databind#978]: Different answer if empty Beans ARE allowed
        m = new ObjectMapper();
        m.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
        assertTrue(m.canSerialize(Object.class));
        assertTrue(MAPPER.writer().without(SerializationFeature.FAIL_ON_EMPTY_BEANS)
                .canSerialize(Object.class));
        assertFalse(MAPPER.writer().with(SerializationFeature.FAIL_ON_EMPTY_BEANS)
                .canSerialize(Object.class));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
        /*
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
                */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
=======
    // for [databind#898]
    public void testSerializerProviderAccess() throws Exception
    {
        // ensure we have "fresh" instance, just in case
        ObjectMapper mapper = new ObjectMapper();
        JsonSerializer<?> ser = mapper.getSerializerProviderInstance()
                .findValueSerializer(Bean.class);
        assertNotNull(ser);
        assertEquals(Bean.class, ser.handledType());
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java;<<<<<<< MINE
            if (name.equals("uri")) {
                assertToken(JsonToken.VALUE_STRING, t);
                assertEquals(FixtureObjectBase.VALUE_URSTR, getAndVerifyText(jp));
            } else if (name.equals("url")) {
=======
            if (name.equals("uri") || name.equals("url")) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/AnySetter1035Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.failing;

import java.util.*;

import com.fasterxml.jackson.annotation.*;

import com.fasterxml.jackson.databind.*;

public class AnySetter1035Test extends BaseMapTest
{
    static class MyGeneric<T>
    {
        private String staticallyMappedProperty;
        private Map<T, Integer> dynamicallyMappedProperties = new HashMap<T, Integer>();

        public String getStaticallyMappedProperty() {
            return staticallyMappedProperty;
        }

        @JsonAnySetter
        public void addDynamicallyMappedProperty(T key, int value) {
            dynamicallyMappedProperties.put(key, value);
        }

        public void setStaticallyMappedProperty(String staticallyMappedProperty) {
            this.staticallyMappedProperty = staticallyMappedProperty;
        }

        @JsonAnyGetter
        public Map<T, Integer> getDynamicallyMappedProperties() {
            return dynamicallyMappedProperties;
        }
    }

    static class MyWrapper
    {
        private MyGeneric<String> myStringGeneric;
        private MyGeneric<Integer> myIntegerGeneric;

        public MyGeneric<String> getMyStringGeneric() {
            return myStringGeneric;
        }

        public void setMyStringGeneric(MyGeneric<String> myStringGeneric) {
            this.myStringGeneric = myStringGeneric;
        }

        public MyGeneric<Integer> getMyIntegerGeneric() {
            return myIntegerGeneric;
        }

        public void setMyIntegerGeneric(MyGeneric<Integer> myIntegerGeneric) {
            this.myIntegerGeneric = myIntegerGeneric;
        }
    }

    public void testGenericAnySetter() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();

        Map<String, Integer> stringGenericMap = new HashMap<String, Integer>();
        stringGenericMap.put("testStringKey", 5);
        Map<Integer, Integer> integerGenericMap = new HashMap<Integer, Integer>();
        integerGenericMap.put(111, 6);

        MyWrapper deserialized = mapper.readValue("{\"myStringGeneric\":{\"staticallyMappedProperty\":\"Test\",\"testStringKey\":5},\"myIntegerGeneric\":{\"staticallyMappedProperty\":\"Test2\",\"111\":6}}", MyWrapper.class);
        MyGeneric<String> stringGeneric = deserialized.getMyStringGeneric();
        MyGeneric<Integer> integerGeneric = deserialized.getMyIntegerGeneric();

        assertNotNull(stringGeneric);
        assertEquals(stringGeneric.getStaticallyMappedProperty(), "Test");
        for(Map.Entry<String, Integer> entry : stringGeneric.getDynamicallyMappedProperties().entrySet()) {
            assertTrue("A key in MyGeneric<String> is not an String.", entry.getKey() instanceof String);
            assertTrue("A value in MyGeneric<Integer> is not an Integer.", entry.getValue() instanceof Integer);
        }
        assertEquals(stringGeneric.getDynamicallyMappedProperties(), stringGenericMap);

        assertNotNull(integerGeneric);
        assertEquals(integerGeneric.getStaticallyMappedProperty(), "Test2");
        for(Map.Entry<Integer, Integer> entry : integerGeneric.getDynamicallyMappedProperties().entrySet()) {
            Object key = entry.getKey();
            assertEquals("A key in MyGeneric<Integer> is not an Integer.", Integer.class, key.getClass());
            Object value = entry.getValue();
            assertEquals("A value in MyGeneric<Integer> is not an Integer.", Integer.class, value.getClass());
        }
        assertEquals(integerGeneric.getDynamicallyMappedProperties(), integerGenericMap);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/ImplicitParamsForCreator806Test.java;<<<<<<< MINE
            .setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES)
=======
            .setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java;<<<<<<< MINE
    // For [Issue#426]
=======
    // For [databind#426]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java;<<<<<<< MINE
        void setUserId(String id) {
            setUserId(new Integer(id));
=======
        void setUserId(CharSequence id) {
            // 21-Dec-2015, tatu: With a fix in 2.7, use of String would not
            //   trigger the problem, so use CharSequence...
            setUserId(new Integer(id.toString()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/ExternalTypeId999Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.failing;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.*;

public class ExternalTypeId999Test extends BaseMapTest
{
    public static interface Payload { }

    @JsonTypeName("foo")
    public static class FooPayload implements Payload { }

    @JsonTypeName("bar")
    public static class BarPayload implements Payload { }

    public static class Message<P extends Payload>
    {
        final String type;

        @JsonTypeInfo(visible = true, use = JsonTypeInfo.Id.NAME,
                include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "type")
        @JsonSubTypes({
                @JsonSubTypes.Type(FooPayload.class),
                @JsonSubTypes.Type(BarPayload.class) })
        private final P payload;

        @JsonCreator
        public Message(@JsonProperty("type") String type,
                @JsonProperty("payload") P payload)
        {
            if (payload == null) {
                throw new RuntimeException("'payload' is null");
            }
            if (type == null) {
                throw new RuntimeException("'type' is null");
            }
            this.type = type;
            this.payload = payload;
        }
    }


    public void testExternalTypeId() throws Exception
    {
        ObjectMapper objectMapper = new ObjectMapper();
        Message<?> msg = objectMapper.readValue(
                "{ \"type\": \"foo\", \"payload\": {} }",
                new TypeReference<Message<FooPayload>>() { });
        assertNotNull(msg);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/failing/BuilderDeserializationTest921.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.failing;

import java.util.List;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;

public class BuilderDeserializationTest921
    extends BaseMapTest
{
    public static class MyPOJO {
      public String x;
      public String y;

      @JsonCreator
      public MyPOJO(@JsonProperty("x") String x, @JsonProperty("y") String y) {
        this.x = x;
        this.y = y;
      }
    }

    @JsonDeserialize(builder = MyGenericPOJO.Builder.class)
    public static class MyGenericPOJO<T> {
      private List<T> data;

      private MyGenericPOJO(List<T> d) {
        data = d;
      }

      public List<T> getData() {
        return data;
      }

      public static class Builder<T> {
        private List<T> data;

        public Builder<T> withData(List<T> d) {
          data = d;
          return this;
        }

        public MyGenericPOJO<T> build() {
          return new MyGenericPOJO<T>(data);
        }
      }
    }

    public static class MyGenericPOJOWithCreator<T> {
      private List<T> data;

      private MyGenericPOJOWithCreator(List<T> d) {
          data = d;
      }

      @JsonCreator
      public static <T> MyGenericPOJOWithCreator<T> create(@JsonProperty("data") List<T> data) {
          return new MyGenericPOJOWithCreator.Builder<T>().withData(data).build();
      }

      public List<T> getData() {
          return data;
      }

      public static class Builder<T> {
          private List<T> data;

          public Builder<T> withData(List<T> d) {
              data = d;
              return this;
          }

          public MyGenericPOJOWithCreator<T> build() {
              return new MyGenericPOJOWithCreator<T>(data);
          }
      }
    }

    public void testWithBuilder() throws Exception {
      final ObjectMapper mapper = new ObjectMapper();
      final String json = aposToQuotes("{ 'data': [ { 'x': 'x', 'y': 'y' } ] }");
      final MyGenericPOJO<MyPOJO> deserialized =
          mapper.readValue(json, new TypeReference<MyGenericPOJO<MyPOJO>>() {});
      assertEquals(1, deserialized.data.size());
      Object ob = deserialized.data.get(0);
      assertNotNull(ob);
      assertEquals(MyPOJO.class, ob.getClass());
    }

    public void testWithCreator() throws Exception {
      final ObjectMapper mapper = new ObjectMapper();
      final String json = aposToQuotes("{ 'data': [ { 'x': 'x', 'y': 'y' } ] }");
      final MyGenericPOJOWithCreator<MyPOJO> deserialized =
          mapper.readValue(json,
                  new TypeReference<MyGenericPOJOWithCreator<MyPOJO>>() {});
      assertEquals(1, deserialized.data.size());
      Object ob = deserialized.data.get(0);
      assertNotNull(ob);
      assertEquals(MyPOJO.class, ob.getClass());
    }
  }>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/attic/MappingIteratorDeserializer.java;<<<<<<< MINE
System.err.println("DEBUG: token/0 == "+p.getCurrentToken());
        
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/attic/MappingIteratorDeserializer.java;<<<<<<< MINE

System.err.println("DEBUG: token/1 == "+p.getCurrentToken());
        
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/attic/MappingIteratorDeserializer.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/attic/TypeBindings.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.type;

import java.lang.reflect.*;
import java.util.*;

import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.util.ClassUtil;

/**
 * Helper class used for resolving type parameters for given class
 */
public class TypeBindings
{
    private final static JavaType[] NO_TYPES = new JavaType[0];

    /**
     * Marker to use for (temporarily) unbound references.
     */
    public final static JavaType UNBOUND = new SimpleType(Object.class);

    /**
     * Factory to use for constructing resolved related types.
     */
    protected final TypeFactory _typeFactory;

    /**
     * @since 2.7
     */
    protected final ClassStack _classStack;
    
    /**
     * Context type used for resolving all types, if specified. May be null,
     * in which case {@link #_contextClass} is used instead.
     */
    protected final JavaType _contextType;

    /**
     * Specific class to use for resolving all types, for methods and fields
     * class and its superclasses and -interfaces contain.
     */
    protected final Class<?> _contextClass;

    /**
     * Lazily-instantiated bindings of resolved type parameters
     */
    protected Map<String,JavaType> _bindings;

    /**
     * Also: we may temporarily want to mark certain named types
     * as resolved (but without exact type); if so, we'll just store
     * names here.
     */
    protected HashSet<String> _placeholders;

    /**
     * Sometimes it is necessary to allow hierarchic resolution of types: specifically
     * in cases where there are local bindings (for methods, constructors). If so,
     * we'll just use simple delegation model.
     */
    private final TypeBindings _parentBindings;

    /*
    /**********************************************************
    /* Construction
    /**********************************************************
     */
    
    public TypeBindings(TypeFactory typeFactory, ClassStack stack, Class<?> cc)
    {
        this(typeFactory, null, stack, cc, null);
    }

    public TypeBindings(TypeFactory typeFactory, ClassStack stack, JavaType type)
    {
        this(typeFactory, null, stack, type.getRawClass(), type);
    }

    /**
     * Constructor used to create "child" instances; mostly to
     * allow delegation from explicitly defined local overrides
     * (local type variables for methods, constructors) to
     * contextual (class-defined) ones.
     */
    public TypeBindings childInstance() {
        return new TypeBindings(_typeFactory, this, _classStack, _contextClass, _contextType);
    }

    private TypeBindings(TypeFactory tf, TypeBindings parent, ClassStack stack,
            Class<?> cc, JavaType type)
    {
        _typeFactory = tf;
        _parentBindings = parent;
        _classStack = stack;
        _contextClass = cc;
        _contextType = type;
    }

    /*
    /**********************************************************
    /* Pass-through type resolution methods
    /**********************************************************
     */

    public JavaType resolveType(Class<?> cls) {
        return _typeFactory._constructType(_classStack, cls, this);
    }

    public JavaType resolveType(Type type) {
        return _typeFactory._constructType(_classStack, type, this);
    }

    /*
    /**********************************************************
    /* Accesors
    /**********************************************************
     */

    public JavaType findType(String name, boolean mustFind)
    {
        if (_bindings == null) {
            _resolve();
        }
        JavaType t = _bindings.get(name);
        if (t != null) {
            return t;
        }
        if (_placeholders != null && _placeholders.contains(name)) {
            return UNBOUND;
        }
        if (_parentBindings != null) {
            return _parentBindings.findType(name, mustFind);
        }
        // nothing found, so...
        // Should we throw an exception or just return null?

        /* 18-Feb-2011, tatu: There are some tricky type bindings within
         *   java.util, such as HashMap$KeySet; so let's punt the problem
         *   (honestly not sure what to do -- they are unbound for good, I think)
         */
        if (_contextClass != null) {
            if (ClassUtil.getEnclosingClass(_contextClass) != null) {
                // [JACKSON-572]: Actually, let's skip this for all non-static inner classes
                //   (which will also cover 'java.util' type cases...
                if (!Modifier.isStatic(_contextClass.getModifiers())) {
                    return UNBOUND;
                }
            }
        }

        if (!mustFind) {
            return null;
        }
        
        String className;
        if (_contextClass != null) {
            className = _contextClass.getName();
        } else if (_contextType != null) {
            className = _contextType.toString();
        } else {
            className = "UNKNOWN";
        }
        throw new IllegalArgumentException("Type variable '"+name
                +"' can not be resolved (with context of class "+className+")");
        //t = UNBOUND;                
    }

    public void addBinding(String name, JavaType type)
    {
        // note: emptyMap() is unmodifiable, hence second check is needed:
        if (_bindings == null || _bindings.size() == 0) {
            _bindings = new LinkedHashMap<String,JavaType>();
        }
        _bindings.put(name, type);
    }

    public JavaType[] typesAsArray()
    {
        if (_bindings == null) {
            _resolve();
        }
        if (_bindings.size() == 0) {
            return NO_TYPES;
        }
        return _bindings.values().toArray(new JavaType[_bindings.size()]);
    }
    
    /*
    /**********************************************************
    /* Internal methods
    /**********************************************************
     */

    // Only for tests!
    protected int getBindingCount() {
        if (_bindings == null) {
            _resolve();
        }
        return _bindings.size();
    }
    
    protected void _resolve()
    {
        _resolveBindings(_contextClass);

        // finally: may have root level type info too
        if (_contextType != null) {
            int count = _contextType.containedTypeCount();
            if (count > 0) {
                for (int i = 0; i < count; ++i) {
                    String name = _contextType.containedTypeName(i);
                    JavaType type = _contextType.containedType(i);
                    addBinding(name, type);
                }
            }
        }

        // nothing bound? mark with empty map to prevent further calls
        if (_bindings == null) {
            _bindings = Collections.emptyMap();
        }
    }

    public void _addPlaceholder(String name) {
        if (_placeholders == null) {
            _placeholders = new HashSet<String>();
        }
        _placeholders.add(name);
    }

    protected void _resolveBindings(Type t)
    {
        if (t == null) return;

        Class<?> raw;
        if (t instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) t;
            Type[] args = pt.getActualTypeArguments();
            if (args  != null && args.length > 0) {
                Class<?> rawType = (Class<?>) pt.getRawType();    
                TypeVariable<?>[] vars = rawType.getTypeParameters();
                if (vars.length != args.length) {
                    throw new IllegalArgumentException("Strange parametrized type (in class "+rawType.getName()+"): number of type arguments != number of type parameters ("+args.length+" vs "+vars.length+")");
                }
                for (int i = 0, len = args.length; i < len; ++i) {
                    TypeVariable<?> var = vars[i];
                    String name = var.getName();
                    if (_bindings == null) {
                        _bindings = new LinkedHashMap<String,JavaType>();
                    } else {
                        // 24-Mar-2010, tatu: Better ensure that we do not overwrite something
                        //  collected earlier (since we descend towards super-classes):
                        if (_bindings.containsKey(name)) continue;
                    }
                    // first: add a placeholder to prevent infinite loops
                    _addPlaceholder(name);
                    // then resolve type
                    _bindings.put(name, _typeFactory._constructType(_classStack, args[i], this));
                }
            }
            raw = (Class<?>)pt.getRawType();
        } else if (t instanceof Class<?>) {
            raw = (Class<?>) t;
            /* [JACKSON-677]: If this is an inner class then the generics are defined on the 
             * enclosing class so we have to check there as well.  We don't
             * need to call getEnclosingClass since anonymous classes declare 
             * generics
             */
            Class<?> decl = ClassUtil.getDeclaringClass(raw);
            /* 08-Feb-2013, tatu: Except that if context is also super-class, we must
             *   skip it; context will be checked anyway, and we'd get StackOverflow if
             *   we went there.
             */
            if (decl != null && !decl.isAssignableFrom(raw)) {
                _resolveBindings(decl);
            }

            /* 24-Mar-2010, tatu: Can not have true generics definitions, but can
             *   have lower bounds ("<T extends BeanBase>") in declaration itself
             */
            TypeVariable<?>[] vars = raw.getTypeParameters();
            if (vars != null && vars.length > 0) {
                JavaType[] typeParams = null;

                if (_contextType != null && raw.isAssignableFrom(_contextType.getRawClass())) {
                    typeParams = _typeFactory.findTypeParameters(_contextType, raw);
                }

                for (int i = 0; i < vars.length; i++) {
                    TypeVariable<?> var = vars[i];

                    String name = var.getName();
                    Type varType = var.getBounds()[0];
                    if (varType != null) {
                        if (_bindings == null) {
                            _bindings = new LinkedHashMap<String,JavaType>();
                        } else { // and no overwriting...
                            if (_bindings.containsKey(name)) continue;
                        }
                        _addPlaceholder(name); // to prevent infinite loops

                        if (typeParams != null && typeParams.length > i) {
                            _bindings.put(name, typeParams[i]);
                        } else {
                            _bindings.put(name, _typeFactory._constructType(_classStack, varType, this));
                        }
                    }
                }
            }
        } else { // probably can't be any of these... so let's skip for now
            //if (type instanceof GenericArrayType) {
            //if (type instanceof TypeVariable<?>) {
            // if (type instanceof WildcardType) {
            return;
        }
        // but even if it's not a parameterized type, its super types may be:
        _resolveBindings(ClassUtil.getGenericSuperclass(raw));
        for (Type intType : raw.getGenericInterfaces()) {
            _resolveBindings(intType);
        }
    }

    @Override
    public String toString()
    {
        if (_bindings == null) {
            _resolve();
        }
        StringBuilder sb = new StringBuilder("[TypeBindings for ");
        if (_contextType != null) {
            sb.append(_contextType.toString());
        } else {
            sb.append(_contextClass.getName());
        }
        sb.append(": ").append(_bindings).append("]");
        return sb.toString();
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_37034fc_bacb37f/rev_37034fc-bacb37f/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
                                           ? format.getPattern()
                                           : StdDateFormat.DATE_FORMAT_STR_ISO8601;
=======
                                    ? format.getPattern()
                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_37034fc_bacb37f/rev_37034fc-bacb37f/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java;<<<<<<< MINE
                                       ? format.getLocale()
                                       : serializers.getLocale();
=======
                                    ? format.getLocale()
                                    : serializers.getLocale();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_37034fc_bacb37f/rev_37034fc-bacb37f/src/test/java/com/fasterxml/jackson/databind/ser/DateSerializationTest.java;<<<<<<< MINE
=======
    static class DateAsDefaultBean {
        public Date date;
        public DateAsDefaultBean(long l) { date = new java.util.Date(l); }
    }
    
    static class DateAsDefaultBeanWithEmptyJsonFormat {
        @JsonFormat
        public Date date;
        public DateAsDefaultBeanWithEmptyJsonFormat(long l) { date = new java.util.Date(l); }
    }

    static class DateAsDefaultBeanWithPattern {
        @JsonFormat(pattern="yyyy-MM-dd")
        public Date date;
        public DateAsDefaultBeanWithPattern(long l) { date = new java.util.Date(l); }
    }

    static class DateAsDefaultBeanWithLocale {
        @JsonFormat(locale = "fr")
        public Date date;
        public DateAsDefaultBeanWithLocale(long l) { date = new java.util.Date(l); }
    }

    static class DateAsDefaultBeanWithTimezone {
        @JsonFormat(timezone="CET")
        public Date date;
        public DateAsDefaultBeanWithTimezone(long l) { date = new java.util.Date(l); }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_37034fc_bacb37f/rev_37034fc-bacb37f/src/test/java/com/fasterxml/jackson/databind/ser/DateSerializationTest.java;<<<<<<< MINE
=======

    /**
     * Test to ensure that the default shape is correctly inferred as string or numeric,
     * when this shape is not explicitly set with a <code>@JsonFormat</code> annotation
     */
    public void testDateDefaultShape() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        // No @JsonFormat => default to user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        String json = mapper.writeValueAsString(new DateAsDefaultBean(0L));
        assertEquals(aposToQuotes("{'date':0}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBean(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T00:00:00.000+0000'}"), json);

        // Empty @JsonFormat => default to user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));
        assertEquals(aposToQuotes("{'date':0}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T00:00:00.000+0000'}"), json);

        // @JsonFormat with Shape.ANY and pattern => STRING shape, regardless of user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01'}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01'}"), json);

        // @JsonFormat with Shape.ANY and locale => STRING shape, regardless of user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T00:00:00.000+0000'}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T00:00:00.000+0000'}"), json);

        // @JsonFormat with Shape.ANY and timezone => STRING shape, regardless of user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T01:00:00.000+0100'}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T01:00:00.000+0100'}"), json);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0934fb7_493ba8d/rev_0934fb7-493ba8d/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
    protected final CompactStringObjectMap _enumLookup;
    private final Enum<?> _enumDefaultValue;
=======
    protected Object[] _enumsByIndex;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0934fb7_493ba8d/rev_0934fb7-493ba8d/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.AnnotationIntrospector;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0934fb7_493ba8d/rev_0934fb7-493ba8d/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.AnnotationIntrospector;

/**
=======
import com.fasterxml.jackson.databind.AnnotationIntrospector;

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_0934fb7_493ba8d/rev_0934fb7-493ba8d/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java;<<<<<<< MINE
        Enum<?> defaultEnum = (ai == null) ? null : ai.findDefaultEnumValue(enumCls);
        return new EnumResolver(enumCls, enumValues, map, defaultEnum);
    }

    /**
     * @deprecated Since 2.8, use {@link #constructUsingMethod(Class, Method, AnnotationIntrospector)} instead
     */
    @Deprecated
    public static EnumResolver constructUsingMethod(Class<Enum<?>> enumCls, Method accessor) {
        return constructUsingMethod(enumCls, accessor, null);
    }
=======
        return new EnumResolver(enumCls, enumValues, map);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_238bb47_cb67177/rev_238bb47-cb67177/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
=======
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_20bd066_24de8a2/rev_20bd066-24de8a2/src/test/java/com/fasterxml/jackson/databind/creators/CreatorPropertiesTest.java;<<<<<<< MINE
import com.fasterxml.jackson.annotation.JsonProperty;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e09adcb_f1f4023/rev_e09adcb-f1f4023/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    /* Abstract method impls
=======
    /* Contextualization (support for property annotations)
    /**********************************************************
     */

    @Override
    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property) throws JsonMappingException
    {
        TypeSerializer typeSer = _valueTypeSerializer;
        if (typeSer != null) {
            typeSer = typeSer.forProperty(property);
        }
        // First: do we have an annotation override from property?
        JsonSerializer<?> ser = findAnnotatedContentSerializer(provider, property);;
        if (ser == null) {
            // If not, use whatever was configured by type
            ser = _valueSerializer;
            if (ser == null) {
                // A few conditions needed to be able to fetch serializer here:
                if (_useStatic(provider, property, _referredType)) {
                    ser = _findSerializer(provider, _referredType, property);
                }
            } else {
                ser = provider.handlePrimaryContextualization(ser, property);
            }
        }
        // Also: may want to have more refined exclusion based on referenced value
        JsonInclude.Include contentIncl = _contentInclusion;
        if (property != null) {
            JsonInclude.Value incl = property.findPropertyInclusion(provider.getConfig(),
                    AtomicReference.class);
            JsonInclude.Include newIncl = incl.getContentInclusion();
            if ((newIncl != contentIncl) && (newIncl != JsonInclude.Include.USE_DEFAULTS)) {
                contentIncl = newIncl;
            }
        }
        return withResolved(property, typeSer, ser, _unwrapper, contentIncl);
    }

    protected boolean _useStatic(SerializerProvider provider, BeanProperty property,
            JavaType referredType)
    {
        // First: no serializer for `Object.class`, must be dynamic
        if (referredType.isJavaLangObject()) {
            return false;
        }
        // but if type is final, might as well fetch
        if (referredType.isFinal()) { // or should we allow annotation override? (only if requested...)
            return true;
        }
        // also: if indicated by typing, should be considered static
        if (referredType.useStaticType()) {
            return true;
        }
        // if neither, maybe explicit annotation?
        AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        if ((intr != null) && (property != null)) {
            Annotated ann = property.getMember();
            if (ann != null) {
                JsonSerialize.Typing t = intr.findSerializationTyping(property.getMember());
                if (t == JsonSerialize.Typing.STATIC) {
                    return true;
                }
                if (t == JsonSerialize.Typing.DYNAMIC) {
                    return false;
                }
            }
        }
        // and finally, may be forced by global static typing (unlikely...)
        return provider.isEnabled(MapperFeature.USE_STATIC_TYPING);
    }

    /*
    /**********************************************************
    /* Accessors
    /**********************************************************
     */

    @Override
    public boolean isEmpty(SerializerProvider provider, AtomicReference<?> value)
    {
        if (value == null) {
            return true;
        }
        Object contents = value.get();
        if (contents == null) {
            return true;
        }
        if (_contentInclusion == null) {
            return false;
        }
        JsonSerializer<Object> ser = _valueSerializer;
        if (ser == null) {
            try {
                ser = _findCachedSerializer(provider, contents.getClass());
            } catch (JsonMappingException e) { // nasty but necessary
                throw new RuntimeJsonMappingException(e);
            }
        }
        return ser.isEmpty(provider, contents);

    }

    @Override
    public boolean isUnwrappingSerializer() {
        return (_unwrapper != null);
    }

    /*
    /**********************************************************
    /* Serialization methods
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9845fb2_779411e/rev_9845fb2-779411e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    protected Object _getReferenced(AtomicReference<?> value) {
        return value.get();
=======
    public void serializeWithType(AtomicReference<?> ref,
            JsonGenerator g, SerializerProvider provider,
            TypeSerializer typeSer) throws IOException
    {
        Object value = ref.get();
        if (value == null) {
            if (_unwrapper == null) {
                provider.defaultSerializeNull(g);
            }
            return;
        }

        // 19-Apr-2016, tatu: In order to basically "skip" the whole wrapper level
        //    (which is what non-polymorphic serialization does too), we will need
        //    to simply delegate call, I think, and NOT try to use it here.
        
        // Otherwise apply type-prefix/suffix, then std serialize:
        /*
        typeSer.writeTypePrefixForScalar(ref, g);
        serialize(ref, g, provider);
        typeSer.writeTypeSuffixForScalar(ref, g);
        */

        JsonSerializer<Object> ser = _valueSerializer;
        if (ser == null) {
            ser = _findCachedSerializer(provider, value.getClass());
        }
        ser.serializeWithType(value, g, provider, typeSer);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_580e652_2520c29/rev_580e652-2520c29/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE

    @Deprecated // since 2.8
    public AtomicReferenceDeserializer(JavaType fullType) {
        this(fullType, null, null);
=======
    protected final JavaType _referencedType;
    
    protected final TypeDeserializer _valueTypeDeserializer;

    protected final JsonDeserializer<?> _valueDeserializer;

    /**
     * @param referencedType Parameterization of this reference
     */
    public AtomicReferenceDeserializer(JavaType referencedType) {
        this(referencedType, null, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6580a9d_f40e6c1/rev_6580a9d-f40e6c1/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
    protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt)
=======
    protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt)
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6580a9d_f40e6c1/rev_6580a9d-f40e6c1/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
        JsonToken t = jp.getCurrentToken();
=======
        JsonToken t = p.getCurrentToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6580a9d_f40e6c1/rev_6580a9d-f40e6c1/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
            return new java.util.Date(jp.getLongValue());
=======
            return new java.util.Date(p.getLongValue());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f68be3c_cbad874/rev_f68be3c-cbad874/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_058bbdf_4c59723/rev_058bbdf-4c59723/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    @SuppressWarnings("incomplete-switch")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_1c68f96_fe32b96/rev_1c68f96-fe32b96/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.ser;

import java.io.*;
import java.util.*;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;

/**
 * Unit tests for checking whether JsonSerializerFactory.Feature
 * configuration works
 */
public class TestFeatures
    extends BaseMapTest
{
    /*
    /**********************************************************
    /* Helper classes
    /**********************************************************
     */

    /**
     * Class with one explicitly defined getter, one name-based
     * auto-detectable getter.
     */
    static class GetterClass
    {
        @JsonProperty("x") public int getX() { return -2; }
        public int getY() { return 1; }
    }

    /**
     * Another test-class that explicitly disables auto-detection
     */
    @JsonAutoDetect(getterVisibility=Visibility.NONE)
    static class DisabledGetterClass
    {
        @JsonProperty("x") public int getX() { return -2; }
        public int getY() { return 1; }
    }

    /**
     * Another test-class that explicitly enables auto-detection
     */
    @JsonAutoDetect(isGetterVisibility=Visibility.NONE)
    static class EnabledGetterClass
    {
        @JsonProperty("x") public int getX() { return -2; }
        public int getY() { return 1; }

        // not auto-detected, since "is getter" auto-detect disabled
        public boolean isOk() { return true; }
    }

    /**
     * One more: only detect "isXxx", not "getXXX"
     */
    @JsonAutoDetect(getterVisibility=Visibility.NONE)
    static class EnabledIsGetterClass
    {
        // Won't be auto-detected any more
        public int getY() { return 1; }

        // but this will be
        public boolean isOk() { return true; }
    }

    static class CloseableBean implements Closeable
    {
        public int a = 3;

        protected boolean wasClosed = false;

        @Override
        public void close() throws IOException {
            wasClosed = true;
        }
    }

    private static class StringListBean {
        @SuppressWarnings("unused")
        public Collection<String> values;
        
        public StringListBean(Collection<String> v) { values = v; }
    }
    
    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    public void testGlobalAutoDetection() throws IOException
    {
        // First: auto-detection enabled (default):
        ObjectMapper m = new ObjectMapper();
        Map<String,Object> result = writeAndMap(m, new GetterClass());
        assertEquals(2, result.size());
        assertEquals(Integer.valueOf(-2), result.get("x"));
        assertEquals(Integer.valueOf(1), result.get("y"));

        // Then auto-detection disabled. But note: we MUST create a new
        // mapper, since old version of serializer may be cached by now
        m = new ObjectMapper();
        m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
        result = writeAndMap(m, new GetterClass());
        assertEquals(1, result.size());
        assertTrue(result.containsKey("x"));
    }

    public void testPerClassAutoDetection() throws IOException
    {
        // First: class-level auto-detection disabling
        ObjectMapper m = new ObjectMapper();
        Map<String,Object> result = writeAndMap(m, new DisabledGetterClass());
        assertEquals(1, result.size());
        assertTrue(result.containsKey("x"));

        // And then class-level auto-detection enabling, should override defaults
        m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
        result = writeAndMap(m, new EnabledGetterClass());
        assertEquals(2, result.size());
        assertTrue(result.containsKey("x"));
        assertTrue(result.containsKey("y"));
    }

    public void testPerClassAutoDetectionForIsGetter() throws IOException
    {
        ObjectMapper m = new ObjectMapper();
        // class level should override
        m.configure(MapperFeature.AUTO_DETECT_GETTERS, true);
        m.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
         Map<String,Object> result = writeAndMap(m, new EnabledIsGetterClass());
        assertEquals(1, result.size());
        assertTrue(result.containsKey("ok"));
        assertEquals(Boolean.TRUE, result.get("ok"));
    }

    // Simple test verifying that chainable methods work ok...
    public void testConfigChainability()
    {
        ObjectMapper m = new ObjectMapper();
        assertTrue(m.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));
        assertTrue(m.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));
        m.configure(MapperFeature.AUTO_DETECT_SETTERS, false)
            .configure(MapperFeature.AUTO_DETECT_GETTERS, false);
        assertFalse(m.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));
        assertFalse(m.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));
    }

    // Test for [JACKSON-282]
    @SuppressWarnings("resource")
    public void testCloseCloseable() throws IOException
    {
        ObjectMapper m = new ObjectMapper();
        // default should be disabled:
        CloseableBean bean = new CloseableBean();
        m.writeValueAsString(bean);
        assertFalse(bean.wasClosed);

        // but can enable it:
        m.configure(SerializationFeature.CLOSE_CLOSEABLE, true);
        bean = new CloseableBean();
        m.writeValueAsString(bean);
        assertTrue(bean.wasClosed);

        // also: let's ensure that ObjectWriter won't interfere with it
        bean = new CloseableBean();
        m.writerFor(CloseableBean.class).writeValueAsString(bean);
        assertTrue(bean.wasClosed);
    }

    // Test for [JACKSON-289]
    public void testCharArrays() throws IOException
    {
        char[] chars = new char[] { 'a','b','c' };
        ObjectMapper m = new ObjectMapper();
        // default: serialize as Strings
        assertEquals(quote("abc"), m.writeValueAsString(chars));
        
        // new feature: serialize as JSON array:
        m.configure(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true);
        assertEquals("[\"a\",\"b\",\"c\"]", m.writeValueAsString(chars));
    }

    // Test for [JACKSON-401]
    public void testFlushingAutomatic() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE));
        // default is to flush after writeValue()
        StringWriter sw = new StringWriter();
        JsonGenerator jgen = mapper.getFactory().createGenerator(sw);
        mapper.writeValue(jgen, Integer.valueOf(13));
        assertEquals("13", sw.toString());
        jgen.close();

        // ditto with ObjectWriter
        sw = new StringWriter();
        jgen = mapper.getFactory().createGenerator(sw);
        ObjectWriter ow = mapper.writer();
        ow.writeValue(jgen, Integer.valueOf(99));
        assertEquals("99", sw.toString());
        jgen.close();
    }

    // Test for [JACKSON-401]
    public void testFlushingNotAutomatic() throws IOException
    {
        // but should not occur if configured otherwise
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(SerializationFeature.FLUSH_AFTER_WRITE_VALUE, false);
        StringWriter sw = new StringWriter();
        JsonGenerator jgen = mapper.getFactory().createGenerator(sw);

        mapper.writeValue(jgen, Integer.valueOf(13));
        // no flushing now:
        assertEquals("", sw.toString());
        // except when actually flushing
        jgen.flush();
        assertEquals("13", sw.toString());
        jgen.close();
        // Also, same should happen with ObjectWriter
        sw = new StringWriter();
        jgen = mapper.getFactory().createGenerator(sw);
        ObjectWriter ow = mapper.writer();
        ow.writeValue(jgen, Integer.valueOf(99));
        assertEquals("", sw.toString());
        // except when actually flushing
        jgen.flush();
        assertEquals("99", sw.toString());
        jgen.close();
    }

    // Test for [JACKSON-805]
    public void testSingleElementCollections() throws IOException
    {
        final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);

        // Lists:
        ArrayList<String> strs = new ArrayList<String>();
        strs.add("xyz");
        assertEquals(quote("xyz"), writer.writeValueAsString(strs));
        ArrayList<Integer> ints = new ArrayList<Integer>();
        ints.add(13);
        assertEquals("13", writer.writeValueAsString(ints));

        // other Collections, like Sets:
        HashSet<Long> longs = new HashSet<Long>();
        longs.add(42L);
        assertEquals("42", writer.writeValueAsString(longs));
        // [Issue#180]
        final String EXP_STRINGS = "{\"values\":\"foo\"}";
        assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo"))));

        final Set<String> SET = new HashSet<String>();
        SET.add("foo");
        assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET)));
        
        // arrays:
        assertEquals("true", writer.writeValueAsString(new boolean[] { true }));
        assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE }));
        assertEquals("3", writer.writeValueAsString(new int[] { 3 }));
        assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" }));
        
    }

    static class TCls {
        @JsonProperty("groupname")
        private String groupname;

        public void setName(String str) {
            this.groupname = str;
        }
        public String getName() {
            return groupname;
        }
    }

    public void testVisibilityFeatures() throws Exception
    {
        ObjectMapper om = new ObjectMapper();
        // Only use explicitly specified values to be serialized/deserialized (i.e., JSONProperty).
        om.configure(MapperFeature.AUTO_DETECT_FIELDS, false);
        om.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
        om.configure(MapperFeature.AUTO_DETECT_SETTERS, false);
        om.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
        om.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);
        om.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, true);
        om.configure(MapperFeature.INFER_PROPERTY_MUTATORS, false);
        om.configure(MapperFeature.USE_ANNOTATIONS, true);

        JavaType javaType = om.getTypeFactory().constructType(TCls.class);        
        BeanDescription desc = (BeanDescription) om.getSerializationConfig().introspect(javaType);
        List<BeanPropertyDefinition> props = desc.findProperties();
        if (props.size() != 1) {
            fail("Should find 1 property, not "+props.size()+"; properties = "+props);
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c270be0_cc53828/rev_c270be0-cc53828/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java;<<<<<<< MINE
        return _idFrom(value, type, _typeFactory);
=======
        return _idFrom(value, type);
    }

    @Deprecated // since 2.3
    @Override
    public JavaType typeFromId(String id) {
        return _typeFromId(id, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c270be0_cc53828/rev_c270be0-cc53828/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java;<<<<<<< MINE
=======
            JavaType t = tf.constructFromCanonical(id);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_548245c_7bc0fc4/rev_548245c-7bc0fc4/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======
    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) {
        String tokenDesc = (token == null) ? "<end of input>" : String.format("%s token", token);
        return JsonMappingException.from(_parser,
                String.format("Can not deserialize instance of %s out of %s",
                        _calcName(targetClass), tokenDesc));
    }
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c4ecc55_f6fbed5/rev_c4ecc55-f6fbed5/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java;<<<<<<< MINE
package com.fasterxml.jackson.databind.jsontype.ext;

import java.io.IOException;
import java.util.UUID;

import org.junit.Test;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.DatabindContext;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;
import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;
import com.fasterxml.jackson.databind.type.TypeFactory;

public class ExternalTypeIdTest1288 {
    public static class ClassesWithoutBuilder {
        
        public static class CreditCardDetails implements PaymentDetails {
            
            private String cardHolderFirstName;
            private String cardHolderLastName;
            private String number;
            private String expiryDate;
            private int    csc;
            private String address;
            private String zipCode;
            private String city;
            private String province;
            
            private String countryCode;
            
            private String description;

            public void setCardHolderFirstName (String cardHolderFirstName) {
                this.cardHolderFirstName = cardHolderFirstName;
            }

            public void setCardHolderLastName (String cardHolderLastName) {
                this.cardHolderLastName = cardHolderLastName;
            }

            public void setNumber (String number) {
                this.number = number;
            }

            public void setExpiryDate (String expiryDate) {
                this.expiryDate = expiryDate;
            }

            public void setCsc (int csc) {
                this.csc = csc;
            }

            public void setAddress (String address) {
                this.address = address;
            }

            public void setZipCode (String zipCode) {
                this.zipCode = zipCode;
            }

            public void setCity (String city) {
                this.city = city;
            }

            public void setProvince (String province) {
                this.province = province;
            }

            public void setCountryCode (String countryCode) {
                this.countryCode = countryCode;
            }

            public void setDescription (String description) {
                this.description = description;
            }
            
            
        }
        
        public static class EncryptedCreditCardDetails implements PaymentDetails {
            
            private UUID   paymentInstrumentID;
            
            private String name;

            public void setPaymentInstrumentID (UUID paymentInstrumentID) {
                this.paymentInstrumentID = paymentInstrumentID;
            }

            public void setName (String name) {
                this.name = name;
            }

        }
        
        public enum FormOfPayment {
            INDIVIDUAL_CREDIT_CARD (CreditCardDetails.class), COMPANY_CREDIT_CARD (
                    CreditCardDetails.class), INSTRUMENTED_CREDIT_CARD (EncryptedCreditCardDetails.class);
            
            private final Class<? extends PaymentDetails> clazz;
            
            FormOfPayment (final Class<? extends PaymentDetails> clazz) {
                this.clazz = clazz;
            }
            
            @SuppressWarnings ("unchecked")
            public <T extends PaymentDetails> Class<T> getDetailsClass () {
                return (Class<T>) this.clazz;
            }
            
            public static FormOfPayment fromDetailsClass (Class<PaymentDetails> detailsClass) {
                for (FormOfPayment fop : FormOfPayment.values ()) {
                    if (fop.clazz == detailsClass) {
                        return fop;
                    }
                }
                throw new IllegalArgumentException ("not found");
            }
        }
        
        public interface PaymentDetails {
            public interface Builder {
                PaymentDetails build ();
            }
        }
        
        public static class PaymentMean {
            
            private FormOfPayment  formOfPayment;
            
            private PaymentDetails paymentDetails;

            public void setFormOfPayment (FormOfPayment formOfPayment) {
                this.formOfPayment = formOfPayment;
            }

            @JsonTypeInfo (use = JsonTypeInfo.Id.CUSTOM, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "form_of_payment", visible = true)
            @JsonTypeIdResolver (PaymentDetailsTypeIdResolver.class)
            public void setPaymentDetails (PaymentDetails paymentDetails) {
                this.paymentDetails = paymentDetails;
            }
            
        }
        
        public static class PaymentDetailsTypeIdResolver implements TypeIdResolver {
            
            @Override
            public void init (JavaType baseType) {
            }
            
            @SuppressWarnings ("unchecked")
            @Override
            public String idFromValue (Object value) {
                if (! (value instanceof PaymentDetails)) {
                    return null;
                }
                return FormOfPayment.fromDetailsClass ((Class<PaymentDetails>) value.getClass ()).name ();
            }
            
            @Override
            public String idFromValueAndType (Object value, Class<?> suggestedType) {
                return this.idFromValue (value);
            }
            
            @Override
            public String idFromBaseType () {
                return null;
            }
            
            @Override
            public JavaType typeFromId (DatabindContext context, String id) throws IOException {
                return TypeFactory.defaultInstance ().constructType (FormOfPayment.valueOf (id).getDetailsClass ());
            }
            
            @Override
            public String getDescForKnownTypeIds () {
                return "PaymentDetails";
            }
            
            @Override
            public Id getMechanism () {
                return JsonTypeInfo.Id.CUSTOM;
            }
            
        }
    }
    
    public static class ClassesWithBuilder {
        
        @JsonDeserialize (builder = CreditCardDetails.IndividualCreditCardDetailsBuilder.class)
        public static class CreditCardDetails implements PaymentDetails {
            @JsonPOJOBuilder (withPrefix = "")
            public static class CompanyCreditCardDetailsBuilder implements Builder {
                private String cardHolderFirstName;
                private String cardHolderLastName;
                private String number;
                private String expiryDate;
                private int    csc;
                private String address;
                private String zipCode;
                private String city;
                private String province;
                private String countryCode;
                
                public CompanyCreditCardDetailsBuilder address (final String address) {
                    this.address = address;
                    return this;
                }
                
                @Override
                public CreditCardDetails build () {
                    return new CreditCardDetails (this.cardHolderFirstName, this.cardHolderLastName, this.number, this.expiryDate, this.csc, this.address, this.zipCode, this.city,
                            this.province, this.countryCode, "COMPANY CREDIT CARD");
                }
                
                public CompanyCreditCardDetailsBuilder cardHolderFirstName (final String cardHolderFirstName) {
                    this.cardHolderFirstName = cardHolderFirstName;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder cardHolderLastName (final String cardHolderLastName) {
                    this.cardHolderLastName = cardHolderLastName;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder city (final String city) {
                    this.city = city;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder countryCode (final String countryCode) {
                    this.countryCode = countryCode;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder csc (final int csc) {
                    this.csc = csc;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder expiryDate (final String expiryDate) {
                    this.expiryDate = expiryDate;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder number (final String number) {
                    this.number = number;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder province (final String province) {
                    this.province = province;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder zipCode (final String zipCode) {
                    this.zipCode = zipCode;
                    return this;
                }
            }
            
            @JsonPOJOBuilder (withPrefix = "")
            public static class IndividualCreditCardDetailsBuilder implements Builder {
                private String cardHolderFirstName;
                private String cardHolderLastName;
                private String number;
                private String expiryDate;
                private int    csc;
                private String address;
                private String zipCode;
                private String city;
                private String province;
                private String countryCode;
                private String description;
                
                public IndividualCreditCardDetailsBuilder address (final String address) {
                    this.address = address;
                    return this;
                }
                
                @Override
                public CreditCardDetails build () {
                    return new CreditCardDetails (this.cardHolderFirstName, this.cardHolderLastName, this.number, this.expiryDate, this.csc, this.address, this.zipCode, this.city,
                            this.province, this.countryCode, this.description);
                }
                
                public IndividualCreditCardDetailsBuilder cardHolderFirstName (final String cardHolderFirstName) {
                    this.cardHolderFirstName = cardHolderFirstName;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder cardHolderLastName (final String cardHolderLastName) {
                    this.cardHolderLastName = cardHolderLastName;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder city (final String city) {
                    this.city = city;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder countryCode (final String countryCode) {
                    this.countryCode = countryCode;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder csc (final int csc) {
                    this.csc = csc;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder description (final String description) {
                    this.description = description;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder expiryDate (final String expiryDate) {
                    this.expiryDate = expiryDate;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder number (final String number) {
                    this.number = number;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder province (final String province) {
                    this.province = province;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder zipCode (final String zipCode) {
                    this.zipCode = zipCode;
                    return this;
                }
                
            }
            
            private final String cardHolderFirstName;
            private final String cardHolderLastName;
            private final String number;
            private final String expiryDate;
            private final int    csc;
            private final String address;
            private final String zipCode;
            private final String city;
            private final String province;
            
            private final String countryCode;
            
            private final String description;
            
            public CreditCardDetails (final String cardHolderFirstName, final String cardHolderLastName, final String number, final String expiryDate, final int csc,
                    final String address, final String zipCode, final String city, final String province, final String countryCode, final String description) {
                super ();
                this.cardHolderFirstName = cardHolderFirstName;
                this.cardHolderLastName = cardHolderLastName;
                this.number = number;
                this.expiryDate = expiryDate;
                this.csc = csc;
                this.address = address;
                this.zipCode = zipCode;
                this.city = city;
                this.province = province;
                this.countryCode = countryCode;
                this.description = description;
            }
        }
        
        @JsonDeserialize (builder = EncryptedCreditCardDetails.InstrumentedCreditCardBuilder.class)
        public static class EncryptedCreditCardDetails implements PaymentDetails {
            @JsonPOJOBuilder (withPrefix = "")
            public static class InstrumentedCreditCardBuilder implements Builder {
                private UUID   paymentInstrumentID;
                private String name;
                
                @Override
                public EncryptedCreditCardDetails build () {
                    return new EncryptedCreditCardDetails (this.paymentInstrumentID, this.name);
                }
                
                public InstrumentedCreditCardBuilder name (final String name) {
                    this.name = name;
                    return this;
                }
                
                public InstrumentedCreditCardBuilder paymentInstrumentID (final UUID paymentInstrumentID) {
                    this.paymentInstrumentID = paymentInstrumentID;
                    return this;
                }
                
            }
            
            private final UUID   paymentInstrumentID;
            
            private final String name;
            
            private EncryptedCreditCardDetails (final UUID paymentInstrumentID, final String name) {
                super ();
                this.paymentInstrumentID = paymentInstrumentID;
                this.name = name;
            }
        }
        
        public enum FormOfPayment {
            INDIVIDUAL_CREDIT_CARD (CreditCardDetails.IndividualCreditCardDetailsBuilder.class), COMPANY_CREDIT_CARD (
                    CreditCardDetails.CompanyCreditCardDetailsBuilder.class), INSTRUMENTED_CREDIT_CARD (EncryptedCreditCardDetails.InstrumentedCreditCardBuilder.class);
            
            private final Class<? extends PaymentDetails.Builder> builderClass;
            
            FormOfPayment (final Class<? extends PaymentDetails.Builder> builderClass) {
                this.builderClass = builderClass;
            }
            
            @SuppressWarnings ("unchecked")
            public <T extends PaymentDetails> Class<T> getDetailsClass () {
                return (Class<T>) this.builderClass.getEnclosingClass ();
            }
            
            public static FormOfPayment fromDetailsClass (Class<PaymentDetails> detailsClass) {
                for (FormOfPayment fop : FormOfPayment.values ()) {
                    if (fop.builderClass.getEnclosingClass () == detailsClass) {
                        return fop;
                    }
                }
                throw new IllegalArgumentException ("not found");
            }
        }
        
        public interface PaymentDetails {
            public interface Builder {
                PaymentDetails build ();
            }
        }
        
        @JsonDeserialize (builder = PaymentMean.Builder.class)
        public static class PaymentMean {
            
            @JsonPOJOBuilder (withPrefix = "")
            @JsonPropertyOrder ({ "form_of_payment", "payment_details" })
            public static class Builder {
                private FormOfPayment  formOfPayment;
                private PaymentDetails paymentDetails;
                
                public PaymentMean build () {
                    return new PaymentMean (this.formOfPayment, this.paymentDetails);
                }
                
                // if you annotate with @JsonIgnore, it works, but the value
                // disappears in the constructor
                public Builder formOfPayment (final FormOfPayment val) {
                    this.formOfPayment = val;
                    return this;
                }

                @JsonTypeInfo (use = JsonTypeInfo.Id.CUSTOM, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "form_of_payment", visible = true)
                @JsonTypeIdResolver (PaymentDetailsTypeIdResolver.class)
                public Builder paymentDetails (final PaymentDetails val) {
                    this.paymentDetails = val;
                    return this;
                }
            }
            
            public static Builder create () {
                return new Builder ();
            }
            
            private final FormOfPayment  formOfPayment;
            
            private final PaymentDetails paymentDetails;
            
            private PaymentMean (final FormOfPayment formOfPayment, final PaymentDetails paymentDetails) {
                super ();
                this.formOfPayment = formOfPayment;
                this.paymentDetails = paymentDetails;
            }
        }
        
        public static class PaymentDetailsTypeIdResolver implements TypeIdResolver {
            
            @Override
            public void init (JavaType baseType) {
            }
            
            @SuppressWarnings ("unchecked")
            @Override
            public String idFromValue (Object value) {
                if (! (value instanceof PaymentDetails)) {
                    return null;
                }
                return FormOfPayment.fromDetailsClass ((Class<PaymentDetails>) value.getClass ()).name ();
            }
            
            @Override
            public String idFromValueAndType (Object value, Class<?> suggestedType) {
                return this.idFromValue (value);
            }
            
            @Override
            public String idFromBaseType () {
                return null;
            }
            
            @Override
            public JavaType typeFromId (DatabindContext context, String id) throws IOException {
                return TypeFactory.defaultInstance ().constructType (FormOfPayment.valueOf (id).getDetailsClass ());
            }
            
            @Override
            public String getDescForKnownTypeIds () {
                return "PaymentDetails";
            }
            
            @Override
            public Id getMechanism () {
                return JsonTypeInfo.Id.CUSTOM;
            }
            
        }
    }
    
    @Test
    public void tryToDeserialize () throws JsonParseException, JsonMappingException, IOException {
        // given
        final String asJson1 = "{\"form_of_payment\":\"INDIVIDUAL_CREDIT_CARD\", \"payment_details\":{\"card_holder_first_name\":\"John\", \"card_holder_last_name\":\"Doe\",  \"number\":\"XXXXXXXXXXXXXXXX\", \"expiry_date\":\"MM/YY\","
                + "\"csc\":666,\"address\":\"10 boulevard de Sebastopol\",\"zip_code\":\"75001\",\"city\":\"Paris\",\"province\":\"Ile-de-France\",\"country_code\":\"FR\",\"description\":\"John Doe personal credit card\"}}";
        final String asJson2 = "{\"form_of_payment\":\"INSTRUMENTED_CREDIT_CARD\",\"payment_details\":{\"payment_instrument_id\":\"00000000-0000-0000-0000-000000000000\", \"name\":\"Mr John Doe encrypted credit card\"}}";
        final ObjectMapper objectMapper = new ObjectMapper ().setPropertyNamingStrategy (PropertyNamingStrategy.SNAKE_CASE)
                .disable (DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        
        // when
        objectMapper.readValue (asJson1, ClassesWithoutBuilder.PaymentMean.class);
        objectMapper.readValue (asJson2, ClassesWithBuilder.PaymentMean.class);
        
        // then payment1 and paymentMean2 should be unmarshalled successfully
    }
}=======
package com.fasterxml.jackson.databind.jsontype.ext;

import java.io.IOException;
import java.util.UUID;

import org.junit.Test;

import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;

import com.fasterxml.jackson.core.JsonParseException;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;
import com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdTest1288.ClassesWithBuilder.PaymentMean;
import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;

@SuppressWarnings("hiding")
public class ExternalTypeIdTest1288 extends BaseMapTest
{
    public static class ClassesWithoutBuilder {
        
        public static class CreditCardDetails implements PaymentDetails {
            
            protected String cardHolderFirstName;
            protected String cardHolderLastName;
            protected String number;
            protected String expiryDate;
            protected int csc;
            protected String address;
            protected String zipCode;
            protected String city;
            protected String province;
            
            protected String countryCode;
            
            protected String description;

            public void setCardHolderFirstName (String cardHolderFirstName) {
                this.cardHolderFirstName = cardHolderFirstName;
            }

            public void setCardHolderLastName (String cardHolderLastName) {
                this.cardHolderLastName = cardHolderLastName;
            }

            public void setNumber (String number) {
                this.number = number;
            }

            public void setExpiryDate (String expiryDate) {
                this.expiryDate = expiryDate;
            }

            public void setCsc (int csc) {
                this.csc = csc;
            }

            public void setAddress (String address) {
                this.address = address;
            }

            public void setZipCode (String zipCode) {
                this.zipCode = zipCode;
            }

            public void setCity (String city) {
                this.city = city;
            }

            public void setProvince (String province) {
                this.province = province;
            }

            public void setCountryCode (String countryCode) {
                this.countryCode = countryCode;
            }

            public void setDescription (String description) {
                this.description = description;
            }
            
            
        }
        
        public static class EncryptedCreditCardDetails implements PaymentDetails {
            
            protected UUID paymentInstrumentID;
            
            protected String name;

            public void setPaymentInstrumentID (UUID paymentInstrumentID) {
                this.paymentInstrumentID = paymentInstrumentID;
            }

            public void setName (String name) {
                this.name = name;
            }

        }
        
        public enum FormOfPayment {
            INDIVIDUAL_CREDIT_CARD (CreditCardDetails.class), COMPANY_CREDIT_CARD (
                    CreditCardDetails.class), INSTRUMENTED_CREDIT_CARD (EncryptedCreditCardDetails.class);
            
            private final Class<? extends PaymentDetails> clazz;
            
            FormOfPayment (final Class<? extends PaymentDetails> clazz) {
                this.clazz = clazz;
            }
            
            @SuppressWarnings ("unchecked")
            public <T extends PaymentDetails> Class<T> getDetailsClass () {
                return (Class<T>) this.clazz;
            }
            
            public static FormOfPayment fromDetailsClass (Class<PaymentDetails> detailsClass) {
                for (FormOfPayment fop : FormOfPayment.values ()) {
                    if (fop.clazz == detailsClass) {
                        return fop;
                    }
                }
                throw new IllegalArgumentException ("not found");
            }
        }
        
        public interface PaymentDetails {
            public interface Builder {
                PaymentDetails build ();
            }
        }
        
        public static class PaymentMean {
            
            FormOfPayment formOfPayment;
            
            PaymentDetails paymentDetails;

            public void setFormOfPayment (FormOfPayment formOfPayment) {
                this.formOfPayment = formOfPayment;
            }

            @JsonTypeInfo (use = JsonTypeInfo.Id.CUSTOM, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "form_of_payment", visible = true)
            @JsonTypeIdResolver (PaymentDetailsTypeIdResolver.class)
            public void setPaymentDetails (PaymentDetails paymentDetails) {
                this.paymentDetails = paymentDetails;
            }
            
        }
        
        public static class PaymentDetailsTypeIdResolver extends TypeIdResolverBase {
            @SuppressWarnings ("unchecked")
            @Override
            public String idFromValue (Object value) {
                if (! (value instanceof PaymentDetails)) {
                    return null;
                }
                return FormOfPayment.fromDetailsClass ((Class<PaymentDetails>) value.getClass ()).name ();
            }
            
            @Override
            public String idFromValueAndType (Object value, Class<?> suggestedType) {
                return this.idFromValue (value);
            }

            @Override
            public JavaType typeFromId (DatabindContext context, String id) {
                return context.getTypeFactory().constructType(FormOfPayment.valueOf(id).getDetailsClass ());
            }

            @Override
            public String getDescForKnownTypeIds () {
                return "PaymentDetails";
            }
            
            @Override
            public Id getMechanism () {
                return JsonTypeInfo.Id.CUSTOM;
            }
        }
    }
    
    public static class ClassesWithBuilder {
        
        @JsonDeserialize (builder = CreditCardDetails.IndividualCreditCardDetailsBuilder.class)
        public static class CreditCardDetails implements PaymentDetails {
            @JsonPOJOBuilder (withPrefix = "")
            public static class CompanyCreditCardDetailsBuilder implements Builder {
                private String cardHolderFirstName;
                private String cardHolderLastName;
                private String number;
                private String expiryDate;
                private int csc;
                private String address;
                private String zipCode;
                private String city;
                private String province;
                private String countryCode;
                
                public CompanyCreditCardDetailsBuilder address (final String a) {
                    address = a;
                    return this;
                }
                
                @Override
                public CreditCardDetails build() {
                    return new CreditCardDetails (this.cardHolderFirstName, this.cardHolderLastName, this.number, this.expiryDate, this.csc, this.address, this.zipCode, this.city,
                            this.province, this.countryCode, "COMPANY CREDIT CARD");
                }
                
                public CompanyCreditCardDetailsBuilder cardHolderFirstName(final String cardHolderFirstName) {
                    this.cardHolderFirstName = cardHolderFirstName;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder cardHolderLastName (final String cardHolderLastName) {
                    this.cardHolderLastName = cardHolderLastName;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder city (final String city) {
                    this.city = city;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder countryCode (final String countryCode) {
                    this.countryCode = countryCode;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder csc (final int csc) {
                    this.csc = csc;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder expiryDate (final String expiryDate) {
                    this.expiryDate = expiryDate;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder number (final String number) {
                    this.number = number;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder province (final String province) {
                    this.province = province;
                    return this;
                }
                
                public CompanyCreditCardDetailsBuilder zipCode (final String zipCode) {
                    this.zipCode = zipCode;
                    return this;
                }
            }
            
            @JsonPOJOBuilder (withPrefix = "")
            public static class IndividualCreditCardDetailsBuilder implements Builder {
                private String cardHolderFirstName;
                private String cardHolderLastName;
                private String number;
                private String expiryDate;
                private int    csc;
                private String address;
                private String zipCode;
                private String city;
                private String province;
                private String countryCode;
                private String description;
                
                public IndividualCreditCardDetailsBuilder address (final String address) {
                    this.address = address;
                    return this;
                }
                
                @Override
                public CreditCardDetails build () {
                    return new CreditCardDetails (this.cardHolderFirstName, this.cardHolderLastName, this.number, this.expiryDate, this.csc, this.address, this.zipCode, this.city,
                            this.province, this.countryCode, this.description);
                }
                
                public IndividualCreditCardDetailsBuilder cardHolderFirstName (final String cardHolderFirstName) {
                    this.cardHolderFirstName = cardHolderFirstName;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder cardHolderLastName (final String cardHolderLastName) {
                    this.cardHolderLastName = cardHolderLastName;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder city (final String city) {
                    this.city = city;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder countryCode (final String countryCode) {
                    this.countryCode = countryCode;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder csc (final int csc) {
                    this.csc = csc;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder description (final String description) {
                    this.description = description;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder expiryDate (final String expiryDate) {
                    this.expiryDate = expiryDate;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder number (final String number) {
                    this.number = number;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder province (final String p) {
                    province = p;
                    return this;
                }
                
                public IndividualCreditCardDetailsBuilder zipCode (final String z) {
                    zipCode = z;
                    return this;
                }
                
            }
            
            protected final String cardHolderFirstName;
            protected final String cardHolderLastName;
            protected final String number;
            protected final String expiryDate;
            protected final int    csc;
            protected final String address;
            protected final String zipCode;
            protected final String city;
            protected final String province;
            
            protected final String countryCode;
            
            protected final String description;
            
            public CreditCardDetails (final String cardHolderFirstName, final String cardHolderLastName, final String number, final String expiryDate, final int csc,
                    final String address, final String zipCode, final String city, final String province, final String countryCode, final String description) {
                super ();
                this.cardHolderFirstName = cardHolderFirstName;
                this.cardHolderLastName = cardHolderLastName;
                this.number = number;
                this.expiryDate = expiryDate;
                this.csc = csc;
                this.address = address;
                this.zipCode = zipCode;
                this.city = city;
                this.province = province;
                this.countryCode = countryCode;
                this.description = description;
            }
        }
        
        @JsonDeserialize (builder = EncryptedCreditCardDetails.InstrumentedCreditCardBuilder.class)
        public static class EncryptedCreditCardDetails implements PaymentDetails {
            @JsonPOJOBuilder (withPrefix = "")
            public static class InstrumentedCreditCardBuilder implements Builder {
                private UUID   paymentInstrumentID;
                private String name;
                
                @Override
                public EncryptedCreditCardDetails build () {
                    return new EncryptedCreditCardDetails (this.paymentInstrumentID, this.name);
                }
                
                public InstrumentedCreditCardBuilder name (final String name) {
                    this.name = name;
                    return this;
                }
                
                public InstrumentedCreditCardBuilder paymentInstrumentID (final UUID paymentInstrumentID) {
                    this.paymentInstrumentID = paymentInstrumentID;
                    return this;
                }
            }

            protected final UUID paymentInstrumentID;
            protected final String name;

            private EncryptedCreditCardDetails (final UUID paymentInstrumentID, final String name) {
                super ();
                this.paymentInstrumentID = paymentInstrumentID;
                this.name = name;
            }
        }
        
        public enum FormOfPayment {
            INDIVIDUAL_CREDIT_CARD (CreditCardDetails.IndividualCreditCardDetailsBuilder.class), COMPANY_CREDIT_CARD (
                    CreditCardDetails.CompanyCreditCardDetailsBuilder.class), INSTRUMENTED_CREDIT_CARD (EncryptedCreditCardDetails.InstrumentedCreditCardBuilder.class);
            
            private final Class<? extends PaymentDetails.Builder> builderClass;
            
            FormOfPayment (final Class<? extends PaymentDetails.Builder> builderClass) {
                this.builderClass = builderClass;
            }
            
            @SuppressWarnings ("unchecked")
            public <T extends PaymentDetails> Class<T> getDetailsClass () {
                return (Class<T>) this.builderClass.getEnclosingClass ();
            }
            
            public static FormOfPayment fromDetailsClass (Class<PaymentDetails> detailsClass) {
                for (FormOfPayment fop : FormOfPayment.values ()) {
                    if (fop.builderClass.getEnclosingClass () == detailsClass) {
                        return fop;
                    }
                }
                throw new IllegalArgumentException ("not found");
            }
        }
        
        public interface PaymentDetails {
            public interface Builder {
                PaymentDetails build ();
            }
        }
        
        @JsonDeserialize (builder = PaymentMean.Builder.class)
        public static class PaymentMean {
            
            @JsonPOJOBuilder (withPrefix = "")
            @JsonPropertyOrder ({ "form_of_payment", "payment_details" })
            public static class Builder {
                private FormOfPayment  formOfPayment;
                private PaymentDetails paymentDetails;
                
                public PaymentMean build () {
                    return new PaymentMean (this.formOfPayment, this.paymentDetails);
                }
                
                // if you annotate with @JsonIgnore, it works, but the value
                // disappears in the constructor
                public Builder formOfPayment (final FormOfPayment val) {
                    this.formOfPayment = val;
                    return this;
                }

                @JsonTypeInfo (use = JsonTypeInfo.Id.CUSTOM, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = "form_of_payment", visible = true)
                @JsonTypeIdResolver (PaymentDetailsTypeIdResolver.class)
                public Builder paymentDetails (final PaymentDetails val) {
                    this.paymentDetails = val;
                    return this;
                }
            }
            
            public static Builder create() {
                return new Builder();
            }

            protected final FormOfPayment  formOfPayment;
            protected final PaymentDetails paymentDetails;

            private PaymentMean (final FormOfPayment formOfPayment, final PaymentDetails paymentDetails) {
                super ();
                this.formOfPayment = formOfPayment;
                this.paymentDetails = paymentDetails;
            }
        }
        
        public static class PaymentDetailsTypeIdResolver extends TypeIdResolverBase {
            @SuppressWarnings ("unchecked")
            @Override
            public String idFromValue (Object value) {
                if (! (value instanceof PaymentDetails)) {
                    return null;
                }
                return FormOfPayment.fromDetailsClass ((Class<PaymentDetails>) value.getClass ()).name ();
            }
            
            @Override
            public String idFromValueAndType (Object value, Class<?> suggestedType) {
                return this.idFromValue (value);
            }

            @Override
            public JavaType typeFromId (DatabindContext context, String id) {
                return context.getTypeFactory().constructType(FormOfPayment.valueOf (id).getDetailsClass ());
            }
            
            @Override
            public String getDescForKnownTypeIds () {
                return "PaymentDetails";
            }
            
            @Override
            public Id getMechanism () {
                return JsonTypeInfo.Id.CUSTOM;
            }
        }
    }

    public void testVisibleExternalTypeId1288() throws Exception
    {
        // given
        final String asJson1 = "{\"form_of_payment\":\"INDIVIDUAL_CREDIT_CARD\", \"payment_details\":{\"card_holder_first_name\":\"John\", \"card_holder_last_name\":\"Doe\",  \"number\":\"XXXXXXXXXXXXXXXX\", \"expiry_date\":\"MM/YY\","
                + "\"csc\":666,\"address\":\"10 boulevard de Sebastopol\",\"zip_code\":\"75001\",\"city\":\"Paris\",\"province\":\"Ile-de-France\",\"country_code\":\"FR\",\"description\":\"John Doe personal credit card\"}}";
        final String asJson2 = "{\"form_of_payment\":\"INSTRUMENTED_CREDIT_CARD\",\"payment_details\":{\"payment_instrument_id\":\"00000000-0000-0000-0000-000000000000\", \"name\":\"Mr John Doe encrypted credit card\"}}";
        final ObjectMapper objectMapper = new ObjectMapper ().setPropertyNamingStrategy (PropertyNamingStrategy.SNAKE_CASE);
//                .disable (DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        ClassesWithoutBuilder.PaymentMean ob1 = objectMapper.readValue (asJson1, ClassesWithoutBuilder.PaymentMean.class);
        assertNotNull(ob1);
        ClassesWithBuilder.PaymentMean ob2 = objectMapper.readValue (asJson2, ClassesWithBuilder.PaymentMean.class);
        assertNotNull(ob2);

    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c4ecc55_f6fbed5/rev_c4ecc55-f6fbed5/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE
            p.nextToken();
=======
            t = p.nextToken();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c4ecc55_f6fbed5/rev_c4ecc55-f6fbed5/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE
=======
                // [JACKSON-831]: may have property AND be used as external type id:
                if (t.isScalarValue()) {
                    ext.handleTypePropertyValue(p, ctxt, propName, bean);
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_be64ad5_24166ac/rev_be64ad5-24166ac/src/test/java/com/fasterxml/jackson/databind/deser/TestJDKAtomicTypes.java;<<<<<<< MINE

    public void testEmpty1256() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);

        String json = mapper.writeValueAsString(new Issue1256Bean());
        assertEquals("{}", json);
    }
=======

    // [databind#1307]
    @SuppressWarnings("unchecked")
    public void testNullValueHandling() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        AtomicReference<Double> inputData = new AtomicReference<Double>();
        String json = mapper.writeValueAsString(inputData);
        AtomicReference<Double> readData = (AtomicReference<Double>) mapper.readValue(json, AtomicReference.class);
        assertNotNull(readData);
        assertNull(readData.get());
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e4dd521_958c824/rev_e4dd521-958c824/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java;<<<<<<< MINE
import java.io.IOException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e4dd521_958c824/rev_e4dd521-958c824/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java;<<<<<<< MINE
import org.junit.Test;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e4dd521_958c824/rev_e4dd521-958c824/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonParseException;

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e4dd521_958c824/rev_e4dd521-958c824/src/test/java/com/fasterxml/jackson/databind/jsontype/ext/ExternalTypeIdTest1288.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdTest1288.ClassesWithBuilder.PaymentMean;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_02a803a_0aa6486/rev_02a803a-0aa6486/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
            if (index >= 0 && index <= _enumsByIndex.length) {
=======
            if (index >= 0 && index < _enumsByIndex.length) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2d80120_e979bc5/rev_2d80120-e979bc5/src/test/java/com/fasterxml/jackson/databind/filter/JsonIncludeTest.java;<<<<<<< MINE

    @JsonPropertyOrder({"list", "map"})
    static class EmptyListMapBean
    {
        public List<String> list = Collections.emptyList();

        public Map<String,String> map = Collections.emptyMap();
    }
    
=======

    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    public static class Issues1327Bean {
        public String myString = "stuff";
        public List<String> myList = new ArrayList<String>();
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2d80120_e979bc5/rev_2d80120-e979bc5/src/test/java/com/fasterxml/jackson/databind/filter/JsonIncludeTest.java;<<<<<<< MINE

    public void testPropConfigOverridesForInclude() throws IOException
    {
        // First, with defaults, both included:
        EmptyListMapBean empty = new EmptyListMapBean();
        assertEquals(aposToQuotes("{'list':[],'map':{}}"),
                MAPPER.writeValueAsString(empty));
        ObjectMapper mapper;

        // and then change inclusion criteria for either

        mapper = new ObjectMapper();
        mapper.configOverride(Map.class)
            .setInclude(JsonInclude.Value.construct(JsonInclude.Include.NON_EMPTY, null));
        assertEquals(aposToQuotes("{'list':[]}"),
                mapper.writeValueAsString(empty));
        
        mapper = new ObjectMapper();
        mapper.configOverride(List.class)
            .setInclude(JsonInclude.Value.construct(JsonInclude.Include.NON_EMPTY, null));
        assertEquals(aposToQuotes("{'map':{}}"),
                mapper.writeValueAsString(empty));
    }
=======

    public void testIssue1327() throws Exception {
        ObjectMapper om = new ObjectMapper();
        om.setSerializationInclusion(JsonInclude.Include.NON_NULL);

        final Issues1327Bean input = new Issues1327Bean();
        final String jsonString = om.writeValueAsString(input);

        if (jsonString.contains("myList")) {
            fail("Should not contain `myList`: "+jsonString);
        }
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_facb2c0_e4b261e/rev_facb2c0-e4b261e/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionDeserialization.java;<<<<<<< MINE
    // [Issue#381]
=======
    // [databind#381]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_facb2c0_e4b261e/rev_facb2c0-e4b261e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-235]: need to retain name of managed forward references:
=======
        // need to retain name of managed forward references:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bb06aa0_1904839/rev_bb06aa0-1904839/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.annotation.JsonIgnore;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        return (_property == prop) ? this : new AsArrayTypeSerializer(this._idResolver, prop);
=======
        return (_property == prop) ? this : new AsArrayTypeSerializer(_idResolver, prop);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartObject();
=======
        g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g, Class<?> type) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartObject();
=======
        g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartArray();
=======
        g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g, Class<?> type) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartArray();
=======
        g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g, Class<?> type) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        if (jgen.canWriteTypeId()) {
=======
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException {
        jgen.writeEndObject();
        if (!jgen.canWriteTypeId()) {
            jgen.writeEndArray();
=======
    public void writeTypeSuffixForObject(Object value, JsonGenerator g) throws IOException {
        g.writeEndObject();
        if (!g.canWriteTypeId()) {
            g.writeEndArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException {
=======
    public void writeTypeSuffixForArray(Object value, JsonGenerator g) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeEndArray();
        if (!jgen.canWriteTypeId()) {
            jgen.writeEndArray();
=======
        g.writeEndArray();
        if (!g.canWriteTypeId()) {
            g.writeEndArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException {
        if (!jgen.canWriteTypeId()) {
=======
    public void writeTypeSuffixForScalar(Object value, JsonGenerator g) throws IOException {
        if (!g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeEndArray();
=======
            g.writeEndArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForObject(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartObject();
=======
        g.writeStartObject();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForArray(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
        jgen.writeStartArray();
=======
        g.writeStartArray();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypePrefixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (jgen.canWriteTypeId()) {
=======
    public void writeCustomTypePrefixForScalar(Object value, JsonGenerator g, String typeId) throws IOException {
        if (g.canWriteTypeId()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
                jgen.writeTypeId(typeId);
=======
                g.writeTypeId(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
            jgen.writeStartArray();
            jgen.writeString(typeId);
=======
            g.writeStartArray();
            g.writeString(typeId);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForObject(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForObject(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForObject(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForArray(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForArray(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForArray(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java;<<<<<<< MINE
    public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException {
        if (!jgen.canWriteTypeId()) {
            writeTypeSuffixForScalar(value, jgen); // standard impl works fine
=======
    public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator g, String typeId) throws IOException {
        if (!g.canWriteTypeId()) {
            writeTypeSuffixForScalar(value, g); // standard impl works fine
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java;<<<<<<< MINE
        return (_property == prop) ? this : new AsWrapperTypeSerializer(this._idResolver, prop);
=======
        return (_property == prop) ? this : new AsWrapperTypeSerializer(_idResolver, prop);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException;
=======
    public abstract void writeTypePrefixForScalar(Object value, JsonGenerator g) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException;
=======
    public abstract void writeTypePrefixForObject(Object value, JsonGenerator g) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException;
=======
    public abstract void writeTypePrefixForArray(Object value, JsonGenerator g) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException;
=======
    public abstract void writeTypeSuffixForScalar(Object value, JsonGenerator g) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException;
=======
    public abstract void writeTypeSuffixForObject(Object value, JsonGenerator g) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException;
=======
    public abstract void writeTypeSuffixForArray(Object value, JsonGenerator g) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
        writeTypePrefixForScalar(value, jgen);
=======
    public void writeTypePrefixForScalar(Object value, JsonGenerator g, Class<?> type) throws IOException {
        writeTypePrefixForScalar(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
        writeTypePrefixForObject(value, jgen);
=======
    public void writeTypePrefixForObject(Object value, JsonGenerator g, Class<?> type) throws IOException {
        writeTypePrefixForObject(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type) throws IOException {
        writeTypePrefixForArray(value, jgen);
=======
    public void writeTypePrefixForArray(Object value, JsonGenerator g, Class<?> type) throws IOException {
        writeTypePrefixForArray(value, g);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeCustomTypePrefixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException;
=======
    public abstract void writeCustomTypePrefixForScalar(Object value, JsonGenerator g, String typeId) throws IOException, JsonProcessingException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param jgen Generator to use for writing type information
=======
     * @param g Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException;
=======
    public abstract void writeCustomTypePrefixForObject(Object value, JsonGenerator g, String typeId) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException;
=======
    public abstract void writeCustomTypePrefixForArray(Object value, JsonGenerator g, String typeId) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeCustomTypeSuffixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException;
=======
    public abstract void writeCustomTypeSuffixForScalar(Object value, JsonGenerator g, String typeId) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException;
=======
    public abstract void writeCustomTypeSuffixForObject(Object value, JsonGenerator g, String typeId) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
    public abstract void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException;
=======
    public abstract void writeCustomTypeSuffixForArray(Object value, JsonGenerator g, String typeId) throws IOException;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9c39fc2_ceddd2c/rev_9c39fc2-ceddd2c/src/test/java/com/fasterxml/jackson/failing/ObjectIdWithCreator1367Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.failing;

import java.beans.ConstructorProperties;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import com.fasterxml.jackson.databind.*;

public class ObjectIdWithCreator1367Test
    extends BaseMapTest
{
    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id")
//            resolver = SimpleObjectIdResolver.class)
    public static class A {
        String id;
        String name;

        public A() { }

        @ConstructorProperties({"id", "name"})
        public A(String id, String name) {
            this.id = id;
            this.name = name;
        }

        public String getId() {
            return id;
        }
        public void setId(String id) {
            this.id = id;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }

    public void testObjectIdWithCreator1367() throws Exception
    {
        A a = new A("123", "A");

        ObjectMapper om = new ObjectMapper();
        String json = om.writeValueAsString(a);
        A deser = om.readValue(json, A.class);
        assertEquals(a.name, deser.name);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8a5b111_efc6b98/rev_8a5b111-efc6b98/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java;<<<<<<< MINE
     * @param g Generator to use for writing type information
=======
     * @param gen Generator to use for writing type information
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fdd9596_ab4f17f/rev_fdd9596-ab4f17f/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java;<<<<<<< MINE
package com.fasterxml.jackson.databind.deser;

import java.io.*;

import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.exc.InputMismatchException;
import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;

/**
 * Unit test for verifying that exceptions are properly handled (caught,
 * re-thrown or wrapped, depending)
 * with Object deserialization.
 */
public class TestExceptionHandling
    extends BaseMapTest
{
    static class Bean {
        public String propX;
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */
    
    /**
     * Verification of [JACKSON-301]
     */
    public void testHandlingOfUnrecognized() throws Exception
    {
        UnrecognizedPropertyException exc = null;
        try {
            new ObjectMapper().readValue("{\"bar\":3}", Bean.class);
        } catch (UnrecognizedPropertyException e) {
            exc = e;
        }
        if (exc == null) {
            fail("Should have failed binding");
        }
        assertEquals("bar", exc.getPropertyName());
        assertEquals(Bean.class, exc.getReferringClass());
        // also: should get list of known properties
        verifyException(exc, "propX");
    }

    /**
     * Simple test to check behavior when end-of-stream is encountered
     * without content. Used to expect EOFException (Jackson 1.x); but
     * nowadays ought to be JsonMappingException
     */
    public void testExceptionWithEmpty() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        try {
            Object result = mapper.readValue("    ", Object.class);
            fail("Expected an exception, but got result value: "+result);
        } catch (Exception e) {
            verifyException(e, InputMismatchException.class, "No content");
        }
    }

    @SuppressWarnings("resource")
    public void testExceptionWithIncomplete()
        throws Exception
    {
        BrokenStringReader r = new BrokenStringReader("[ 1, ", "TEST");
        JsonFactory f = new JsonFactory();
        JsonParser jp = f.createParser(r);
        ObjectMapper mapper = new ObjectMapper();
        try {
            @SuppressWarnings("unused")
            Object ob = mapper.readValue(jp, Object.class);
            fail("Should have gotten an exception");
        } catch (IOException e) {
            /* For "bona fide" IO problems (due to low-level problem,
             * thrown by reader/stream), IOException must be thrown
             */
            verifyException(e, IOException.class, "TEST");
        }
    }

    public void testExceptionWithEOF() throws Exception
    {
        StringReader r = new StringReader("  3");
        JsonFactory f = new JsonFactory();
        JsonParser jp = f.createParser(r);
        ObjectMapper mapper = new ObjectMapper();

        Integer I = mapper.readValue(jp, Integer.class);
        assertEquals(3, I.intValue());

        // and then end-of-input...
        try {
            I = mapper.readValue(jp, Integer.class);
            fail("Should have gotten an exception");
        } catch (IOException e) {
            verifyException(e, InputMismatchException.class, "No content");
        }
        // also: should have no current token after end-of-input
        JsonToken t = jp.getCurrentToken();
        if (t != null) {
            fail("Expected current token to be null after end-of-stream, was: "+t);
        }
        jp.close();
    }

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    void verifyException(Exception e, Class<?> expType, String expMsg)
        throws Exception
    {
        if (e.getClass() != expType) {
            fail("Expected exception of type "+expType.getName()+", got "+e.getClass().getName());
        }
        if (expMsg != null) {
            verifyException(e, expMsg);
        }
    }
}=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_847fd82_ea30c7b/rev_847fd82-ea30c7b/src/test/java/com/fasterxml/jackson/databind/filter/JsonIncludeTest.java;<<<<<<< MINE
    static class Issue1351Bean
    {
        public final String first;
        public final double second;

        public Issue1351Bean(String first, double second) {
            this.first = first;
            this.second = second;
        }
    }

    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
    static abstract class Issue1351NonBeanParent
    {
        protected static final String NUM_VAR = "num";
        protected final int num;

        @com.fasterxml.jackson.annotation.JsonCreator
        public Issue1351NonBeanParent(@com.fasterxml.jackson.annotation.JsonProperty(NUM_VAR) int num) {
            this.num = num;
        }

        @com.fasterxml.jackson.annotation.JsonProperty(NUM_VAR)
        public int getNum() {
            return num;
        }
    }

    static class Issue1351NonBean extends Issue1351NonBeanParent {
        private String str;

        @com.fasterxml.jackson.annotation.JsonCreator
        public Issue1351NonBean(@com.fasterxml.jackson.annotation.JsonProperty(NUM_VAR) int num) {
            super(num);
        }

        public String getStr() {
            return str;
        }

        public void setStr(String str) {
            this.str = str;
        }
    }
    
=======
    // [databind#1351], [databind#1417]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b6d330f_6362e24/rev_b6d330f-6362e24/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java;<<<<<<< MINE
=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b6d330f_6362e24/rev_b6d330f-6362e24/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java;<<<<<<< MINE
=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b6d330f_6362e24/rev_b6d330f-6362e24/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java;<<<<<<< MINE
=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b6d330f_6362e24/rev_b6d330f-6362e24/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java;<<<<<<< MINE
import com.fasterxml.jackson.core.JsonParser.NumberType;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_179088e_9257bd6/rev_179088e-9257bd6/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java;<<<<<<< MINE
=======
    // [databind#142]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f2b029d_494ebce/rev_f2b029d-494ebce/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java;<<<<<<< MINE
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
=======
import java.util.*;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7eaf599_407f10e/rev_7eaf599-407f10e/src/main/java/com/fasterxml/jackson/databind/deser/std/ReferenceTypeDeserializer.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.deser.ValueInstantiator;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7eaf599_407f10e/rev_7eaf599-407f10e/src/main/java/com/fasterxml/jackson/databind/deser/std/ReferenceTypeDeserializer.java;<<<<<<< MINE
    @Deprecated // since 2.9
    public ReferenceTypeDeserializer(JavaType fullType,
            TypeDeserializer typeDeser, JsonDeserializer<?> deser)
    {
        this(fullType, null, typeDeser, deser);
    }

=======
    // NOTE: for forwards-compatibility; added in 2.8.5 since 2.9.0 has it
    public ReferenceTypeDeserializer(JavaType fullType, ValueInstantiator inst,
            TypeDeserializer typeDeser, JsonDeserializer<?> deser) {
        this(fullType, typeDeser, deser);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c3cad3_4499bb6/rev_2c3cad3-4499bb6/src/test/java/com/fasterxml/jackson/failing/GenericParameterTypeFactory1456Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.failing;

import java.lang.reflect.Method;
import java.lang.reflect.Type;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.introspect.AnnotatedClass;
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;

public class GenericParameterTypeFactory1456Test extends BaseMapTest
{
    public static class BaseController<Entity extends BaseEntity> {
        public void process(Entity entity) {}
    }

    public static class ImplController extends BaseController<ImplEntity> {}

    public static class BaseEntity {}

    public static class ImplEntity extends BaseEntity {}

    private final ObjectMapper MAPPER = new ObjectMapper();
    
    public void testGenericParameterDirect() throws Exception
    {
        Method proceed = BaseController.class.getMethod("process", BaseEntity.class);
        Type entityType = proceed.getGenericParameterTypes()[0];

        JavaType resolvedType = MAPPER.getTypeFactory().constructType(entityType, ImplController.class);
        assertEquals(ImplEntity.class, resolvedType.getRawClass());
    }

    public void testGenericParameterViaClass() throws Exception
    {
        BeanDescription desc = MAPPER.getDeserializationConfig().introspect(
                MAPPER.constructType(ImplController.class));
        AnnotatedClass ac = desc.getClassInfo();
        AnnotatedMethod m = ac.findMethod("process", new Class<?>[] { BaseEntity.class });
        assertNotNull(m);
        assertEquals(1, m.getParameterCount());
        AnnotatedParameter param = m.getParameter(0);
        assertEquals(ImplEntity.class, param.getType().getRawClass());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_a0bd159_c3e0113/rev_a0bd159-c3e0113/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import java.io.*;
import java.util.*;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;
import com.fasterxml.jackson.databind.module.SimpleModule;

/**
 * Unit tests for verifying "raw" (or "untyped") data binding from JSON to JDK objects;
 * one that only uses core JDK types; wrappers, Maps and Lists.
 */
@SuppressWarnings("serial")
public class TestUntypedDeserialization
    extends BaseMapTest
{
    static class UCStringDeserializer
        extends StdScalarDeserializer<String>
    {
        public UCStringDeserializer() { super(String.class); }

        @Override
        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
            return jp.getText().toUpperCase();
        }
    }

    static class CustomNumberDeserializer
        extends StdScalarDeserializer<Number>
    {
        protected final Integer value;
        
        public CustomNumberDeserializer(int nr) {
            super(Number.class);
            value = nr;
        }

        @Override
        public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
            return value;
        }
    }

    // Let's make this Contextual, to tease out cyclic resolution issues, if any
    static class ListDeserializer extends StdDeserializer<List<Object>>
        implements ContextualDeserializer
    {
        public ListDeserializer() { super(List.class); }

        @Override
        public List<Object> deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException
        {
            ArrayList<Object> list = new ArrayList<Object>();
            while (jp.nextValue() != JsonToken.END_ARRAY) {
                list.add("X"+jp.getText());
            }
            return list;
        }

        @Override
        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
                BeanProperty property) throws JsonMappingException
        {
            // For now, we just need to access "untyped" deserializer; not use it.
            
            /*JsonDeserializer<Object> ob = */
            ctxt.findContextualValueDeserializer(ctxt.constructType(Object.class), property);
            return this;
        }
    }

    static class MapDeserializer extends StdDeserializer<Map<String,Object>>
    {
        public MapDeserializer() { super(Map.class); }

        @Override
        public Map<String,Object> deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException
        {
            Map<String,Object> map = new LinkedHashMap<String,Object>();
            while (jp.nextValue() != JsonToken.END_OBJECT) {
                map.put(jp.getCurrentName(), "Y"+jp.getText());
            }
            return map;
        }
    }

    static class DelegatingUntyped {
        protected Object value;
        
        @JsonCreator // delegating
        public DelegatingUntyped(Object v) {
            value = v;
        }
    }

    static class WrappedUntyped1460 {
        public Object value;
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();
    
    @SuppressWarnings("unchecked")
    public void testSampleDoc() throws Exception
    {
        final String JSON = SAMPLE_DOC_JSON_SPEC;

        /* To get "untyped" Mapping (to Maps, Lists, instead of beans etc),
         * we'll specify plain old Object.class as the target.
         */
        Object root = MAPPER.readValue(JSON, Object.class);

        assertType(root, Map.class);
        Map<?,?> rootMap = (Map<?,?>) root;
        assertEquals(1, rootMap.size());
        Map.Entry<?,?> rootEntry =  rootMap.entrySet().iterator().next();
        assertEquals("Image", rootEntry.getKey());
        Object image = rootEntry.getValue();
        assertType(image, Map.class);
        Map<?,?> imageMap = (Map<?,?>) image;
        assertEquals(5, imageMap.size());

        Object value = imageMap.get("Width");
        assertType(value, Integer.class);
        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_WIDTH), value);

        value = imageMap.get("Height");
        assertType(value, Integer.class);
        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), value);

        assertEquals(SAMPLE_SPEC_VALUE_TITLE, imageMap.get("Title"));

        // Another Object, "thumbnail"
        value = imageMap.get("Thumbnail");
        assertType(value, Map.class);
        Map<?,?> tnMap = (Map<?,?>) value;
        assertEquals(3, tnMap.size());

        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), tnMap.get("Height"));
        // for some reason, width is textual, not numeric...
        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, tnMap.get("Width"));
        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, tnMap.get("Url"));

        // And then number list, "IDs"
        value = imageMap.get("IDs");
        assertType(value, List.class);
        List<Object> ids = (List<Object>) value;
        assertEquals(4, ids.size());
        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), ids.get(0));
        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), ids.get(1));
        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), ids.get(2));
        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), ids.get(3));

        // and that's all folks!
    }
    
    public void testNestedUntypes() throws IOException
    {
        // 05-Apr-2014, tatu: Odd failures if using shared mapper; so work around:
        Object root = MAPPER.readValue(aposToQuotes("{'a':3,'b':[1,2]}"),
                Object.class);
        assertTrue(root instanceof Map<?,?>);
        Map<?,?> map = (Map<?,?>) root;
        assertEquals(2, map.size());
        assertEquals(Integer.valueOf(3), map.get("a"));
        Object ob = map.get("b");
        assertTrue(ob instanceof List<?>);
        List<?> l = (List<?>) ob;
        assertEquals(2, l.size());
        assertEquals(Integer.valueOf(2), l.get(1));
    }
    
    // Allow 'upgrade' of big integers into Long, BigInteger
    public void testObjectSerializeWithLong() throws IOException
    {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping(DefaultTyping.JAVA_LANG_OBJECT, As.PROPERTY);
        final long VALUE = 1337800584532L;

        String serialized = "{\"timestamp\":"+VALUE+"}";
        // works fine as node
        JsonNode deserialized = mapper.readTree(serialized);
        assertEquals(VALUE, deserialized.get("timestamp").asLong());
        // and actually should work in Maps too
        Map<?,?> deserMap = mapper.readValue(serialized, Map.class);
        Number n = (Number) deserMap.get("timestamp");
        assertNotNull(n);
        assertSame(Long.class, n.getClass());
        assertEquals(Long.valueOf(VALUE), n);
    }

    public void testUntypedWithCustomScalarDesers() throws IOException
    {
        SimpleModule m = new SimpleModule("test-module");
        m.addDeserializer(String.class, new UCStringDeserializer());
        m.addDeserializer(Number.class, new CustomNumberDeserializer(13));
        final ObjectMapper mapper = new ObjectMapper()
            .registerModule(m);

        Object ob = mapper.readValue("{\"a\":\"b\", \"nr\":1 }", Object.class);
        assertTrue(ob instanceof Map);
        Object value = ((Map<?,?>) ob).get("a");
        assertNotNull(value);
        assertTrue(value instanceof String);
        assertEquals("B", value);

        value = ((Map<?,?>) ob).get("nr");
        assertNotNull(value);
        assertTrue(value instanceof Number);
        assertEquals(Integer.valueOf(13), value);
    }

    public void testUntypedWithListDeser() throws IOException
    {
        SimpleModule m = new SimpleModule("test-module");
        m.addDeserializer(List.class, new ListDeserializer());
        final ObjectMapper mapper = new ObjectMapper()
            .registerModule(m);

        // And then list...
        Object ob = mapper.readValue("[1, 2, true]", Object.class);
        assertTrue(ob instanceof List<?>);
        List<?> l = (List<?>) ob;
        assertEquals(3, l.size());
        assertEquals("X1", l.get(0));
        assertEquals("X2", l.get(1));
        assertEquals("Xtrue", l.get(2));
    }

    public void testUntypedWithMapDeser() throws IOException
    {
        SimpleModule m = new SimpleModule("test-module");
        m.addDeserializer(Map.class, new MapDeserializer());
        final ObjectMapper mapper = new ObjectMapper()
            .registerModule(m);

        // And then list...
        Object ob = mapper.readValue("{\"a\":true}", Object.class);
        assertTrue(ob instanceof Map<?,?>);
        Map<?,?> map = (Map<?,?>) ob;
        assertEquals(1, map.size());
        assertEquals("Ytrue", map.get("a"));
    }

    public void testNestedUntyped989() throws IOException
    {
        DelegatingUntyped pojo;
        ObjectReader r = MAPPER.readerFor(DelegatingUntyped.class);

        pojo = r.readValue("[]");
        assertTrue(pojo.value instanceof List);
        pojo = r.readValue("[{}]");
        assertTrue(pojo.value instanceof List);
        
        pojo = r.readValue("{}");
        assertTrue(pojo.value instanceof Map);
        pojo = r.readValue("{\"a\":[]}");
        assertTrue(pojo.value instanceof Map);
    }

    public void testUntypedWithJsonArrays() throws Exception
    {
        // by default we get:
        Object ob = MAPPER.readValue("[1]", Object.class);
        assertTrue(ob instanceof List<?>);

        // but can change to produce Object[]:
        MAPPER.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);
        ob = MAPPER.readValue("[1]", Object.class);
        assertEquals(Object[].class, ob.getClass());
    }

    public void testUntypedIntAsLong() throws Exception
    {
        final String JSON = aposToQuotes("{'value':3}");
        WrappedUntyped1460 w = MAPPER.readerFor(WrappedUntyped1460.class)
                .readValue(JSON);
        assertEquals(Integer.valueOf(3), w.value);

        w = MAPPER.readerFor(WrappedUntyped1460.class)
                .with(DeserializationFeature.USE_LONG_FOR_INTS)
                .readValue(JSON);
        assertEquals(Long.valueOf(3), w.value);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_75b7049_d44600d/rev_75b7049-d44600d/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex,
            boolean explicit) {
=======
    /**
     * @return True if specified Creator is to be used
     */
    protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
    {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_48902b1_7fe2d4f/rev_48902b1-7fe2d4f/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
     * /********************************************************** /* Helper
     * class(es) /**********************************************************
=======
    /**********************************************************
    /* Helper class(es)
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c9c78f3_749edaa/rev_c9c78f3-749edaa/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;

@SuppressWarnings("serial")
public class TestMapDeserialization
    extends BaseMapTest
{
    static enum Key {
        KEY1, KEY2, WHATEVER;
    }

    static class BrokenMap
        extends HashMap<Object,Object>
    {
        // No default ctor, nor @JsonCreators
        public BrokenMap(boolean dummy) { super(); }
    }

    @JsonDeserialize(using=MapDeserializer.class)
    static class CustomMap extends LinkedHashMap<String,String> { }

    static class MapDeserializer extends StdDeserializer<CustomMap>
    {
        public MapDeserializer() { super(CustomMap.class); }
        @Override
        public CustomMap deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException
        {
            CustomMap result = new CustomMap();
            result.put("x", jp.getText());
            return result;
        }
    }

    static class KeyType {
        protected String value;
        
        private KeyType(String v, boolean bogus) {
            value = v;
        }

        @JsonCreator
        public static KeyType create(String v) {
            return new KeyType(v, true);
        }
    }

    // [databind#142]
    public static class EnumMapContainer {
        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")
        public EnumMap<KeyEnum,ITestType> testTypes;
    }

    public static class ListContainer {
        public List<ITestType> testTypes;
    }

    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")
    public static interface ITestType { }

    public static enum KeyEnum {
        A, B
    }
    public static enum ConcreteType implements ITestType {
        ONE, TWO;
    }

    static class ClassStringMap extends HashMap<Class<?>,String> { }
    
    /*
    /**********************************************************
    /* Test methods, untyped (Object valued) maps
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testUntypedMap() throws Exception
    {
        // to get "untyped" default map-to-map, pass Object.class
        String JSON = "{ \"foo\" : \"bar\", \"crazy\" : true, \"null\" : null }";

        // Not a guaranteed cast theoretically, but will work:
        @SuppressWarnings("unchecked")
        Map<String,Object> result = (Map<String,Object>)MAPPER.readValue(JSON, Object.class);
        assertNotNull(result);
        assertTrue(result instanceof Map<?,?>);

        assertEquals(3, result.size());

        assertEquals("bar", result.get("foo"));
        assertEquals(Boolean.TRUE, result.get("crazy"));
        assertNull(result.get("null"));

        // Plus, non existing:
        assertNull(result.get("bar"));
        assertNull(result.get(3));
    }

    public void testBigUntypedMap() throws Exception
    {
        Map<String,Object> map = new LinkedHashMap<String,Object>();
        for (int i = 0; i < 1100; ++i) {
            if ((i & 1) == 0) {
                map.put(String.valueOf(i), Integer.valueOf(i));
            } else {
                Map<String,Object> map2 = new LinkedHashMap<String,Object>();
                map2.put("x", Integer.valueOf(i));
                map.put(String.valueOf(i), map2);
            }
        }
        String json = MAPPER.writeValueAsString(map);
        Object bound = MAPPER.readValue(json, Object.class);
        assertEquals(map, bound);
    }
    
    /**
     * Let's also try another way to express "gimme a Map" deserialization;
     * this time by specifying a Map class, to reduce need to cast
     */
    public void testUntypedMap2() throws Exception
    {
        // to get "untyped" default map-to-map, pass Object.class
        String JSON = "{ \"a\" : \"x\" }";

        @SuppressWarnings("unchecked")
        HashMap<String,Object> result = /*(HashMap<String,Object>)*/ MAPPER.readValue(JSON, HashMap.class);
        assertNotNull(result);
        assertTrue(result instanceof Map<?,?>);

        assertEquals(1, result.size());

        assertEquals("x", result.get("a"));
    }

    /**
     * Unit test for [JACKSON-185]
     */
    public void testUntypedMap3() throws Exception
    {
        String JSON = "{\"a\":[{\"a\":\"b\"},\"value\"]}";
        Map<?,?> result = MAPPER.readValue(JSON, Map.class);
        assertTrue(result instanceof Map<?,?>);
        assertEquals(1, result.size());
        Object ob = result.get("a");
        assertNotNull(ob);
        Collection<?> list = (Collection<?>)ob;
        assertEquals(2, list.size());

        JSON = "{ \"var1\":\"val1\", \"var2\":\"val2\", "
            +"\"subvars\": ["
            +" {  \"subvar1\" : \"subvar2\", \"x\" : \"y\" }, "
            +" { \"a\":1 } ]"
            +" }"
            ;
        result = MAPPER.readValue(JSON, Map.class);
        assertTrue(result instanceof Map<?,?>);
        assertEquals(3, result.size());
    }

    private static final String UNTYPED_MAP_JSON =
            "{ \"double\":42.0, \"string\":\"string\","
            +"\"boolean\":true, \"list\":[\"list0\"],"
            +"\"null\":null }";
    
    static class ObjectWrapperMap extends HashMap<String, ObjectWrapper> { }
    
    public void testSpecialMap() throws IOException
    {
       final ObjectWrapperMap map = MAPPER.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class);
       assertNotNull(map);
       _doTestUntyped(map);
    }

    public void testGenericMap() throws IOException
    {
        final Map<String, ObjectWrapper> map = MAPPER.readValue
            (UNTYPED_MAP_JSON,
             new TypeReference<Map<String, ObjectWrapper>>() { });
       _doTestUntyped(map);
    }
    
    private void _doTestUntyped(final Map<String, ObjectWrapper> map)
    {
        ObjectWrapper w = map.get("double");
        assertNotNull(w);
        assertEquals(Double.valueOf(42), w.getObject());
        assertEquals("string", map.get("string").getObject());
        assertEquals(Boolean.TRUE, map.get("boolean").getObject());
        assertEquals(Collections.singletonList("list0"), map.get("list").getObject());
        assertTrue(map.containsKey("null"));
        assertNull(map.get("null"));
        assertEquals(5, map.size());
    }
    
    // [JACKSON-620]: allow "" to mean 'null' for Maps
    public void testFromEmptyString() throws Exception
    {
        ObjectMapper m = new ObjectMapper();
        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);
        Map<?,?> result = m.readValue(quote(""), Map.class);
        assertNull(result);
    }

    /*
    /**********************************************************
    /* Test methods, typed maps
    /**********************************************************
     */

    public void testExactStringIntMap() throws Exception
    {
        // to get typing, must use type reference
        String JSON = "{ \"foo\" : 13, \"bar\" : -39, \n \"\" : 0 }";
        Map<String,Integer> result = MAPPER.readValue
            (JSON, new TypeReference<HashMap<String,Integer>>() { });

        assertNotNull(result);
        assertEquals(HashMap.class, result.getClass());
        assertEquals(3, result.size());

        assertEquals(Integer.valueOf(13), result.get("foo"));
        assertEquals(Integer.valueOf(-39), result.get("bar"));
        assertEquals(Integer.valueOf(0), result.get(""));
        assertNull(result.get("foobar"));
        assertNull(result.get(" "));
    }

    /**
     * Let's also check that it is possible to do type conversions
     * to allow use of non-String Map keys.
     */
    public void testIntBooleanMap() throws Exception
    {
        // to get typing, must use type reference
        String JSON = "{ \"1\" : true, \"-1\" : false }";
        Map<String,Integer> result = MAPPER.readValue
            (JSON, new TypeReference<HashMap<Integer,Boolean>>() { });

        assertNotNull(result);
        assertEquals(HashMap.class, result.getClass());
        assertEquals(2, result.size());

        assertEquals(Boolean.TRUE, result.get(Integer.valueOf(1)));
        assertEquals(Boolean.FALSE, result.get(Integer.valueOf(-1)));
        assertNull(result.get("foobar"));
        assertNull(result.get(0));
    }

    public void testExactStringStringMap() throws Exception
    {
        // to get typing, must use type reference
        String JSON = "{ \"a\" : \"b\" }";
        Map<String,Integer> result = MAPPER.readValue
            (JSON, new TypeReference<TreeMap<String,String>>() { });

        assertNotNull(result);
        assertEquals(TreeMap.class, result.getClass());
        assertEquals(1, result.size());

        assertEquals("b", result.get("a"));
        assertNull(result.get("b"));
    }

    /**
     * Unit test that verifies that it's ok to have incomplete
     * information about Map class itself, as long as it's something
     * we good guess about: for example, <code>Map.Class</code> will
     * be replaced by something like <code>HashMap.class</code>,
     * if given.
     */
    public void testGenericStringIntMap() throws Exception
    {
        // to get typing, must use type reference; but with abstract type
        String JSON = "{ \"a\" : 1, \"b\" : 2, \"c\" : -99 }";
        Map<String,Integer> result = MAPPER.readValue
            (JSON, new TypeReference<Map<String,Integer>>() { });
        assertNotNull(result);
        assertTrue(result instanceof Map<?,?>);
        assertEquals(3, result.size());

        assertEquals(Integer.valueOf(-99), result.get("c"));
        assertEquals(Integer.valueOf(2), result.get("b"));
        assertEquals(Integer.valueOf(1), result.get("a"));

        assertNull(result.get(""));
    }

    // [Databind#540]
    public void testMapFromEmptyArray() throws Exception
    {
        final String JSON = "  [\n]";
        assertFalse(MAPPER.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT));
        // first, verify default settings which do not accept empty Array
        ObjectMapper mapper = new ObjectMapper();
        try {
            mapper.readValue(JSON, Map.class);
            fail("Should not accept Empty Array for Map by default");
        } catch (JsonProcessingException e) {
            verifyException(e, "START_ARRAY token");
        }
        // should be ok to enable dynamically:
        ObjectReader r = MAPPER.readerFor(Map.class)
                .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);

        Map<?,?> result = r.readValue(JSON);
        assertNull(result);

        EnumMap<?,?> result2 = r.forType(new TypeReference<EnumMap<Key,String>>() { })
                .readValue(JSON);
        assertNull(result2);
    }

    /*
    /**********************************************************
    /* Test methods, maps with enums
    /**********************************************************
     */

    public void testEnumMap() throws Exception
    {
        String JSON = "{ \"KEY1\" : \"\", \"WHATEVER\" : null }";

        // to get typing, must use type reference
        EnumMap<Key,String> result = MAPPER.readValue
            (JSON, new TypeReference<EnumMap<Key,String>>() { });

        assertNotNull(result);
        assertEquals(EnumMap.class, result.getClass());
        assertEquals(2, result.size());

        assertEquals("", result.get(Key.KEY1));
        // null should be ok too...
        assertTrue(result.containsKey(Key.WHATEVER));
        assertNull(result.get(Key.WHATEVER));

        // plus we have nothing for this key
        assertFalse(result.containsKey(Key.KEY2));
        assertNull(result.get(Key.KEY2));
    }

    public void testMapWithEnums() throws Exception
    {
        String JSON = "{ \"KEY2\" : \"WHATEVER\" }";

        // to get typing, must use type reference
        Map<Enum<?>,Enum<?>> result = MAPPER.readValue
            (JSON, new TypeReference<Map<Key,Key>>() { });

        assertNotNull(result);
        assertTrue(result instanceof Map<?,?>);
        assertEquals(1, result.size());

        assertEquals(Key.WHATEVER, result.get(Key.KEY2));
        assertNull(result.get(Key.WHATEVER));
        assertNull(result.get(Key.KEY1));
    }

    public void testEnumPolymorphicSerializationTest() throws Exception 
    {
        ObjectMapper mapper = new ObjectMapper();
        List<ITestType> testTypesList = new ArrayList<ITestType>();
        testTypesList.add(ConcreteType.ONE);
        testTypesList.add(ConcreteType.TWO);
        ListContainer listContainer = new ListContainer();
        listContainer.testTypes = testTypesList;
        String json = mapper.writeValueAsString(listContainer);
        listContainer = mapper.readValue(json, ListContainer.class);
        EnumMapContainer enumMapContainer = new EnumMapContainer();
        EnumMap<KeyEnum,ITestType> testTypesMap = new EnumMap<KeyEnum,ITestType>(KeyEnum.class);
        testTypesMap.put(KeyEnum.A, ConcreteType.ONE);
        testTypesMap.put(KeyEnum.B, ConcreteType.TWO);
        enumMapContainer.testTypes = testTypesMap;
        
        json = mapper.writeValueAsString(enumMapContainer);
        enumMapContainer = mapper.readValue(json, EnumMapContainer.class);
    }

    /*
    /**********************************************************
    /* Test methods, maps with Date
    /**********************************************************
     */
    public void testDateMap() throws Exception
    {
    	 Date date1=new Date(123456000L);
    	 DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
         
    	 String JSON = "{ \""+  fmt.format(date1)+"\" : \"\", \""+new Date(0).getTime()+"\" : null }";
    	 HashMap<Date,String> result=  MAPPER.readValue
    	            (JSON, new TypeReference<HashMap<Date,String>>() { });
    	 
    	 assertNotNull(result);
    	 assertEquals(HashMap.class, result.getClass());
    	 assertEquals(2, result.size());
    	 
    	 assertTrue(result.containsKey(date1));
    	 assertEquals("", result.get(new Date(123456000L)));

    	 assertTrue(result.containsKey(new Date(0)));
    	 assertNull(result.get(new Date(0)));
    }

    /*
    /**********************************************************
    /* Test methods, maps with various alternative key types
    /**********************************************************
     */

    public void testCalendarMap() throws Exception
    {
        // 18-Jun-2015, tatu: Should be safest to use default timezone that mapper would use
        TimeZone tz = MAPPER.getSerializationConfig().getTimeZone();        
        Calendar c = Calendar.getInstance(tz);

        c.setTimeInMillis(123456000L);
        DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
        String JSON = "{ \""+fmt.format(c.getTime())+"\" : \"\", \""+new Date(0).getTime()+"\" : null }";
        HashMap<Calendar,String> result = MAPPER.readValue
                (JSON, new TypeReference<HashMap<Calendar,String>>() { });

        assertNotNull(result);
        assertEquals(HashMap.class, result.getClass());
        assertEquals(2, result.size());

        assertTrue(result.containsKey(c));
        assertEquals("", result.get(c));
        c.setTimeInMillis(0);
        assertTrue(result.containsKey(c));
        assertNull(result.get(c));
    }

    public void testUUIDKeyMap() throws Exception
    {
         UUID key = UUID.nameUUIDFromBytes("foobar".getBytes("UTF-8"));
         String JSON = "{ \""+key+"\":4}";
         Map<UUID,Object> result = MAPPER.readValue(JSON, new TypeReference<Map<UUID,Object>>() { });
         assertNotNull(result);
         assertEquals(1, result.size());
         Object ob = result.keySet().iterator().next();
         assertNotNull(ob);
         assertEquals(UUID.class, ob.getClass());
         assertEquals(key, ob);
    }

    public void testLocaleKeyMap() throws Exception {
        Locale key = Locale.CHINA;
        String JSON = "{ \"" + key + "\":4}";
        Map<Locale, Object> result = MAPPER.readValue(JSON, new TypeReference<Map<Locale, Object>>() {
        });
        assertNotNull(result);
        assertEquals(1, result.size());
        Object ob = result.keySet().iterator().next();
        assertNotNull(ob);
        assertEquals(Locale.class, ob.getClass());
        assertEquals(key, ob);
    }

    public void testCurrencyKeyMap() throws Exception {
        Currency key = Currency.getInstance("USD");
        String JSON = "{ \"" + key + "\":4}";
        Map<Currency, Object> result = MAPPER.readValue(JSON, new TypeReference<Map<Currency, Object>>() {
        });
        assertNotNull(result);
        assertEquals(1, result.size());
        Object ob = result.keySet().iterator().next();
        assertNotNull(ob);
        assertEquals(Currency.class, ob.getClass());
        assertEquals(key, ob);
    }

    // Test confirming that @JsonCreator may be used with Map Key types
    public void testKeyWithCreator() throws Exception
    {
        // first, key should deserialize normally:
        KeyType key = MAPPER.readValue(quote("abc"), KeyType.class);
        assertEquals("abc", key.value);

        Map<KeyType,Integer> map = MAPPER.readValue("{\"foo\":3}", new TypeReference<Map<KeyType,Integer>>() {} );
        assertEquals(1, map.size());
        key = map.keySet().iterator().next();
        assertEquals("foo", key.value);
    }

    public void testClassKeyMap() throws Exception {
        ClassStringMap map = MAPPER.readValue(aposToQuotes("{'java.lang.String':'foo'}"),
                ClassStringMap.class);
        assertNotNull(map);
        assertEquals(1, map.size());
        assertEquals("foo", map.get(String.class));
    }

    public void testcharSequenceKeyMap() throws Exception {
        String JSON = aposToQuotes("{'a':'b'}");
        Map<CharSequence,String> result = MAPPER.readValue(JSON, new TypeReference<Map<CharSequence,String>>() { });
        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals("b", result.get("a"));
    }

    /*
    /**********************************************************
    /* Test methods, annotated Maps
    /**********************************************************
     */

    /**
     * Simple test to ensure that @JsonDeserialize.using is
     * recognized
     */
    public void testMapWithDeserializer() throws Exception
    {
        CustomMap result = MAPPER.readValue(quote("xyz"), CustomMap.class);
        assertEquals(1, result.size());
        assertEquals("xyz", result.get("x"));
    }

    /*
    /**********************************************************
    /* Test methods, annotated Map.Entry
    /**********************************************************
     */

    public void testMapEntrySimpleTypes() throws Exception
    {
        List<Map.Entry<String,Long>> stuff = MAPPER.readValue(aposToQuotes("[{'a':15},{'b':42}]"),
                new TypeReference<List<Map.Entry<String,Long>>>() { });
        assertNotNull(stuff);
        assertEquals(2, stuff.size());
        assertNotNull(stuff.get(1));
        assertEquals("b", stuff.get(1).getKey());
        assertEquals(Long.valueOf(42), stuff.get(1).getValue());
    }

    public void testMapEntryWithStringBean() throws Exception
    {
        List<Map.Entry<Integer,StringWrapper>> stuff = MAPPER.readValue(aposToQuotes("[{'28':'Foo'},{'13':'Bar'}]"),
                new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });
        assertNotNull(stuff);
        assertEquals(2, stuff.size());
        assertNotNull(stuff.get(1));
        assertEquals(Integer.valueOf(13), stuff.get(1).getKey());
        
        StringWrapper sw = stuff.get(1).getValue();
        assertEquals("Bar", sw.str);
    }

    public void testMapEntryFail() throws Exception
    {
        try {
            /*List<Map.Entry<Integer,StringWrapper>> stuff =*/ MAPPER.readValue(aposToQuotes("[{'28':'Foo','13':'Bar'}]"),
                    new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });
            fail("Should not have passed");
        } catch (Exception e) {
            verifyException(e, "more than one entry in JSON");
        }
    }

    /*
    /**********************************************************
    /* Test methods, other exotic Map types
    /**********************************************************
     */
    
    // [databind#810]
    public void testReadProperties() throws Exception
    {
        Properties props = MAPPER.readValue(aposToQuotes("{'a':'foo', 'b':123, 'c':true}"),
                Properties.class);
        assertEquals(3, props.size());
        assertEquals("foo", props.getProperty("a"));
        assertEquals("123", props.getProperty("b"));
        assertEquals("true", props.getProperty("c"));
    }

    // JDK singletonMap
    public void testSingletonMapRoundtrip() throws Exception
    {
        final TypeReference<?> type = new TypeReference<Map<String,IntWrapper>>() { };

        String json = MAPPER.writeValueAsString(Collections.singletonMap("value", new IntWrapper(5)));
        Map<String,IntWrapper> result = MAPPER.readValue(json, type);
        assertNotNull(result);
        assertEquals(1, result.size());
        IntWrapper w = result.get("value");
        assertNotNull(w);
        assertEquals(5, w.i);
    }

    /*
    /**********************************************************
    /* Error tests
    /**********************************************************
     */

    public void testMapError() throws Exception
    {
        try {
            Object result = MAPPER.readValue("[ 1, 2 ]", 
                                             new TypeReference<Map<String,String>>() { });
            fail("Expected an exception, but got result value: "+result);
        } catch (JsonMappingException jex) {
            verifyException(jex, "START_ARRAY");
        }
    }

    public void testNoCtorMap() throws Exception
    {
        try {
            BrokenMap result = MAPPER.readValue("{ \"a\" : 3 }", BrokenMap.class);
            // should never get here; assert added to remove compiler warning
            assertNull(result);
        } catch (JsonMappingException e) {
            // instead, should get this exception:
            verifyException(e, "no default constructor found");
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_d83a0db_dfd864f/rev_d83a0db-dfd864f/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java;<<<<<<< MINE
=======
    @Override
    public InnerClassProperty withValueDeserializer(JsonDeserializer<?> deser) {
        return new InnerClassProperty(this, deser);
    }

    @Override
    public void assignIndex(int index) { _delegate.assignIndex(index); }

    @Override
    public int getPropertyIndex() { return _delegate.getPropertyIndex(); }

    @Override
    public int getCreatorIndex() { return _delegate.getCreatorIndex(); }
    
    @Override
    public void fixAccess(DeserializationConfig config) {
        _delegate.fixAccess(config);
    }

    // // // BeanProperty impl
    
    @Override
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _delegate.getAnnotation(acls);
    }

    @Override public AnnotatedMember getMember() {  return _delegate.getMember(); }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_a66b4e0_cc478a2/rev_a66b4e0-cc478a2/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
                if (enclosing != null && enclosing == _beanType.getRawClass()) {
=======
                if ((enclosing != null) && (enclosing == _beanType.getRawClass())) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_71430dd_0ee6a6d/rev_71430dd-0ee6a6d/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
    @Override
    public PropertyMetadata getMetadata() {
        final Boolean b = _findRequired();
        final String desc = _findDescription();
        final Integer idx = _findIndex();
        final String def = _findDefaultValue();
        if (b == null && idx == null && def == null) {
            return (desc == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL
                    : PropertyMetadata.STD_REQUIRED_OR_OPTIONAL.withDescription(desc);
        }
        return PropertyMetadata.construct(b, desc, idx, def);
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e0be428_8d5bd66/rev_e0be428-8d5bd66/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java;<<<<<<< MINE
        return provider.findTypedValueSerializer(type, true, prop);
=======
        // 13-Mar-2017, tatu: Used to call `findTypeValueSerializer()`, but contextualization
        //   not working for that case for some reason
//        return provider.findTypedValueSerializer(type, true, prop);
        return provider.findValueSerializer(type, prop);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e0be428_8d5bd66/rev_e0be428-8d5bd66/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_ab494a1_23d49e3/rev_ab494a1-23d49e3/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java;<<<<<<< MINE
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return typeDeserializer.deserializeTypedFromScalar(p, ctxt);
    }

    /**
     * Overridden to simply call <code>deserialize()</code> method that does not take value
     * to update, since scalar values are usually non-mergeable.
     */
    @Override // since 2.9
    public T deserialize(JsonParser p, DeserializationContext ctxt, T intoValue) throws IOException {
        // 25-Oct-2016, tatu: And if attempt is made, see if we are to complain...
        ctxt.reportBadMerge(this);
        // except that it is possible to suppress this; and if so...
        return deserialize(p, ctxt);
    }

    /**
     * By default assumption is that scalar types can not be updated: many are immutable
     * values (such as primitives and wrappers)
     */
    @Override // since 2.9
    public Boolean supportsUpdate(DeserializationConfig config) {
        return Boolean.FALSE;
    }

    // Typically Scalar values have default setting of "nulls as nulls"
    @Override
    public AccessPattern getNullAccessPattern() {
        return AccessPattern.ALWAYS_NULL;
    }

    // While some scalar types have non-null empty values (hence can't say "ALWAYS_NULL")
    // they are mostly immutable, shareable and so constant.
    @Override // since 2.9
    public AccessPattern getEmptyAccessPattern() {
        return AccessPattern.CONSTANT;
=======
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return typeDeserializer.deserializeTypedFromScalar(p, ctxt);
    }

    protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        JsonToken t;
        if (ctxt.hasSomeOfFeatures(FEATURES_ACCEPT_ARRAYS)) {
            t = p.nextToken();
            if (t == JsonToken.END_ARRAY) {
                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
                    return getNullValue(ctxt);
                }
            }
            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
                final T parsed = deserialize(p, ctxt);
                if (p.nextToken() != JsonToken.END_ARRAY) {
                    handleMissingEndArrayForSingle(p, ctxt);
                }
                return parsed;            
            }
        } else {
            t = p.getCurrentToken();
        }
        @SuppressWarnings("unchecked")
        T result = (T) ctxt.handleUnexpectedToken(_valueClass, t, p, null);
        return result;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_ab494a1_23d49e3/rev_ab494a1-23d49e3/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;

@SuppressWarnings("serial")
public class TestMapDeserialization
    extends BaseMapTest
{
    static enum Key {
        KEY1, KEY2, WHATEVER;
    }

    static class BrokenMap
        extends HashMap<Object,Object>
    {
        // No default ctor, nor @JsonCreators
        public BrokenMap(boolean dummy) { super(); }
    }

    @JsonDeserialize(using=MapDeserializer.class)
    static class CustomMap extends LinkedHashMap<String,String> { }

    static class MapDeserializer extends StdDeserializer<CustomMap>
    {
        public MapDeserializer() { super(CustomMap.class); }
        @Override
        public CustomMap deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException
        {
            CustomMap result = new CustomMap();
            result.put("x", jp.getText());
            return result;
        }
    }

    static class KeyType {
        protected String value;
        
        private KeyType(String v, boolean bogus) {
            value = v;
        }

        @JsonCreator
        public static KeyType create(String v) {
            return new KeyType(v, true);
        }
    }

    // [databind#142]
    public static class EnumMapContainer {
        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")
        public EnumMap<KeyEnum,ITestType> testTypes;
    }

    public static class ListContainer {
        public List<ITestType> testTypes;
    }

    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")
    public static interface ITestType { }

    public static enum KeyEnum {
        A, B
    }
    public static enum ConcreteType implements ITestType {
        ONE, TWO;
    }

    static class ClassStringMap extends HashMap<Class<?>,String> { }
    
    /*
    /**********************************************************
    /* Test methods, untyped (Object valued) maps
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testUntypedMap() throws Exception
    {
        // to get "untyped" default map-to-map, pass Object.class
        String JSON = "{ \"foo\" : \"bar\", \"crazy\" : true, \"null\" : null }";

        // Not a guaranteed cast theoretically, but will work:
        @SuppressWarnings("unchecked")
        Map<String,Object> result = (Map<String,Object>)MAPPER.readValue(JSON, Object.class);
        assertNotNull(result);
        assertTrue(result instanceof Map<?,?>);

        assertEquals(3, result.size());

        assertEquals("bar", result.get("foo"));
        assertEquals(Boolean.TRUE, result.get("crazy"));
        assertNull(result.get("null"));

        // Plus, non existing:
        assertNull(result.get("bar"));
        assertNull(result.get(3));
    }

    public void testBigUntypedMap() throws Exception
    {
        Map<String,Object> map = new LinkedHashMap<String,Object>();
        for (int i = 0; i < 1100; ++i) {
            if ((i & 1) == 0) {
                map.put(String.valueOf(i), Integer.valueOf(i));
            } else {
                Map<String,Object> map2 = new LinkedHashMap<String,Object>();
                map2.put("x", Integer.valueOf(i));
                map.put(String.valueOf(i), map2);
            }
        }
        String json = MAPPER.writeValueAsString(map);
        Object bound = MAPPER.readValue(json, Object.class);
        assertEquals(map, bound);
    }
    
    /**
     * Let's also try another way to express "gimme a Map" deserialization;
     * this time by specifying a Map class, to reduce need to cast
     */
    public void testUntypedMap2() throws Exception
    {
        // to get "untyped" default map-to-map, pass Object.class
        String JSON = "{ \"a\" : \"x\" }";

        @SuppressWarnings("unchecked")
        HashMap<String,Object> result = /*(HashMap<String,Object>)*/ MAPPER.readValue(JSON, HashMap.class);
        assertNotNull(result);
        assertTrue(result instanceof Map<?,?>);

        assertEquals(1, result.size());

        assertEquals("x", result.get("a"));
    }

    /**
     * Unit test for [JACKSON-185]
     */
    public void testUntypedMap3() throws Exception
    {
        String JSON = "{\"a\":[{\"a\":\"b\"},\"value\"]}";
        Map<?,?> result = MAPPER.readValue(JSON, Map.class);
        assertTrue(result instanceof Map<?,?>);
        assertEquals(1, result.size());
        Object ob = result.get("a");
        assertNotNull(ob);
        Collection<?> list = (Collection<?>)ob;
        assertEquals(2, list.size());

        JSON = "{ \"var1\":\"val1\", \"var2\":\"val2\", "
            +"\"subvars\": ["
            +" {  \"subvar1\" : \"subvar2\", \"x\" : \"y\" }, "
            +" { \"a\":1 } ]"
            +" }"
            ;
        result = MAPPER.readValue(JSON, Map.class);
        assertTrue(result instanceof Map<?,?>);
        assertEquals(3, result.size());
    }

    private static final String UNTYPED_MAP_JSON =
            "{ \"double\":42.0, \"string\":\"string\","
            +"\"boolean\":true, \"list\":[\"list0\"],"
            +"\"null\":null }";
    
    static class ObjectWrapperMap extends HashMap<String, ObjectWrapper> { }
    
    public void testSpecialMap() throws IOException
    {
       final ObjectWrapperMap map = MAPPER.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class);
       assertNotNull(map);
       _doTestUntyped(map);
    }

    public void testGenericMap() throws IOException
    {
        final Map<String, ObjectWrapper> map = MAPPER.readValue
            (UNTYPED_MAP_JSON,
             new TypeReference<Map<String, ObjectWrapper>>() { });
       _doTestUntyped(map);
    }
    
    private void _doTestUntyped(final Map<String, ObjectWrapper> map)
    {
        ObjectWrapper w = map.get("double");
        assertNotNull(w);
        assertEquals(Double.valueOf(42), w.getObject());
        assertEquals("string", map.get("string").getObject());
        assertEquals(Boolean.TRUE, map.get("boolean").getObject());
        assertEquals(Collections.singletonList("list0"), map.get("list").getObject());
        assertTrue(map.containsKey("null"));
        assertNull(map.get("null"));
        assertEquals(5, map.size());
    }
    
    // [JACKSON-620]: allow "" to mean 'null' for Maps
    public void testFromEmptyString() throws Exception
    {
        ObjectMapper m = new ObjectMapper();
        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);
        Map<?,?> result = m.readValue(quote(""), Map.class);
        assertNull(result);
    }

    /*
    /**********************************************************
    /* Test methods, typed maps
    /**********************************************************
     */

    public void testExactStringIntMap() throws Exception
    {
        // to get typing, must use type reference
        String JSON = "{ \"foo\" : 13, \"bar\" : -39, \n \"\" : 0 }";
        Map<String,Integer> result = MAPPER.readValue
            (JSON, new TypeReference<HashMap<String,Integer>>() { });

        assertNotNull(result);
        assertEquals(HashMap.class, result.getClass());
        assertEquals(3, result.size());

        assertEquals(Integer.valueOf(13), result.get("foo"));
        assertEquals(Integer.valueOf(-39), result.get("bar"));
        assertEquals(Integer.valueOf(0), result.get(""));
        assertNull(result.get("foobar"));
        assertNull(result.get(" "));
    }

    /**
     * Let's also check that it is possible to do type conversions
     * to allow use of non-String Map keys.
     */
    public void testIntBooleanMap() throws Exception
    {
        // to get typing, must use type reference
        String JSON = "{ \"1\" : true, \"-1\" : false }";
        Map<String,Integer> result = MAPPER.readValue
            (JSON, new TypeReference<HashMap<Integer,Boolean>>() { });

        assertNotNull(result);
        assertEquals(HashMap.class, result.getClass());
        assertEquals(2, result.size());

        assertEquals(Boolean.TRUE, result.get(Integer.valueOf(1)));
        assertEquals(Boolean.FALSE, result.get(Integer.valueOf(-1)));
        assertNull(result.get("foobar"));
        assertNull(result.get(0));
    }

    public void testExactStringStringMap() throws Exception
    {
        // to get typing, must use type reference
        String JSON = "{ \"a\" : \"b\" }";
        Map<String,Integer> result = MAPPER.readValue
            (JSON, new TypeReference<TreeMap<String,String>>() { });

        assertNotNull(result);
        assertEquals(TreeMap.class, result.getClass());
        assertEquals(1, result.size());

        assertEquals("b", result.get("a"));
        assertNull(result.get("b"));
    }

    /**
     * Unit test that verifies that it's ok to have incomplete
     * information about Map class itself, as long as it's something
     * we good guess about: for example, <code>Map.Class</code> will
     * be replaced by something like <code>HashMap.class</code>,
     * if given.
     */
    public void testGenericStringIntMap() throws Exception
    {
        // to get typing, must use type reference; but with abstract type
        String JSON = "{ \"a\" : 1, \"b\" : 2, \"c\" : -99 }";
        Map<String,Integer> result = MAPPER.readValue
            (JSON, new TypeReference<Map<String,Integer>>() { });
        assertNotNull(result);
        assertTrue(result instanceof Map<?,?>);
        assertEquals(3, result.size());

        assertEquals(Integer.valueOf(-99), result.get("c"));
        assertEquals(Integer.valueOf(2), result.get("b"));
        assertEquals(Integer.valueOf(1), result.get("a"));

        assertNull(result.get(""));
    }

    /*
    /**********************************************************
    /* Test methods, maps with enums
    /**********************************************************
     */

    public void testEnumMap() throws Exception
    {
        String JSON = "{ \"KEY1\" : \"\", \"WHATEVER\" : null }";

        // to get typing, must use type reference
        EnumMap<Key,String> result = MAPPER.readValue
            (JSON, new TypeReference<EnumMap<Key,String>>() { });

        assertNotNull(result);
        assertEquals(EnumMap.class, result.getClass());
        assertEquals(2, result.size());

        assertEquals("", result.get(Key.KEY1));
        // null should be ok too...
        assertTrue(result.containsKey(Key.WHATEVER));
        assertNull(result.get(Key.WHATEVER));

        // plus we have nothing for this key
        assertFalse(result.containsKey(Key.KEY2));
        assertNull(result.get(Key.KEY2));
    }

    public void testMapWithEnums() throws Exception
    {
        String JSON = "{ \"KEY2\" : \"WHATEVER\" }";

        // to get typing, must use type reference
        Map<Enum<?>,Enum<?>> result = MAPPER.readValue
            (JSON, new TypeReference<Map<Key,Key>>() { });

        assertNotNull(result);
        assertTrue(result instanceof Map<?,?>);
        assertEquals(1, result.size());

        assertEquals(Key.WHATEVER, result.get(Key.KEY2));
        assertNull(result.get(Key.WHATEVER));
        assertNull(result.get(Key.KEY1));
    }

    public void testEnumPolymorphicSerializationTest() throws Exception 
    {
        ObjectMapper mapper = new ObjectMapper();
        List<ITestType> testTypesList = new ArrayList<ITestType>();
        testTypesList.add(ConcreteType.ONE);
        testTypesList.add(ConcreteType.TWO);
        ListContainer listContainer = new ListContainer();
        listContainer.testTypes = testTypesList;
        String json = mapper.writeValueAsString(listContainer);
        listContainer = mapper.readValue(json, ListContainer.class);
        EnumMapContainer enumMapContainer = new EnumMapContainer();
        EnumMap<KeyEnum,ITestType> testTypesMap = new EnumMap<KeyEnum,ITestType>(KeyEnum.class);
        testTypesMap.put(KeyEnum.A, ConcreteType.ONE);
        testTypesMap.put(KeyEnum.B, ConcreteType.TWO);
        enumMapContainer.testTypes = testTypesMap;
        
        json = mapper.writeValueAsString(enumMapContainer);
        enumMapContainer = mapper.readValue(json, EnumMapContainer.class);
    }

    /*
    /**********************************************************
    /* Test methods, maps with Date
    /**********************************************************
     */
    public void testDateMap() throws Exception
    {
    	 Date date1=new Date(123456000L);
    	 DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
         
    	 String JSON = "{ \""+  fmt.format(date1)+"\" : \"\", \""+new Date(0).getTime()+"\" : null }";
    	 HashMap<Date,String> result=  MAPPER.readValue
    	            (JSON, new TypeReference<HashMap<Date,String>>() { });
    	 
    	 assertNotNull(result);
    	 assertEquals(HashMap.class, result.getClass());
    	 assertEquals(2, result.size());
    	 
    	 assertTrue(result.containsKey(date1));
    	 assertEquals("", result.get(new Date(123456000L)));

    	 assertTrue(result.containsKey(new Date(0)));
    	 assertNull(result.get(new Date(0)));
    }

    /*
    /**********************************************************
    /* Test methods, maps with various alternative key types
    /**********************************************************
     */

    public void testCalendarMap() throws Exception
    {
        // 18-Jun-2015, tatu: Should be safest to use default timezone that mapper would use
        TimeZone tz = MAPPER.getSerializationConfig().getTimeZone();        
        Calendar c = Calendar.getInstance(tz);

        c.setTimeInMillis(123456000L);
        DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
        String JSON = "{ \""+fmt.format(c.getTime())+"\" : \"\", \""+new Date(0).getTime()+"\" : null }";
        HashMap<Calendar,String> result = MAPPER.readValue
                (JSON, new TypeReference<HashMap<Calendar,String>>() { });

        assertNotNull(result);
        assertEquals(HashMap.class, result.getClass());
        assertEquals(2, result.size());

        assertTrue(result.containsKey(c));
        assertEquals("", result.get(c));
        c.setTimeInMillis(0);
        assertTrue(result.containsKey(c));
        assertNull(result.get(c));
    }

    public void testUUIDKeyMap() throws Exception
    {
         UUID key = UUID.nameUUIDFromBytes("foobar".getBytes("UTF-8"));
         String JSON = "{ \""+key+"\":4}";
         Map<UUID,Object> result = MAPPER.readValue(JSON, new TypeReference<Map<UUID,Object>>() { });
         assertNotNull(result);
         assertEquals(1, result.size());
         Object ob = result.keySet().iterator().next();
         assertNotNull(ob);
         assertEquals(UUID.class, ob.getClass());
         assertEquals(key, ob);
    }

    public void testLocaleKeyMap() throws Exception {
        Locale key = Locale.CHINA;
        String JSON = "{ \"" + key + "\":4}";
        Map<Locale, Object> result = MAPPER.readValue(JSON, new TypeReference<Map<Locale, Object>>() {
        });
        assertNotNull(result);
        assertEquals(1, result.size());
        Object ob = result.keySet().iterator().next();
        assertNotNull(ob);
        assertEquals(Locale.class, ob.getClass());
        assertEquals(key, ob);
    }

    public void testCurrencyKeyMap() throws Exception {
        Currency key = Currency.getInstance("USD");
        String JSON = "{ \"" + key + "\":4}";
        Map<Currency, Object> result = MAPPER.readValue(JSON, new TypeReference<Map<Currency, Object>>() {
        });
        assertNotNull(result);
        assertEquals(1, result.size());
        Object ob = result.keySet().iterator().next();
        assertNotNull(ob);
        assertEquals(Currency.class, ob.getClass());
        assertEquals(key, ob);
    }

    // Test confirming that @JsonCreator may be used with Map Key types
    public void testKeyWithCreator() throws Exception
    {
        // first, key should deserialize normally:
        KeyType key = MAPPER.readValue(quote("abc"), KeyType.class);
        assertEquals("abc", key.value);

        Map<KeyType,Integer> map = MAPPER.readValue("{\"foo\":3}", new TypeReference<Map<KeyType,Integer>>() {} );
        assertEquals(1, map.size());
        key = map.keySet().iterator().next();
        assertEquals("foo", key.value);
    }

    public void testClassKeyMap() throws Exception {
        ClassStringMap map = MAPPER.readValue(aposToQuotes("{'java.lang.String':'foo'}"),
                ClassStringMap.class);
        assertNotNull(map);
        assertEquals(1, map.size());
        assertEquals("foo", map.get(String.class));
    }

    public void testcharSequenceKeyMap() throws Exception {
        String JSON = aposToQuotes("{'a':'b'}");
        Map<CharSequence,String> result = MAPPER.readValue(JSON, new TypeReference<Map<CharSequence,String>>() { });
        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals("b", result.get("a"));
    }

    /*
    /**********************************************************
    /* Test methods, annotated Maps
    /**********************************************************
     */

    /**
     * Simple test to ensure that @JsonDeserialize.using is
     * recognized
     */
    public void testMapWithDeserializer() throws Exception
    {
        CustomMap result = MAPPER.readValue(quote("xyz"), CustomMap.class);
        assertEquals(1, result.size());
        assertEquals("xyz", result.get("x"));
    }

    /*
    /**********************************************************
    /* Test methods, annotated Map.Entry
    /**********************************************************
     */

    public void testMapEntrySimpleTypes() throws Exception
    {
        List<Map.Entry<String,Long>> stuff = MAPPER.readValue(aposToQuotes("[{'a':15},{'b':42}]"),
                new TypeReference<List<Map.Entry<String,Long>>>() { });
        assertNotNull(stuff);
        assertEquals(2, stuff.size());
        assertNotNull(stuff.get(1));
        assertEquals("b", stuff.get(1).getKey());
        assertEquals(Long.valueOf(42), stuff.get(1).getValue());
    }

    public void testMapEntryWithStringBean() throws Exception
    {
        List<Map.Entry<Integer,StringWrapper>> stuff = MAPPER.readValue(aposToQuotes("[{'28':'Foo'},{'13':'Bar'}]"),
                new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });
        assertNotNull(stuff);
        assertEquals(2, stuff.size());
        assertNotNull(stuff.get(1));
        assertEquals(Integer.valueOf(13), stuff.get(1).getKey());
        
        StringWrapper sw = stuff.get(1).getValue();
        assertEquals("Bar", sw.str);
    }

    public void testMapEntryFail() throws Exception
    {
        try {
            /*List<Map.Entry<Integer,StringWrapper>> stuff =*/ MAPPER.readValue(aposToQuotes("[{'28':'Foo','13':'Bar'}]"),
                    new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });
            fail("Should not have passed");
        } catch (Exception e) {
            verifyException(e, "more than one entry in JSON");
        }
    }

    /*
    /**********************************************************
    /* Test methods, other exotic Map types
    /**********************************************************
     */
    
    // [databind#810]
    public void testReadProperties() throws Exception
    {
        Properties props = MAPPER.readValue(aposToQuotes("{'a':'foo', 'b':123, 'c':true}"),
                Properties.class);
        assertEquals(3, props.size());
        assertEquals("foo", props.getProperty("a"));
        assertEquals("123", props.getProperty("b"));
        assertEquals("true", props.getProperty("c"));
    }

    // JDK singletonMap
    public void testSingletonMapRoundtrip() throws Exception
    {
        final TypeReference<?> type = new TypeReference<Map<String,IntWrapper>>() { };

        String json = MAPPER.writeValueAsString(Collections.singletonMap("value", new IntWrapper(5)));
        Map<String,IntWrapper> result = MAPPER.readValue(json, type);
        assertNotNull(result);
        assertEquals(1, result.size());
        IntWrapper w = result.get("value");
        assertNotNull(w);
        assertEquals(5, w.i);
    }

    /*
    /**********************************************************
    /* Error tests
    /**********************************************************
     */

    public void testMapError() throws Exception
    {
        try {
            Object result = MAPPER.readValue("[ 1, 2 ]", 
                                             new TypeReference<Map<String,String>>() { });
            fail("Expected an exception, but got result value: "+result);
        } catch (JsonMappingException jex) {
            verifyException(jex, "START_ARRAY");
        }
    }

    public void testNoCtorMap() throws Exception
    {
        try {
            BrokenMap result = MAPPER.readValue("{ \"a\" : 3 }", BrokenMap.class);
            // should never get here; assert added to remove compiler warning
            assertNull(result);
        } catch (JsonMappingException e) {
            // instead, should get this exception:
            verifyException(e, "no default constructor found");
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java;<<<<<<< MINE
    // need to override to ensure both get fixed
=======
    @Override
    public ManagedReferenceProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new ManagedReferenceProperty(this, deser);
    }
 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java;<<<<<<< MINE
    protected SettableBeanProperty withDelegate(SettableBeanProperty d) {
        return new InnerClassProperty(d, _creator);
=======
    public InnerClassProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new InnerClassProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java;<<<<<<< MINE
    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        return new ObjectIdValueProperty(this, deser, _nullProvider);
    }

    @Override
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new ObjectIdValueProperty(this, _valueDeserializer, nva);
=======
    public ObjectIdValueProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new ObjectIdValueProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        return new MethodProperty(this, deser, _nullProvider);
    }

    @Override
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new MethodProperty(this, _valueDeserializer, nva);
=======
    public MethodProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new MethodProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new FieldProperty(this, _valueDeserializer, nva);
=======
    public FieldProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new FieldProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java;<<<<<<< MINE
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new SetterlessProperty(this, _valueDeserializer, nva);
=======
    public SetterlessProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new SetterlessProperty(this, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2db5afe_934f485/rev_2db5afe-934f485/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java;<<<<<<< MINE
        // 19-Oct-2016, tatu: Simplified to bare essentials since this is deprecated
        g.writeFieldName(value.toString());
=======
        String str;
        Class<?> cls = value.getClass();

        if (cls == String.class) {
            str = (String) value;
        } else if (cls.isEnum()) {
            // 24-Sep-2015, tatu: Minor improvement over older (2.6.2 and before) code: at least
            //     use name/toString() variation for as per configuration
            if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {
                str = value.toString();
            } else {
                Enum<?> en = (Enum<?>) value;
                if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {
                    str = String.valueOf(en.ordinal());
                } else {
                    str = en.name();
                }
            }
        } else if (value instanceof Date) {
            provider.defaultSerializeDateKey((Date) value, g);
            return;
        } else if (cls == Class.class) {
            str = ((Class<?>) value).getName();
        } else {
            str = value.toString();
        }
        g.writeFieldName(str);
    }

    @Override
    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {
        return createSchemaNode("string");
    }

    @Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {
        visitStringFormat(visitor, typeHint);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fea0d29_9919f9d/rev_fea0d29-9919f9d/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE

    /**
     * Type that the builder will produce, target type; as opposed to
     * `handledType()` which refers to Builder class.
     *
     * @since 2.9
     */
    protected final JavaType _targetType;
	
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fea0d29_9919f9d/rev_fea0d29-9919f9d/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fea0d29_9919f9d/rev_fea0d29-9919f9d/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fea0d29_9919f9d/rev_fea0d29-9919f9d/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fea0d29_9919f9d/rev_fea0d29-9919f9d/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE
=======
    protected final Object _deserialize(JsonParser p,
            DeserializationContext ctxt, Object builder)
        throws IOException, JsonProcessingException
    {
        if (_injectables != null) {
            injectValues(ctxt, builder);
        }
        if (_unwrappedPropertyHandler != null) {
            return deserializeWithUnwrapped(p, ctxt, builder);
        }
        if (_externalTypeIdHandler != null) {
            return deserializeWithExternalTypeId(p, ctxt, builder);
        }
        if (_needViewProcesing) {
            Class<?> view = ctxt.getActiveView();
            if (view != null) {
                return deserializeWithView(p, ctxt, builder, view);
            }
        }
        JsonToken t = p.getCurrentToken();
        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...
        if (t == JsonToken.START_OBJECT) {
            t = p.nextToken();
        }
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            // Skip field name:
            p.nextToken();
            SettableBeanProperty prop = _beanProperties.find(propName);

            if (prop != null) { // normal case
                try {
                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);
                } catch (Exception e) {
                    wrapAndThrow(e, builder, propName, ctxt);
                }
                continue;
            }
            handleUnknownVanilla(p, ctxt, handledType(), propName);
        }
        return builder;
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fea0d29_9919f9d/rev_fea0d29-9919f9d/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE

    protected final Object _deserialize(JsonParser p,
            DeserializationContext ctxt, Object builder) throws IOException
    {        
        if (_injectables != null) {
            injectValues(ctxt, builder);
        }
        if (_unwrappedPropertyHandler != null) {
            return deserializeWithUnwrapped(p, ctxt, builder);
        }
        if (_externalTypeIdHandler != null) {
            return deserializeWithExternalTypeId(p, ctxt, builder);
        }
        if (_needViewProcesing) {
            Class<?> view = ctxt.getActiveView();
            if (view != null) {
                return deserializeWithView(p, ctxt, builder, view);
            }
        }
        JsonToken t = p.getCurrentToken();
        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...
        if (t == JsonToken.START_OBJECT) {
            t = p.nextToken();
        }
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            // Skip field name:
            p.nextToken();
            SettableBeanProperty prop = _beanProperties.find(propName);
            
            if (prop != null) { // normal case
                try {
                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);
                } catch (Exception e) {
                    wrapAndThrow(e, builder, propName, ctxt);
                }
                continue;
            }
            handleUnknownVanilla(p, ctxt, handledType(), propName);
        }
        return builder;
    }

=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fea0d29_9919f9d/rev_fea0d29-9919f9d/src/test/java/com/fasterxml/jackson/databind/deser/builder/BuilderWithUnwrappedTest.java;<<<<<<< MINE
package com.fasterxml.jackson.databind.deser.builder;

import com.fasterxml.jackson.annotation.*;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.exc.InvalidDefinitionException;

public class BuilderWithUnwrappedTest extends BaseMapTest
{
    // // // Builder with unwrapped stuff

    final static class Location {
        public int x;
        public int y;

        public Location() { }
        public Location(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    @JsonDeserialize(builder=UnwrappingBuilder.class)
    static class UnwrappingValue
    {
        final String name;
        final Location location;
        final String stuff;

        public UnwrappingValue(String n, Location l, String st) {
            name = n;
            location = l;
            stuff = st;
        }
    }

    static class UnwrappingBuilder
    {
        private String name;

        Location loc;

        @JacksonInject
        protected String stuff;
        
        @JsonUnwrapped(prefix="loc.")
        public UnwrappingBuilder withLocation(Location l) {
            loc = l;
            return this;
        }

        public UnwrappingBuilder withName(String n) {
            name = n;
            return this;
        }
        
        public UnwrappingValue build() {
            return new UnwrappingValue(name, loc, stuff);
        }
    }

    @JsonDeserialize(builder=UnwrappingCreatorBuilder.class)
    static class UnwrappingCreatorValue
    {
        final String name;
        final Location location;
        final String stuff;

        public UnwrappingCreatorValue(String n, Location l, String st) {
            name = n;
            location = l;
            stuff = st;
        }
    }

    static class UnwrappingCreatorBuilder
    {
        private String name;

        Location loc;

        @JacksonInject
        protected String stuff;
        
        
        public UnwrappingCreatorBuilder(@JsonProperty("name") String name,
                @JsonUnwrapped(prefix="loc.") Location l
                ) {
            loc = l;
        }

        public UnwrappingCreatorValue build() {
            return new UnwrappingCreatorValue(name, loc, stuff);
        }
    }

    /*
    /**********************************************************
    /* Unit tests
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testWithUnwrapping() throws Exception
    {
        final String json = aposToQuotes("{'loc.x':3,'name':'Foobar','loc.y':5}}");

        ObjectMapper mapper = new ObjectMapper();
        mapper.setInjectableValues(new InjectableValues.Std()
                .addValue(String.class, "stuffValue")
                );
        
        UnwrappingValue result = mapper.readValue(json, UnwrappingValue.class);
        assertNotNull(result);
        assertNotNull(result.location);
        assertEquals("Foobar", result.name);
        assertEquals(3, result.location.x);
        assertEquals(5, result.location.y);
        assertEquals("stuffValue", result.stuff);

        ObjectReader r = MAPPER.readerFor(UnwrappingValue.class)
                .withValueToUpdate(new UnwrappingValue("foo", new Location(1, 2), null));
        // 30-Nov-2016, tatu: Actually, updateValue() NOT supported, verify:
        try {
            result = r.readValue(json);
            fail("Should not pass");
        } catch (InvalidDefinitionException e) {
            verifyException(e, "existing instance");
        }
    }

    // Alas: can't pass, until [databind#265] fixed:
    // 23-Feb-2017, tatu: or its follow-up: error message is now more descriptive...
    public void testWithCreatorUnwrapping() throws Exception
    {
        final String json = aposToQuotes("{'loc.x':4,'name':'Foobar','loc.y': 7}}");

        ObjectMapper mapper = new ObjectMapper();
        mapper.setInjectableValues(new InjectableValues.Std()
                .addValue(String.class, "stuffValue")
                );

        @SuppressWarnings("unused")
        UnwrappingCreatorValue result;
        try {
            result = mapper.readValue(json, UnwrappingCreatorValue.class);
            fail("Did not expect to really pass -- should maybe update the test");
        } catch (InvalidDefinitionException e) {
            verifyException(e, "combination not yet supported");
        }

        /*
        assertNotNull(result);
        assertNotNull(result.location);
        assertEquals("Foobar", result.name);
        assertEquals(4, result.location.x);
        assertEquals(7, result.location.y);
        */
    }
}=======
package com.fasterxml.jackson.databind.deser.builder;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonUnwrapped;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;

public class BuilderWithUnwrappedTest extends BaseMapTest {
    /*
     *************************************
     * Mock classes
     *************************************
     */

    final static class Name {
        private final String first;
        private final String last;

        @JsonCreator
        Name(
                @JsonProperty("first_name") String first,
                @JsonProperty("last_name") String last
        ) {
            this.first = first;
            this.last = last;
        }

        String getFirst() {
            return first;
        }

        String getLast() {
            return last;
        }
    }

    @JsonDeserialize(builder = Person.Builder.class)
    final static class Person {
        private final long id;
        private final Name name;
        private final int age;
        private final boolean alive;

        private Person(Builder builder) {
            id = builder.id;
            name = builder.name;
            age = builder.age;
            alive = builder.alive;
        }

        long getId() {
            return id;
        }

        Name getName() {
            return name;
        }

        int getAge() {
            return age;
        }

        boolean isAlive() {
            return alive;
        }

        @JsonPOJOBuilder(withPrefix = "set")
        final static class Builder {
            private final long id;
            private Name name;
            private int age;
            private boolean alive;

            Builder(@JsonProperty("person_id") long id) {
                this.id = id;
            }

            @JsonUnwrapped
            void setName(Name name) {
                this.name = name;
            }

            @JsonProperty("years_old")
            void setAge(int age) {
                this.age = age;
            }

            @JsonProperty("living")
            void setAlive(boolean alive) {
                this.alive = alive;
            }

            Person build() {
                return new Person(this);
            }
        }
    }

    @JsonDeserialize(builder = Animal.Builder.class)
    final static class Animal {
        private final long id;
        private final Name name;
        private final int age;
        private final boolean alive;

        private Animal(Builder builder) {
            id = builder.id;
            name = builder.name;
            age = builder.age;
            alive = builder.alive;
        }

        long getId() {
            return id;
        }

        Name getName() {
            return name;
        }

        int getAge() {
            return age;
        }

        boolean isAlive() {
            return alive;
        }

        @JsonPOJOBuilder(withPrefix = "set")
        final static class Builder {
            private final long id;
            private Name name;
            private int age;
            private final boolean alive;

            Builder(
                    @JsonProperty("animal_id") long id,
                    @JsonProperty("living") boolean alive
            ) {
                this.id = id;
                this.alive = alive;
            }

            @JsonUnwrapped
            void setName(Name name) {
                this.name = name;
            }

            @JsonProperty("years_old")
            void setAge(int age) {
                this.age = age;
            }

            Animal build() {
                return new Animal(this);
            }
        }
    }

    /*
     *************************************
     * Unit tests
     *************************************
     */

    public void testWithUnwrappedAndCreatorSingleParameterAtBeginning() throws Exception {
        final String json = aposToQuotes("{'person_id':1234,'first_name':'John','last_name':'Doe','years_old':30,'living':true}");

        final ObjectMapper mapper = new ObjectMapper();
        Person person = mapper.readValue(json, Person.class);
        assertEquals(1234, person.getId());
        assertNotNull(person.getName());
        assertEquals("John", person.getName().getFirst());
        assertEquals("Doe", person.getName().getLast());
        assertEquals(30, person.getAge());
        assertEquals(true, person.isAlive());
    }

    public void testWithUnwrappedAndCreatorSingleParameterInMiddle() throws Exception {
        final String json = aposToQuotes("{'first_name':'John','last_name':'Doe','person_id':1234,'years_old':30,'living':true}");

        final ObjectMapper mapper = new ObjectMapper();
        Person person = mapper.readValue(json, Person.class);
        assertEquals(1234, person.getId());
        assertNotNull(person.getName());
        assertEquals("John", person.getName().getFirst());
        assertEquals("Doe", person.getName().getLast());
        assertEquals(30, person.getAge());
        assertEquals(true, person.isAlive());
    }

    public void testWithUnwrappedAndCreatorSingleParameterAtEnd() throws Exception {
        final String json = aposToQuotes("{'first_name':'John','last_name':'Doe','years_old':30,'living':true,'person_id':1234}");

        final ObjectMapper mapper = new ObjectMapper();
        Person person = mapper.readValue(json, Person.class);
        assertEquals(1234, person.getId());
        assertNotNull(person.getName());
        assertEquals("John", person.getName().getFirst());
        assertEquals("Doe", person.getName().getLast());
        assertEquals(30, person.getAge());
        assertEquals(true, person.isAlive());
    }

    public void testWithUnwrappedAndCreatorMultipleParametersAtBeginning() throws Exception {
        final String json = aposToQuotes("{'animal_id':1234,'living':true,'first_name':'John','last_name':'Doe','years_old':30}");

        final ObjectMapper mapper = new ObjectMapper();
        Animal animal = mapper.readValue(json, Animal.class);
        assertEquals(1234, animal.getId());
        assertNotNull(animal.getName());
        assertEquals("John", animal.getName().getFirst());
        assertEquals("Doe", animal.getName().getLast());
        assertEquals(30, animal.getAge());
        assertEquals(true, animal.isAlive());
    }

    public void testWithUnwrappedAndCreatorMultipleParametersInMiddle() throws Exception {
        final String json = aposToQuotes("{'first_name':'John','animal_id':1234,'last_name':'Doe','living':true,'years_old':30}");

        final ObjectMapper mapper = new ObjectMapper();
        Animal animal = mapper.readValue(json, Animal.class);
        assertEquals(1234, animal.getId());
        assertNotNull(animal.getName());
        assertEquals("John", animal.getName().getFirst());
        assertEquals("Doe", animal.getName().getLast());
        assertEquals(30, animal.getAge());
        assertEquals(true, animal.isAlive());
    }

    public void testWithUnwrappedAndCreatorMultipleParametersAtEnd() throws Exception {
        final String json = aposToQuotes("{'first_name':'John','last_name':'Doe','years_old':30,'living':true,'animal_id':1234}");

        final ObjectMapper mapper = new ObjectMapper();
        Animal animal = mapper.readValue(json, Animal.class);
        assertEquals(1234, animal.getId());
        assertNotNull(animal.getName());
        assertEquals("John", animal.getName().getFirst());
        assertEquals("Doe", animal.getName().getLast());
        assertEquals(30, animal.getAge());
        assertEquals(true, animal.isAlive());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_17a8c72_a2e3460/rev_17a8c72-a2e3460/src/test/java/com/fasterxml/jackson/failing/TestMultipleExternalIds291.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.failing;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
import com.fasterxml.jackson.databind.*;

public class TestMultipleExternalIds291 extends BaseMapTest
{
    // For [Issue#291]
    interface F1 {}

    static class A implements F1 {
        public String a;
    }

    static class B implements F1 {
        public String b;
    }

    static interface F2 {}

    static class C implements F2 {
        public String c;
    }

    static class D implements F2{
        public String d;
    }

    static class Container {
        public String type;

        @JsonTypeInfo(use = Id.NAME, property = "type", include = As.EXTERNAL_PROPERTY)
        @JsonSubTypes({
                @JsonSubTypes.Type(value = A.class, name = "1"),
                @JsonSubTypes.Type(value = B.class, name = "2")})
        public F1 field1;

        @JsonTypeInfo(use = Id.NAME, property = "type", include = As.EXTERNAL_PROPERTY)
        @JsonSubTypes({
                @JsonSubTypes.Type(value = C.class, name = "1"),
                @JsonSubTypes.Type(value = D.class, name = "2")})
        public F2 field2;
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    // [databind#291]
    public void testMultiple() throws Exception
    {
        final ObjectMapper mapper = objectMapper();
        final String JSON =
"{\"type\" : \"1\",\n"
+"\"field1\" : {\n"
+"  \"a\" : \"AAA\"\n"
+"}, \"field2\" : {\n"
+"  \"c\" : \"CCC\"\n"
+"}\n"
+"}";

        Container c = mapper.readValue(JSON, Container.class);
        assertNotNull(c);
        assertTrue(c.field1 instanceof A);
        assertTrue(c.field2 instanceof C);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        AnnotatedMethodMap memberMethods = new AnnotatedMethodMap();
=======
        _memberMethods = _resolveMemberMethods();
    }

    private AnnotatedMethodMap _resolveMemberMethods()
    {
        AnnotatedMethodMap memberMethods = new AnnotatedMethodMap();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        _addMemberMethods(_class, this, _memberMethods, _primaryMixIn, mixins);
=======
        _addMemberMethods(_class, this, memberMethods, _primaryMixIn, mixins);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                    _memberMethods, mixin, mixins);
=======
                    memberMethods, mixin, mixins);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                _addMethodMixIns(_class, _memberMethods, mixin, mixins);
=======
                _addMethodMixIns(_class, memberMethods, mixin, mixins);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
                            _memberMethods.add(am);
=======
                            memberMethods.add(am);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
        return memberMethods;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
        List<AnnotatedField> f;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            _fields = Collections.emptyList();
=======
            f = Collections.emptyList();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
            f = new ArrayList<AnnotatedField>(foundFields.size());
            f.addAll(foundFields.values());
=======
            f = new ArrayList<AnnotatedField>(foundFields.size());
            f.addAll(foundFields.values());
        }
        _fields = f;
    }

    /*
    /**********************************************************
    /* Helper methods for resolving class annotations
    /* (resolution consisting of inheritance, overrides,
    /* and injection of mix-ins as necessary)
    /**********************************************************
     */
    
    /**
     * Helper method for adding any mix-in annotations specified
     * class might have.
     */
    protected void _addClassMixIns(AnnotationMap annotations, JavaType target)
    {
        if (_mixInResolver != null) {
            final Class<?> toMask = target.getRawClass();
            _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask));
        }
    }

    protected void _addClassMixIns(AnnotationMap annotations, Class<?> target)
    {
        if (_mixInResolver != null) {
            _addClassMixIns(annotations, target, _mixInResolver.findMixInClassFor(target));
        }
    }

    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask,
            Class<?> mixin)
    {
        if (mixin == null) {
            return;
        }
        // Ok, first: annotations from mix-in class itself:
        _addAnnotationsIfNotPresent(annotations, ClassUtil.findClassAnnotations(mixin));

        /* And then from its supertypes, if any. But note that we will
         * only consider super-types up until reaching the masked
         * class (if found); this because often mix-in class
         * is a sub-class (for convenience reasons). And if so, we
         * absolutely must NOT include super types of masked class,
         * as that would inverse precedence of annotations.
         */
        for (Class<?> parent : ClassUtil.findSuperClasses(mixin, toMask, false)) {
            _addAnnotationsIfNotPresent(annotations, ClassUtil.findClassAnnotations(parent));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6b9782b_96eb83b/rev_6b9782b-96eb83b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
                    // otherwise just ignored
=======
                    // 23-Sep-2016, tatu: [databind#1383]: Need to also sever link to avoid possible
                    //    later problems with "unresolved" constructor property
                    if (argDef != null) {
                        ((POJOPropertyBuilder) argDef).removeConstructors();
                    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6b9782b_96eb83b/rev_6b9782b-96eb83b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java;<<<<<<< MINE
=======

    static class XY {
        public int x, y;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6b9782b_96eb83b/rev_6b9782b-96eb83b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java;<<<<<<< MINE
=======
    // [databind#1383]
    static class SingleArgWithImplicit {
        protected XY _value;

        private SingleArgWithImplicit() {
            throw new Error("Should not get called");
        }
        private SingleArgWithImplicit(XY v, boolean bogus) {
            _value = v;
        }

        @JsonCreator
        public static SingleArgWithImplicit from(XY v) {
            return new SingleArgWithImplicit(v, true);
        }

        public XY getFoobar() { return _value; }
    }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6b9782b_96eb83b/rev_6b9782b-96eb83b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6b9782b_96eb83b/rev_6b9782b-96eb83b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java;<<<<<<< MINE
=======

    // [databind#1383]
    public void testSingleImplicitDelegating() throws Exception
    {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.setAnnotationIntrospector(new MyParamIntrospector("value"));
        SingleArgWithImplicit bean = mapper.readValue(aposToQuotes("{'x':1,'y':2}"),
                SingleArgWithImplicit.class);
        XY v = bean.getFoobar();
        assertNotNull(v);
        assertEquals(1, v.x);
        assertEquals(2, v.y);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_262961a_28ec8a4/rev_262961a-28ec8a4/src/test/java/com/fasterxml/jackson/databind/deser/TestNullHandling.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.module.SimpleModule;

public class TestNullHandling extends BaseMapTest
{
    static class FunnyNullDeserializer extends JsonDeserializer<String>
    {
        @Override
        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
            return "text";
        }

        @Override
        public String getNullValue(DeserializationContext ctxt) { return "funny"; }
    }

    static class AnySetter{

        private Map<String,String> any = new HashMap<String,String>();

        @JsonAnySetter
        public void setAny(String name, String value){
            this.any.put(name,value);
        }

        public Map<String,String> getAny(){
            return this.any;
        }
    }

    // [databind#1601]
    static class RootData {
        public String name;
        public String type;
        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXTERNAL_PROPERTY,
                property = "type")
        @JsonSubTypes({
                @Type(value = TypeA.class, name = "TypeA"),
                @Type(value = TypeB.class, name = "TypeB")})
        public Proxy proxy;

        public RootData() {}

        public RootData(String name, String type, Proxy proxy) {
            this.name = name;
            this.type = type;
            this.proxy = proxy;
        }
    }
    static interface Proxy { }

    static class TypeA implements Proxy {
        public String aValue;
        public TypeA() {}
        public TypeA(String a) {
            this.aValue = a;
        }
    }

    static class TypeB implements Proxy {
        public String bValue;
        public TypeB() {}
        public TypeB(String b) {
            this.bValue = b;
        }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    public void testAnySetterNulls() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule("test", Version.unknownVersion());
        module.addDeserializer(String.class, new FunnyNullDeserializer());
        mapper.registerModule(module);

        String fieldName = "fieldName";
        String nullValue = "{\""+fieldName+"\":null}";

        // should get non-default null directly:
        AnySetter result = mapper.readValue(nullValue, AnySetter.class);

        assertEquals(1, result.getAny().size());
        assertNotNull(result.getAny().get(fieldName));
        assertEquals("funny", result.getAny().get(fieldName));

        // as well as via ObjectReader
        ObjectReader reader = mapper.readerFor(AnySetter.class);
        result = reader.readValue(nullValue);

        assertEquals(1, result.getAny().size());
        assertNotNull(result.getAny().get(fieldName));
        assertEquals("funny", result.getAny().get(fieldName));
    }

    // Test for [JACKSON-643]
    public void testCustomRootNulls() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule("test", Version.unknownVersion());
        module.addDeserializer(String.class, new FunnyNullDeserializer());
        mapper.registerModule(module);

        // should get non-default null directly:
        String str = mapper.readValue("null", String.class);
        assertNotNull(str);
        assertEquals("funny", str);
        
        // as well as via ObjectReader
        ObjectReader reader = mapper.readerFor(String.class);
        str = reader.readValue("null");
        assertNotNull(str);
        assertEquals("funny", str);
    }

    // Test for [#407]
    public void testListOfNulls() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule("test", Version.unknownVersion());
        module.addDeserializer(String.class, new FunnyNullDeserializer());
        mapper.registerModule(module);

        List<String> list = Arrays.asList("funny");
        JavaType type = mapper.getTypeFactory().constructCollectionType(List.class, String.class);

        // should get non-default null directly:
        List<?> deser = mapper.readValue("[null]", type);
        assertNotNull(deser);
        assertEquals(1, deser.size());
        assertEquals(list.get(0), deser.get(0));

        // as well as via ObjectReader
        ObjectReader reader = mapper.readerFor(type);
        deser = reader.readValue("[null]");
        assertNotNull(deser);
        assertEquals(1, deser.size());
        assertEquals(list.get(0), deser.get(0));
    }

    // Test for [#407]
    public void testMapOfNulls() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        SimpleModule module = new SimpleModule("test", Version.unknownVersion());
        module.addDeserializer(String.class, new FunnyNullDeserializer());
        mapper.registerModule(module);

        JavaType type = mapper.getTypeFactory().constructMapType(Map.class, String.class, String.class);
        // should get non-default null directly:
        Map<?,?> deser = mapper.readValue("{\"key\":null}", type);
        assertNotNull(deser);
        assertEquals(1, deser.size());
        assertEquals("funny", deser.get("key"));

        // as well as via ObjectReader
        ObjectReader reader = mapper.readerFor(type);
        deser = reader.readValue("{\"key\":null}");
        assertNotNull(deser);
        assertEquals(1, deser.size());
        assertEquals("funny", deser.get("key"));
    }

    // [databind#1601]
    public void testPolymorphicDataNull() throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        String typeA =
                "{\"name\":\"TypeAData\", \"type\":\"TypeA\", \"proxy\":{\"aValue\":\"This works!\"}}";
        RootData typeAData = mapper.readValue(typeA, RootData.class);
        assertEquals("No value for aValue!?", "This works!", ((TypeA) typeAData.proxy).aValue);
        String typeB =
                "{\"name\":\"TypeBData\", \"type\":\"TypeB\", \"proxy\":{\"bValue\":\"This works too!\"}}";
        RootData typeBData = mapper.readValue(typeB, RootData.class);
        assertEquals("No value for bValue!?", "This works too!", ((TypeB) typeBData.proxy).bValue);
        String typeBNull =
                "{\"name\":\"TypeBData\", \"type\":\"TypeB\", \"proxy\": null}";
        RootData typeBNullData = mapper.readValue(typeBNull, RootData.class);
        assertNull("Proxy should be null!", typeBNullData.proxy);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3e75d54_4a2b1ae/rev_3e75d54-4a2b1ae/src/test/java/com/fasterxml/jackson/databind/filter/IgnorePropertiesDeser1575Test.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.filter;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

import com.fasterxml.jackson.databind.*;

public class IgnorePropertiesDeser1575Test extends BaseMapTest
{
    static class Person {
        public String name;

        @JsonProperty("person_z") // renaming this to person_p works
        @JsonIgnoreProperties({"person_z"}) // renaming this to person_p works
//        public Set<Person> personZ;
        public Person personZ;
    }

    public void testIgnorePropDeser1575() throws Exception
    {
        String st = aposToQuotes("{ 'name': 'admin',\n"
//                + "    'person_z': [ { 'name': 'admin' } ]"
              + "    'person_z': { 'name': 'admin' }"
                + "}");

        ObjectMapper mapper = new ObjectMapper();
        Person result = mapper.readValue(st, Person.class);
        assertEquals("admin", result.name);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_24b5821_9a083ad/rev_24b5821-9a083ad/src/test/java/com/fasterxml/jackson/databind/filter/ProblemHandlerTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.filter;

import java.io.IOException;
import java.util.Map;
import java.util.UUID;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;
import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;
import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;

/**
 * Tests to exercise handler methods of {@link DeserializationProblemHandler}.
 *
 * @since 2.8
 */
public class ProblemHandlerTest extends BaseMapTest
{
    /*
    /**********************************************************
    /* Test handler types
    /**********************************************************
     */

    static class WeirdKeyHandler
        extends DeserializationProblemHandler
    {
        protected final Object key;

        public WeirdKeyHandler(Object key0) {
            key = key0;
        }

        @Override
        public Object handleWeirdKey(DeserializationContext ctxt,
                Class<?> rawKeyType, String keyValue,
                String failureMsg)
            throws IOException
        {
            return key;
        }
    }

    static class WeirdNumberHandler
        extends DeserializationProblemHandler
    {
        protected final Object value;

        public WeirdNumberHandler(Object v0) {
            value = v0;
        }

        @Override
        public Object handleWeirdNumberValue(DeserializationContext ctxt,
                Class<?> targetType, Number n,
                String failureMsg)
            throws IOException
        {
            return value;
        }
    }

    static class WeirdStringHandler
        extends DeserializationProblemHandler
    {
        protected final Object value;
    
        public WeirdStringHandler(Object v0) {
            value = v0;
        }
    
        @Override
        public Object handleWeirdStringValue(DeserializationContext ctxt,
                Class<?> targetType, String v,
                String failureMsg)
            throws IOException
        {
            return value;
        }
    }

    static class InstantiationProblemHandler
        extends DeserializationProblemHandler
    {
        protected final Object value;
    
        public InstantiationProblemHandler(Object v0) {
            value = v0;
        }
    
        @Override
        public Object handleInstantiationProblem(DeserializationContext ctxt,
                Class<?> instClass, Object argument, Throwable t)
            throws IOException
        {
            return value;
        }
    }

    static class MissingInstantiationHandler
        extends DeserializationProblemHandler
    {
        protected final Object value;
    
        public MissingInstantiationHandler(Object v0) {
            value = v0;
        }
    
        @Override
        public Object handleMissingInstantiator(DeserializationContext ctxt,
                Class<?> instClass, JsonParser p, String msg)
            throws IOException
        {
            p.skipChildren();
            return value;
        }
    }

    static class WeirdTokenHandler
        extends DeserializationProblemHandler
    {
        protected final Object value;
    
        public WeirdTokenHandler(Object v) {
            value = v;
        }
    
        @Override
        public Object handleUnexpectedToken(DeserializationContext ctxt,
                Class<?> targetType, JsonToken t, JsonParser p,
                String failureMsg)
            throws IOException
        {
            return value;
        }
    }

    static class TypeIdHandler
        extends DeserializationProblemHandler
    {
        protected final Class<?> raw;

        public TypeIdHandler(Class<?> r) { raw = r; }
        
        @Override
        public JavaType handleUnknownTypeId(DeserializationContext ctxt,
                JavaType baseType, String subTypeId, TypeIdResolver idResolver,
                String failureMsg)
            throws IOException
        {
            return ctxt.constructType(raw);
        }
    }

    /*
    /**********************************************************
    /* Other helper types
    /**********************************************************
     */

    static class IntKeyMapWrapper {
        public Map<Integer,String> stuff;
    }

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
    static class Base { }
    static class BaseImpl extends Base {
        public int a;
    }

    static class BaseWrapper {
        public Base value;
    }

    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, property = "clazz")
    static class Base2 { }
    static class Base2Impl extends Base2 {
        public int a;
    }

    static class Base2Wrapper {
        public Base2 value;
    }
    
    enum SingleValuedEnum {
        A;
    }

    static class BustedCtor {
        public final static BustedCtor INST = new BustedCtor(true);

        public BustedCtor() {
            throw new RuntimeException("Fail!");
        }
        private BustedCtor(boolean b) { }
    }

    static class NoDefaultCtor {
        public int value;

        public NoDefaultCtor(int v) { value = v; }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testWeirdKeyHandling() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new WeirdKeyHandler(7));
        IntKeyMapWrapper w = mapper.readValue("{\"stuff\":{\"foo\":\"abc\"}}",
                IntKeyMapWrapper.class);
        Map<Integer,String> map = w.stuff;
        assertEquals(1, map.size());
        assertEquals("abc", map.values().iterator().next());
        assertEquals(Integer.valueOf(7), map.keySet().iterator().next());
    }

    public void testWeirdNumberHandling() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new WeirdNumberHandler(SingleValuedEnum.A))
            ;
        SingleValuedEnum result = mapper.readValue("3", SingleValuedEnum.class);
        assertEquals(SingleValuedEnum.A, result);
    }

    public void testWeirdStringHandling() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new WeirdStringHandler(SingleValuedEnum.A))
            ;
        SingleValuedEnum result = mapper.readValue("\"B\"", SingleValuedEnum.class);
        assertEquals(SingleValuedEnum.A, result);

        // also, write [databind#1629] try this
        mapper = new ObjectMapper()
                .addHandler(new WeirdStringHandler(null));
        UUID result2 = mapper.readValue(quote("not a uuid!"), UUID.class);
        assertNull(result2);
    }

    public void testInvalidTypeId() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new TypeIdHandler(BaseImpl.class));
        BaseWrapper w = mapper.readValue("{\"value\":{\"type\":\"foo\",\"a\":4}}",
                BaseWrapper.class);
        assertNotNull(w);
        assertEquals(BaseImpl.class, w.value.getClass());
    }


    public void testInvalidClassAsId() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new TypeIdHandler(Base2Impl.class));
        Base2Wrapper w = mapper.readValue("{\"value\":{\"clazz\":\"com.fizz\",\"a\":4}}",
                Base2Wrapper.class);
        assertNotNull(w);
        assertEquals(Base2Impl.class, w.value.getClass());
    }

    // verify that by default we get special exception type
    public void testInvalidTypeIdFail() throws Exception
    {
        try {
            MAPPER.readValue("{\"value\":{\"type\":\"foo\",\"a\":4}}",
                BaseWrapper.class);
            fail("Should not pass");
        } catch (InvalidTypeIdException e) {
            verifyException(e, "Could not resolve type id 'foo'");
            assertEquals(Base.class, e.getBaseType().getRawClass());
            assertEquals("foo", e.getTypeId());
        }
    }

    public void testInstantiationExceptionHandling() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new InstantiationProblemHandler(BustedCtor.INST));
        BustedCtor w = mapper.readValue("{ }",
                BustedCtor.class);
        assertNotNull(w);
    }

    public void testMissingInstantiatorHandling() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new MissingInstantiationHandler(new NoDefaultCtor(13)))
            ;
        NoDefaultCtor w = mapper.readValue("{ \"x\" : true }", NoDefaultCtor.class);
        assertNotNull(w);
        assertEquals(13, w.value);
    }

    public void testUnexpectedTokenHandling() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
            .addHandler(new WeirdTokenHandler(Integer.valueOf(13)))
        ;
        Integer v = mapper.readValue("true", Integer.class);
        assertEquals(Integer.valueOf(13), v);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38f749b_147fb08/rev_38f749b-147fb08/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
=======
import java.util.logging.Logger;
import java.util.logging.Level;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38f749b_147fb08/rev_38f749b-147fb08/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
            Logger.getLogger(OptionalHandlerFactory.class.getName())
                .log(Level.INFO, "Could not load DOM `Node` and/or `Document` classes: no DOM support");
=======
            Logger.getLogger("com.fasterxml.jackson.databind.ext.OptionalHandlerFactory")
                .log(Level.INFO, "Could not load DOM `Node` and/or `Document` classes: ignoring");
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38f749b_147fb08/rev_38f749b-147fb08/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
            x = Java7Support.instance();
        } catch (Throwable t) { }
        _jdk7Helper = x;
=======
            cls = Class.forName("java.nio.file.Path");
        } catch (Exception e) {
            Logger.getLogger("com.fasterxml.jackson.databind.ext.OptionalHandlerFactory")
                .log(Level.INFO, "Could not load Java7 `java.nio.file.Path` class: ignoring");
        }
        CLASS_JAVA7_PATH = cls;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f636532_93f7e14/rev_f636532-93f7e14/src/test/java/com/fasterxml/jackson/databind/ser/DateSerializationTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.ser;

import java.io.*;
import java.text.*;
import java.util.*;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.*;

public class DateSerializationTest
    extends BaseMapTest
{
    static class TimeZoneBean {
        private TimeZone tz;
        
        public TimeZoneBean(String name) {
            tz = TimeZone.getTimeZone(name);
        }

        public TimeZone getTz() { return tz; }
    }

    static class DateAsNumberBean {
        @JsonFormat(shape=JsonFormat.Shape.NUMBER)
        public Date date;
        public DateAsNumberBean(long l) { date = new java.util.Date(l); }
    }

    static class SqlDateAsDefaultBean {
        public java.sql.Date date;
        public SqlDateAsDefaultBean(long l) { date = new java.sql.Date(l); }
    }

    static class SqlDateAsNumberBean {
        @JsonFormat(shape=JsonFormat.Shape.NUMBER)
        public java.sql.Date date;
        public SqlDateAsNumberBean(long l) { date = new java.sql.Date(l); }
    }

    static class DateAsStringBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd")
        public Date date;
        public DateAsStringBean(long l) { date = new java.util.Date(l); }
    }

    static class DateAsDefaultStringBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING)
        public Date date;
        public DateAsDefaultStringBean(long l) { date = new java.util.Date(l); }
    }

    static class DateInCETBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd,HH:00", timezone="CET")
        public Date date;
        public DateInCETBean(long l) { date = new java.util.Date(l); }
    }

    static class CalendarAsStringBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd")
        public Calendar value;
        public CalendarAsStringBean(long l) {
            value = new GregorianCalendar();
            value.setTimeInMillis(l);
        }
    }

    static class DateAsDefaultBean {
        public Date date;
        public DateAsDefaultBean(long l) { date = new java.util.Date(l); }
    }
    
    static class DateAsDefaultBeanWithEmptyJsonFormat {
        @JsonFormat
        public Date date;
        public DateAsDefaultBeanWithEmptyJsonFormat(long l) { date = new java.util.Date(l); }
    }

    static class DateAsDefaultBeanWithPattern {
        @JsonFormat(pattern="yyyy-MM-dd")
        public Date date;
        public DateAsDefaultBeanWithPattern(long l) { date = new java.util.Date(l); }
    }

    static class DateAsDefaultBeanWithLocale {
        @JsonFormat(locale = "fr")
        public Date date;
        public DateAsDefaultBeanWithLocale(long l) { date = new java.util.Date(l); }
    }

    static class DateAsDefaultBeanWithTimezone {
        @JsonFormat(timezone="CET")
        public Date date;
        public DateAsDefaultBeanWithTimezone(long l) { date = new java.util.Date(l); }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testDateNumeric() throws IOException
    {
        // default is to output time stamps...
        assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));
        // shouldn't matter which offset we give...
        String json = MAPPER.writeValueAsString(new Date(199L));
        assertEquals("199", json);
    }

    public void testDateISO8601() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        // let's hit epoch start
        String json = mapper.writeValueAsString(new Date(0L));
        assertEquals("\"1970-01-01T00:00:00.000+0000\"", json);
    }

    public void testDateOther() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");
        mapper.setDateFormat(df);
        mapper.setTimeZone(TimeZone.getTimeZone("PST"));
        // let's hit epoch start, offset by a bit
        assertEquals(quote("1969-12-31X16:00:00"), mapper.writeValueAsString(new Date(0L)));
    }

    @SuppressWarnings("deprecation")
    public void testSqlDate() throws IOException
    {
        // use date 1999-04-01 (note: months are 0-based, use constant)
        java.sql.Date date = new java.sql.Date(99, Calendar.APRIL, 1);
        assertEquals(quote("1999-04-01"), MAPPER.writeValueAsString(date));

        java.sql.Date date0 = new java.sql.Date(0L);
        assertEquals(aposToQuotes("{'date':'"+date0.toString()+"'}"),
                MAPPER.writeValueAsString(new SqlDateAsDefaultBean(0L)));

        // but may explicitly force timestamp too
        assertEquals(aposToQuotes("{'date':0}"), MAPPER.writeValueAsString(new SqlDateAsNumberBean(0L)));
    }

    public void testSqlTime() throws IOException
    {
        java.sql.Time time = new java.sql.Time(0L);
        // not 100% sure what we should expect wrt timezone, but what serializes
        // does use is quite simple:
        assertEquals(quote(time.toString()), MAPPER.writeValueAsString(time));
    }

    public void testSqlTimestamp() throws IOException
    {
        java.sql.Timestamp input = new java.sql.Timestamp(0L);
        // just should produce same output as standard `java.util.Date`:
        Date altTnput = new Date(0L);
        assertEquals(MAPPER.writeValueAsString(altTnput),
                MAPPER.writeValueAsString(input));
    }

    public void testTimeZone() throws IOException
    {
        TimeZone input = TimeZone.getTimeZone("PST");
        String json = MAPPER.writeValueAsString(input);
        assertEquals(quote("PST"), json);
    }

    public void testTimeZoneInBean() throws IOException
    {
        String json = MAPPER.writeValueAsString(new TimeZoneBean("PST"));
        assertEquals("{\"tz\":\"PST\"}", json);
    }

    public void testDateUsingObjectWriter() throws IOException
    {
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");
        TimeZone tz = TimeZone.getTimeZone("PST");
        assertEquals(quote("1969-12-31X16:00:00"),
                MAPPER.writer(df)
                    .with(tz)
                    .writeValueAsString(new Date(0L)));
        ObjectWriter w = MAPPER.writer((DateFormat)null);
        assertEquals("0", w.writeValueAsString(new Date(0L)));

        w = w.with(df).with(tz);
        assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L)));
        w = w.with((DateFormat) null);
        assertEquals("0", w.writeValueAsString(new Date(0L)));
    }

    public void testDatesAsMapKeys() throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        Map<Date,Integer> map = new HashMap<Date,Integer>();
        assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS));
        map.put(new Date(0L), Integer.valueOf(1));
        // by default will serialize as ISO-8601 values...
        assertEquals("{\"1970-01-01T00:00:00.000+0000\":1}", mapper.writeValueAsString(map));
        
        // but can change to use timestamps too
        mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);
        assertEquals("{\"0\":1}", mapper.writeValueAsString(map));
    }

    public void testDateWithJsonFormat() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        String json;

        // first: test overriding writing as timestamp
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsNumberBean(0L));
        assertEquals(aposToQuotes("{'date':0}"), json);

        // then reverse
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writer().with(getUTCTimeZone()).writeValueAsString(new DateAsStringBean(0L));
        assertEquals("{\"date\":\"1970-01-01\"}", json);

        // and with different DateFormat; CET is one hour ahead of GMT
        json = mapper.writeValueAsString(new DateInCETBean(0L));
        assertEquals("{\"date\":\"1970-01-01,01:00\"}", json);
        
        // and for [Issue#423] as well:
        json = mapper.writer().with(getUTCTimeZone()).writeValueAsString(new CalendarAsStringBean(0L));
        assertEquals("{\"value\":\"1970-01-01\"}", json);

        // and with default (ISO8601) format (databind#1109)
        json = mapper.writeValueAsString(new DateAsDefaultStringBean(0L));
        assertEquals("{\"date\":\"1970-01-01T00:00:00.000+0000\"}", json);
    }

    /**
     * Test to ensure that setting a TimeZone _after_ dateformat should enforce
     * that timezone on format, regardless of TimeZone format had.
     */
    public void testWithTimeZoneOverride() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z"));
        mapper.setTimeZone(TimeZone.getTimeZone("PST"));
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        String json = mapper.writeValueAsString(new Date(0));
        // pacific time is GMT-8; so midnight becomes 16:00 previous day:
        assertEquals(quote("1969-12-31/16:00 PST"), json);

        // Let's also verify that Locale won't matter too much...
        mapper.setLocale(Locale.FRANCE);
        json = mapper.writeValueAsString(new Date(0));
        assertEquals(quote("1969-12-31/16:00 PST"), json);

        // Also: should be able to dynamically change timezone:
        ObjectWriter w = mapper.writer();
        w = w.with(TimeZone.getTimeZone("EST"));
        json = w.writeValueAsString(new Date(0));
        assertEquals(quote("1969-12-31/19:00 EST"), json);
    }

    /**
     * Test to ensure that the default shape is correctly inferred as string or numeric,
     * when this shape is not explicitly set with a <code>@JsonFormat</code> annotation
     */
    public void testDateDefaultShape() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        // No @JsonFormat => default to user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        String json = mapper.writeValueAsString(new DateAsDefaultBean(0L));
        assertEquals(aposToQuotes("{'date':0}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBean(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T00:00:00.000+0000'}"), json);

        // Empty @JsonFormat => default to user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));
        assertEquals(aposToQuotes("{'date':0}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T00:00:00.000+0000'}"), json);

        // @JsonFormat with Shape.ANY and pattern => STRING shape, regardless of user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01'}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01'}"), json);

        // @JsonFormat with Shape.ANY and locale => STRING shape, regardless of user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T00:00:00.000+0000'}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithLocale(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T00:00:00.000+0000'}"), json);

        // @JsonFormat with Shape.ANY and timezone => STRING shape, regardless of user config
        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T01:00:00.000+0100'}"), json);
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01T01:00:00.000+0100'}"), json);
    }

    // [databind#1648]: contextual default format should be used
    public void testFormatWithoutPattern() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss"));
        String json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));
        assertEquals(aposToQuotes("{'date':'1970-01-01X01:00:00'}"), json);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e353aa0_fe80e86/rev_e353aa0-fe80e86/src/test/java/com/fasterxml/jackson/databind/filter/TestAnyGetterFiltering.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.filter;

import java.util.*;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.FilterProvider;
import com.fasterxml.jackson.databind.ser.PropertyWriter;
import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;
import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;

/**
 * Unit tests for ensuring that entries accessible via "any filter"
 * can also be filtered with JSON Filter functionality.
 */
public class TestAnyGetterFiltering extends BaseMapTest
{
    @JsonFilter("anyFilter")
    public static class AnyBean
    {
        private Map<String, String> properties = new HashMap<String, String>();
        {
            properties.put("a", "1");
            properties.put("b", "2");
        }

        @JsonAnyGetter
        public Map<String, String> anyProperties()
        {
            return properties;
        }
    }

    public static class AnyBeanWithIgnores
    {
        private Map<String, String> properties = new LinkedHashMap<String, String>();
        {
            properties.put("a", "1");
            properties.put("bogus", "2");
            properties.put("b", "3");
        }

        @JsonAnyGetter
        @JsonIgnoreProperties({ "bogus" })
        public Map<String, String> anyProperties()
        {
            return properties;
        }
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testAnyGetterFiltering() throws Exception
    {
        FilterProvider prov = new SimpleFilterProvider().addFilter("anyFilter",
                SimpleBeanPropertyFilter.filterOutAllExcept("b"));
        assertEquals("{\"b\":\"2\"}", MAPPER.writer(prov).writeValueAsString(new AnyBean()));
    }

    // for [databind#1142]
    public void testAnyGetterIgnore() throws Exception
    {
        assertEquals(aposToQuotes("{'a':'1','b':'3'}"),
                MAPPER.writeValueAsString(new AnyBeanWithIgnores()));
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2d7fecf_5a0ce57/rev_2d7fecf-5a0ce57/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import com.fasterxml.jackson.databind.util.ISO8601DateFormat;

public class TestDateDeserialization
    extends BaseMapTest
{
    // Test for [JACKSON-435]
    static class DateAsStringBean
    {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="/yyyy/MM/dd/")
        public Date date;
    }

    static class DateAsStringBeanGermany
    {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="/yyyy/MM/dd/", locale="fr_FR")
        public Date date;
    }
    
    static class CalendarAsStringBean
    {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=";yyyy/MM/dd;")
        public Calendar cal;
    }

    static class DateInCETBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd,HH", timezone="CET")
        public Date date;
    }
    
    /*
    /**********************************************************
    /* Unit tests
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();

    public void testDateUtil() throws Exception
    {
        long now = 123456789L;
        java.util.Date value = new java.util.Date(now);

        // First from long
        assertEquals(value, MAPPER.readValue(""+now, java.util.Date.class));

        // then from String
        String dateStr = dateToString(value);
        java.util.Date result = MAPPER.readValue("\""+dateStr+"\"", java.util.Date.class);

        assertEquals("Date: expect "+value+" ("+value.getTime()+"), got "+result+" ("+result.getTime()+")",
                value.getTime(), result.getTime());
    }

    public void testDateUtilWithStringTimestamp() throws Exception
    {
        long now = 1321992375446L;
        /* As of 1.5.0, should be ok to pass as JSON String, as long
         * as it is plain timestamp (all numbers, 64-bit)
         */
        String json = quote(String.valueOf(now));
        java.util.Date value = MAPPER.readValue(json, java.util.Date.class);
        assertEquals(now, value.getTime());

        // #267: should handle negative timestamps too; like 12 hours before 1.1.1970
        long before = - (24 * 3600 * 1000L);
        json = quote(String.valueOf(before));
        value = MAPPER.readValue(json, java.util.Date.class);
        assertEquals(before, value.getTime());
    }

    public void testDateUtilRFC1123() throws Exception
    {
        DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
        // let's use an arbitrary value...
        String inputStr = "Sat, 17 Jan 2009 06:13:58 +0000";
        java.util.Date inputDate = fmt.parse(inputStr);
        assertEquals(inputDate, MAPPER.readValue("\""+inputStr+"\"", java.util.Date.class));
    }

    public void testDateUtilRFC1123OnNonUSLocales() throws Exception
    {
        Locale old = Locale.getDefault();
        Locale.setDefault(Locale.GERMAN);
        DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
        // let's use an arbitrary value...
        String inputStr = "Sat, 17 Jan 2009 06:13:58 +0000";
        java.util.Date inputDate = fmt.parse(inputStr);
        assertEquals(inputDate, MAPPER.readValue("\""+inputStr+"\"", java.util.Date.class));
        Locale.setDefault(old);
    }

    /**
     * ISO8601 is supported as well
     */
    public void testDateUtilISO8601() throws Exception
    {
        /* let's use simple baseline value, arbitrary date in GMT,
         * using the standard notation
         */
        String inputStr = "1972-12-28T00:00:00.000+0000";
        Date inputDate = MAPPER.readValue("\""+inputStr+"\"", java.util.Date.class);
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(inputDate);
        assertEquals(1972, c.get(Calendar.YEAR));
        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));
        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));

        // And then the same, but using 'Z' as alias for +0000 (very common)
        inputStr = "1972-12-28T00:00:00.000Z";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1972, c.get(Calendar.YEAR));
        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));
        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));

        // Same but using colon in timezone
        inputStr = "1972-12-28T00:00:00.000+00:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1972, c.get(Calendar.YEAR));
        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));
        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));

        // Same but only passing hour difference as timezone
        inputStr = "1972-12-28T00:00:00.000+00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1972, c.get(Calendar.YEAR));
        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));
        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));

        inputStr = "1984-11-30T00:00:00.000Z";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1984, c.get(Calendar.YEAR));
        assertEquals(Calendar.NOVEMBER, c.get(Calendar.MONTH));
        assertEquals(30, c.get(Calendar.DAY_OF_MONTH));
    }

    // [Databind#570]
    public void testISO8601PartialMilliseconds() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        
        inputStr = "2014-10-03T18:00:00.6-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(2014, c.get(Calendar.YEAR));
        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));
        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(600, c.get(Calendar.MILLISECOND));

        inputStr = "2014-10-03T18:00:00.61-05:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(2014, c.get(Calendar.YEAR));
        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));
        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(0, c.get(Calendar.MINUTE));
        assertEquals(0, c.get(Calendar.SECOND));
        assertEquals(610, c.get(Calendar.MILLISECOND));

        inputStr = "1997-07-16T19:20:30.45+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(20, c.get(Calendar.MINUTE));
        assertEquals(30, c.get(Calendar.SECOND));
        assertEquals(450, c.get(Calendar.MILLISECOND));

        // 14-Sep-2015, tatu: Colon for timezone offset is optional, verify
        inputStr = "1997-07-16T19:20:30.45+0100";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(20, c.get(Calendar.MINUTE));
        assertEquals(30, c.get(Calendar.SECOND));
        assertEquals(450, c.get(Calendar.MILLISECOND));

        // plus may also just have hour part
        inputStr = "1997-07-16T19:20:30.45+01";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(20, c.get(Calendar.MINUTE));
        assertEquals(30, c.get(Calendar.SECOND));
        assertEquals(450, c.get(Calendar.MILLISECOND));
    }

    public void testISO8601MissingSeconds() throws Exception
    {
        String inputStr;
        Date inputDate;
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));

        inputStr = "1997-07-16T19:20+01:00";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(0, c.get(Calendar.SECOND));
        assertEquals(0, c.get(Calendar.MILLISECOND));

        // 14-Sep-2015, tatu: Colon for timezone offset is optional, verify
        inputStr = "1997-07-16T19:20+0200";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(19 - 2, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(0, c.get(Calendar.SECOND));
        assertEquals(0, c.get(Calendar.MILLISECOND));

        // or just hour
        inputStr = "1997-07-16T19:20+04";
        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        c.setTime(inputDate);
        assertEquals(1997, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(19 - 4, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(0, c.get(Calendar.SECOND));
        assertEquals(0, c.get(Calendar.MILLISECOND));
    }

    public void testDateUtilISO8601NoTimezone() throws Exception
    {
        // Timezone itself is optional as well... 
        String inputStr = "1984-11-13T00:00:09";
        Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(inputDate);
        assertEquals(1984, c.get(Calendar.YEAR));
        assertEquals(Calendar.NOVEMBER, c.get(Calendar.MONTH));
        assertEquals(13, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(0, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(0, c.get(Calendar.MINUTE));
        assertEquals(9, c.get(Calendar.SECOND));
        assertEquals(0, c.get(Calendar.MILLISECOND));
    }

    // [databind#1657]: no timezone should use configured default
    public void testDateUtilISO8601NoTimezoneNonDefault() throws Exception
    {
        // In first case, no timezone -> SHOULD use configured timezone
        ObjectReader r = MAPPER.readerFor(Date.class);
        TimeZone tz = TimeZone.getTimeZone("GMT-2");
        Date date1 = r.with(tz)
                .readValue(quote("1970-01-01T00:00:00.000"));
        // Second case, should use specified timezone, not configured
        Date date2 = r.with(TimeZone.getTimeZone("GMT+5"))
                .readValue(quote("1970-01-01T00:00:00.000-02:00"));
        assertEquals(date1, date2);

        // also verify actual value, in GMT
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(date1);
        assertEquals(1970, c.get(Calendar.YEAR));
        assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));
        assertEquals(1, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(2, c.get(Calendar.HOUR_OF_DAY));
    }

    // [Issue#338]
    public void testDateUtilISO8601NoMilliseconds() throws Exception
    {
        final String INPUT_STR = "2013-10-31T17:27:00";
        Date inputDate;
        Calendar c;
        
        inputDate = MAPPER.readValue(quote(INPUT_STR), java.util.Date.class);
        c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(inputDate);
        assertEquals(2013, c.get(Calendar.YEAR));
        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));
        assertEquals(31, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(17, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(27, c.get(Calendar.MINUTE));
        assertEquals(0, c.get(Calendar.SECOND));
        assertEquals(0, c.get(Calendar.MILLISECOND));

        // 03-Nov-2013, tatu: This wouldn't work, and is the nominal reason
        //    for #338 I think
        /*
        inputDate =  ISO8601Utils.parse(INPUT_STR);
        c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(inputDate);
        assertEquals(2013, c.get(Calendar.YEAR));
        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));
        assertEquals(31, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(17, c.get(Calendar.HOUR_OF_DAY));
        assertEquals(27, c.get(Calendar.MINUTE));
        assertEquals(0, c.get(Calendar.SECOND));
        assertEquals(0, c.get(Calendar.MILLISECOND));
        */
    }

    public void testDateUtilISO8601JustDate() throws Exception
    {
        // Plain date (no time)
        String inputStr = "1972-12-28";
        Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTime(inputDate);
        assertEquals(1972, c.get(Calendar.YEAR));
        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));
        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));
    }

    @SuppressWarnings("deprecation")
    public void testDateSql() throws Exception
    {
        java.sql.Date value = new java.sql.Date(0L);
        value.setYear(99); // 1999
        value.setDate(19);
        value.setMonth(Calendar.APRIL);
        long now = value.getTime();

        // First from long
        assertEquals(value, MAPPER.readValue(String.valueOf(now), java.sql.Date.class));

        // then from default java.sql.Date String serialization:
        
        java.sql.Date result = MAPPER.readValue(quote(value.toString()), java.sql.Date.class);
        Calendar c = gmtCalendar(result.getTime());
        assertEquals(1999, c.get(Calendar.YEAR));
        assertEquals(Calendar.APRIL, c.get(Calendar.MONTH));
        assertEquals(19, c.get(Calendar.DAY_OF_MONTH));

        /* [JACKSON-200]: looks like we better add support for regular date
         *   formats as well
         */
        String expStr = "1981-07-13";
        result = MAPPER.readValue(quote(expStr), java.sql.Date.class);
        c.setTimeInMillis(result.getTime());
        assertEquals(1981, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(13, c.get(Calendar.DAY_OF_MONTH));

        /* 20-Nov-2009, tatus: I'll be damned if I understand why string serialization
         *   is off-by-one, but day-of-month does seem to be one less. My guess is
         *   that something is funky with timezones (i.e. somewhere local TZ is
         *   being used), but just can't resolve it. Hence, need to comment this:
         */
//        assertEquals(expStr, result.toString());
    }

    public void testCalendar() throws Exception
    {
        // not ideal, to use (ever-changing) current date, but...
        java.util.Calendar value = Calendar.getInstance();
        long l = 12345678L;
        value.setTimeInMillis(l);

        // First from long
        Calendar result = MAPPER.readValue(""+l, Calendar.class);
        assertEquals(l, result.getTimeInMillis());

        // Then from serialized String
        String dateStr = dateToString(new Date(l));
        result = MAPPER.readValue(quote(dateStr), Calendar.class);

        // note: representation may differ (wrt timezone etc), but underlying value must remain the same:
        assertEquals(l, result.getTimeInMillis());
    }

    public void testCustom() throws Exception
    {
        final ObjectMapper mapper = new ObjectMapper();
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");
        df.setTimeZone(TimeZone.getTimeZone("PST"));
        mapper.setDateFormat(df);

        String dateStr = "1972-12-28X15:45:00";
        java.util.Date exp = df.parse(dateStr);
        java.util.Date result = mapper.readValue("\""+dateStr+"\"", java.util.Date.class);
        assertEquals(exp, result);
    }

    /**
     * Test for [JACKSON-203]: make empty Strings deserialize as nulls by default,
     * without need to turn on feature (which may be added in future)
     */
    public void testDatesWithEmptyStrings() throws Exception
    {
        assertNull(MAPPER.readValue(quote(""), java.util.Date.class));
        assertNull(MAPPER.readValue(quote(""), java.util.Calendar.class));
        assertNull(MAPPER.readValue(quote(""), java.sql.Date.class));
    }

    // for [JACKSON-334]
    public void test8601DateTimeNoMilliSecs() throws Exception
    {
        // ok, Zebra, no milliseconds
        for (String inputStr : new String[] {
               "2010-06-28T23:34:22Z",
               "2010-06-28T23:34:22+0000",
               "2010-06-28T23:34:22+00:00",
               "2010-06-28T23:34:22+00",
        }) {
            Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);
            Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
            c.setTime(inputDate);
            assertEquals(2010, c.get(Calendar.YEAR));
            assertEquals(Calendar.JUNE, c.get(Calendar.MONTH));
            assertEquals(28, c.get(Calendar.DAY_OF_MONTH));
            assertEquals(23, c.get(Calendar.HOUR_OF_DAY));
            assertEquals(34, c.get(Calendar.MINUTE));
            assertEquals(22, c.get(Calendar.SECOND));
            assertEquals(0, c.get(Calendar.MILLISECOND));
        }
    }

    public void testTimeZone() throws Exception
    {
        TimeZone result = MAPPER.readValue(quote("PST"), TimeZone.class);
        assertEquals("PST", result.getID());
    }

    public void testCustomDateWithAnnotation() throws Exception
    {
        final String INPUT = "{\"date\":\"/2005/05/25/\"}";
        DateAsStringBean result = MAPPER.readValue(INPUT, DateAsStringBean.class);
        assertNotNull(result);
        assertNotNull(result.date);
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        long l = result.date.getTime();
        if (l == 0L) {
            fail("Should not get null date");
        }
        c.setTimeInMillis(l);
        assertEquals(2005, c.get(Calendar.YEAR));
        assertEquals(Calendar.MAY, c.get(Calendar.MONTH));
        assertEquals(25, c.get(Calendar.DAY_OF_MONTH));

        // 27-Mar-2014, tatu: Let's verify that changing Locale won't break it;
        //   either via context Locale
        result = MAPPER.readerFor(DateAsStringBean.class)
                .with(Locale.GERMANY)
                .readValue(INPUT);
        assertNotNull(result);
        assertNotNull(result.date);
        l = result.date.getTime();
        if (l == 0L) {
            fail("Should not get null date");
        }
        c.setTimeInMillis(l);
        assertEquals(2005, c.get(Calendar.YEAR));
        assertEquals(Calendar.MAY, c.get(Calendar.MONTH));
        assertEquals(25, c.get(Calendar.DAY_OF_MONTH));

        // or, via annotations
        DateAsStringBeanGermany result2 = MAPPER.readerFor(DateAsStringBeanGermany.class).readValue(INPUT);
        assertNotNull(result2);
        assertNotNull(result2.date);
        l = result2.date.getTime();
        if (l == 0L) {
            fail("Should not get null date");
        }
        c.setTimeInMillis(l);
        assertEquals(2005, c.get(Calendar.YEAR));
        assertEquals(Calendar.MAY, c.get(Calendar.MONTH));
        assertEquals(25, c.get(Calendar.DAY_OF_MONTH));
    }

    public void testCustomCalendarWithAnnotation() throws Exception
    {
        CalendarAsStringBean cbean = MAPPER.readValue("{\"cal\":\";2007/07/13;\"}",
                CalendarAsStringBean.class);
        assertNotNull(cbean);
        assertNotNull(cbean.cal);
        Calendar c = cbean.cal;
        assertEquals(2007, c.get(Calendar.YEAR));
        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));
        assertEquals(13, c.get(Calendar.DAY_OF_MONTH));
    }

    public void testCustomCalendarWithTimeZone() throws Exception
    {
        // And then with different TimeZone: CET is +01:00 from GMT -- read as CET
        DateInCETBean cet = MAPPER.readValue("{\"date\":\"2001-01-01,10\"}",
                DateInCETBean.class);
        Calendar c = Calendar.getInstance(getUTCTimeZone());
        c.setTimeInMillis(cet.date.getTime());
        // so, going to UTC/GMT should reduce hour by one
        assertEquals(2001, c.get(Calendar.YEAR));
        assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));
        assertEquals(1, c.get(Calendar.DAY_OF_MONTH));
        assertEquals(9, c.get(Calendar.HOUR_OF_DAY));
    }

    // Based on an external report; was throwing an exception for second case here
    public void testISO8601Directly() throws Exception
    {
        final String TIME_STR = "2015-01-21T08:56:13.533+0000";
        Date d = MAPPER.readValue(quote(TIME_STR), Date.class);
        assertNotNull(d);

        ISO8601DateFormat f = new ISO8601DateFormat();
        Date d2 = f.parse(TIME_STR);
        assertNotNull(d2);
        assertEquals(d.getTime(), d2.getTime());
    }

    /*
    /**********************************************************
    /* Tests to verify failing cases
    /**********************************************************
     */

    public void testInvalidFormat() throws Exception
    {
        try {
            MAPPER.readValue(quote("foobar"), Date.class);
            fail("Should have failed with an exception");
        } catch (InvalidFormatException e) {
            verifyException(e, "Can not deserialize value of type java.util.Date from String");
            assertEquals("foobar", e.getValue());
            assertEquals(Date.class, e.getTargetType());
        } catch (Exception e) {
            fail("Wrong type of exception ("+e.getClass().getName()+"), should get "
                    +InvalidFormatException.class.getName());
        }
    }
    
    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    private String dateToString(java.util.Date value)
    {
        /* Then from String. This is bit tricky, since JDK does not really
         * suggest a 'standard' format. So let's try using something...
         */
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
        return df.format(value);
    }

    private static Calendar gmtCalendar(long time)
    {
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.setTimeInMillis(time);
        return c;
    }

}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7683f49_dc2c003/rev_7683f49-dc2c003/src/test/java/com/fasterxml/jackson/databind/deser/DateDeserializationTest.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser;

import java.math.BigInteger;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.BaseMapTest;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;

@SuppressWarnings("javadoc")
public class DateDeserializationTest
    extends BaseMapTest
{
    private static final String LOCAL_TZ = "GMT+2";

    private static final DateFormat FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
    
    static class Annot_TimeZone {
        @JsonFormat(timezone="GMT+4")
        private java.util.Date date;
    }

    static class Annot_Pattern {
        @JsonFormat(pattern="'*'d MMM yyyy HH:mm:ss'*'")
        private java.util.Date pattern;

        @JsonFormat(pattern="'*'d MMM yyyy HH:mm:ss'*'", locale="FR")
        private java.util.Date pattern_FR;

        @JsonFormat(pattern="'*'d MMM yyyy HH:mm:ss'*'", timezone="GMT+4")
        private java.util.Date pattern_GMT4;

        @JsonFormat(pattern="'*'d MMM yyyy HH:mm:ss'*'", locale="FR", timezone="GMT+4")
        private java.util.Date pattern_FR_GMT4;
    }

    static class DateAsStringBean {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="/yyyy/MM/dd/")
        public Date date;
    }

    static class DateAsStringBeanGermany {
        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="/yyyy/MM/dd/", locale="fr_FR")
        public Date date;
    }

    private ObjectMapper MAPPER;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        // Create an ObjectMapper with its timezone set to something other than the default (UTC).
        // This way we can verify that serialization and deserialization actually consider the time
        // zone set on the mapper.
        ObjectMapper m = new ObjectMapper();
        m.setTimeZone(TimeZone.getTimeZone(LOCAL_TZ));
        MAPPER = m;
        
        FORMAT.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

    /**
     * Test the various timezone/offset representations
     */
    public void testDateUtilISO8601_Timezone() throws Exception
    {
        // Complete offset, with ':' between hours and minutes
        verify( MAPPER, "2000-01-02T03:04:05.678+01:00", judate(2000, 1, 2,   3, 4, 5, 678, "GMT+1"));
        // Complete offset, without ':' between hours and minutes
        verify( MAPPER, "2000-01-02T03:04:05.678+0100",  judate(2000, 1, 2,   3, 4, 5, 678, "GMT+1"));
        // Hour offset (no minutes)
        verify( MAPPER, "2000-01-02T03:04:05.678+01",    judate(2000, 1, 2,   3, 4, 5, 678, "GMT+1"));

        // 'zulu' offset
        verify( MAPPER, "2000-01-02T03:04:05.678Z",      judate(2000, 1, 2,   3, 4, 5, 678, "UTC"));

        // ---------------------------------------------------------------------------------------------
        // WARNING:
        //   According to ISO8601, hours and minutes of the offset must be expressed with 2 digits 
        //   (not more, not less), i.e. Z or +hh:mm or -hh:mm. See https://www.w3.org/TR/NOTE-datetime. 
        //
        //   The forms below should be refused but some are accepted by the StdDateFormat. They are 
        //   included in the test to detect any change in behavior in futur releases...
        // ---------------------------------------------------------------------------------------------

        // Interpreted as if there was no timezone, therefore producing a date with the TZ set on the mapper
        // FIXME it is probably better to refuse these cases instead of silently creating dates in local tz...
        verify( MAPPER, "2000-01-02T03:04:05.678+",        judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T03:04:05.678+1",       judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
            // FIXME this should probably give GMT+1
        verify( MAPPER, "2000-01-02T03:04:05.678+001",     judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T03:04:05.678+00:",     judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T03:04:05.678+00:001",  judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T03:04:05.678+001:001", judate(2000, 1, 2,   3, 4, 5, 678, LOCAL_TZ));

        // Considering the above forms have been accepted, it is strange the following are refused...
        failure( MAPPER, "2000-01-02T03:04:05.678+1:");      // FIXME
        failure( MAPPER, "2000-01-02T03:04:05.678+00:1");    // FIXME
    }

    /**
     * Test the millis
     */
    public void testDateUtilISO8601_DateTimeMillis() throws Exception 
    {    
        // WITH timezone (from 4 to 0 digits)
        failure(MAPPER, "2000-01-02T03:04:05.6789+01:00");
        verify( MAPPER, "2000-01-02T03:04:05.678+01:00", judate(2000, 1, 2,   3, 4, 5, 678, "GMT+1"));
        verify( MAPPER, "2000-01-02T03:04:05.67+01:00",  judate(2000, 1, 2,   3, 4, 5, 670, "GMT+1"));
        verify( MAPPER, "2000-01-02T03:04:05.6+01:00",   judate(2000, 1, 2,   3, 4, 5, 600, "GMT+1"));
        verify( MAPPER, "2000-01-02T03:04:05+01:00",     judate(2000, 1, 2,   3, 4, 5, 000, "GMT+1"));

        
        // WITH timezone Z (from 4 to 0 digits)
        verify( MAPPER, "2000-01-02T03:04:05.6789Z", judate(2000, 1, 2,   3, 4, 11, 789, "UTC"));
            // FIXME the .6789 millis are interpreted as 6789 millisecondes or 6.789 seconds!
        verify( MAPPER, "2000-01-02T03:04:05.678Z", judate(2000, 1, 2,   3, 4, 5, 678, "UTC"));
        verify( MAPPER, "2000-01-02T03:04:05.67Z",  judate(2000, 1, 2,   3, 4, 5,  67, "UTC"));
           // FIXME should be 670 millis instead of 67
        verify( MAPPER, "2000-01-02T03:04:05.6Z",   judate(2000, 1, 2,   3, 4, 5,   6, "UTC"));
           // FIXME should be 600 millis instead of 6
        verify( MAPPER, "2000-01-02T03:04:05Z",     judate(2000, 1, 2,   3, 4, 5,   0, "UTC"));
        

        // WITHOUT timezone (from 4 to 0 digits)
        verify(MAPPER, "2000-01-02T03:04:05.6789",       judate(2000, 1, 2,   3, 4, 11, 789, LOCAL_TZ));
            // FIXME: the .6789 millis are interpreted as 6789 millisecondes or 6.789 seconds!
        
        verify( MAPPER, "2000-01-02T03:04:05.678",       judate(2000, 1, 2,   3, 4,  5, 678, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T03:04:05.67",        judate(2000, 1, 2,   3, 5, 12, 000, LOCAL_TZ));
            // FIXME: the .67 millis are interpreted as 67 seconds.
        
        verify( MAPPER, "2000-01-02T03:04:05.6",         judate(2000, 1, 2,   3, 4,  5, 600, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T03:04:05",           judate(2000, 1, 2,   3, 4,  5, 000, LOCAL_TZ));
        
        
        // ---------------------------------------------------------------------------------------------
        // WARNING:
        //   RFC339 includes an Internet profile of the ISO 8601 standard for representation of dates 
        //   and times using the Gregorian calendar (https://tools.ietf.org/html/rfc3339).
        //
        //   The RFC defines a partial time with the following BNF notation (chapter 5.6):
        //      time-hour       = 2DIGIT  ; 00-23
        //      time-minute     = 2DIGIT  ; 00-59
        //      time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second rules
        //      time-secfrac    = "." 1*DIGIT
        //      partial-time    = time-hour ":" time-minute ":" time-second [time-secfrac]
        //
        //   The second fraction (ie the millis) is optional and can be ommitted. However, a fraction
        //   with only a dot (.) and no digit is not allowed.
        //
        //   The forms below should be refused but some are accepted by the StdDateFormat. They are 
           //   included in the test to detect any change in behavior in futur releases...
        // ---------------------------------------------------------------------------------------------
        
        // millis part with only a dot (.) and no digits
        verify( MAPPER, "2000-01-02T03:04:05.+01:00",    judate(2000, 1, 2,   3, 4, 5, 000, "GMT+1"));
        verify( MAPPER, "2000-01-02T03:04:05.",          judate(2000, 1, 2,   3, 4, 5, 000, LOCAL_TZ));
        failure(MAPPER, "2000-01-02T03:04:05.Z");	     // FIXME this one fails, but not the others...
    }


    /**
     * Date+Time representations
     * 
     * NOTE: millis are not tested here since they are covered by another test case
     */
    public void testDateUtilISO8601_DateTime() throws Exception 
    {
        // Full representation with a timezone
        verify(MAPPER, "2000-01-02T03:04:05+01:00",  judate(2000, 1, 2,   3, 4, 5, 0, "GMT+1"));

        // No timezone --> the one configured on the ObjectMapper must be used
        verify(MAPPER, "2000-01-02T03:04:05",        judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));

        // Hours, minutes and seconds are mandatory when time is specified
        failure(MAPPER, "2000-01-02T");
        failure(MAPPER, "2000-01-02T03");
        failure(MAPPER, "2000-01-02T03:");
        failure(MAPPER, "2000-01-02T03:04");
        failure(MAPPER, "2000-01-02T03:04:");

        // Although hours, minutes and seconds are mandatory, they can sometimes be omitted 
        // if a TZ is specified... !!??
        failure(MAPPER, "2000-01-02T+01:00");
        failure(MAPPER, "2000-01-02T03+01:00");
        failure(MAPPER, "2000-01-02T03:+01:00");
        verify( MAPPER, "2000-01-02T03:04+01:00",   judate(2000, 1, 2,   3, 4, 0, 0, "GMT+1"));    // FIXME should be refused
        failure(MAPPER, "2000-01-02T03:04:+01:00");
        
        failure(MAPPER, "2000-01-02TZ");
        failure(MAPPER, "2000-01-02T03Z");
        failure(MAPPER, "2000-01-02T03:Z");
        failure(MAPPER, "2000-01-02T03:04Z");
        failure(MAPPER, "2000-01-02T03:04:Z");

        
        // ---------------------------------------------------------------------------------------------
        // WARNING:
        //   ISO8601 (https://en.wikipedia.org/wiki/ISO_8601#Times) and its RFC339 profile 
        //   (https://tools.ietf.org/html/rfc3339, chapter 5.6) seem to require 2 DIGITS for 
        //   the hours, minutes and seconds.
        //
        //   The following forms should therefore be refused but are accepted by Jackson (and 
        //   java.text.SimpleDateFormat). They are verified here to detect any changes in future
        //   releases.
        //
        // ---------------------------------------------------------------------------------------------
        
        // FIXME As highlighted in the tests below, the behaviour is not consistent and largely 
        // depends on wether a timezone and or millis are specified or not.
        // The tests assert the behavior with different number of digits for hour, min and sec.
        // Behavior should be the SAME whatever the timezone and/or the millis.
        
        // seconds (no TZ)
        verify( MAPPER, "2000-01-02T03:04:5",           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T03:04:5.000",       judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
        failure(MAPPER, "2000-01-02T03:04:005");
        
        // seconds (+01:00)
        failure(MAPPER, "2000-01-02T03:04:5+01:00");
        failure(MAPPER, "2000-01-02T03:04:5.000+01:00");
        failure(MAPPER, "2000-01-02T03:04:005+01:00");
        
        // seconds (Z)
        failure(MAPPER, "2000-01-02T03:04:5Z");
        verify( MAPPER, "2000-01-02T03:04:5.000Z",      judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
        failure(MAPPER, "2000-01-02T03:04:005Z");
        

        // minutes (no TZ)
        verify( MAPPER, "2000-01-02T03:4:05",           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T03:4:05.000",       judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
        failure(MAPPER, "2000-01-02T03:004:05");
        
        // minutes (+01:00)
        failure(MAPPER, "2000-01-02T03:4:05+01:00");
        failure(MAPPER, "2000-01-02T03:4:05.000+01:00");
        failure(MAPPER, "2000-01-02T03:004:05+01:00");
        
        // minutes (Z)
        verify( MAPPER, "2000-01-02T03:4:05Z",          judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
        verify( MAPPER, "2000-01-02T03:4:05.000Z",      judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
        verify( MAPPER, "2000-01-02T03:004:05Z",        judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));


        // hour (no TZ)
        verify( MAPPER, "2000-01-02T3:04:05",           judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
        verify( MAPPER, "2000-01-02T3:04:05.000",       judate(2000, 1, 2,   3, 4, 5, 0, LOCAL_TZ));
        failure(MAPPER, "2000-01-02T003:04:05");

        // hour (+01:00)
        failure(MAPPER, "2000-01-02T3:04:05+01:00");
        failure(MAPPER, "2000-01-02T3:04:05.000+01:00");
        failure(MAPPER, "2000-01-02T003:04:05+01:00");

        // hour (Z)
        verify( MAPPER, "2000-01-02T3:04:05Z",         judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
        verify( MAPPER, "2000-01-02T3:04:05.000Z",     judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
        verify( MAPPER, "2000-01-02T003:04:05Z",       judate(2000, 1, 2,   3, 4, 5, 0, "UTC"));
    }


    /**
     * Date-only representations (no Time part)
     * 
     * NOTE: time part is not tested here since they it is covered by another test case
     */
    public void testDateUtilISO8601_Date() throws Exception
    {
        // Date is constructed with the timezone of the ObjectMapper. Time part is set to zero.
        verify(MAPPER, "2000-01-02", judate(2000, 1, 2,   0, 0, 0, 0, LOCAL_TZ));
        
        
        // ---------------------------------------------------------------------------------------------
        // WARNING:
        //   ISO8601 (https://en.wikipedia.org/wiki/ISO_8601#Times) and its RFC339 profile 
        //   (https://tools.ietf.org/html/rfc3339, chapter 5.6) seem to require 2 DIGITS for 
        //   the month and dayofweek but 4 DIGITS for the year.
        //
        //   The following forms should therefore be refused but are accepted by Jackson (and 
        //   java.text.SimpleDateFormat). They are verified here to detect any changes in future
        //   releases.
        // ---------------------------------------------------------------------------------------------

        // day
        verify(  MAPPER, "2000-01-2",      judate(2000, 1, 2,   0, 0, 0, 0, LOCAL_TZ));
        failure( MAPPER, "2000-01-002");
        
        // month
        verify(  MAPPER, "2000-1-02",      judate(2000, 1, 2,   0, 0, 0, 0, LOCAL_TZ));
        failure( MAPPER, "2000-001-02");
        
        // year
        failure( MAPPER, "20000-01-02");
        failure( MAPPER, "200-01-02"  );
        failure( MAPPER, "20-01-02"   );
        verify(  MAPPER, "2-01-02",        judate(2, 1, 2,   0, 0, 0, 0, LOCAL_TZ));    // FIXME Why accept 1 digit and refuse they other cases??
    }


    /**
     * DateTime as numeric representation
     */
    public void testDateUtil_Numeric() throws Exception
    {
        {
            long now = 123456789L;
            verify( MAPPER,                now, new java.util.Date(now) ); // as a long
            verify( MAPPER, Long.toString(now), new java.util.Date(now) ); // as a string
        }
        {
            /* As of 1.5.0, should be ok to pass as JSON String, as long
             * as it is plain timestamp (all numbers, 64-bit)
             */
            long now = 1321992375446L;
            verify( MAPPER,                now, new java.util.Date(now) );    // as a long
            verify( MAPPER, Long.toString(now), new java.util.Date(now) );  // as a string
        }
        {
            // #267: should handle negative timestamps too; like 12 hours before 1.1.1970
            long now = - (24 * 3600 * 1000L);
            verify( MAPPER,                now, new java.util.Date(now) );    // as a long
            verify( MAPPER, Long.toString(now), new java.util.Date(now) );  // as a string
        }

        // value larger than a long (Long.MAX_VALUE+1)
        BigInteger tooLarge = BigInteger.valueOf(Long.MAX_VALUE).add( BigInteger.valueOf(1) );
        failure(MAPPER, tooLarge, JsonParseException.class);    // FIXME: InvalidFormatException is thrown everywhere else...
        failure(MAPPER, tooLarge.toString());

        // decimal value
        failure(MAPPER, 0.0, JsonMappingException.class);        // FIXME: InvalidFormatException is thrown everywhere else...
        failure(MAPPER, "0.0");
    }


    /**
     * Note: may be these cases are already covered by {@link #testDateUtil_Annotation_PatternAndLocale()}
     */
    public void testDateUtil_Annotation() throws Exception
    {
        // Build the input JSON and expected value
        String json = aposToQuotes("{'date':'/2005/05/25/'}");
        java.util.Date expected = judate(2005, 05, 25, 0, 0, 0, 0, LOCAL_TZ);
        
        
        // Read it to make sure the format specified by the annotation is taken into account
        {
            DateAsStringBean result = MAPPER.readValue(json, DateAsStringBean.class);
            assertNotNull(result);
            assertEquals( expected, result.date );
        }
        {
            DateAsStringBean result = MAPPER.readerFor(DateAsStringBean.class)
                    .with(Locale.GERMANY)
                    .readValue(json);
            assertNotNull(result);
            assertEquals( expected, result.date );
        }
        
        // or, via annotations
        {
            DateAsStringBeanGermany result = MAPPER.readerFor(DateAsStringBeanGermany.class)
                                                   .readValue(json);
            assertNotNull(result);
            assertEquals( expected, result.date );
        }
    }

    /**
     * Test a POJO annotated with @JsonFormat to force an pattern.
     * Alternate with different combination of Locale and TimeZone.
     */
    public void testDateUtil_Annotation_PatternAndLocale() throws Exception
    {
        // Change the default locale set on the ObjectMapper to something else than the default.
        // This way we know if the default is correctly taken into account
        ObjectMapper mapper = MAPPER.copy();
        mapper.setLocale( Locale.ITALY );

        // Build the JSON string. This is a mixed of ITALIAN and FRENCH (no ENGLISH because this 
        // would be the default).
        String json = aposToQuotes("{ 'pattern': '*1 giu 2000 01:02:03*', 'pattern_FR': '*01 juin 2000 01:02:03*', 'pattern_GMT4': '*1 giu 2000 01:02:03*', 'pattern_FR_GMT4': '*1 juin 2000 01:02:03*'}");
        Annot_Pattern result = mapper.readValue(json, Annot_Pattern.class);

        assertNotNull(result);
        assertEquals( judate(2000, 6, 1, 1, 2, 3, 0, LOCAL_TZ), result.pattern        );
        assertEquals( judate(2000, 6, 1, 1, 2, 3, 0, LOCAL_TZ), result.pattern_FR     );
        assertEquals( judate(2000, 6, 1, 1, 2, 3, 0, "GMT+4"),  result.pattern_GMT4    );
        assertEquals( judate(2000, 6, 1, 1, 2, 3, 0, "GMT+4"),  result.pattern_FR_GMT4 );
    }

    /**
     * Test a POJO annotated with @JsonFormat to force a default TimeZone
     * other than the one set on the ObjectMapper when the JSON doesn't contain any.
     */
    public void testDateUtil_Annotation_TimeZone() throws Exception
    {
        // WITHOUT timezone
        {
            String json = aposToQuotes("{ 'date': '2000-01-02T03:04:05.678' }");
            Annot_TimeZone result = MAPPER.readValue(json, Annot_TimeZone.class);
            
            assertNotNull(result);
            assertEquals( judate(2000, 1, 2, 3, 4, 5, 678, "GMT+4"), result.date);
        }
        
        // WITH timezone
        //   --> the annotation acts as the "default" timezone. The timezone specified
        //       in the JSON should be considered first.
        {
            String json = aposToQuotes("{ 'date': '2000-01-02T03:04:05.678+01:00' }");
            Annot_TimeZone result = MAPPER.readValue(json, Annot_TimeZone.class);
            
            assertNotNull(result);
            assertEquals( judate(2000, 1, 2, 3, 4, 5, 678, "GMT+1"), result.date);
        }
    }

    /**
     * ObjectMapper configured with a custom date format that does NOT handle the TIMEZONE.
     * Dates must be constructed with the time zone set on the ObjectMapper.
     */
    public void testDateUtil_customDateFormat_withoutTZ() throws Exception
    {
        // FIXME
        //
        // The general rule with the StdDateFormat is:
        //     the TimeZone of the ObjectMapper is used if the JSON doesn't hold
        //     any timezone/offset information.
        //
        // This rule remains valid with the @JsonFormat annotation unless it forces
        // an explicit timezeone, in which case the latter takes precedence.
        //
        // One would expect the same behavior when the StdDateFormat is replaced by a 
        // custom DateFormat on the ObjectMapper. In other words, the timezone of the 
        // DateFormat is of no importance: the ObjectMapper's default should be used
        // whenever it is needed.
        
        
        // Test first with a non default TZ on the ObjectMapper
        // --> OK: the mapper's default TZ is used to parse the date.
        {
            DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");
            df.setTimeZone( TimeZone.getTimeZone("GMT+4") );    // TZ different from mapper's default
            
            ObjectMapper mapper = new ObjectMapper();
            mapper.setTimeZone( TimeZone.getTimeZone(LOCAL_TZ) );
            mapper.setDateFormat(df);
            
            // The mapper's default TZ is used...
            verify(mapper, "2000-01-02X04:00:00", judate(2000, 1, 2, 4, 00, 00, 00, LOCAL_TZ));
        }
        
        // Test a second time with the default TZ on the ObjectMapper
        // Note it is important NOT TO CALL mapper.setTimeZone(...) in this test..
        // --> KO: the custom format's TZ is used instead of the mapper's default as above.
        //
        {
            DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");
            df.setTimeZone( TimeZone.getTimeZone("GMT+4") );    // TZ different from mapper's default
            
            ObjectMapper mapper = new ObjectMapper();
            mapper.setDateFormat(df);
            
            // FIXME mapper's default TZ should have been used
            verify(mapper, "2000-01-02X04:00:00", judate(2000, 1, 2, 4, 00, 00, 00, "GMT+4"));
        }
    }

    /**
     * ObjectMapper configured with a custom date format that DOES handle the TIMEZONE.
     * Dates must be constructed from the timezone of the input, regardless of the one
     * of the ObjectMapper.
     */
    public void testDateUtil_customDateFormat_withTZ() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ssZ");
        df.setTimeZone(TimeZone.getTimeZone("GMT+4"));    // use a timezone different than the ObjectMapper and the system default
        mapper.setDateFormat(df);

        verify(mapper, "2000-01-02X03:04:05+0300", judate(2000, 1, 2, 3, 4, 5, 00, "GMT+3"));
    }

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    /**
     * Create a {@link java.util.Date} with all the fields set to the given value.
     * 
     * @param year year
     * @param month month (1-12)
     * @param day day of month (1-31)
     * @param hour hour (0-23)
     * @param minutes minutes (0-59)
     * @param seconds seconds (0-59)
     * @param millis millis
     * @param tz timezone id as accepted by {@link TimeZone#getTimeZone(String)}
     * @return a new {@link Date} instance
     */
    private static Date judate(int year, int month, int day, int hour, int minutes, int seconds, int millis, String tz) 
    {
        Calendar cal = Calendar.getInstance();
        cal.setLenient(false);
        cal.set(year, month-1, day, hour, minutes, seconds);
        cal.set(Calendar.MILLISECOND, millis);
        cal.setTimeZone(TimeZone.getTimeZone(tz));
        
        return cal.getTime();
    }

    private static void verify(ObjectMapper mapper, Object input, Date expected) throws Exception {
        // Deserialize using the supplied ObjectMapper
        Date actual = read(mapper, input, java.util.Date.class);

        // Test against the expected
        if( expected==null && actual==null) {
            return;
        }
        if( expected==null && actual != null) {
            fail("Failed to deserialize "+input+", actual: '"+FORMAT.format(actual)+"', expected: <null>'");
        }
        if( expected != null && actual == null ) {
            fail("Failed to deserialize "+input+", actual: <null>, expected: '"+FORMAT.format(expected)+"'");
        }
        if( actual.getTime() != expected.getTime() ) {
            fail("Failed to deserialize "+input+", actual: '"+FORMAT.format(actual)+"', expected: '"+FORMAT.format(expected)+"'");
        }
    }

    private static void failure(ObjectMapper mapper, Object input) throws Exception {
        failure(mapper, input, InvalidFormatException.class);
    }

    private static void failure(ObjectMapper mapper, Object input, Class<? extends Exception> exceptionType) throws Exception {
        try {
            Date date = read(mapper, input, java.util.Date.class);
            fail("Input "+input+" should not have been accepted but was deserialized into "+FORMAT.format(date));
        }
        catch(Exception e) {
            // Is it the expected exception ?
            if( ! exceptionType.isAssignableFrom(e.getClass()) ) {
                fail("Wrong exception thrown when reading "+input+", actual: "+e.getClass().getName() + "("+e.getMessage()+"), expected: "+exceptionType.getName());
            }
        }
    }

    private static <T> T read(ObjectMapper mapper, Object input, Class<T> type) throws Exception {
        // Construct the json representation from the input
        String json = input.toString();
        if( !(input instanceof Number) ) {
            json = "\""+json+"\"";
        }

        // Deserialize using the supplied ObjectMapper
        return (T) mapper.readValue(json, type);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_03cc86b_27491ae/rev_03cc86b-27491ae/src/test/java/com/fasterxml/jackson/databind/deser/exc/TestExceptionDeserialization.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.deser.exc;

import java.io.IOException;
import java.util.*;

import com.fasterxml.jackson.annotation.*;

import com.fasterxml.jackson.databind.*;

/**
 * Unit tests for verifying that simple exceptions can be deserialized.
 */
public class TestExceptionDeserialization
    extends BaseMapTest
{
    @SuppressWarnings("serial")
    static class MyException extends Exception
    {
        protected int value;

        protected String myMessage;
        protected HashMap<String,Object> stuff = new HashMap<String, Object>();
        
        @JsonCreator
        MyException(@JsonProperty("message") String msg, @JsonProperty("value") int v)
        {
            super(msg);
            myMessage = msg;
            value = v;
        }

        public int getValue() { return value; }
        
        public String getFoo() { return "bar"; }

        @JsonAnySetter public void setter(String key, Object value)
        {
            stuff.put(key, value);
        }
    }

    @SuppressWarnings("serial")
    static class MyNoArgException extends Exception
    {
        @JsonCreator MyNoArgException() { }
    }

    /*
    /**********************************************************
    /* Tests
    /**********************************************************
     */

    private final ObjectMapper MAPPER = new ObjectMapper();
    
    public void testIOException() throws IOException
    {
        IOException ioe = new IOException("TEST");
        String json = MAPPER.writeValueAsString(ioe);
        IOException result = MAPPER.readValue(json, IOException.class);
        assertEquals(ioe.getMessage(), result.getMessage());
    }

    public void testWithCreator() throws IOException
    {
        final String MSG = "the message";
        String json = MAPPER.writeValueAsString(new MyException(MSG, 3));

        MyException result = MAPPER.readValue(json, MyException.class);
        assertEquals(MSG, result.getMessage());
        assertEquals(3, result.value);
        assertEquals(1, result.stuff.size());
        assertEquals(result.getFoo(), result.stuff.get("foo"));
    }

    public void testWithNullMessage() throws IOException
    {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        String json = mapper.writeValueAsString(new IOException((String) null));
        IOException result = mapper.readValue(json, IOException.class);
        assertNotNull(result);
        assertNull(result.getMessage());
    }

    public void testNoArgsException() throws IOException
    {
        MyNoArgException exc = MAPPER.readValue("{}", MyNoArgException.class);
        assertNotNull(exc);
    }

    // try simulating JDK 7 behavior
    public void testJDK7SuppressionProperty() throws IOException
    {
        Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class);
        assertNotNull(exc);
    }
    
    // [databind#381]
    public void testSingleValueArrayDeserialization() throws Exception {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.enable(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS);
        final IOException exp;
        try {
            throw new IOException("testing");
        } catch (IOException internal) {
            exp = internal;
        }
        final String value = "[" + mapper.writeValueAsString(exp) + "]";
        
        final IOException cloned = mapper.readValue(value, IOException.class);
        assertEquals(exp.getMessage(), cloned.getMessage());    
        
        assertEquals(exp.getStackTrace().length, cloned.getStackTrace().length);
        for (int i = 0; i < exp.getStackTrace().length; i ++) {
            _assertEquality(i, exp.getStackTrace()[i], cloned.getStackTrace()[i]);
        }
    }

    protected void _assertEquality(int ix, StackTraceElement exp, StackTraceElement act)
    {
        _assertEquality(ix, "className", exp.getClassName(), act.getClassName());
        _assertEquality(ix, "methodName", exp.getMethodName(), act.getMethodName());
        _assertEquality(ix, "fileName", exp.getFileName(), act.getFileName());
        _assertEquality(ix, "lineNumber", exp.getLineNumber(), act.getLineNumber());
    }

    protected void _assertEquality(int ix, String prop,
            Object exp, Object act)
    {
        if (exp == null) {
            if (act == null) {
                return;
            }
        } else {
            if (exp.equals(act)) {
                return;
            }
        }
        fail(String.format("StackTraceElement #%d, property '%s' differs: expected %s, actual %s",
                ix, prop, exp, act));
    }

    public void testSingleValueArrayDeserializationException() throws Exception {
        final ObjectMapper mapper = new ObjectMapper();
        mapper.disable(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS);
        
        final IOException exp;
        try {
            throw new IOException("testing");
        } catch (IOException internal) {
            exp = internal;
        }
        final String value = "[" + mapper.writeValueAsString(exp) + "]";
        
        try {
            mapper.readValue(value, IOException.class);
            fail("Exception not thrown when attempting to deserialize an IOException wrapped in a single value array with UNWRAP_SINGLE_VALUE_ARRAYS disabled");
        } catch (JsonMappingException exp2) {
            verifyException(exp2, "out of START_ARRAY");
        }
    }

    // mostly to help with XML module (and perhaps CSV)
    public void testLineNumberAsString() throws IOException
    {
        Exception exc = MAPPER.readValue(aposToQuotes(
                "{'message':'Test',\n'stackTrace': "
                +"[ { 'lineNumber':'50' } ] }"
        ), IOException.class);
        assertNotNull(exc);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
    public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException
=======
    public final void serialize(JsonGenerator g, SerializerProvider provider) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
            jg.writeNull();
=======
            g.writeNull();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
            jg.writeString(_value);
=======
            g.writeString(_value);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
=======

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex)
        throws JsonParseException
    {
        _reportInvalidBase64(b64variant, ch, bindex, null);
    }

    /**
     * @param bindex Relative index within base64 character unit; between 0
     *   and 3 (as unit has exactly 4 characters)
     */
    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)
        throws JsonParseException
    {
        String base;
        if (ch <= ' ') {
            base = "Illegal white space character (code 0x"+Integer.toHexString(ch)+") as character #"+(bindex+1)+" of 4-char base64 unit: can only used between units";
        } else if (b64variant.usesPaddingChar(ch)) {
            base = "Unexpected padding character ('"+b64variant.getPaddingChar()+"') as character #"+(bindex+1)+" of 4-char base64 unit: padding only legal as 3rd or 4th character";
        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {
            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)
            base = "Illegal character (code 0x"+Integer.toHexString(ch)+") in base64 content";
        } else {
            base = "Illegal character '"+ch+"' (code 0x"+Integer.toHexString(ch)+") in base64 content";
        }
        if (msg != null) {
            base = base + ": " + msg;
        }
        throw new JsonParseException(null, base, JsonLocation.NA);
    }

    protected void _reportBase64EOF() throws JsonParseException {
        throw new JsonParseException(null, "Unexpected end-of-String when base64 content");
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java;<<<<<<< MINE
=======
package com.fasterxml.jackson.databind.node;

import java.math.BigDecimal;
import java.math.BigInteger;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.*;

/**
 * Basic tests for {@link JsonNode} implementations that
 * contain numeric values.
 */
public class TestNumberNodes extends NodeTestBase
{
    public void testShort()
    {
        ShortNode n = ShortNode.valueOf((short) 1);
        assertStandardEquals(n);
        assertTrue(0 != n.hashCode());
        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());
        assertEquals(JsonParser.NumberType.INT, n.numberType());	// should be SHORT
        assertEquals(1, n.intValue());
        assertEquals(1L, n.longValue());
        assertEquals(BigDecimal.ONE, n.decimalValue());
        assertEquals(BigInteger.ONE, n.bigIntegerValue());
        assertEquals("1", n.asText());

        assertNodeNumbers(n, 1, 1.0);

        assertTrue(ShortNode.valueOf((short) 0).canConvertToInt());
        assertTrue(ShortNode.valueOf(Short.MAX_VALUE).canConvertToInt());
        assertTrue(ShortNode.valueOf(Short.MIN_VALUE).canConvertToInt());

        assertTrue(ShortNode.valueOf((short) 0).canConvertToLong());
        assertTrue(ShortNode.valueOf(Short.MAX_VALUE).canConvertToLong());
        assertTrue(ShortNode.valueOf(Short.MIN_VALUE).canConvertToLong());
    }
    
	public void testInt()
    {
        IntNode n = IntNode.valueOf(1);
        assertStandardEquals(n);
        assertTrue(0 != n.hashCode());
        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());
        assertEquals(JsonParser.NumberType.INT, n.numberType());
        assertEquals(1, n.intValue());
        assertEquals(1L, n.longValue());
        assertEquals(BigDecimal.ONE, n.decimalValue());
        assertEquals(BigInteger.ONE, n.bigIntegerValue());
        assertEquals("1", n.asText());
        // 2.4
        assertEquals("1", n.asText("foo"));
        
        assertNodeNumbers(n, 1, 1.0);

        assertTrue(IntNode.valueOf(0).canConvertToInt());
        assertTrue(IntNode.valueOf(Integer.MAX_VALUE).canConvertToInt());
        assertTrue(IntNode.valueOf(Integer.MIN_VALUE).canConvertToInt());

        assertTrue(IntNode.valueOf(0).canConvertToLong());
        assertTrue(IntNode.valueOf(Integer.MAX_VALUE).canConvertToLong());
        assertTrue(IntNode.valueOf(Integer.MIN_VALUE).canConvertToLong());
    }

    public void testLong()
    {
        LongNode n = LongNode.valueOf(1L);
        assertStandardEquals(n);
        assertTrue(0 != n.hashCode());
        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());
        assertEquals(JsonParser.NumberType.LONG, n.numberType());
        assertEquals(1, n.intValue());
        assertEquals(1L, n.longValue());
        assertEquals(BigDecimal.ONE, n.decimalValue());
        assertEquals(BigInteger.ONE, n.bigIntegerValue());
        assertEquals("1", n.asText());

        assertNodeNumbers(n, 1, 1.0);

        // ok if contains small enough value
        assertTrue(LongNode.valueOf(0).canConvertToInt());
        assertTrue(LongNode.valueOf(Integer.MAX_VALUE).canConvertToInt());
        assertTrue(LongNode.valueOf(Integer.MIN_VALUE).canConvertToInt());
        // but not in other cases
        assertFalse(LongNode.valueOf(1L + Integer.MAX_VALUE).canConvertToInt());
        assertFalse(LongNode.valueOf(-1L + Integer.MIN_VALUE).canConvertToInt());

        assertTrue(LongNode.valueOf(0L).canConvertToLong());
        assertTrue(LongNode.valueOf(Long.MAX_VALUE).canConvertToLong());
        assertTrue(LongNode.valueOf(Long.MIN_VALUE).canConvertToLong());
    }

    public void testDouble() throws Exception
    {
        DoubleNode n = DoubleNode.valueOf(0.25);
        assertStandardEquals(n);
        assertTrue(0 != n.hashCode());
        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());
        assertEquals(JsonParser.NumberType.DOUBLE, n.numberType());
        assertEquals(0, n.intValue());
        assertEquals(0.25, n.doubleValue());
        assertNotNull(n.decimalValue());
        assertEquals(BigInteger.ZERO, n.bigIntegerValue());
        assertEquals("0.25", n.asText());

        // 1.6:
        assertNodeNumbers(DoubleNode.valueOf(4.5), 4, 4.5);

        assertTrue(DoubleNode.valueOf(0).canConvertToInt());
        assertTrue(DoubleNode.valueOf(Integer.MAX_VALUE).canConvertToInt());
        assertTrue(DoubleNode.valueOf(Integer.MIN_VALUE).canConvertToInt());
        assertFalse(DoubleNode.valueOf(1L + Integer.MAX_VALUE).canConvertToInt());
        assertFalse(DoubleNode.valueOf(-1L + Integer.MIN_VALUE).canConvertToInt());

        assertTrue(DoubleNode.valueOf(0L).canConvertToLong());
        assertTrue(DoubleNode.valueOf(Long.MAX_VALUE).canConvertToLong());
        assertTrue(DoubleNode.valueOf(Long.MIN_VALUE).canConvertToLong());

        JsonNode num = objectMapper().readTree(" -0.0");
        assertTrue(num.isDouble());
        n = (DoubleNode) num;
        assertEquals(-0.0, n.doubleValue());
        assertEquals("-0.0", String.valueOf(n.doubleValue()));
    }

    // @since 2.2
    public void testFloat()
    {
        FloatNode n = FloatNode.valueOf(0.45f);
        assertStandardEquals(n);
        assertTrue(0 != n.hashCode());
        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());
        assertEquals(JsonParser.NumberType.FLOAT, n.numberType());
        assertEquals(0, n.intValue());
        
        // NOTE: conversion to double NOT as simple as with exact numbers like 0.25:
        assertEquals(0.45f, n.floatValue());
        assertEquals("0.45", n.asText());

        // so; as double we'll get more complex number; however, should round-trip
        // to something that gets printed the same way. But not exact value, alas, hence:
        assertEquals("0.45",  String.valueOf((float) n.doubleValue()));

        assertNotNull(n.decimalValue());
        // possibly surprisingly, however, this will produce same output:
        assertEquals(BigInteger.ZERO, n.bigIntegerValue());
        assertEquals("0.45", n.asText());

        // 1.6:
        assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f);

        assertTrue(FloatNode.valueOf(0).canConvertToInt());
        assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt());
        assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt());

        // rounding errors if we just add/sub 1... so:
        assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt());
        assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt());

        assertTrue(FloatNode.valueOf(0L).canConvertToLong());
        assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong());
        assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong());
    }
    
    public void testDecimalNode() throws Exception
    {
        DecimalNode n = DecimalNode.valueOf(BigDecimal.ONE);
        assertStandardEquals(n);
        assertTrue(n.equals(new DecimalNode(BigDecimal.ONE)));
        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());
        assertEquals(JsonParser.NumberType.BIG_DECIMAL, n.numberType());
        assertTrue(n.isNumber());
        assertFalse(n.isIntegralNumber());
        assertTrue(n.isBigDecimal());
        assertEquals(BigDecimal.ONE, n.numberValue());
        assertEquals(1, n.intValue());
        assertEquals(1L, n.longValue());
        assertEquals(BigDecimal.ONE, n.decimalValue());
        assertEquals("1", n.asText());

        // 1.6:
        assertNodeNumbers(n, 1, 1.0);

        assertTrue(DecimalNode.valueOf(BigDecimal.ZERO).canConvertToInt());
        assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Integer.MAX_VALUE)).canConvertToInt());
        assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Integer.MIN_VALUE)).canConvertToInt());
        assertFalse(DecimalNode.valueOf(BigDecimal.valueOf(1L + Integer.MAX_VALUE)).canConvertToInt());
        assertFalse(DecimalNode.valueOf(BigDecimal.valueOf(-1L + Integer.MIN_VALUE)).canConvertToInt());

        assertTrue(DecimalNode.valueOf(BigDecimal.ZERO).canConvertToLong());
        assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Long.MAX_VALUE)).canConvertToLong());
        assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Long.MIN_VALUE)).canConvertToLong());
    }

    public void testDecimalNodeEqualsHashCode()
    {
        // We want DecimalNodes with equivalent _numeric_ values to be equal;
        // this is not the case for BigDecimal where "1.0" and "1" are not
        // equal!
        BigDecimal b1 = BigDecimal.ONE;
        BigDecimal b2 = new BigDecimal("1.0");
        BigDecimal b3 = new BigDecimal("0.01e2");
        BigDecimal b4 = new BigDecimal("1000e-3");

        DecimalNode node1 = new DecimalNode(b1);
        DecimalNode node2 = new DecimalNode(b2);
        DecimalNode node3 = new DecimalNode(b3);
        DecimalNode node4 = new DecimalNode(b4);

        assertEquals(node1.hashCode(), node2.hashCode());
        assertEquals(node2.hashCode(), node3.hashCode());
        assertEquals(node3.hashCode(), node4.hashCode());

        assertEquals(node1, node2);
        assertEquals(node2, node1);
        assertEquals(node2, node3);
        assertEquals(node3, node4);
    }

    public void testBigIntegerNode() throws Exception
    {
        BigIntegerNode n = BigIntegerNode.valueOf(BigInteger.ONE);
        assertStandardEquals(n);
        assertTrue(n.equals(new BigIntegerNode(BigInteger.ONE)));
        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());
        assertEquals(JsonParser.NumberType.BIG_INTEGER, n.numberType());
        assertTrue(n.isNumber());
        assertTrue(n.isIntegralNumber());
        assertTrue(n.isBigInteger());
        assertEquals(BigInteger.ONE, n.numberValue());
        assertEquals(1, n.intValue());
        assertEquals(1L, n.longValue());
        assertEquals(BigInteger.ONE, n.bigIntegerValue());
        assertEquals("1", n.asText());
        assertNodeNumbers(n, 1, 1.0);

        BigInteger maxLong = BigInteger.valueOf(Long.MAX_VALUE);
        
        n = BigIntegerNode.valueOf(maxLong);
        assertEquals(Long.MAX_VALUE, n.longValue());

        ObjectMapper mapper = new ObjectMapper();
        JsonNode n2 = mapper.readTree(maxLong.toString());
        assertEquals(Long.MAX_VALUE, n2.longValue());

        // then over long limit:
        BigInteger beyondLong = maxLong.shiftLeft(2); // 4x max long
        n2 = mapper.readTree(beyondLong.toString());
        assertEquals(beyondLong, n2.bigIntegerValue());

        assertTrue(BigIntegerNode.valueOf(BigInteger.ZERO).canConvertToInt());
        assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Integer.MAX_VALUE)).canConvertToInt());
        assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Integer.MIN_VALUE)).canConvertToInt());
        assertFalse(BigIntegerNode.valueOf(BigInteger.valueOf(1L + Integer.MAX_VALUE)).canConvertToInt());
        assertFalse(BigIntegerNode.valueOf(BigInteger.valueOf(-1L + Integer.MIN_VALUE)).canConvertToInt());

        assertTrue(BigIntegerNode.valueOf(BigInteger.ZERO).canConvertToLong());
        assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Long.MAX_VALUE)).canConvertToLong());
        assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Long.MIN_VALUE)).canConvertToLong());
    }

    public void testBigDecimalAsPlain() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper()
                .enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)
                .enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);
        final String INPUT = "{\"x\":1e2}";
        final JsonNode node = mapper.readTree(INPUT);
        String result = mapper.writeValueAsString(node);
        assertEquals("{\"x\":100}", result);

        // also via ObjectWriter:
        assertEquals("{\"x\":100}", mapper.writer().writeValueAsString(node));

        // and once more for [core#175]:
        BigDecimal bigDecimal = new BigDecimal(100);
        JsonNode tree = mapper.valueToTree(bigDecimal);
        assertEquals("100", mapper.writeValueAsString(tree));
    }

    // Related to [databind#333]
    public void testCanonicalNumbers() throws Exception
    {
        JsonNodeFactory f = new JsonNodeFactory();
        NumericNode n = f.numberNode(123);
        assertTrue(n.isInt());
        n = f.numberNode(1L + Integer.MAX_VALUE);
        assertFalse(n.isInt());
        assertTrue(n.isLong());

        /* 19-May-2015, tatu: Actually, no, coercion should not happen by default.
         *   But it should be possible to change it if necessary.
         */
        // but "too small" number will be 'int'...
        n = f.numberNode(123L);
        assertTrue(n.isLong());
    }
}>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5136650_9c4a7e5/rev_5136650-9c4a7e5/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java;<<<<<<< MINE
=======

    // [databind#186]
    public void testNullHandling() throws Exception
    {
        // First, a stand-alone null
        JsonNode n = objectReader().readTree("null");
        assertNotNull(n);
        assertTrue(n.isNull());

        n = objectMapper().readTree("null");
        assertNotNull(n);
        assertTrue(n.isNull());
        
        // Then object property
        ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}");
        assertEquals(1, root.size());
        n = root.get("x");
        assertNotNull(n);
        assertTrue(n.isNull());
    }

    public void testNullHandlingCovariance() throws Exception
    {
        String JSON = "{\"object\" : null, \"array\" : null }";
        CovarianceBean bean = objectMapper().readValue(JSON, CovarianceBean.class);

        ObjectNode on = bean._object;
        assertNull(on);

        ArrayNode an = bean._array;
        assertNull(an);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_991ccbe_ddfddfb/rev_991ccbe-ddfddfb/src/test/java/com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java;<<<<<<< MINE
        final String NASTY_CLASS = "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl";
=======
        final String clsName = "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl";
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_991ccbe_ddfddfb/rev_991ccbe-ddfddfb/src/test/java/com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java;<<<<<<< MINE
+" 'obj':[ '"+NASTY_CLASS+"',\n"
=======
+" 'obj':[ '"+clsName+"',\n"
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_991ccbe_ddfddfb/rev_991ccbe-ddfddfb/src/test/java/com/fasterxml/jackson/databind/interop/IllegalTypesCheckTest.java;<<<<<<< MINE
        } catch (InvalidDefinitionException e) {
            verifyException(e, "Illegal type");
            verifyException(e, "to deserialize");
            verifyException(e, "prevented for security reasons");
            BeanDescription desc = e.getBeanDescription();
            assertNotNull(desc);
            assertEquals(NASTY_CLASS, desc.getBeanClass().getName());
=======
        } catch (JsonMappingException e) {
            _verifySecurityException(e, clsName);
        }
    }

    // // // Tests for [databind#1737]

    public void testJDKTypes1737() throws Exception
    {
        _testTypes1737(java.util.logging.FileHandler.class);
        _testTypes1737(java.rmi.server.UnicastRemoteObject.class);
    }

    // 17-Aug-2017, tatu: Ideally would test handling of 3rd party types, too,
    //    but would require adding dependencies. This may be practical when
    //    checking done by module, but for now let's not do that for databind.

    /*
    public void testSpringTypes1737() throws Exception
    {
        _testTypes1737("org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor");
        _testTypes1737("org.springframework.beans.factory.config.PropertyPathFactoryBean");
    }

    public void testC3P0Types1737() throws Exception
    {
        _testTypes1737("com.mchange.v2.c3p0.JndiRefForwardingDataSource");
        _testTypes1737("com.mchange.v2.c3p0.WrapperConnectionPoolDataSource");
    }
    */

    private void _testTypes1737(Class<?> nasty) throws Exception {
        _testTypes1737(nasty.getName());
    }

    private void _testTypes1737(String clsName) throws Exception
    {
        // While usually exploited via default typing let's not require
        // it here; mechanism still the same
        String json = aposToQuotes(
                "{'v':['"+clsName+"','/tmp/foobar.txt']}"
                );
        try {
            MAPPER.readValue(json, PolyWrapper.class);
            fail("Should not pass");
        } catch (JsonMappingException e) {
            _verifySecurityException(e, clsName);
        }
    }

    protected void _verifySecurityException(Throwable t, String clsName) throws Exception
    {
        // 17-Aug-2017, tatu: Expected type more granular in 2.9 (over 2.8)
        _verifyException(t, JsonMappingException.class,
            "Illegal type",
            "to deserialize",
            "prevented for security reasons");
        verifyException(t, clsName);
    }

    protected void _verifyException(Throwable t, Class<?> expExcType,
            String... patterns) throws Exception
    {
        Class<?> actExc = t.getClass();
        if (!expExcType.isAssignableFrom(actExc)) {
            fail("Expected Exception of type '"+expExcType.getName()+"', got '"
                    +actExc.getName()+"', message: "+t.getMessage());
        }
        for (String pattern : patterns) {
            verifyException(t, pattern);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_5c48390_8fda858/rev_5c48390-8fda858/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
=======
    @Override
    @Deprecated
    public Iterable<Annotation> annotations() {
        if (_annotations == null) {
            return Collections.emptyList();
        }
        return _annotations.annotations();
    }

    /**
     *<p>
     * NOTE: promoted in 2.9 from `Annotated` up
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_9a81cf1_3414458/rev_9a81cf1-3414458/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        String reflectTypeName = objects.getClass().getGenericSuperclass().getTypeName();
=======
        String reflectTypeName = objects.getClass().getGenericSuperclass().toString();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8ca9c1c_04c777f/rev_8ca9c1c-04c777f/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======
    /* Deprecated exception factory methods
    /**********************************************************
     */

    /**
     * @since 2.5
     *
     * @deprecated Since 2.8 use {@link #handleUnknownTypeId} instead
     */
    @Deprecated
    public JsonMappingException unknownTypeException(JavaType type, String id,
            String extraDesc)
    {
        String msg = String.format("Could not resolve type id '%s' into a subtype of %s",
                id, type);
        msg = _colonConcat(msg, extraDesc);
        return MismatchedInputException.from(_parser, type, msg);
    }

    /**
     * Helper method for constructing exception to indicate that end-of-input was
     * reached while still expecting more tokens to deserialize value of specified type.
     *
     * @deprecated Since 2.8; currently no way to catch EOF at databind level
     */
    @Deprecated
    public JsonMappingException endOfInputException(Class<?> instClass) {
        return MismatchedInputException.from(_parser, instClass,
                "Unexpected end-of-input when trying to deserialize a "+instClass.getName());
    }

    /*
    /**********************************************************
    /* Deprecated methods for constructing, throwing non-specific
    /* JsonMappingExceptions: as of 2.9, should use more specific
    /* ones.
    /**********************************************************
     */
    
    /**
     * Fallback method that may be called if no other <code>reportXxx</code>
     * is applicable -- but only in that case.
     *
     * @since 2.8
     * 
     * @deprecated Since 2.9: use a more specific method, or {@link #reportBadDefinition(JavaType, String)},
     *    or {@link #reportInputMismatch} instead
     */
    @Deprecated // since 2.9
    public void reportMappingException(String msg, Object... msgArgs)
        throws JsonMappingException
    {
        throw JsonMappingException.from(getParser(), _format(msg, msgArgs));
    }

    /**
     * Helper method for constructing generic mapping exception with specified
     * message and current location information.
     * Note that application code should almost always call
     * one of <code>handleXxx</code> methods, or {@link #reportMappingException(String, Object...)}
     * instead.
     * 
     * @since 2.6
     * 
     * @deprecated Since 2.9 use more specific error reporting methods instead
     */
    @Deprecated
    public JsonMappingException mappingException(String message) {
        return JsonMappingException.from(getParser(), message);
    }

    /**
     * Helper method for constructing generic mapping exception with specified
     * message and current location information
     * Note that application code should almost always call
     * one of <code>handleXxx</code> methods, or {@link #reportMappingException(String, Object...)}
     * instead.
     * 
     * @since 2.6
     *
     * @deprecated Since 2.9 use more specific error reporting methods instead
     */
    @Deprecated
    public JsonMappingException mappingException(String msg, Object... msgArgs) {
        return JsonMappingException.from(getParser(), _format(msg, msgArgs));
    }

    /**
     * Helper method for constructing generic mapping exception for specified type
     * 
     * @deprecated Since 2.8 use {@link #handleUnexpectedToken(Class, JsonParser)} instead
     */
    @Deprecated
    public JsonMappingException mappingException(Class<?> targetClass) {
        return mappingException(targetClass, _parser.getCurrentToken());
    }

    /**
     * @deprecated Since 2.8 use {@link #handleUnexpectedToken(Class, JsonParser)} instead
     */
    @Deprecated
    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) {
        return JsonMappingException.from(_parser,
                String.format("Cannot deserialize instance of %s out of %s token",
                        ClassUtil.nameOf(targetClass), token));
    }

    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_998d79f_9d4a741/rev_998d79f-9d4a741/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
            boolean explicit, SettableBeanProperty[] injectables)
    {
        int delegateIndex = 0; // !!! TO FIX !!!
        if (creator.getParameterType(delegateIndex).isCollectionLikeType()) {
=======
            boolean explicit, SettableBeanProperty[] injectables,
            int delegateeIndex)
    {
        if (creator.getParameterType(delegateeIndex).isCollectionLikeType()) {
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3c814ae_c96798c/rev_3c814ae-c96798c/src/test/java/com/fasterxml/jackson/databind/jsontype/AbstractTypeMapping1186Test.java;<<<<<<< MINE
public class AbstracTypeMapping1186Test extends BaseMapTest
=======
public class AbstractTypeMapping1186Test extends BaseMapTest
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f1b16a8_cab130e/rev_f1b16a8-cab130e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        /*
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f1b16a8_cab130e/rev_f1b16a8-cab130e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    }

    public void testTypeGeneralization()
    {
        TypeFactory tf = newTypeFactory();
        MapType t = tf.constructMapType(HashMap.class, String.class, Long.class);
        JavaType superT = tf.constructGeneralizedType(t, Map.class);
        assertEquals(String.class, superT.getKeyType().getRawClass());
        assertEquals(Long.class, superT.getContentType().getRawClass());

        assertSame(t, tf.constructGeneralizedType(t, HashMap.class));

        // plus check there is super/sub relationship
        try {
            tf.constructGeneralizedType(t, TreeMap.class);
            fail("Should not pass");
        } catch (IllegalArgumentException e) {
            verifyException(e, "not a super-type of");
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b505162_4675896/rev_b505162-4675896/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // 20-Oct-2015, tatu: Old simplistic approach

        /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException("Class "+subclass.getClass().getName()+" not subtype of "+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, EMPTY_BINDINGS);
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
=======
    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)
    {
        PlaceholderForType[] placeholders = new PlaceholderForType[typeParamCount];
        for (int i = 0; i < typeParamCount; ++i) {
            placeholders[i] = new PlaceholderForType(i);
        }
        TypeBindings b = TypeBindings.create(subclass, placeholders);
        // First: pseudo-resolve to get placeholders in place:
        JavaType tmpSub = _fromClass(null, subclass, b);
        // Then find super-type
        JavaType baseWithPlaceholders = tmpSub.findSuperType(baseType.getRawClass());
        if (baseWithPlaceholders == null) { // should be found but...
            throw new IllegalArgumentException(String.format(
                    "Internal error: unable to locate supertype (%s) from resolved subtype %s", baseType.getRawClass().getName(),
                    subclass.getName()));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b505162_4675896/rev_b505162-4675896/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Otherwise, two choices: match N first, or empty. Do latter, for now
        return EMPTY_BINDINGS;
=======
        return true;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_6ec6e3e_a43d23d/rev_6ec6e3e-a43d23d/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
    public final boolean isArray() {
        return getNodeType() == JsonNodeType.ARRAY;
=======
    public boolean isMissingNode() {
        return false;
    }

    @Override
    public boolean isArray() {
        return false;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_985a3f9_dfaca81/rev_985a3f9-dfaca81/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        /* Let's try to figure out the reason, to give better error
         * messages
         */
=======
        // Let's try to figure out the reason, to give better error messages
>>>>>>> YOURS
