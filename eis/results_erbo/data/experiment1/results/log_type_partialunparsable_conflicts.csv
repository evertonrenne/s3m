/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fcb529e_dc65cc0/rev_fcb529e-dc65cc0/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java;<<<<<<< MINE
=======

    // 24-May-2012, tatu: Comment out for 2.0.x to keep tests green; leave for 2.1 to fix
    
    /*
    // [JACKSON-822]: ensure that type can be coerced
    public void testTypedLists() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        List<Issue822Interface> list = new ArrayList<Issue822Interface>();
        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());
        // start with specific value case:
        assertEquals("{\"a\":3}", singleJson);
        // then lists
        list.add(new Issue822Impl());
        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})
                .writeValueAsString(list);
        assertEquals("[{\"a\":3}]", listJson);
    }

    // [JACKSON-822]: ensure that type can be coerced
    public void testTypedArrays() throws Exception
    {
        ObjectMapper mapper = new ObjectMapper();
        assertEquals("[{\"a\":3}]", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(
                new Issue822Interface[] { new Issue822Impl() }));
    }
    */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
=======
     * @return This node after adding/replacing property value (to allow chaining)
     *
     * @since 2.1
     */
    public JsonNode set(String fieldName, JsonNode value)
    {
        if (value == null) {
            value = nullNode();
        }
        _put(fieldName, value);
        return this;
    }

    /**
     * Method for adding given properties to this object node, overriding
     * any existing values for those properties.
     * 
     * @param properties Properties to add
     * 
     * @return This node after adding/replacing property values (to allow chaining)
     *
     * @since 2.1
     */
    public JsonNode setAll(Map<String,JsonNode> properties)
    {
        if (_children == null) {
            _children = new LinkedHashMap<String, JsonNode>(properties);
        } else {
            for (Map.Entry<String, JsonNode> en : properties.entrySet()) {
                JsonNode n = en.getValue();
                if (n == null) {
                    n = nullNode();
                }
                _children.put(en.getKey(), n);
            }
        }
        return this;
    }

    /**
     * Method for adding all properties of the given Object, overriding
     * any existing values for those properties.
     * 
     * @param other Object of which properties to add to this object
     *
     * @return This node after addition (to allow chaining)
     *
     * @since 2.1
     */
    public JsonNode setAll(ObjectNode other)
    {
        int len = other.size();
        if (len > 0) {
            if (_children == null) {
                _children = new LinkedHashMap<String, JsonNode>(len);
            }
            other.putContentsTo(_children);
        }
        return this;
    }
    
    /**
     * Method for replacing value of specific property with passed
     * value, and returning value (or null if none).
     *
     * @param fieldName Property of which value to replace
     * @param value Value to set property to, replacing old value if any
     * 
     * @return Old value of the property; null if there was no such property
     *   with value
     * 
     * @since 2.1
     */
    public JsonNode replace(String fieldName, JsonNode value)
    {
        if (value == null) { // let's not store 'raw' nulls but nodes
            value = nullNode();
        }
        return _put(fieldName, value);
    }

    /**
     * Method for removing field entry from this ObjectNode, and
     * returning instance after removal.
     * 
     * @return This node after removing entry (if any)
     * 
     * @since 2.1
     */
    public JsonNode without(String fieldName)
    {
        if (_children != null) {
            _children.remove(fieldName);
        }
        return this;
    }

    /**
     * Method for removing specified field properties out of
     * this ObjectNode.
     * 
     * @param fieldNames Names of fields to remove
     * 
     * @return This node after removing entries
     * 
     * @since 2.1
     */
    public ObjectNode without(Collection<String> fieldNames)
    {
        if (_children != null) {
            for (String fieldName : fieldNames) {
                _children.remove(fieldName);
            }
        }
        return this;
    }
    
    /*
    /**********************************************************
    /* Extended ObjectNode API, mutators, generic
    /**********************************************************
     */
    
    /**
     * Method that will set specified field, replacing old value, if any.
     *
     * @param value to set field to; if null, will be converted
     *   to a {@link NullNode} first  (to remove field entry, call
     *   {@link #remove} instead)
     *<p>
     * NOTE: this method will be <b>deprecated</b> in 2.2; and should
     * be replace with either
     * {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},
     * depending on which return value is desired for possible chaining.
     *   
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: this method will be <b>deprecated</b> in 2.2; and should
     * be replace with {@link #setAll(Map)}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: this method will be <b>deprecated</b> in 2.2; and should
     * be replace with {@link #setAll(ObjectNode)}.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java;<<<<<<< MINE
=======
     * 
     * @return Node removed, if any; null if none
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java;<<<<<<< MINE
=======
    /**
     * Method for removing all elements of this array, leaving the
     * array empty.
     * 
     * @return This node (to allow chaining)
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        _defaultBase64 = defaultBase64;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_classIntrospector == ci) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_annotationIntrospector == ai) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_visibilityChecker == vc) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_propertyNamingStrategy == pns) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_typeFactory == tf) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_typeResolverBuilder == typer) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_dateFormat == df) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_handlerInstantiator == hi) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java;<<<<<<< MINE
=======
        if (_locale == l) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * Equivalent to:
     *<pre>
     *  mapper.setSerializationConfig(mapper.getSerializationConfig().withSerializationInclusion(incl));
     *</pre>
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8d2cdd7_2a4f66b/rev_8d2cdd7-2a4f66b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
    
static int col = 0;
=======
//static int col = 0;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
        /* 15-Jan-2010, tatu: This should probably be rewritten, given that
         *    more information about content type is actually being explicitly
         *    passed. So there should be less need to try to re-process that
         *    information.
         */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
        JavaType contentType = null;
        if (typeHint != null) {
            JavaType javaType = provider.constructType(typeHint);
            contentType = javaType.getContentType();
            if (contentType == null) { // could still be parametrized (Iterators)
                if (typeHint instanceof ParameterizedType) {
                    Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();
                    if (typeArgs.length == 1) {
                        contentType = provider.constructType(typeArgs[0]);
                    }
                }
            }
        }
        if (contentType == null && _elementType != null) {
            contentType = _elementType;
        }
=======
        JavaType contentType = _elementType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
                    deser = _findDefaultImplDeserializer(ctxt);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
            deser = _findDefaultImplDeserializer(ctxt);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
=======
            } catch (Exception e) {
                wrapAndThrow(e, result, fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java;<<<<<<< MINE
=======
            } catch (Exception e) {
                wrapAndThrow(e, result, fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still
    //   not really robust
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
                /* 24-Nov-2009, tatu: Ugh. This is getting pretty
                 *   ugly. Need to rewrite!
                 */

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
                // [Issue#541] ... but only as long as it's visible
                if (!node.isVisible) {
                    continue;
                }
                
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java;<<<<<<< MINE
=======
            if ("false".equals(v)) {
                return false;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======

        assertTrue(TextNode.valueOf("true").asBoolean(true));
        assertTrue(TextNode.valueOf("true").asBoolean(false));
        assertFalse(TextNode.valueOf("false").asBoolean(true));
        assertFalse(TextNode.valueOf("false").asBoolean(false));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java;<<<<<<< MINE
    // Beans for [JACKSON-387], [JACKSON-430]
=======
    static class WrappedContainerWithField {
        public ContainerWithField<?> animalContainer;
    }

	// Beans for [JACKSON-387], [JACKSON-430]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_3261453_d9c92cd/rev_3261453-d9c92cd/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java;<<<<<<< MINE
=======
    @JsonIdentityReference(alwaysAsId = true) // #524
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_17ab26b_c271fbc/rev_17ab26b-c271fbc/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #setMixIns(Class, Class)}.
     */
    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {
        setMixIns(sourceMixins);
    }

    /**
     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.
=======
     * Method to use for adding mix-in annotations to use for augmenting
     * specified class or interface. All annotations from
     * <code>mixinSource</code> are taken to override annotations
     * that <code>target</code> (or its supertypes) has.
     *
     * @param target Class (or interface) whose annotations to effectively override
     * @param mixinSource Class (or interface) whose annotations are to
     *   be "added" to target's annotations, overriding as necessary
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
=======
    @SuppressWarnings("unchecked")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
=======

        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization
         *    should always be called separately, from within "createContextual()".
         *    But this is a very singular deserializer since it operates on `Object`
         *    (and often for `?` type parameter), and as a result, easily and commonly
         *    results in cycles, being value deserializer for various Maps and Collections.
         *    Because of this, we must somehow break the cycles. This is done here by
         *    forcing pseudo-contextualization with null property.
         */

        // So: first find possible custom instances
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
=======

        // and then do bogus contextualization, in case custom ones need to resolve dependencies of
        // their own
        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null);
        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null);
        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null);
        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
    
=======

    /**
     * We only use contextualization for optimizing the case where no customization
     * occurred; if so, can slip in a more streamlined version.
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java;<<<<<<< MINE
        JsonDeserializer<?> mapDeserializer = _mapDeserializer;
        if (mapDeserializer instanceof ContextualDeserializer) {
            mapDeserializer = ((ContextualDeserializer)mapDeserializer).createContextual(ctxt, property);
        }
        JsonDeserializer<?> listDeserializer = _listDeserializer;
        if (listDeserializer instanceof ContextualDeserializer) {
            listDeserializer = ((ContextualDeserializer)listDeserializer).createContextual(ctxt, property);
        }
        JsonDeserializer<?> stringDeserializer = _stringDeserializer;
        if (stringDeserializer instanceof ContextualDeserializer) {
            stringDeserializer = ((ContextualDeserializer)stringDeserializer).createContextual(ctxt, property);
        }
        JsonDeserializer<?> numberDeserializer = _numberDeserializer;
        if (numberDeserializer instanceof ContextualDeserializer) {
            numberDeserializer = ((ContextualDeserializer)numberDeserializer).createContextual(ctxt, property);
        }

        // And if anything changed, we'll need to change too!
        if ((mapDeserializer != _mapDeserializer)
                || (listDeserializer != _listDeserializer)
                || (stringDeserializer != _stringDeserializer)
                || (numberDeserializer != _numberDeserializer)
                ) {
            return _withResolved(mapDeserializer, listDeserializer,
                    stringDeserializer, numberDeserializer);
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
=======
@SuppressWarnings("serial")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
    @SuppressWarnings("serial")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
    @SuppressWarnings("serial")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
=======
        implements ContextualDeserializer
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_603991b_7d4201c/rev_603991b-7d4201c/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java;<<<<<<< MINE
    @SuppressWarnings("serial")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38573ad_3e0d5d8/rev_38573ad-3e0d5d8/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java;<<<<<<< MINE
=======
        } else if (raw == Currency.class) {
            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);
            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_38573ad_3e0d5d8/rev_38573ad-3e0d5d8/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java;<<<<<<< MINE

=======
        case TYPE_CURRENCY:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IOException e) {
                throw ctxt.weirdKeyException(_keyClass, key, "unable to parse key as currency");
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7e507d1_e4ece74/rev_7e507d1-e4ece74/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
        _injectableValues = src._injectableValues;

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7cf964a_195e9b5/rev_7cf964a-195e9b5/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
                /* 18-Sep-2014, tatu: This is unfortunate patch over related change
                 *    that pushes creation of "unknown type" serializer deeper down
                 *    in BeanSerializerFactory; as a result, we need to "undo" creation
                 *    here.
                 */
                if (isUnknownTypeSerializer(ser)) {
                    return null;
                }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_7cf964a_195e9b5/rev_7cf964a-195e9b5/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
=======
        /* 18-Sep-2014, tatu: This is unfortunate patch over related change
         *    that pushes creation of "unknown type" serializer deeper down
         *    in BeanSerializerFactory; as a result, we need to "undo" creation
         *    here.
         */
        if (isUnknownTypeSerializer(ser)) {
            return null;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_2c9fa0e_3470803/rev_2c9fa0e-3470803/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java;<<<<<<< MINE
        
	/*
=======

    // for [databind#761]

    @JsonDeserialize(builder=ValueInterfaceBuilder.class)
    interface ValueInterface {
        int getX();
    }

    @JsonDeserialize(builder=ValueInterface2Builder.class)
    interface ValueInterface2 {
        int getX();
    }
    
    static class ValueInterfaceImpl implements ValueInterface
    {
        final int _x;

        protected ValueInterfaceImpl(int x) {
            _x = x+1;
        }

        @Override
        public int getX() {
            return _x;
        }
    }

    static class ValueInterface2Impl implements ValueInterface2
    {
        final int _x;

        protected ValueInterface2Impl(int x) {
            _x = x+1;
        }

        @Override
        public int getX() {
            return _x;
        }
    }
    
    static class ValueInterfaceBuilder
    {
        public int x;

        public ValueInterfaceBuilder withX(int x0) {
            this.x = x0;
            return this;
        }

        public ValueInterface build() {
            return new ValueInterfaceImpl(x);
        }
    }

    static class ValueInterface2Builder
    {
        public int x;

        public ValueInterface2Builder withX(int x0) {
            this.x = x0;
            return this;
        }

        // should also be ok: more specific type
        public ValueInterface2Impl build() {
            return new ValueInterface2Impl(x);
        }
    }
    
    // for [databind#761]
    @JsonDeserialize(builder = ValueBuilderWrongBuildType.class)
    static class ValueClassWrongBuildType {
    }

    static class ValueBuilderWrongBuildType
    {
        public int x;

        public ValueBuilderWrongBuildType withX(int x0) {
            this.x = x0;
            return this;
        }

        public ValueClassXY build() {
            return null;
        }
    }

    /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e5b8ff1_5183922/rev_e5b8ff1-5183922/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
=======
        assertFalse(m.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
        m.enable(JsonParser.Feature.ALLOW_COMMENTS);
        assertTrue(m.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_e5b8ff1_5183922/rev_e5b8ff1-5183922/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
=======

        // [Issue#913]: Ensure JsonFactory Features copied
        assertTrue(m2.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_313a713_d21210b/rev_313a713-d21210b/src/main/java/com/fasterxml/jackson/databind/node/BooleanNode.java;<<<<<<< MINE
=======
    public int hashCode() {
        return Boolean.valueOf(_value).hashCode();
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_90da5db_2a9808c/rev_90da5db-2a9808c/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_be11363_c966a03/rev_be11363-c966a03/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
=======
        if (_delegateDeserializer != null) {
            /* 24-Nov-2015, tatu: Use of delegating creator needs to have precedence, and basically
             *   external type id handling just has to be ignored, as they would relate to target
             *   type and not delegate type. Whether this works as expected is another story, but
             *   there's no other way to really mix these conflicting features.
             */
            return _valueInstantiator.createUsingDelegate(ctxt,
                    _delegateDeserializer.deserialize(p, ctxt));
        }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_bf2b2b0_e59a1ae/rev_bf2b2b0-e59a1ae/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
    // [JACKSON-799] stuff:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java;<<<<<<< MINE
            JsonFormat.Value format = property.findFormatOverrides(ai);
            if (format != null) {
                unwrapSingle = format.getFeature(JsonFormat.Feature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);
            }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java;<<<<<<< MINE
=======
        visitArrayFormat(visitor, typeHint, valueSer, _elementType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java;<<<<<<< MINE
                        // To fix [JACKSON-508]
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java;<<<<<<< MINE
            // [JACKSON-55] Need to add reference information
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java;<<<<<<< MINE
                    // [JACKSON-55] Need to add reference information
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
    
=======

    /*
    /**********************************************************
    /* Helper methods for JSON Schema generation
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
        // as per [JACKSON-563]. Note that 'required' defaults to false
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
=======
        Object ob = provider.getAttribute(CONVERTING_CONTENT_CONVERTER_LOCK);
        if (ob != null) {
            return existingSerializer;
        }
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java;<<<<<<< MINE
                Object convDef = intr.findSerializationContentConverter(m);
=======
                provider.setAttribute(CONVERTING_CONTENT_CONVERTER_LOCK, Boolean.TRUE);
                Object convDef;
                try {
                    convDef = intr.findSerializationContentConverter(m);
                } finally {
                    provider.setAttribute(CONVERTING_CONTENT_CONVERTER_LOCK, null);
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
        super((prop == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL : prop.getMetadata());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Rest of BeanProperty, nop
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
=======
    implements ContextualSerializer
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    
=======

    /*
    /**********************************************************
    /* Serialization methods
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/AtomicReferenceSerializer.java;<<<<<<< MINE
    
=======

    /*
    /**********************************************************
    /* Introspection support
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java;<<<<<<< MINE
    @Deprecated // since 2.5
    public boolean isEmpty(UUID value) {
        return isEmpty(null, value);
    }

    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java;<<<<<<< MINE
     * Jackson 1.5 did NOT include any type information; but this seems wrong,
     * and so 1.6 WILL include type information.
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java;<<<<<<< MINE
=======
        // 07-Nov-2015, tatu: One special case, Object.class; will work only if
        //   empty beans are allowed or custom serializer registered. Easiest to
        //   check here.
        if (cls == Object.class) {
            if (!_config.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {
                return true;
            }
        }
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java;<<<<<<< MINE
        if (type.isReferenceType()) {
            if (type.isTypeOrSubTypeOf(AtomicReference.class)) {
                return new AtomicReferenceSerializer((ReferenceType) type);
            }
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java;<<<<<<< MINE
=======
            if (ser instanceof ResolvableSerializer) {
                ((ResolvableSerializer) ser).resolve(provider);
            }
        }
    }

    /**
     * Another alternative that will cover both access via raw type and matching
     * fully resolved type, in one fell swoop.
     *
     * @since 2.7
     */
    public void addAndResolveNonTypedSerializer(Class<?> rawType, JavaType fullType,
            JsonSerializer<Object> ser,
            SerializerProvider provider)
        throws JsonMappingException
    {
        synchronized (this) {
            Object ob1 = _sharedMap.put(new TypeKey(rawType, false), ser);
            Object ob2 = _sharedMap.put(new TypeKey(fullType, false), ser);
            if ((ob1 == null) || (ob2 == null)) {
                _readOnlyMap.set(null);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java;<<<<<<< MINE
=======
     * given {@link ReferenceType}
     *
     * @since 2.7
     */
    public JsonSerializer<?> findReferenceSerializer(SerializationConfig config,
            ReferenceType type, BeanDescription beanDesc,
            TypeSerializer contentTypeSerializer, JsonSerializer<Object> contentValueSerializer);
    
    /**
     * Method called by serialization framework first time a serializer is needed for
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
=======
     *
     * @deprecated Since 2.7: should not be needed; should be enough to see if
     *     type has 'isStatic' modifier
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
=======
        /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java;<<<<<<< MINE
=======
        */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
                // [Issue#23]: Need to figure out how to force passed parameterization
                //  to stick...
                /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    public JsonSerializer<?> findReferenceSerializer(SerializerProvider prov, ReferenceType refType,
            BeanDescription beanDesc, boolean staticTyping)
        throws JsonMappingException
    {
        JavaType contentType = refType.getContentType(); 
        TypeSerializer contentTypeSerializer = contentType.getTypeHandler();
        final SerializationConfig config = prov.getConfig();
        if (contentTypeSerializer == null) {
            contentTypeSerializer = createTypeSerializer(config, contentType);
        }
        JsonSerializer<Object> contentSerializer = contentType.getValueHandler();
        for (Serializers serializers : customSerializers()) {
            JsonSerializer<?> ser = serializers.findReferenceSerializer(config, refType, beanDesc,
                    contentTypeSerializer, contentSerializer);
            if (ser != null) {
                return ser;
            }
        }
        if (refType.isTypeOrSubTypeOf(AtomicReference.class)) {
            return new AtomicReferenceSerializer(refType, staticTyping,
                    contentTypeSerializer, contentSerializer);
        }
        return null;
    }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
        */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
        throws JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
                declaredType = declaredType.widenBy(serClass);
=======
                ; // fine as is
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
                declaredType = _config.constructSpecializedType(declaredType, serClass);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
        }

        // Should not have to do static method but...
        JavaType secondary = BasicSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType);
        if (secondary != declaredType) {
            useStaticTyping = true;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
                 */

                // And use a marker
                def = NO_DEFAULT_MARKER;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
            _defaultBean = def;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java;<<<<<<< MINE
=======
        if (defaultBean == null) {
            return getDefaultValue(type);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    extends ConcreteBeanPropertyBase // since 2.7
    implements java.io.Serializable
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
        super(propDef);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        _metadata = propDef.getMetadata();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
        super(PropertyMetadata.STD_REQUIRED_OR_OPTIONAL);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        _metadata = null;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
        super(base);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        _metadata = base._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
        super(base);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
        _metadata = base._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======

    /*
    public JavaType getFullPropertyType() {
        if (_accessorMethod != null) {
            return _accessorMethod.getType()
        }
        if (_field != null) {
            return _field.getType();
        }
        return null;
    }
    */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7, to be removed from 2.8, use {@link #getType()} instead.
     */
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
     *
     * @deprecated Since 2.7, to be removed from 2.8, use {@link #getType()} instead.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
	 * This is a CSS color (like "#FF0000" or "red"), based on CSS
  		2.1 [W3C.CR-CSS21-20070719].
	 */
	COLOR("color"),

	/**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java;<<<<<<< MINE
=======
     @JsonValue // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java;<<<<<<< MINE
     *<p>
     * TODO: demote down to be part of {@link TypeIdResolver} in 2.6 or 2.7
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java;<<<<<<< MINE
=======
            // 01-Nov-2015, tatu: Actually this is still exactly wrong. Should fix.
            // 15-Jan-2016, tatu: ... as witnessed by [databind#1083], patched, but
            //     fundamentally this call can't be made to work for all cases
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java;<<<<<<< MINE
=======
    // !!! TODO: remove from 2.8
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
    implements ContextualDeserializer // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
=======
        _unwrapSingle = null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java;<<<<<<< MINE
            // [JACKSON-620] Empty String can become null...
            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)
                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {
                if (jp.getText().length() == 0) {
                    return null;
                }
            }
            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {
                throw ctxt.mappingException(_valueClass);
            }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java;<<<<<<< MINE
=======
            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {
                _failOnNumber(ctxt, p, index);
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = null;
    }

    /**
     * @since 2.7
     */
    @SuppressWarnings("unchecked" )
    protected EnumSetDeserializer(EnumSetDeserializer base,
            JsonDeserializer<?> deser, Boolean unwrapSingle) {
        super(EnumSet.class);
        _enumType = base._enumType;
        _enumClass = base._enumClass;
        _enumDeserializer = (JsonDeserializer<Enum<?>>) deser;
        _unwrapSingle = unwrapSingle;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = unwrapSingle;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
=======
        if ((valueDeser == _valueDeserializer) && (typeDeser == _valueTypeDeserializer)) {
            return this;
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
=======
        } else { // otherwise directly assigned, probably not contextual yet:
            deser = ctxt.handleSecondaryContextualization(deser, property, _referencedType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java;<<<<<<< MINE
        if (deser == _valueDeserializer && typeDeser == _valueTypeDeserializer) {
            return this;
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
    @SuppressWarnings("unchecked")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java;<<<<<<< MINE
        // #125: May have a content converter
=======
        Boolean unwrapSingle = findFormatFeature(ctxt, property, _arrayType.getRawClass(),
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
        // May have a content converter
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = unwrapSingle;
    }

    /**
     * Contextualization is needed to see whether we can "inline" deserialization
     * of String values, or if we have to use separate value deserializer.
     */
    @Override
    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException
    {
        JsonDeserializer<?> deser = _elementDeserializer;
        // May have a content converter
        deser = findConvertingContentDeserializer(ctxt, property, deser);
        JavaType type = ctxt.constructType(String.class);
        if (deser == null) {
            deser = ctxt.findContextualValueDeserializer(type, property);
        } else { // if directly assigned, probably not yet contextual, so:
            deser = ctxt.handleSecondaryContextualization(deser, property, type);
        }
        // One more thing: allow unwrapping?
        Boolean unwrapSingle = findFormatFeature(ctxt, property, String[].class,
                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
        // Ok ok: if all we got is the default String deserializer, can just forget about it
        if ((deser != null) && isDefaultDeserializer(deser)) {
            deser = null;
        }
        if ((_elementDeserializer == deser) && (_unwrapSingle == unwrapSingle)) {
            return this;
        }
        return new StringArrayDeserializer(deser, unwrapSingle);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java;<<<<<<< MINE
            throw ctxt.mappingException(_valueClass);
        }
        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };
    }

    /**
     * Contextualization is needed to see whether we can "inline" deserialization
     * of String values, or if we have to use separate value deserializer.
     */
    @Override
    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException
    {
        JsonDeserializer<?> deser = _elementDeserializer;
        // #125: May have a content converter
        deser = findConvertingContentDeserializer(ctxt, property, deser);
        JavaType type = ctxt.constructType(String.class);
        if (deser == null) {
            deser = ctxt.findContextualValueDeserializer(type, property);
        } else { // if directly assigned, probably not yet contextual, so:
            deser = ctxt.handleSecondaryContextualization(deser, property, type);
        }
        // Ok ok: if all we got is the default String deserializer, can just forget about it
        if (deser != null && this.isDefaultDeserializer(deser)) {
            deser = null;
        }
        if (_elementDeserializer != deser) {
            return new StringArrayDeserializer(deser);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======

        _arrayDelegateType = src._arrayDelegateType;
        _arrayDelegateCreator = src._arrayDelegateCreator;
        _arrayDelegateArguments = src._arrayDelegateArguments;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
    public JavaType getArrayDelegateType(DeserializationConfig config) {
        return _arrayDelegateType;
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        return _createUsingDelegate(_arrayDelegateCreator, _arrayDelegateArguments, ctxt, delegate);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        return _createFromStringFallbacks(ctxt, value);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        if (_fromLongCreator == null) {
            throw ctxt.mappingException("Can not instantiate value of type %s"
                    +" from Long integral number (%s); no single-long-arg constructor/factory method",
                    getValueTypeDesc(), value);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        throw ctxt.mappingException("Can not instantiate value of type %s"
                +" from Long integral number (%s); no single-long-arg constructor/factory method",
                getValueTypeDesc(), value);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        if (_fromDoubleCreator == null) {
            throw ctxt.mappingException("Can not instantiate value of type %s"
                    +" from Floating-point number (%s); no one-double/Double-arg constructor/factory method",
                    getValueTypeDesc(), value);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        throw ctxt.mappingException("Can not instantiate value of type %s"
                +" from Floating-point number (%s); no one-double/Double-arg constructor/factory method",
                getValueTypeDesc(), value);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        if (_fromBooleanCreator == null) {
            throw ctxt.mappingException("Can not instantiate value of type %s"
                    +" from Boolean value (%s); no single-boolean/Boolean-arg constructor/factory method",
                    getValueTypeDesc(), value);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
        throw ctxt.mappingException("Can not instantiate value of type %s"
                +" from Boolean value (%s); no single-boolean/Boolean-arg constructor/factory method",
                getValueTypeDesc(), value);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
    public AnnotatedWithParams getArrayDelegateCreator() {
        return _arrayDelegateCreator;
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7 call either {@link #unwrapAndWrapException} or
     *  {@link #wrapAsJsonMappingException}
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java;<<<<<<< MINE
=======
        String msg = String.format("Instantiation of %s value failed (%s): %s",
                getValueTypeDesc(), t.getClass().getName(), t.getMessage());
        return JsonMappingException.from(ctxt.getParser(), msg, t);
    }

    /**
     * @since 2.7
     */
    protected JsonMappingException wrapAsJsonMappingException(DeserializationContext ctxt,
            Throwable t)
    {
        // 05-Nov-2015, tatu: Only avoid wrapping if already a JsonMappingException
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
=======
        case JsonTokenId.ID_FIELD_NAME:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java;<<<<<<< MINE
        case JsonTokenId.ID_FIELD_NAME:
            return deserializeObject(p, ctxt, nodeFactory);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = unwrapSingle;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
        _unwrapSingle = src._unwrapSingle;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java;<<<<<<< MINE
=======
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
=======
            // 15-Sep-2015, tatu: How coud we get a ref to JsonParser?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java;<<<<<<< MINE
=======
            // 15-Sep-2015, tatu: How coud we get a ref to JsonParser?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
=======
            // 15-Sep-2015, tatu: How coud we get a ref to JsonParser?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java;<<<<<<< MINE
=======
            // 15-Sep-2015, tatu: How coud we get a ref to JsonParser?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    final protected boolean _forceAccess;
    
    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
        JavaType delegateType;
        boolean maybeVanilla = !_hasNonDefaultCreator;

        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {
            delegateType = null;
        } else {
            // need to find type...
            int ix = 0;
            if (_delegateArgs != null) {
                for (int i = 0, len = _delegateArgs.length; i < len; ++i) {
                    if (_delegateArgs[i] == null) { // marker for delegate itself
                        ix = i;
                        break;
                    }
                }
            }
            TypeBindings bindings = _beanDesc.bindingsForBeanType();
            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));
        }

=======
        final JavaType delegateType = _computeDelegateType(_creators[C_DELEGATE], _delegateArgs);
        final JavaType arrayDelegateType = _computeDelegateType(_creators[C_ARRAY_DELEGATE], _arrayDelegateArgs);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java;<<<<<<< MINE
=======
        inst.configureFromArraySettings(_creators[C_ARRAY_DELEGATE], arrayDelegateType, _arrayDelegateArgs);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java;<<<<<<< MINE
     * 
     * @since 2.0
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java;<<<<<<< MINE
     * Method called to create and return a deserializer that can construct
     * JsonNode(s) from JSON content.
     */
    public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException;

    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java;<<<<<<< MINE
=======
     * @since 2.2
     */
    public JsonDeserializer<?> modifyEnumDeserializer(DeserializationConfig config,
            JavaType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {
        return deserializer;
    }

    /**
     * @since 2.7
     */
    public JsonDeserializer<?> modifyReferenceDeserializer(DeserializationConfig config,
            ReferenceType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {
        return deserializer;
    }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java;<<<<<<< MINE
     * @since 2.2
     */
    public JsonDeserializer<?> modifyEnumDeserializer(DeserializationConfig config,
            JavaType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) {
        return deserializer;
    }
    
    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
    
    /*
    /**********************************************************
    /* JsonDeserializerFactory impl: Tree deserializers
    /**********************************************************
     */
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // [JACKSON-193] May have @JsonCreator for static factory method:
=======
        // May have @JsonCreator for static factory method:
        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        
        if (type.isReferenceType()) {
            JavaType referencedType = type.getReferencedType();
            if (AtomicReference.class.isAssignableFrom(rawType)) {
                TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);
                BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);
                JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());
                return new AtomicReferenceDeserializer(referencedType, vts, deser);
            }
            // Hmmh. Should we continue here for unknown referential types?
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
        // first: let's check class for the instance itself:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java;<<<<<<< MINE
=======
        // then: type refinement(s)?
        type = (T) intr.refineDeserializationType(ctxt.getConfig(), a, type);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
=======
        if (type.isReferenceType()) {
            return factory.createReferenceDeserializer(ctxt, (ReferenceType) type, beanDesc);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
        // first: let's check class for the instance itself:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java;<<<<<<< MINE
=======

        // And after handlers, possible type refinements
        // (note: could possibly avoid this if explicit deserializer was invoked?)
        type = intr.refineDeserializationType(ctxt.getConfig(), a, type);
        
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
=======

        case VALUE_NULL:
            return deserializeFromNull(p, ctxt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
            throw ctxt.mappingException(handledType());
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java;<<<<<<< MINE
=======
        throw ctxt.mappingException(handledType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java;<<<<<<< MINE
=======
     * Method that can be called to check whether a array-delegate-based creator
     * (single-arg constructor or factory method)
     * is available for this instantiator
     */
    public boolean canCreateUsingArrayDelegate() { return false; }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java;<<<<<<< MINE
=======
     * static factory method) that is used as the "array delegate creator".
     * Note that implementations not required to return actual object
     * they use (or, they may use some other instantiation) method.
     * That is, even if {@link #canCreateUsingArrayDelegate()} returns true,
     * this method may return null .
     */
    public AnnotatedWithParams getArrayDelegateCreator() { return null; }

    /**
     * Method that can be called to try to access member (constructor,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
=======
        if (_arrayDelegateDeserializer != null) {
            try {
                Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt));
                if (_injectables != null) {
                    injectValues(ctxt, bean);
                }
                return bean;
            } catch (Exception e) {
                wrapInstantiationProblem(e, ctxt);
            }
        }
        // fallback to non-array delegate
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
                KeyDeserializer keyDeserializer,
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java;<<<<<<< MINE
                KeyDeserializer keyDeserializer,
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java;<<<<<<< MINE
        final JavaType abstractType = beanDesc.getType();
        // [JACKSON-502]: Now it is possible to have multiple resolvers too,
        //   as they are registered via module interface.
=======
        // May have multiple resolvers, call in precedence order until one returns non-null
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(metadata);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(metadata);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = src._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = src._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
=======
        super(src);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
        _metadata = src._metadata;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java;<<<<<<< MINE
    public PropertyMetadata getMetadata() { return _metadata; }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
=======
    public static List<JavaType> findSuperTypes(JavaType type, Class<?> endBefore,
            boolean addClassItself) {
        if ((type == null) || type.hasRawClass(endBefore) || type.hasRawClass(Object.class)) {
            return Collections.emptyList();
        }
        List<JavaType> result = new ArrayList<JavaType>(8);
        _addSuperTypes(type, endBefore, result, addClassItself);
        return result;
    }

    /**
     * @since 2.7
     */
    public static List<Class<?>> findRawSuperTypes(Class<?> cls, Class<?> endBefore, boolean addClassItself) {
        if ((cls == null) || (cls == endBefore) || (cls == Object.class)) {
            return Collections.emptyList();
        }
        List<Class<?>> result = new ArrayList<Class<?>>(8);
        _addRawSuperTypes(cls, endBefore, result, addClassItself);
        return result;
    }

    /**
     * Method for finding all super classes (but not super interfaces) of given class,
     * starting with the immediate super class and ending in the most distant one.
     * Class itself is included if <code>addClassItself</code> is true.
     *
     * @since 2.7
     */
    public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore,
            boolean addClassItself) {
        List<Class<?>> result = new LinkedList<Class<?>>();
        if ((cls != null) && (cls != endBefore))  {
            if (addClassItself) {
                result.add(cls);
            }
            while ((cls = cls.getSuperclass()) != null) {
                if (cls == endBefore) {
                    break;
                }
                result.add(cls);
            }
        }
        return result;
    }

    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
    
=======

    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java;<<<<<<< MINE
        catch (NullPointerException e) { }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
//    private static final String UTC_ID = "UTC";
=======
    private static final String UTC_ID = "UTC";
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======
     * 
     * @deprecated Since 2.7 use {@link #TIMEZONE_UTC} instead
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
//    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);
=======
    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java;<<<<<<< MINE
=======
                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
    /**
     * @deprecated Since 2.4, use variant that also takes Locale
     */
    @Deprecated // since 2.4
    public StdDateFormat(TimeZone tz) {
        this(tz, DEFAULT_LOCALE);
    }
    
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
            _formatRFC1123 = null;
            _formatISO8601 = null;
            _formatISO8601_z = null;
            _formatPlain = null;
=======
            _clearFormats();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Public API, writing
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
            formatStr = DATE_FORMAT_STR_PLAIN;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
                formatStr = DATE_FORMAT_STR_ISO8601;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
                formatStr = DATE_FORMAT_STR_ISO8601_Z;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java;<<<<<<< MINE
=======
        if (lenient != null) {
            df.setLenient(lenient.booleanValue());
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
=======
     *
     * @since 2.7
     */
    public abstract JavaType getType();

    /**
     * @deprecated Since 2.7 Use {@link #getType()} instead. To be removed from 2.8.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java;<<<<<<< MINE
=======
     *
     * @deprecated Since 2.7 should instead use {@link #getType()}. To be removed from 2.8
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
    implements TypeResolutionContext
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    final protected JavaType _type;

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     * Type bindings to use for members of {@link #_class}.
     *
     * @since 2.7
     */
    final protected TypeBindings _bindings;

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: changed in 2.7 from List of <code>Class</code>es to List of {@link JavaType}s.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    final protected TypeFactory _typeFactory;
    
    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
        _typeFactory = tf;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
     * 
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
    public boolean hasOneOf(Class<? extends Annotation>[] annoClasses) {
        return _classAnnotations().hasOneOf(annoClasses);
    }
    
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        List<Class<?>> parents = new ArrayList<Class<?>>();
        parents.add(mixInCls);
        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);
=======
//        List<Class<?>> parents = ClassUtil.findSuperClasses(mixInCls, targetClass, true);

        List<Class<?>> parents = ClassUtil.findRawSuperTypes(mixInCls, targetClass, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        List<Class<?>> parents = new ArrayList<Class<?>>();
        parents.add(mixInCls);
        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);
=======
        List<Class<?>> parents = ClassUtil.findSuperClasses(mixInCls, targetClass, true);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
        if (paramCount == 0) { // no-arg default constructors, can simplify slightly
            return new AnnotatedConstructor(typeContext, ctor.getConstructor(),
                    _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), NO_ANNOTATION_MAPS);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
            resolvedAnnotations = null;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE
=======
    /*
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java;<<<<<<< MINE

    /*
    /**********************************************************
    /* Partial Annotated impl
    /**********************************************************
     */

    @Override
    public final <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _annotations.get(acls);
    }
=======
    */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
        return _findFilterId(a);
    }

    protected final Object _findFilterId(Annotated a)
    {
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Deserialization: type modifications
    /**********************************************************
     */

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java;<<<<<<< MINE

=======
    
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
     * Class that was resolved to produce this member instance; either class that declared
     * the member, or one of its subtypes that inherited it.
     * 
     * @since 2.5
=======
     * Context object needed for resolving generic type associated with this
     * member (method parameter or return value, or field type).
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
     * Note that this may be different from what {@link #getContextClass()} returns;
     * "owner" may be a sub-type of "declaring class".
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
     * Accessor for {@link AnnotatedClass} that was the type that was resolved
     * and that contains this member: this is either the {@link java.lang.Class}
     * in which member was declared, or one of its super types. If distinction
     * between result type, and actual class in which declaration was found matters,
     * you can compare return value to that of {@link #getDeclaringClass()}.
     * The main use for this accessor is (usually) to access class annotations.
     *<p>
     * Also note that owner property is NOT (JDK-)serialized; this should usually not
     * matter, but means that while it is accessible during construction of various
     * (de)serializers, it may not be available on per-call basis, if (but only if)
     * <code>ObjectMapper</code> (etc) has been serialized/deserialized.
=======
     * Accessor for {@link TypeResolutionContext} that is used for resolving
     * full generic type of this member.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
=======
     *<p>
     * Note that caller should verify that
     * {@link com.fasterxml.jackson.databind.MapperFeature#CAN_OVERRIDE_ACCESS_MODIFIERS}
     * is enabled before calling this method; as well as pass
     * <code>force</code> flag appropriately.
     * 
     * @since 2.7
     */
    public final void fixAccess(boolean force) {
        ClassUtil.checkAndFixAccess(getMember(), force);
    }
    
    /**
     * @deprecated Since 2.7 use {@link #fixAccess(boolean)} instead
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
    public Class<?> findSerializationType(Annotated a) {
        Class<?> r = _primary.findSerializationType(a);
        return (r == null) ? _secondary.findSerializationType(a) : r;
    }

    @Override
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {
        Class<?> r = _primary.findSerializationKeyType(am, baseType);
        return (r == null) ? _secondary.findSerializationKeyType(am, baseType) : r;
    }

    @Override
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {
        Class<?> r = _primary.findSerializationContentType(am, baseType);
        return (r == null) ? _secondary.findSerializationContentType(am, baseType) : r;
    }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
        _config = config;
        _annotationIntrospector = ai;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        _annotationIntrospector = annotationIntrospector;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
        _config = src._config;
        _annotationIntrospector = src._annotationIntrospector;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
        _annotationIntrospector = src._annotationIntrospector;
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java;<<<<<<< MINE
=======
            // 11-Dec-2015, tatu: As per [databind#1033] allow pluggable conflict resolution
            if (_annotationIntrospector != null) {
                AnnotatedMethod pref = _annotationIntrospector.resolveSetterConflict(_config,
                        currM, nextM);
                
                // note: should be one of nextM/currM; but no need to check
                if (pref == currM) {
                    continue;
                }
                if (pref == nextM) {
                    curr = next;
                    continue;
                }
            }
            
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java;<<<<<<< MINE
=======
    public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,
            DeserializationConfig config, BeanDescription beanDesc)
        throws JsonMappingException
    {
        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(nodeType));
    }
    
    @Override
    public JsonDeserializer<?> findReferenceDeserializer(ReferenceType refType,
            DeserializationConfig config, BeanDescription beanDesc,
            TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer)
        throws JsonMappingException {
        // 21-Oct-2015, tatu: Unlikely this will really get used (reference types need more
        //    work, simple registration probably not sufficient). But whatever.
        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(refType.getRawClass()));
    }
    
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
=======
    @Deprecated
    // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
=======
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return new MapLikeType(rawType, bindings, superClass, superInterfaces,
                _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    /**
     * Not sure if we should count on this, but type names
     * for core interfaces are "K" and "V" respectively.
     * For now let's assume this should work.
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java;<<<<<<< MINE
    // TODO: should allow construction of instances that do refer
    //  to parameterization, since it is NOT Map
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    public JavaType widenKey(Class<?> keySubclass)
    {
        // Can do a quick check first:
        if (keySubclass == _keyType.getRawClass()) {
            return this;
        }
        return new MapType(_class, _keyType.widenBy(keySubclass), _valueType,
                _valueHandler, _typeHandler, _asStatic);
    }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/MapType.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Overridden accessors
    /**********************************************************
     */
=======
    @Override
    public JavaType withContentType(JavaType contentType) {
        if (_valueType == contentType) {
            return this;
        }
        return new MapType(_class, _bindings, _superClass, _superInterfaces,
                _keyType, contentType, _valueHandler, _typeHandler, _asStatic);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java;<<<<<<< MINE
 * 
 * @author tatu
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
=======
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        return new ReferenceType(rawType, _bindings,
                superClass, superInterfaces, _referencedType,
                _valueHandler, _typeHandler, _asStatic);
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    
    /*
    /**********************************************************
    /* Public API overrides
    /**********************************************************
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java;<<<<<<< MINE
    public int containedTypeCount() {
        return 1;
    }

    @Override
    public JavaType containedType(int index) {
        return (index == 0) ? _referencedType : null;
    }

    @Override
    public String containedTypeName(int index) {
        return (index == 0) ? "T" : null;
    }

    @Override
    public Class<?> getParameterSource() {
        // Hmmh. For now, assume it's the raw type
        return _class;
    }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java;<<<<<<< MINE
    /**
     * Not sure if we should count on this, but type names
     * for core interfaces use "E" for element type
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
=======
    /**
     * Constructor only used by core Jackson databind functionality;
     * should never be called by application code.
     *<p>
     * As with other direct construction that by-passes {@link TypeFactory},
     * no introspection occurs with respect to super-types; caller must be
     * aware of consequences if using this method.
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    @Override
    protected JavaType _narrow(Class<?> subclass)
    {
        // Should we check that there is a sub-class relationship?
        return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler,
                _asStatic, _typeParametersFor);
    }

    @Override
    public JavaType narrowContentsBy(Class<?> subclass)
    {
        // should never get called
        throw new IllegalArgumentException("Internal error: SimpleType.narrowContentsBy() should never be called");
    }

    @Override
    public JavaType widenContentsBy(Class<?> subclass)
    {
        // should never get called
        throw new IllegalArgumentException("Internal error: SimpleType.widenContentsBy() should never be called");
    }
    
=======
    /**
     * Method that should NOT to be used by application code:
     * it does NOT properly handle inspection of super-types, so neither parent
     * Classes nor implemented Interfaces are accessible with resulting type
     * instance. Instead, please use {@link TypeFactory}'s <code>constructType</code>
     * methods which handle introspection appropriately.
     *<p>
     * Note that prior to 2.7, method usage was not limited and would typically
     * have worked acceptably: the problem comes from inability to resolve super-type
     * information, for which {@link TypeFactory} is needed.
     * 
     * @deprecated Since 2.7
     */
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
=======
    public JavaType refine(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInterfaces) {
        // SimpleType means something not-specialized, so:
        return null;
    }
    
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
    public Class<?> getParameterSource() {
        return _typeParametersFor;
    }
    
    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java;<<<<<<< MINE
=======
    /* Internal methods
    /**********************************************************
     */

    /**
     * Helper method we need to recursively build skeletal representations
     * of superclasses.
     * 
     * @since 2.7 -- remove when not needed (2.8?)
     */
    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)
    {
        if (superClass == null) {
            return null;
        }
        if (superClass == Object.class) {
            return TypeFactory.unknownType();
        }
        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);
        return new SimpleType(superClass, b,
                superSuper, null, null, null, false);
    }

    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
        */
    }

    /**
     * Method similar to {@link #constructSpecializedType}, but that creates a
     * less-specific type of given type. Usually this is as simple as simply
     * finding super-type with type erasure of <code>superClass</code>, but
     * there may be need for some additional work-arounds.
     *
     * @param superClass
     *
     * @since 2.7
     */
    public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass)
    {
        // simple optimization to avoid costly introspection if type-erased type does NOT differ
        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == superClass) {
            return baseType;
        }
        JavaType superType = baseType.findSuperType(superClass);
        if (superType == null) {
            // Most likely, caller did not verify sub/super-type relationship
            if (!superClass.isAssignableFrom(rawBase)) {
                throw new IllegalArgumentException(String.format(
                        "Class %s not a super-type of %s", superClass.getName(), baseType));
            }
            // 01-Nov-2015, tatu: Should never happen, but ch
            throw new IllegalArgumentException(String.format(
                    "Internal error: class %s not included as super-type for %s",
                    superClass.getName(), baseType));
        }
        return superType;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE

=======
    
    /**
     * @deprecated Since 2.7 resolve raw type first, then find type parameters
     */
    @Deprecated // since 2.7    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    @Deprecated
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
     *
     * @since 2.6
     *
     * @deprecated Since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @param parametrized Type-erased type of instance being constructed
     * @param parametersFor class or interface for which type parameters are applied; either
     *   <code>parametrized</code> or one of its supertypes
     * @param parameterClasses Type parameters to apply
     * 
     * @since 2.5
=======
     * @since 2.5 NOTE: was briefly deprecated for 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * @param parametrized Actual full type
     * @param parametersFor class or interface for which type parameters are applied; either
     *   <code>parametrized</code> or one of its supertypes
=======
     * @param rawType Actual type-erased type
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        // Very first thing: small set of core types we know well:
        if (clz == String.class) return CORE_TYPE_STRING;
        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;
        if (clz == Integer.TYPE) return CORE_TYPE_INT;
        if (clz == Long.TYPE) return CORE_TYPE_LONG;
=======
        JavaType kt, vt;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
        return MapType.construct(rawClass, bindings, superClass, superInterfaces, kt, vt);
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            return _collectionType(clz);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * This method deals with parameterized types, that is,
     * first class generic classes.
=======
     * Factory method that is to create a new {@link SimpleType} with no
     * checks whatsoever. Default implementation calls the single argument
     * constructor of {@link SimpleType}.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        Class<?> rawType = (Class<?>) type.getRawType();
        Type[] args = type.getActualTypeArguments();
        int paramCount = (args == null) ? 0 : args.length;
=======
        return CORE_TYPE_OBJECT;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
        return null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
            return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {
                (kt == null) ? unknownType() : kt,
                (vt == null) ? unknownType() : vt });
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
            // no, but need to update context to allow for proper cycle resolution
            context = context.child(rawType);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
        /* 29-Jan-2010, tatu: We used to throw exception here, if type was
         *   bound: but the problem is that this can occur for generic "base"
         *   method, overridden by sub-class. If so, we will want to ignore
         *   current type (for method) since it will be masked.
         */
        Type[] bounds = type.getBounds();
=======
        // First: do we have an array type?
        if (rawType.isArray()) {
            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),
                    bindings);
        } else {
            // If not, need to proceed by first resolving parent type hierarchy
            
            JavaType superClass;
            JavaType[] superInterfaces;

            if (rawType.isInterface()) {
                superClass = null;
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            } else {
                // Note: even Enums can implement interfaces, so can not drop those
                superClass = _resolveSuperClass(context, rawType, bindings);
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            }

            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...
            if (rawType == Properties.class) {
                result = MapType.construct(rawType, bindings, superClass, superInterfaces,
                        CORE_TYPE_STRING, CORE_TYPE_STRING);
            }
            // And then check what flavor of type we got. Start by asking resolved
            // super-type if refinement is all that is needed?
            else if (superClass != null) {
                result = superClass.refine(rawType, bindings, superClass, superInterfaces);
            }
            // if not, perhaps we are now resolving a well-known class or interface?
            if (result == null) {
                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); 
                if (result == null) {
                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);
                    if (result == null) {
                        // but if nothing else, "simple" class for now:
                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);
                    }
                }
            }
        }
        context.resolveSelfReferences(result);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
     * Helper method used to find inheritance (implements, extends) path
     * between given types, if one exists (caller generally checks before
     * calling this method). Returned type represents given <b>subtype</b>,
     * with supertype linkage extending to <b>supertype</b>.
=======
     * This method deals with parameterized types, that is,
     * first class generic classes.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java;<<<<<<< MINE
=======
            newBindings = TypeBindings.create(rawType, pt);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    // Since 1.7:
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java;<<<<<<< MINE
    /*
    /**********************************************************
    /* Overridden accessors
    /**********************************************************
     */
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
    implements java.io.Serializable
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    /**
     * Specific class to use for resolving all types, for methods and fields
     * class and its superclasses and -interfaces contain.
     */
    protected final Class<?> _contextClass;
=======
    // // // Pre-resolved instances for minor optimizations
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
    // // // Actual member information
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
     * Constructor used to create "child" instances; mostly to
     * allow delegation from explicitly defined local overrides
     * (local type variables for methods, constructors) to
     * contextual (class-defined) ones.
=======
     * Factory method for constructing bindings for given class using specified type
     * parameters.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
        return null;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
//            sb = _types[i].appendBriefDescription(sb);
            String sig = _types[i].getGenericSignature();
            sb.append(sig);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
=======
        sb.append('>');
        return sb.toString();
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        // nothing bound? mark with empty map to prevent further calls
        if (_bindings == null) {
            _bindings = Collections.emptyMap();
        }
    }
=======
    @Override public int hashCode() { return _hashCode; }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
        Class<?> raw;
        if (t instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) t;
            Type[] args = pt.getActualTypeArguments();
            if (args  != null && args.length > 0) {
                Class<?> rawType = (Class<?>) pt.getRawType();    
                TypeVariable<?>[] vars = rawType.getTypeParameters();
                if (vars.length != args.length) {
                    throw new IllegalArgumentException("Strange parametrized type (in class "+rawType.getName()+"): number of type arguments != number of type parameters ("+args.length+" vs "+vars.length+")");
                }
                for (int i = 0, len = args.length; i < len; ++i) {
                    TypeVariable<?> var = vars[i];
                    String name = var.getName();
                    if (_bindings == null) {
                        _bindings = new LinkedHashMap<String,JavaType>();
                    } else {
                        /* 24-Mar-2010, tatu: Better ensure that we do not overwrite something
                         *  collected earlier (since we descend towards super-classes):
                         */
                        if (_bindings.containsKey(name)) continue;
                    }
                    // first: add a placeholder to prevent infinite loops
                    _addPlaceholder(name);
                    // then resolve type
                    _bindings.put(name, _typeFactory._constructType(args[i], this));
                }
            }
            raw = (Class<?>)pt.getRawType();
        } else if (t instanceof Class<?>) {
            raw = (Class<?>) t;
            /* [JACKSON-677]: If this is an inner class then the generics are defined on the 
             * enclosing class so we have to check there as well.  We don't
             * need to call getEnclosingClass since anonymous classes declare 
             * generics
             */
            Class<?> decl = raw.getDeclaringClass();
            /* 08-Feb-2013, tatu: Except that if context is also super-class, we must
             *   skip it; context will be checked anyway, and we'd get StackOverflow if
             *   we went there.
             */
            if (decl != null && !decl.isAssignableFrom(raw)) {
                _resolveBindings(raw.getDeclaringClass());
            }

            /* 24-Mar-2010, tatu: Can not have true generics definitions, but can
             *   have lower bounds ("<T extends BeanBase>") in declaration itself
             */
            TypeVariable<?>[] vars = raw.getTypeParameters();
            if (vars != null && vars.length > 0) {
                JavaType[] typeParams = null;
=======
    protected JavaType[] typeParameterArray() {
        return _types;
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
                    String name = var.getName();
                    Type varType = var.getBounds()[0];
                    if (varType != null) {
                        if (_bindings == null) {
                            _bindings = new LinkedHashMap<String,JavaType>();
                        } else { // and no overwriting...
                            if (_bindings.containsKey(name)) continue;
                        }
                        _addPlaceholder(name); // to prevent infinite loops

                        if (typeParams != null && typeParams.length > i) {
                            _bindings.put(name, typeParams[i]);
                        } else {
                            _bindings.put(name, _typeFactory._constructType(varType, this));
                        }
                    }
                }
=======
    /**
     * Helper class that contains simple logic for avoiding repeated lookups via
     * {@link Class#getTypeParameters()} as that can be a performance issue for
     * some use cases (wasteful, usually one-off or not reusing mapper).
     * Partly isolated to avoid initialization for cases where no generic types are
     * used.
     */
    static class TypeParamStash {
        private final static TypeVariable<?>[] VARS_ABSTRACT_LIST = AbstractList.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_COLLECTION = Collection.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_ITERABLE = Iterable.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_LIST = List.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_ARRAY_LIST = ArrayList.class.getTypeParameters();

        private final static TypeVariable<?>[] VARS_MAP = Map.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_HASH_MAP = HashMap.class.getTypeParameters();
        private final static TypeVariable<?>[] VARS_LINKED_HASH_MAP = LinkedHashMap.class.getTypeParameters();

        public static TypeVariable<?>[] paramsFor1(Class<?> erasedType)
        {
            if (erasedType == Collection.class) {
                return VARS_COLLECTION;
            }
            if (erasedType == List.class) {
                return VARS_LIST;
            }
            if (erasedType == ArrayList.class) {
                return VARS_ARRAY_LIST;
            }
            if (erasedType == AbstractList.class) {
                return VARS_ABSTRACT_LIST;
            }
            if (erasedType == Iterable.class) {
                return VARS_ITERABLE;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java;<<<<<<< MINE
    @Override
    public String toString()
    {
        if (_bindings == null) {
            _resolve();
        }
        StringBuilder sb = new StringBuilder("[TypeBindings for ");
        if (_contextType != null) {
            sb.append(_contextType.toString());
        } else {
            sb.append(_contextClass.getName());
        }
        sb.append(": ").append(_bindings).append("]");
        return sb.toString();
    }
=======
        public static TypeVariable<?>[] paramsFor2(Class<?> erasedType)
        {
            if (erasedType == Map.class) {
                return VARS_MAP;
            }
            if (erasedType == HashMap.class) {
                return VARS_HASH_MAP;
            }
            if (erasedType == LinkedHashMap.class) {
                return VARS_LINKED_HASH_MAP;
            }
            return erasedType.getTypeParameters();
        }    
    }    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
    private final static String CLASS_NAME_DOM_NODE = "org.w3c.dom.Node";
    private final static String CLASS_NAME_DOM_DOCUMENT = "org.w3c.dom.Node";
=======
//    private final static String CLASS_NAME_DOM_NODE = "org.w3c.dom.Node";
//    private final static String CLASS_NAME_DOM_DOCUMENT = "org.w3c.dom.Document";
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        Class<?> rawType = type.getRawClass();
=======
        final Class<?> rawType = type.getRawClass();

        if ((CLASS_JAVA7_PATH != null) && CLASS_JAVA7_PATH.isAssignableFrom(rawType)) {
            return ToStringSerializer.instance;
        }
        if ((CLASS_DOM_NODE != null) && CLASS_DOM_NODE.isAssignableFrom(rawType)) {
            return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        Class<?> rawType = type.getRawClass();
=======
        final Class<?> rawType = type.getRawClass();

        if ((CLASS_JAVA7_PATH != null) && CLASS_JAVA7_PATH.isAssignableFrom(rawType)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_PATH);
        }
        if ((CLASS_DOM_NODE != null) && CLASS_DOM_NODE.isAssignableFrom(rawType)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE);
        }
        if ((CLASS_DOM_DOCUMENT != null) && CLASS_DOM_DOCUMENT.isAssignableFrom(rawType)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT);
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT);
        } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) {
            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        // first, superclasses
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
=======
            if (supertype == Object.class) {
                return false;
            }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java;<<<<<<< MINE
        // then interfaces
        for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) {
            if (hasInterfaceStartingWith(cls, prefix)) {
                return true;
            }
        }
        return false;
    }

    private boolean hasInterfaceStartingWith(Class<?> type, String prefix)
    {
        Class<?>[] interfaces = type.getInterfaces();
        for (Class<?> iface : interfaces) {
            if (iface.getName().startsWith(prefix)) {
                return true;
            }
        }
        // maybe super-interface?
        for (Class<?> iface : interfaces) {
            if (hasInterfaceStartingWith(iface, prefix)) {
                return true;
            }
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java;<<<<<<< MINE
=======
         *<p>
         * NOTE: typed as Object-to-Object, unlike {@link #_shared}, because
         * we need to be able to modify contents, and wildcard type would
         * complicate that access.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    protected final static JsonInclude.Value EMPTY_INCLUDE = JsonInclude.Value.empty();

    /**
     * @since 2.7
     */
    protected final static JsonFormat.Value EMPTY_FORMAT = JsonFormat.Value.empty();

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java;<<<<<<< MINE
=======
    /* Configuration: default settings with per-type overrides
    /**********************************************************
     */

    /**
     * Accessor for default property inclusion to use for serialization,
     * used unless overridden by per-type or per-property overrides.
     *
     * @since 2.7
     */
    public abstract JsonInclude.Value getDefaultPropertyInclusion();

    /**
     * Accessor for default property inclusion to use for serialization,
     * considering possible per-type override for given base type.
     *
     * @since 2.7
     */
    public abstract JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType);

    /**
     * Accessor for default format settings to use for serialization (and, to a degree
     * deserialization), considering baseline settings and per-type defaults
     * for given base type (if any).
     *
     * @since 2.7
     */
    public abstract JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType);
    
    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java;<<<<<<< MINE
=======
    public UnrecognizedPropertyException(JsonParser p, String msg, JsonLocation loc,
            Class<?> referringClass, String propName,
            Collection<Object> propertyIds)
    {
        super(p, msg, loc, referringClass, propName, propertyIds);
    }

    /**
     * @deprecated Since 2.7
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
    
=======

    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser}
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/InvalidFormatException.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser}
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java;<<<<<<< MINE
=======
    /**
     * @since 2.7
     */
    public IgnoredPropertyException(JsonParser p, String msg, JsonLocation loc,
            Class<?> referringClass, String propName,
            Collection<Object> propertyIds)
    {
        super(p, msg, loc, referringClass, propName, propertyIds);
    }

    /**
     * @deprecated Since 2.7
     */
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java;<<<<<<< MINE
=======
     *<p>
     * Default implementation will call obsolete method for Jackson 2.7,
     * to try to keep some level of backwards compatibility.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
 * Although default implementations are based on using annotations as the only
 * (or at least main) information source, custom implementations are not limited
 * in such a way, and in fact there is no expectation they should be. So the name
 * is bit of misnomer; this is a general configuration introspection facility.
 *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
     * @deprecated Since 2.3: use the one that takes generic {@link Annotated}
     */
    @Deprecated
    public Object findFilterId(AnnotatedClass ac) { return findFilterId((Annotated) ac); }

    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
     * Method for accessing annotated type definition that a
     * method/field can have, to be used as the type for serialization
     * instead of the runtime type.
     * Type returned (if any) needs to be widening conversion (super-type).
     * Declared return type of the method is also considered acceptable.
     *
     * @return Class to use instead of runtime type
     */
    public Class<?> findSerializationType(Annotated a) {
        return null;
    }

    /**
     * Method for finding possible widening type definition that a property
     * value can have, to define less specific key type to use for serialization.
     * It should be only be used with {@link java.util.Map} types.
     * 
     * @return Class specifying more general type to use instead of
     *   declared type, if annotation found; null if not
     */
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {
        return null;
    }

    /**
     * Method for finding possible widening type definition that a property
     * value can have, to define less specific key type to use for serialization.
     * It should be only used with structured types (arrays, collections, maps).
     * 
     * @return Class specifying more general type to use instead of
     *   declared type, if annotation found; null if not
     */
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {
        return null;
    }
    
    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
     * 
     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
     * 
     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
    // // // Forwards compatibility: added in 2.6 BUT NOT YET USED until 2.7

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
     * NOTE: introduced in 2.6 but NOT YET USED by core databind until 2.7
=======
     * Method for checking inclusion criteria for a type (Class) or property (yes, method
     * name is bit unfortunate -- not just for properties!).
     * In case of class, acts as the default for properties POJO contains; for properties
     * acts as override for class defaults and possible global defaults.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java;<<<<<<< MINE
     * Method for accessing annotated type definition that a
     * method can have, to be used as the type for serialization
     * instead of the runtime type.
     * Type must be a narrowing conversion
     * (i.e.subtype of declared type).
     * Declared return type of the method is also considered acceptable.
     *
     * @param baseType Assumed type before considering annotations
     *
     * @return Class to use for deserialization instead of declared type
     */
    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {
        return null;
    }

    /**
     * Method for accessing additional narrowing type definition that a
     * method can have, to define more specific key type to use.
     * It should be only be used with {@link java.util.Map} types.
     * 
     * @param baseKeyType Assumed key type before considering annotations
     *
     * @return Class specifying more specific type to use instead of
     *   declared type, if annotation found; null if not
     */
    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {
        return null;
    }

    /**
     * Method for accessing additional narrowing type definition that a
     * method can have, to define more specific content type to use;
     * content refers to Map values and Collection/array elements.
     * It should be only be used with Map, Collection and array types.
     * 
     * @param baseContentType Assumed content (value) type before considering annotations
     *
     * @return Class specifying more specific type to use instead of
     *   declared type, if annotation found; null if not
     */
    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {
        return null;
    }

    /**
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
     * and specifically does NOT try to find per-type format defaults to merge;
     * use {@link #findPropertyFormat} if such defaults would be useful.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
     *<p>
     * NOTE: Starting with 2.7, takes explicit {@link SerializerProvider}
     * argument to reduce the need to rely on provider visitor may or may not
     * have assigned.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
        @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java;<<<<<<< MINE
=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java;<<<<<<< MINE
=======
    /* Life-cycle, fluent factories for FormatFeature (2.7)
    /**********************************************************
     */

    /**
     * @since 2.7
     */
    public ObjectWriter with(FormatFeature feature)  {
        SerializationConfig newConfig = _config.with(feature);
        return (newConfig == _config) ? this : _new(this, newConfig);
    }

    /**
     * @since 2.7
     */
    public ObjectWriter withFeatures(FormatFeature... features) {
        SerializationConfig newConfig = _config.withFeatures(features);
        return (newConfig == _config) ? this : _new(this, newConfig);
    }

    /**
     * @since 2.7
     */
    public ObjectWriter without(FormatFeature feature) {
        SerializationConfig newConfig = _config.without(feature);
        return (newConfig == _config) ? this : _new(this, newConfig);
    }

    /**
     * @since 2.7
     */
    public ObjectWriter withoutFeatures(FormatFeature... features) {
        SerializationConfig newConfig = _config.withoutFeatures(features);
        return (newConfig == _config) ? this : _new(this, newConfig);
    }
    
    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java;<<<<<<< MINE
=======
     * Mutant factory method that allows construction of a new writer instance
     * that uses specified set of default attribute values.
     *
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======
    public final boolean canOverrideAccessModifiers() {
        return _config.canOverrideAccessModifiers();
    }

    @Override
    public final boolean isEnabled(MapperFeature feature) {
        return _config.isEnabled(feature);
    }

    @Override
    public final JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {
        return _config.getDefaultPropertyFormat(baseType);
    }
    
    @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======
        if (desc == null) {
            return "[N/A]";
        }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = 0;
        _formatWriteFeaturesToChange = 0;
        _serializationInclusion = DEFAULT_INCLUSION;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = formatFeatures;
        _formatWriteFeaturesToChange = formatFeaturesMask;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
        _formatWriteFeatures = src._formatWriteFeatures;
        _formatWriteFeaturesToChange = src._formatWriteFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7 use {@link #withPropertyInclusion} instead
     */
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    public SerializationConfig withPropertyInclusion(JsonInclude.Value incl) {
        if (_serializationInclusion.equals(incl)) {
            return this;
        }
        return new SerializationConfig(this, incl);
    }
    
    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
            g.overrideStdFeatures(newFlags, mask);
        }
        if (_formatWriteFeaturesToChange != 0) {
            g.overrideFormatFeatures(_formatWriteFeatures, _formatWriteFeaturesToChange);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
    public boolean useRootWrapping()
    {
        if (_rootName != null) { // empty String disables wrapping; non-empty enables
            return !_rootName.isEmpty();
        }
        return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);
    }

    @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java;<<<<<<< MINE
=======
    /* Configuration: default settings with per-type overrides
    /**********************************************************
     */
    
    /**
     * @deprecated Since 2.7 use {@link #getDefaultPropertyInclusion} instead
     */
    @Deprecated
    public JsonInclude.Include getSerializationInclusion()
    {
        JsonInclude.Include incl = _serializationInclusion.getValueInclusion();
        return (incl == JsonInclude.Include.USE_DEFAULTS) ? JsonInclude.Include.ALWAYS : incl;
    }

    @Override
    public JsonInclude.Value getDefaultPropertyInclusion() {
        return _serializationInclusion;
    }

    @Override
    public JsonInclude.Value getDefaultPropertyInclusion(Class<?> baseType) {
        // !!! TODO: per-type defaults
        return _serializationInclusion;
    }

    @Override
    public JsonFormat.Value getDefaultPropertyFormat(Class<?> baseType) {
        // !!! TODO: per-type defaults
        return EMPTY_FORMAT;
    }
    
    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
    /**
     * Accessor for the "blueprint" (or, factory) instance, from which instances
     * are created by calling {@link DefaultSerializerProvider#createInstance}.
     * Note that returned instance can not be directly used as it is not properly
     * configured: to get a properly configured instance to call, use
     * {@link #getSerializerProviderInstance()} instead.
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
     * Convenience method, equivalent in function to:
     *<pre>
     *   readerFor(valueType).readValues(p);
     *</pre>
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
     *    (which under the hood calls {@link #acceptJsonFormatVisitor(JavaType, JsonFormatVisitorWrapper)})
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7, not used internally any more
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
=======
     *
     * @since 2.6
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java;<<<<<<< MINE
=======
            // 21-Dec-2015, tatu: Should we also cache using raw key?
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
=======
     *
     * @deprecated Since 2.7, use {@link #resolveType(java.lang.reflect.Type)} instead.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
     * Mutant factory method that may be called on structured types
     * that have a so-called content type (element of arrays, value type
     * of Maps, referenced type of referential types),
     * and will construct a new instance that is identical to
     * this instance, except that it has specified content type, instead of current
     * one. If content type is already set to given type, <code>this</code> is returned.
     * If type does not have a content type (which is the case with
     * <code>SimpleType</code>), {@link IllegalArgumentException}
     * will be thrown.
     * 
     * @return Newly created type instance
     *
     * @since 2.7
     */
    public abstract JavaType withContentType(JavaType contentType);

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
     * Method that can be called to do a "narrowing" conversions; that is,
     * to return a type with a raw class that is assignable to the raw
     * class of this type. If this is not possible, an
     * {@link IllegalArgumentException} is thrown.
     * If class is same as the current raw class, instance itself is
     * returned.
=======
     * Mutant factory method that will try to create and return a sub-type instance
     * for known parameterized types; for other types will return `null` to indicate
     * that no just refinement makes necessary sense, without trying to detect
     * special status through implemented interfaces.
     *
     * @since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
    /**
     * Method that can be called to do a "widening" conversions; that is,
     * to return a type with a raw class that could be assigned from this
     * type.
     * If such conversion is not possible, an
     * {@link IllegalArgumentException} is thrown.
     * If class is same as the current raw class, instance itself is
     * returned.
     */
    public JavaType widenBy(Class<?> superclass) {
        // First: if same raw class, just return this instance
        if (superclass == _class) { return this; }
        // Otherwise, ensure compatibility
        _assertSubclass(_class, superclass);
        return _widen(superclass);
    }

=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JavaType.java;<<<<<<< MINE
=======
     * @since 2.7
     */
    public Object getContentValueHandler() { return null; }

    /**
     * @since 2.7
     */
    public Object getContentTypeHandler() { return null; }    

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = 0;
        _formatReadFeaturesToChange = 0;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = formatFeatures;
        _formatReadFeaturesToChange = formatFeatureMask;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    /**
     * @since 2.3
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
    /**
     * @since 2.1
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
        _formatReadFeatures = src._formatReadFeatures;
        _formatReadFeaturesToChange = src._formatReadFeaturesToChange;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java;<<<<<<< MINE
=======
                    newSet, newMask,
                    _formatReadFeatures, _formatReadFeaturesToChange);
    }

    /*
    /**********************************************************
    /* Life-cycle, JsonParser.FormatFeature-based factory methods
    /**********************************************************
     */

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features enabled.
     *
     * @since 2.7
     */
    public DeserializationConfig with(FormatFeature feature)
    {
        int newSet = _formatReadFeatures | feature.getMask();
        int newMask = _formatReadFeaturesToChange | feature.getMask();
        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :
            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,
                    _parserFeatures, _parserFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features enabled.
     *
     * @since 2.7
     */
    public DeserializationConfig withFeatures(FormatFeature... features)
    {
        int newSet = _formatReadFeatures;
        int newMask = _formatReadFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet |= mask;
            newMask |= mask;
        }
        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :
            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,
                    _parserFeatures, _parserFeaturesToChange,
                    newSet, newMask);
    }
    
    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified feature disabled.
     *
     * @since 2.7
     */
    public DeserializationConfig without(FormatFeature feature)
    {
        int newSet = _formatReadFeatures & ~feature.getMask();
        int newMask = _formatReadFeaturesToChange | feature.getMask();
        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :
            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,
                    _parserFeatures, _parserFeaturesToChange,
                    newSet, newMask);
    }

    /**
     * Fluent factory method that will construct and return a new configuration
     * object instance with specified features disabled.
     *
     * @since 2.7
     */
    public DeserializationConfig withoutFeatures(FormatFeature... features)
    {
        int newSet = _formatReadFeatures;
        int newMask = _formatReadFeaturesToChange;
        for (FormatFeature f : features) {
            int mask = f.getMask();
            newSet &= ~mask;
            newMask |= mask;
        }
        return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this :
            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,
                    _parserFeatures, _parserFeaturesToChange,
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
=======
     * Feature that determines that forces call to
     * {@link java.lang.reflect.AccessibleObject#setAccessible} even for
     * <code>public</code> accessors -- that is, even if no such call is
     * needed from functionality perspective -- if call is allowed
     * (that is, {@link #CAN_OVERRIDE_ACCESS_MODIFIERS} is set to true).
     * The main reason to enable this feature is possible performance
     * improvement as JDK does not have to perform access checks; these
     * checks are otherwise made for all accessors, including public ones,
     * and may result in slower Reflection calls. Exact impact (if any)
     * depends on Java platform (Java SE, Android) as well as JDK version.
     *<p>
     * Feature is enabled by default, for legacy reasons (it was the behavior
     * until 2.6)
     *
     * @since 2.7
     */
    OVERRIDE_PUBLIC_ACCESS_MODIFIERS(true),

    /**
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java;<<<<<<< MINE
=======
    /**
     * Feature that when enabled will allow explicitly named properties (i.e., fields or methods
     * annotated with {@link com.fasterxml.jackson.annotation.JsonProperty}("explicitName")) to
     * be re-named by a {@link PropertyNamingStrategy}, if one is configured.
     * <p>
     * Feature is disabled by default.
     *
     * @since 2.7
     */
    ALLOW_EXPLICIT_PROPERTY_RENAMING(false),

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
=======
     * Naming convention used in languages like Pascal, where words are capitalized
     * and no separator is used between words.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
=======
     * Naming convention used in Java, where words other than first are capitalized
     * and no separator is used between words. Since this is the native Java naming convention,
     * naming strategy will not do any transformation between names in data (JSON) and
     * POJOS.
     *
     * @since 2.7 (was formerly called {@link #PASCAL_CASE_TO_CAMEL_CASE})
     */
    public static final PropertyNamingStrategy LOWER_CAMEL_CASE = new PropertyNamingStrategy();
    
    /**
     * Naming convention in which all words of the logical name are in lower case, and
     * no separator is used between words.
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java;<<<<<<< MINE
=======
     *
     * @since 2.7 (was previously called }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
    /* Life-cycle, fluent factory methods for FormatFeature (2.7)
    /**********************************************************
     */

    /**
     * Method for constructing a new reader instance that is configured
     * with specified feature enabled.
     *
     * @since 2.7
     */
    public ObjectReader with(FormatFeature feature) {
        return _with(_config.with(feature));
    }

    /**
     * Method for constructing a new reader instance that is configured
     * with specified features enabled.
     *
     * @since 2.7
     */
    public ObjectReader withFeatures(FormatFeature... features) {
        return _with(_config.withFeatures(features));
    }    

    /**
     * Method for constructing a new reader instance that is configured
     * with specified feature disabled.
     *
     * @since 2.7
     */
    public ObjectReader without(FormatFeature feature) {
        return _with(_config.without(feature)); 
    }

    /**
     * Method for constructing a new reader instance that is configured
     * with specified features disabled.
     *
     * @since 2.7
     */
    public ObjectReader withoutFeatures(FormatFeature... features) {
        return _with(_config.withoutFeatures(features));
    }
    
    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
    /**
     * Mutant factory method that will construct a new instance that has
     * specified underlying {@link DeserializationConfig}.
     *<p>
     * NOTE: use of this method is not recommended, as there are many other
     * re-configuration methods available.
     */
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
     * Method reads a sequence of Objects from parser stream.
     * Sequence can be either root-level "unwrapped" sequence (without surrounding
     * JSON array), or a sequence contained in a JSON Array.
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
     * the first element, OR not point to any token (in which case it is advanced
     * to the next token). This means, specifically, that for wrapped sequences,
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
     * Method reads a sequence of Objects from parser stream.
     * Sequence can be either root-level "unwrapped" sequence (without surrounding
     * JSON array), or a sequence contained in a JSON Array.
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
     * the first element, OR not point to any token (in which case it is advanced
     * to the next token). This means, specifically, that for wrapped sequences,
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
     * Method reads a sequence of Objects from parser stream.
     * Sequence can be either root-level "unwrapped" sequence (without surrounding
     * JSON array), or a sequence contained in a JSON Array.
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
     * the first element, OR not point to any token (in which case it is advanced
     * to the next token). This means, specifically, that for wrapped sequences,
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java;<<<<<<< MINE
=======
     * Method reads a sequence of Objects from parser stream.
     * Sequence can be either root-level "unwrapped" sequence (without surrounding
     * JSON array), or a sequence contained in a JSON Array.
     * In either case {@link JsonParser} <b>MUST</b> point to the first token of
     * the first element, OR not point to any token (in which case it is advanced
     * to the next token). This means, specifically, that for wrapped sequences,
     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
     * contains values to read) but rather to the token following it which is the first
     * token of the first value to read.
     *<p>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======
    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser} instead
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======

    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser} instead
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======

    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser} instead
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======

    /**
     * @deprecated Since 2.7 Use variant that takes {@link JsonParser} instead
     */
    @Deprecated // since 2.7
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java;<<<<<<< MINE
=======
    @SuppressWarnings("resource")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/main/java/com/fasterxml/jackson/databind/JsonNode.java;<<<<<<< MINE
=======
     * Method that will produce developer-readable representation of the
     * node; which may <b>or may not</b> be as valid JSON.
     * If you want valid JSON output (or output formatted using one of
     * other Jackson supported data formats) make sure to use
     * {@link ObjectMapper} or {@link ObjectWriter} to serialize an
     * instance, for example:
     *<pre>
     *   String json = objectMapper.writeValueAsString(rootNode);
     *</pre>
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java;<<<<<<< MINE
    
    // for [JACKSON-694]
=======

>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
     * CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES was added in Jackson 1.9, 
     * as per [JACKSON-598].
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
    @Test
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
     * PASCAL_CASE_TO_CAMEL_CASE was added in Jackson 2.1.0, 
     * as per [JACKSON-63].
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
=======
    /*
    /**********************************************************
    /* Test methods for LOWER_CASE
    /**********************************************************
     */
    
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestNamingStrategyStd.java;<<<<<<< MINE
        ObjectMapper m = new ObjectMapper();
        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
=======
        ObjectMapper m = new ObjectMapper()
            .setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java;<<<<<<< MINE
    }    

    /**
     * Tests to ensure that {@link JsonIgnoreType} is detected as expected
     * by the standard introspector.
     * 
     * @since 1.7
     */
    public void testIgnoredType() throws Exception
    {
        JacksonAnnotationIntrospector ai = new JacksonAnnotationIntrospector();
        AnnotatedClass ac = AnnotatedClass.construct(IgnoredType.class, ai, null);
        assertEquals(Boolean.TRUE, ai.isIgnorableType(ac));

        // also, should inherit as expected
        ac = AnnotatedClass.construct(IgnoredSubType.class, ai, null);
        assertEquals(Boolean.TRUE, ai.isIgnorableType(ac));
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java;<<<<<<< MINE
=======
    // for [jackson-databind#1023]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/DateSerializationTest.java;<<<<<<< MINE
=======

        // and with default (ISO8601) format (databind#1109)
        json = mapper.writeValueAsString(new DateAsDefaultStringBean(0L));
        assertEquals("{\"date\":\"1970-01-01T00:00:00.000+0000\"}", json);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // Test [JACKSON-220]
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    // Test [JACKSON-314]
    public void testMapNullSerialization() throws IOException
    {
        ObjectMapper m = new ObjectMapper();
        Map<String,String> map = new HashMap<String,String>();
        map.put("a", null);
        // by default, should output null-valued entries:
        assertEquals("{\"a\":null}", m.writeValueAsString(map));
        // but not if explicitly asked not to (note: config value is dynamic here)
        m.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);
        assertEquals("{}", m.writeValueAsString(map));
    }

    // [JACKSON-499], problems with map entries, values
=======
    // problems with map entries, values
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java;<<<<<<< MINE
    }        
    
    // [databind#527]
    public void testNonNullValueMap() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoNullsStringMap()
            .add("a", "foo")
            .add("b", null)
            .add("c", "bar"));
        assertEquals(aposToQuotes("{'a':'foo','c':'bar'}"), json);
    }

    // [databind#527]
    public void testNonEmptyValueMap() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoEmptyStringsMap()
            .add("a", "foo")
            .add("b", "bar")
            .add("c", ""));
        assertEquals(aposToQuotes("{'a':'foo','b':'bar'}"), json);
    }

    public void testNonAbsentValueMap() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoAbsentStringMap()
            .add("a", "foo")
            .add("b", null));
        assertEquals(aposToQuotes("{'a':'foo'}"), json);
    }
    
    // [databind#527]
    public void testNonNullValueMapViaProp() throws IOException
    {
        String json = MAPPER.writeValueAsString(new NoNullValuesMapContainer()
            .add("a", "foo")
            .add("b", null)
            .add("c", "bar"));
        assertEquals(aposToQuotes("{'stuff':{'a':'foo','c':'bar'}}"), json);
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======
        ObjectNode nestedObject1 = MAPPER.createObjectNode();
        nestedObject1.put("value", 6);
        ArrayNode nestedArray1 = MAPPER.createArrayNode();
        nestedArray1.add(7);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======
        root1.set("nested_object", nestedObject1);
        root1.set("nested_array", nestedArray1);

        ObjectNode nestedObject2 = MAPPER.createObjectNode();
        nestedObject2.put("value", 6.9);
        ArrayNode nestedArray2 = MAPPER.createArrayNode();
        nestedArray2.add(7.0);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======
        root2.set("nested_object", nestedObject2);
        root2.set("nested_array", nestedArray2);
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java;<<<<<<< MINE
=======
                if (o1 instanceof ContainerNode || o2 instanceof ContainerNode) {
                    fail("container nodes should be traversed, comparator should not be invoked");
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/TestFieldDeserialization.java;<<<<<<< MINE
=======
        @SuppressWarnings("hiding")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE

=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/deser/ExceptionFromCustomEnumKeyDeserializerTest.java;<<<<<<< MINE
        /**
         * Register a Jackson module for Rosette's top-level enums an {@link ObjectMapper}.
         * @param mapper the mapper.
         * @return the same mapper, for convenience.
         */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java;<<<<<<< MINE
        param = ((CollectionLikeType) type).getContentType();
=======
        JavaType param = ((CollectionLikeType) type).getContentType();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java;<<<<<<< MINE
    // [Issue-14]
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE

        /* both narrow and widen just return type itself (exact, not just
         * equal)
         * (also note that widen/narrow wouldn't work on basic simple
         * class type otherwise)
         */
        assertSame(baseType, baseType.narrowBy(BaseType.class));
        assertSame(baseType, baseType.widenBy(BaseType.class));

        // Also: no narrowing for simple types (but should there be?)
        try {
            baseType.narrowBy(SubType.class);
        } catch (IllegalArgumentException e) {
            verifyException(e, "should never be called");
        }

        // Also, let's try assigning bogus handler
        /*
        baseType.setValueHandler("xyz"); // untyped
        assertEquals("xyz", baseType.getValueHandler());
        // illegal to re-set
        try {
            baseType.setValueHandler("foobar");
            fail("Shouldn't allow re-setting value handler");
        } catch (IllegalStateException iae) {
            verifyException(iae, "Trying to reset");
        }
        */
    }

    public void testMapType()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
        JavaType keyT = tf.constructType(String.class);
        JavaType baseT = tf.constructType(BaseType.class);

        MapType mapT = MapType.construct(Map.class, keyT, baseT);
        assertNotNull(mapT);
        assertTrue(mapT.isContainerType());

        // NOPs:
        assertSame(mapT, mapT.narrowContentsBy(BaseType.class));
        assertSame(mapT, mapT.narrowKey(String.class));

        assertTrue(mapT.equals(mapT));
        assertFalse(mapT.equals(null));
        assertFalse(mapT.equals("xyz"));

        MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT);
        assertFalse(mapT.equals(mapT2));

        // Also, must use map type constructor, not simple...
        try {
            SimpleType.construct(HashMap.class);
        } catch (IllegalArgumentException e) {
            verifyException(e, "for a Map");
        }
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java;<<<<<<< MINE
        // NOPs:
        assertSame(arrayT, arrayT.narrowContentsBy(String.class));

=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
        t = tf.constructType(new TypeReference<MyLongList<Integer>>() {});
=======
        JavaType t = tf.constructType(new TypeReference<MyLongList<Integer>>() {});
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java;<<<<<<< MINE
=======
    }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
    @SuppressWarnings("deprecation")
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
        // Ok, first: let's test what happens when we pass 'raw' Collection:
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
    
    public void testMaps()
    {
        TypeFactory tf = newTypeFactory();

        // Ok, first: let's test what happens when we pass 'raw' Map:
        JavaType t = tf.constructType(HashMap.class);
        assertEquals(MapType.class, t.getClass());
        assertSame(HashMap.class, t.getRawClass());

        // Then explicit construction
        t = tf.constructMapType(TreeMap.class, String.class, Integer.class);
        assertEquals(MapType.class, t.getClass());
        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());
        assertSame(Integer.class, ((MapType) t).getContentType().getRawClass());

        // And then with TypeReference
        t = tf.constructType(new TypeReference<HashMap<String,Integer>>() { });
        assertEquals(MapType.class, t.getClass());
        assertSame(HashMap.class, t.getRawClass());
        MapType mt = (MapType) t;
        assertEquals(tf.constructType(String.class), mt.getKeyType());
        assertEquals(tf.constructType(Integer.class), mt.getContentType());

        t = tf.constructType(new TypeReference<LongValuedMap<Boolean>>() { });
        assertEquals(MapType.class, t.getClass());
        assertSame(LongValuedMap.class, t.getRawClass());
        mt = (MapType) t;
        assertEquals(tf.constructType(Boolean.class), mt.getKeyType());
        assertEquals(tf.constructType(Long.class), mt.getContentType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    public void testMapTypesSimple()
    {
        TypeFactory tf = TypeFactory.defaultInstance();
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
=======
        type = tf.constructRawCollectionLikeType(CollectionLike.class); // must have type vars
        assertTrue(type.isCollectionLikeType());
        assertEquals(TypeFactory.unknownType(), type.getContentType());
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java;<<<<<<< MINE
    /**
     * Test for [JACKSON-454]
     */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
=======

        // [databind#978]: Different answer if empty Beans ARE allowed
        m = new ObjectMapper();
        m.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
        assertTrue(m.canSerialize(Object.class));
        assertTrue(MAPPER.writer().without(SerializationFeature.FAIL_ON_EMPTY_BEANS)
                .canSerialize(Object.class));
        assertFalse(MAPPER.writer().with(SerializationFeature.FAIL_ON_EMPTY_BEANS)
                .canSerialize(Object.class));
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
        /*
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/src/test/java/com/fasterxml/jackson/databind/ObjectMapperTest.java;<<<<<<< MINE
                */
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/attic/MappingIteratorDeserializer.java;<<<<<<< MINE
System.err.println("DEBUG: token/0 == "+p.getCurrentToken());
        
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b8e2580_1317d3e/rev_b8e2580-1317d3e/attic/MappingIteratorDeserializer.java;<<<<<<< MINE

System.err.println("DEBUG: token/1 == "+p.getCurrentToken());
        
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_058bbdf_4c59723/rev_058bbdf-4c59723/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java;<<<<<<< MINE
    @SuppressWarnings("incomplete-switch")
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_c4ecc55_f6fbed5/rev_c4ecc55-f6fbed5/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java;<<<<<<< MINE
=======
                // [JACKSON-831]: may have property AND be used as external type id:
                if (t.isScalarValue()) {
                    ext.handleTypePropertyValue(p, ctxt, propName, bean);
                }
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_847fd82_ea30c7b/rev_847fd82-ea30c7b/src/test/java/com/fasterxml/jackson/databind/filter/JsonIncludeTest.java;<<<<<<< MINE
    static class Issue1351Bean
    {
        public final String first;
        public final double second;

        public Issue1351Bean(String first, double second) {
            this.first = first;
            this.second = second;
        }
    }

    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
    static abstract class Issue1351NonBeanParent
    {
        protected static final String NUM_VAR = "num";
        protected final int num;

        @com.fasterxml.jackson.annotation.JsonCreator
        public Issue1351NonBeanParent(@com.fasterxml.jackson.annotation.JsonProperty(NUM_VAR) int num) {
            this.num = num;
        }

        @com.fasterxml.jackson.annotation.JsonProperty(NUM_VAR)
        public int getNum() {
            return num;
        }
    }

    static class Issue1351NonBean extends Issue1351NonBeanParent {
        private String str;

        @com.fasterxml.jackson.annotation.JsonCreator
        public Issue1351NonBean(@com.fasterxml.jackson.annotation.JsonProperty(NUM_VAR) int num) {
            super(num);
        }

        public String getStr() {
            return str;
        }

        public void setStr(String str) {
            this.str = str;
        }
    }
    
=======
    // [databind#1351], [databind#1417]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b6d330f_6362e24/rev_b6d330f-6362e24/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java;<<<<<<< MINE
=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b6d330f_6362e24/rev_b6d330f-6362e24/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java;<<<<<<< MINE
=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_b6d330f_6362e24/rev_b6d330f-6362e24/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java;<<<<<<< MINE
=======
        @Override
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_179088e_9257bd6/rev_179088e-9257bd6/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java;<<<<<<< MINE
=======
    // [databind#142]
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_fc74771_8de9cef/rev_fc74771-8de9cef/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java;<<<<<<< MINE
    // need to override to ensure both get fixed
=======
    @Override
    public ManagedReferenceProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        return new ManagedReferenceProperty(this, deser);
    }
 
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
        AnnotatedMethodMap memberMethods = new AnnotatedMethodMap();
=======
        _memberMethods = _resolveMemberMethods();
    }

    private AnnotatedMethodMap _resolveMemberMethods()
    {
        AnnotatedMethodMap memberMethods = new AnnotatedMethodMap();
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_93a0b9b_32001a6/rev_93a0b9b-32001a6/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java;<<<<<<< MINE
=======
        return memberMethods;
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_8ca9c1c_04c777f/rev_8ca9c1c-04c777f/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java;<<<<<<< MINE
=======
    /* Deprecated exception factory methods
    /**********************************************************
     */

    /**
     * @since 2.5
     *
     * @deprecated Since 2.8 use {@link #handleUnknownTypeId} instead
     */
    @Deprecated
    public JsonMappingException unknownTypeException(JavaType type, String id,
            String extraDesc)
    {
        String msg = String.format("Could not resolve type id '%s' into a subtype of %s",
                id, type);
        msg = _colonConcat(msg, extraDesc);
        return MismatchedInputException.from(_parser, type, msg);
    }

    /**
     * Helper method for constructing exception to indicate that end-of-input was
     * reached while still expecting more tokens to deserialize value of specified type.
     *
     * @deprecated Since 2.8; currently no way to catch EOF at databind level
     */
    @Deprecated
    public JsonMappingException endOfInputException(Class<?> instClass) {
        return MismatchedInputException.from(_parser, instClass,
                "Unexpected end-of-input when trying to deserialize a "+instClass.getName());
    }

    /*
    /**********************************************************
    /* Deprecated methods for constructing, throwing non-specific
    /* JsonMappingExceptions: as of 2.9, should use more specific
    /* ones.
    /**********************************************************
     */
    
    /**
     * Fallback method that may be called if no other <code>reportXxx</code>
     * is applicable -- but only in that case.
     *
     * @since 2.8
     * 
     * @deprecated Since 2.9: use a more specific method, or {@link #reportBadDefinition(JavaType, String)},
     *    or {@link #reportInputMismatch} instead
     */
    @Deprecated // since 2.9
    public void reportMappingException(String msg, Object... msgArgs)
        throws JsonMappingException
    {
        throw JsonMappingException.from(getParser(), _format(msg, msgArgs));
    }

    /**
     * Helper method for constructing generic mapping exception with specified
     * message and current location information.
     * Note that application code should almost always call
     * one of <code>handleXxx</code> methods, or {@link #reportMappingException(String, Object...)}
     * instead.
     * 
     * @since 2.6
     * 
     * @deprecated Since 2.9 use more specific error reporting methods instead
     */
    @Deprecated
    public JsonMappingException mappingException(String message) {
        return JsonMappingException.from(getParser(), message);
    }

    /**
     * Helper method for constructing generic mapping exception with specified
     * message and current location information
     * Note that application code should almost always call
     * one of <code>handleXxx</code> methods, or {@link #reportMappingException(String, Object...)}
     * instead.
     * 
     * @since 2.6
     *
     * @deprecated Since 2.9 use more specific error reporting methods instead
     */
    @Deprecated
    public JsonMappingException mappingException(String msg, Object... msgArgs) {
        return JsonMappingException.from(getParser(), _format(msg, msgArgs));
    }

    /**
     * Helper method for constructing generic mapping exception for specified type
     * 
     * @deprecated Since 2.8 use {@link #handleUnexpectedToken(Class, JsonParser)} instead
     */
    @Deprecated
    public JsonMappingException mappingException(Class<?> targetClass) {
        return mappingException(targetClass, _parser.getCurrentToken());
    }

    /**
     * @deprecated Since 2.8 use {@link #handleUnexpectedToken(Class, JsonParser)} instead
     */
    @Deprecated
    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) {
        return JsonMappingException.from(_parser,
                String.format("Cannot deserialize instance of %s out of %s token",
                        ClassUtil.nameOf(targetClass), token));
    }

    /*
    /**********************************************************
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f1b16a8_cab130e/rev_f1b16a8-cab130e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
        /*
=======
>>>>>>> YOURS
/home/ramdisk/experiment1/projects/jackson-databind/revisions/rev_f1b16a8_cab130e/rev_f1b16a8-cab130e/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java;<<<<<<< MINE
    }

    public void testTypeGeneralization()
    {
        TypeFactory tf = newTypeFactory();
        MapType t = tf.constructMapType(HashMap.class, String.class, Long.class);
        JavaType superT = tf.constructGeneralizedType(t, Map.class);
        assertEquals(String.class, superT.getKeyType().getRawClass());
        assertEquals(Long.class, superT.getContentType().getRawClass());

        assertSame(t, tf.constructGeneralizedType(t, HashMap.class));

        // plus check there is super/sub relationship
        try {
            tf.constructGeneralizedType(t, TreeMap.class);
            fail("Should not pass");
        } catch (IllegalArgumentException e) {
            verifyException(e, "not a super-type of");
        }
=======
>>>>>>> YOURS
