/home/ramdisk/experiment2/projects/jmxtrans/revisions/rev_1a750dd_4d726a9/rev_1a750dd-4d726a9/src/com/googlecode/jmxtrans/model/output/TCollectorUDPWriter.java;<<<<<<< MINE
package com.googlecode.jmxtrans.model.output;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.io.IOException;

import com.googlecode.jmxtrans.util.LifecycleException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * {@link com.googlecode.jmxtrans.OutputWriter} for the <a href="https://github.com/OpenTSDB/tcollector/blob/master/collectors/0/udp_bridge.py">TCollector udp_bridge</a>.
 * Largely based on StatsDWriter and OpenTSDBWriter
 *
 * @author kieren
 */
public class TCollectorUDPWriter extends OpenTSDBGenericWriter {
    private static final Logger log = LoggerFactory.getLogger(TCollectorUDPWriter.class);

    protected SocketAddress     address;
    protected Socket            socket;
    protected DataOutputStream  out;

    protected DatagramChannel   channel;
    protected ByteBuffer        sendBuffer;

    /**
     * Prepare for sending metrics.
     */
    @Override
    protected void  prepareSender() throws LifecycleException {
        try {
            channel = DatagramChannel.open();
            setBufferSize((short) 1500);

            this.address = new InetSocketAddress(this.host, this.port);
            tagName = this.getStringSetting("tagName", "");
        } catch(IOException e) {
            log.error("error opening socket to TCollector", e);
            throw new LifecycleException(e);
        }
    }

    /**
     * Shutdown the sender as it will no longer be used to send metrics.
     */
    @Override
    protected void  shutdownSender() throws LifecycleException {
    }

    /**
     * Start the output for the results of a Query to OpenTSDB.
     */
    @Override
    protected void  startOutput() throws IOException {
        try {
            this.out = new DataOutputStream(socket.getOutputStream());
        } catch (IOException e) {
            log.error("error getting the output stream", e);
            throw e;
        }
    }

    /**
     * Send a single metric to the server.
     *
     * @param   metricLine - the line containing the metric name, value, and tags for a single metric; excludes the
     *          "put" keyword expected by OpenTSDB and the trailing newline character.
     */
    @Override
    protected void  sendOutput(String metricLine) throws IOException {
        try {
            this.out.writeBytes("put " + metricLine + "\n"); 
        } catch (IOException e) {
            log.error("error writing result to the output stream", e);
            throw e;
        }
    }

    /**
     * Finish the output for a single Query, flushing all data to the server and logging the server's response.
     */
    @Override
    protected void  finishOutput() throws IOException {
        try {
            this.out.flush();
        } catch (IOException e) {
            log.error("flush failed");
            throw e;
        }

            // Read and log the response from the server for diagnostic purposes.

        InputStreamReader socketInputStream = new InputStreamReader(socket.getInputStream());
        BufferedReader bufferedSocketInputStream = new BufferedReader(socketInputStream);
        String line;
        while (socketInputStream.ready() && (line = bufferedSocketInputStream.readLine()) != null) {
            log.warn("OpenTSDB says: " + line); 
        }
    }

    public synchronized void setBufferSize(short packetBufferSize) {
        if(sendBuffer != null) {
            flush();
        }
        sendBuffer = ByteBuffer.allocate(packetBufferSize);
    }

    protected void  doSend(String stat) {
        try {
            final byte[] data = stat.getBytes("utf-8");

            // If we're going to go past the threshold of the buffer then flush.
            // the +1 is for the potential '\n' in multi_metrics below
            if (sendBuffer.remaining() < (data.length + 1)) {
                flush();
            }

            if (sendBuffer.position() > 0) { // multiple metrics are separated by '\n'
                sendBuffer.put((byte) '\n');
            }

            sendBuffer.put(data); // append the data

            flush();
        } catch (IOException e) {
            log.error("failed to send metrics to TCollector", e);
        }
    }

    public boolean  flush() {
        try {
            final int sizeOfBuffer = sendBuffer.position();

            if (sizeOfBuffer <= 0) {
                return false;
            } // empty buffer

            // send and reset the buffer
            sendBuffer.flip();
            final int nbSentBytes = channel.send(sendBuffer, this.address);
            sendBuffer.limit(sendBuffer.capacity());
            sendBuffer.rewind();

            if (sizeOfBuffer == nbSentBytes) {
                return true;
            } else {
                return false;
            }

        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }
}=======
package com.googlecode.jmxtrans.model.output;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.Socket;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.io.IOException;

import com.googlecode.jmxtrans.util.LifecycleException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * {@link com.googlecode.jmxtrans.OutputWriter} for the <a href="https://github.com/OpenTSDB/tcollector/blob/master/collectors/0/udp_bridge.py">TCollector udp_bridge</a>.
 * Largely based on StatsDWriter and OpenTSDBWriter
 *
 * @author Kieren Hynd
 * @author Arthur Naseef
 */
public class TCollectorUDPWriter extends OpenTSDBGenericWriter {
    private static final Logger log = LoggerFactory.getLogger(TCollectorUDPWriter.class);

    protected SocketAddress     address;
    protected DatagramSocket    dgSocket;
    protected ByteBuffer        sendBuffer;

    /**
     * Do not add the hostname tag "host" with the name of the host by default since tcollector normally adds the
     * hostname.
     */
    @Override
    protected boolean   getAddHostnameTagDefault() {
        return  false;
    }

    /**
     * Setup at start of the writer.
     */
    @Override
    public void start() throws LifecycleException {
        super.start();

        try {
            this.dgSocket = new DatagramSocket();
            this.address = new InetSocketAddress(this.host, this.port);
        } catch ( SocketException sockExc ) {
            log.error("failed to create a datagram socket", sockExc);
            throw   new LifecycleException(sockExc);
        }
    }

    /**
     * Send a single metric to the server.
     *
     * @param   metricLine - the line containing the metric name, value, and tags for a single metric; excludes the
     *          "put" keyword expected by OpenTSDB and the trailing newline character.
     */
    @Override
    protected void  sendOutput (String metricLine) throws IOException {
        DatagramPacket  packet;
        byte[]          data;
        String          formattedLine;

        formattedLine = metricLine + "\n";

        data = formattedLine.getBytes("UTF-8");
        packet = new DatagramPacket(data, 0, data.length, this.address);

        this.dgSocket.send(packet);
    }

    /**
     * Finish the output for a single Query, flushing all data to the server and logging the server's response.
     */
    @Override
    protected void  finishOutput() throws IOException {
    }
}>>>>>>> YOURS
/home/ramdisk/experiment2/projects/jmxtrans/revisions/rev_1a750dd_4d726a9/rev_1a750dd-4d726a9/src/com/googlecode/jmxtrans/model/output/OpenTSDBWriter.java;<<<<<<< MINE
public class OpenTSDBWriter extends BaseOutputWriter {
=======

public class OpenTSDBWriter extends OpenTSDBGenericWriter {
>>>>>>> YOURS
/home/ramdisk/experiment2/projects/jmxtrans/revisions/rev_1a750dd_4d726a9/rev_1a750dd-4d726a9/src/com/googlecode/jmxtrans/model/output/OpenTSDBGenericWriter.java;<<<<<<< MINE
package com.googlecode.jmxtrans.model.output;

import com.googlecode.jmxtrans.model.Query;
import com.googlecode.jmxtrans.model.Result;
import com.googlecode.jmxtrans.util.BaseOutputWriter;
import com.googlecode.jmxtrans.util.ValidationException;
import com.googlecode.jmxtrans.util.JmxUtils;
import com.googlecode.jmxtrans.util.LifecycleException;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.io.IOException;

/**
 * Originally written by Balazs Kossovics <bko@witbe.net>.  Common base class for OpenTSDBWriter and TCollectorWriter.
 * Date: 4/4/13
 * Time: 6:00 PM
 */
public abstract class OpenTSDBGenericWriter extends BaseOutputWriter {
    private static final Logger log = LoggerFactory.getLogger(OpenTSDBGenericWriter.class);

    protected String host;
    protected Integer port;
    protected Map<String, String> tags;
    protected String tagName;

    /**
     * Prepare for sending metrics.
     */
    protected abstract void prepareSender() throws LifecycleException;

    /**
     * Shutdown the sender.
     */
    protected abstract void shutdownSender() throws LifecycleException;

    /**
     * Subcall responsibility: called at the start of a set of results to send.
     */
    protected abstract void startOutput() throws IOException;

    /**
     * Subcall responsibility: method to perform the actual output for the given metric line.
     *
     * @param   metricLine - the line containing the metric name, value, and tags for a single metric; excludes the
     *          "put" keyword expected by OpenTSDB and the trailing newline character.
     */
    protected abstract void sendOutput(String metricLine) throws IOException;

    /**
     * Subcall responsibility: called at the start of a set of results to send.
     */
    protected abstract void finishOutput() throws IOException;


    /**
     * Add tags to the given result string, including a "host" tag with the name of the server and all of the tags
     * defined in the "settings" entry in the configuration file within the "tag" element.
     *
     * @param   resultString - the string containing the metric name, timestamp, value, and possibly other content.
     */
    String addTags(String resultString) throws UnknownHostException {
        resultString = addTag(resultString, "host", java.net.InetAddress.getLocalHost().getHostName());
        if (tags != null)
            for (Map.Entry<String, String> tagEntry : tags.entrySet()) {
                resultString = addTag(resultString, tagEntry.getKey(), tagEntry.getValue());
            }
        return resultString;
    }

    /**
     * Add one tag, with the provided name and value, to the given result string.
     *
     * @param   resultString - the string containing the metric name, timestamp, value, and possibly other content.
     * @return  String - the new result string with the tag appended.
     */
    String addTag(String resultString, String tagName, String tagValue) {

        String tagFormat = " %s=%s";
        resultString += String.format(tagFormat, JmxUtils.cleanupStr(tagName), JmxUtils.cleanupStr(tagValue));
        return resultString;
    }

    /**
     * Format the result string given the class name and attribute name of the source value, the timestamp, and the
     * value.
     *
     * @param   className - the name of the class of the MBean from which the value was sourced.
     * @param   attributeName - the name of the attribute of the MBean from which the value was sourced.  For complex
     *                          types (such as CompositeData), the attribute name may describe a hierarchy.
     * @param   epoch - the timestamp of the metric.
     * @param   value - value of the attribute to use as the metric value.
     * @return  String - the formatted result string.
     */
    String getResultString(String className, String attributeName, long epoch, Object value) {
        String resultStringFormat = "%s.%s %d %s";
        return String.format(resultStringFormat, className, attributeName, epoch, value);
    }

    /**
     * Format the result string given the class name and attribute name of the source value, the timestamp, the value,
     * a tagname, and a tag value.
     *
     * @param   className - the name of the class of the MBean from which the value was sourced.
     * @param   attributeName - the name of the attribute of the MBean from which the value was sourced.  For complex
     *                          types (such as CompositeData), the attribute name may describe a hierarchy.
     * @param   epoch - the timestamp of the metric.
     * @param   value - value of the attribute to use as the metric value.
     * @param   tagName - name of the tag to include.
     * @param   tagValue - value of the tag to include.
     * @return  String - the formatted result string.
     */
    String getResultString(String className, String attributeName, long epoch, Object value, String tagName, String tagValue) {
        String taggedResultStringFormat = "%s.%s %d %s %s=%s";
        return String.format(taggedResultStringFormat, className, attributeName, epoch, value, tagName, tagValue);
    }

    /**
     * Parse one of the results of a Query and return a list of strings containing metric details ready for sending to
     * OpenTSDB.
     *
     * @param   result - one results from the Query.
     * @return  List<String> - the list of strings containing metric details ready for sending to OpenTSDB.
     */
    List<String> resultParser(Result result) throws UnknownHostException {
        List<String> resultStrings = new LinkedList<String>();
        Map<String, Object> values = result.getValues();
        if (values == null)
            return resultStrings;

        String attributeName = result.getAttributeName();
        String className = result.getClassNameAlias() == null ? result.getClassName() : result.getClassNameAlias();
        if (values.containsKey(attributeName) && values.size() == 1) {
            if ( JmxUtils.isNumeric(values.get(attributeName)) ) {
                String resultString = getResultString(className, attributeName, (long)(result.getEpoch()/1000L), values.get(attributeName));
                resultString = addTags(resultString);
                if (getTypeNames().size() > 0) {
                    resultString = addTag(resultString, StringUtils.join(getTypeNames(), ""), getConcatedTypeNameValues(result.getTypeName()));
                }
                resultStrings.add(resultString);
            }
            else {
                log.debug("discarding non-numeric value for attribute {}; value={}", attributeName,
                          values.get(attributeName));
            }
        } else {
            for (Map.Entry<String, Object> valueEntry: values.entrySet() ) {
                if ( JmxUtils.isNumeric(valueEntry.getValue()) ) {
                    String resultString = getResultString(className, attributeName, (long)(result.getEpoch()/1000L), valueEntry.getValue(), tagName, valueEntry.getKey());
                    resultString = addTags(resultString);
                    if (getTypeNames().size() > 0) {
                        resultString = addTag(resultString, StringUtils.join(getTypeNames(), ""), getConcatedTypeNameValues(result.getTypeName()));
                    }
                    resultStrings.add(resultString);
                }
                else {
                    log.debug("discarding non-numeric value for attribute {}; value={}", attributeName,
                              valueEntry.getValue());
                }
            }
        }
        return resultStrings;
    }

    /**
     * Write the results of the query.
     *
     * @param   query - the query and its results.
     */
    @Override
    public void doWrite(Query query) throws Exception {
        this.startOutput();
        for (Result result : query.getResults()) {
            for(String resultString: resultParser(result)) {
                if (isDebugEnabled())
                    System.out.println(resultString);

                this.sendOutput(resultString);
            }
        }
        this.finishOutput();
    }

    @Override
    public void validateSetup(Query query) throws ValidationException {
        if (host == null || port == null) {
            throw new ValidationException("Host and port can't be null", query);
        }
    }

    /** 
     * Start the output writer.  At this time, the settings are read from the configuration file and saved for later
     * use.
     */
    @Override
    public void start() throws LifecycleException {
        host = (String) this.getSettings().get(HOST);
        port = (Integer) this.getSettings().get(PORT);
        tags = (Map<String, String>) this.getSettings().get("tags");
        tagName = this.getStringSetting("tagName", "type");

        this.prepareSender();
    }

    @Override
    public void stop() throws LifecycleException {
        this.shutdownSender();
    }
}=======
package com.googlecode.jmxtrans.model.output;

import com.googlecode.jmxtrans.model.NamingStrategy;
import com.googlecode.jmxtrans.model.Query;
import com.googlecode.jmxtrans.model.Result;
import com.googlecode.jmxtrans.model.naming.ClassAttributeNamingStrategy;
import com.googlecode.jmxtrans.model.naming.JexlNamingStrategy;
import com.googlecode.jmxtrans.util.BaseOutputWriter;
import com.googlecode.jmxtrans.util.ValidationException;
import com.googlecode.jmxtrans.util.JmxUtils;
import com.googlecode.jmxtrans.util.LifecycleException;
import org.apache.commons.jexl2.JexlException;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.io.IOException;

/**
 * Originally written by Balazs Kossovics <bko@witbe.net>.  Common base class for OpenTSDBWriter and TCollectorWriter.
 * Date: 4/4/13
 * Time: 6:00 PM
 *
 * Updates by Arthur Naseef
 */
public abstract class OpenTSDBGenericWriter extends BaseOutputWriter {
    public static final boolean DEFAULT_MERGE_TYPE_NAMES_TAGS = true;

    private static final Logger log = LoggerFactory.getLogger(OpenTSDBGenericWriter.class);

    protected String host;
    protected Integer port;
    protected Map<String, String> tags;
    protected String tagName;
    protected NamingStrategy metricNameStrategy;

    protected boolean mergeTypeNamesTags = DEFAULT_MERGE_TYPE_NAMES_TAGS;
    protected boolean addHostnameTag     = getAddHostnameTagDefault();

    /**
     * Prepare for sending metrics, if needed.  For use by subclasses.
     */
    protected void  prepareSender() throws LifecycleException {
    }

    /**
     * Shutdown the sender, if needed.  For use by subclasses.
     */
    protected void  shutdownSender() throws LifecycleException {
    }

    /**
     * Prepare a batch of results output, if needed.  For use by subclasses.
     */
    protected void  startOutput() throws IOException {
    }

    /**
     * Subclass responsibility: specify the default value for the "addHostnameTag" setting.
     */
    protected abstract boolean  getAddHostnameTagDefault();

    /**
     * Subcall responsibility: method to perform the actual output for the given metric line.  Every subclass
     * <b>must</b> implement this method.
     *
     * @param   metricLine - the line containing the metric name, value, and tags for a single metric; excludes the
     *          "put" keyword expected by OpenTSDB and the trailing newline character.
     */
    protected abstract void sendOutput(String metricLine) throws IOException;

    /**
     * Complete a batch of results output, if needed.  For use by subclasses.
     */
    protected void  finishOutput() throws IOException {
    }

    /**
     * Add tags to the given result string, including a "host" tag with the name of the server and all of the tags
     * defined in the "settings" entry in the configuration file within the "tag" element.
     *
     * @param   resultString - the string containing the metric name, timestamp, value, and possibly other content.
     */
    String addTags(String resultString) throws UnknownHostException {
        if ( addHostnameTag ) {
            resultString = addTag(resultString, "host", java.net.InetAddress.getLocalHost().getHostName());
        }

        if (tags != null) {
            // Add the constant tag names and values.
            for (Map.Entry<String, String> tagEntry : tags.entrySet()) {
                resultString = addTag(resultString, tagEntry.getKey(), tagEntry.getValue());
            }
        }

        return resultString;
    }

    /**
     * Add one tag, with the provided name and value, to the given result string.
     *
     * @param   resultString - the string containing the metric name, timestamp, value, and possibly other content.
     * @return  String - the new result string with the tag appended.
     */
    String addTag(String resultString, String tagName, String tagValue) {

        String tagFormat = " %s=%s";
        resultString += String.format(tagFormat, sanitizeString(tagName), sanitizeString(tagValue));
        return resultString;
    }

    /**
     * Format the result string given the class name and attribute name of the source value, the timestamp, and the
     * value.
     *
     * @param   className - the name of the class of the MBean from which the value was sourced.
     * @param   attributeName - the name of the attribute of the MBean from which the value was sourced.  For complex
     *                          types (such as CompositeData), the attribute name may describe a hierarchy.
     * @param   epoch - the timestamp of the metric.
     * @param   value - value of the attribute to use as the metric value.
     * @return  String - the formatted result string.
     */
    String getResultString(String metricName, long epoch, Object value) {
        String resultStringFormat = "%s %d %s";
        return String.format(resultStringFormat, sanitizeString(metricName), epoch, sanitizeString(value.toString()));
    }

    /**
     * Parse one of the results of a Query and return a list of strings containing metric details ready for sending to
     * OpenTSDB.
     *
     * @param   result - one results from the Query.
     * @return  List<String> - the list of strings containing metric details ready for sending to OpenTSDB.
     */
    List<String> resultParser(Result result) throws UnknownHostException {
        List<String> resultStrings = new LinkedList<String>();
        Map<String, Object> values = result.getValues();
        if (values == null)
            return resultStrings;

        String attributeName = result.getAttributeName();
        String className = result.getClassNameAlias() == null ? result.getClassName() : result.getClassNameAlias();
        if (values.containsKey(attributeName) && values.size() == 1) {
            if ( JmxUtils.isNumeric(values.get(attributeName)) ) {
                String metricName = this.metricNameStrategy.formatName(result);
                String resultString = getResultString(metricName, (long)(result.getEpoch()/1000L), values.get(attributeName));
                resultString = addTags(resultString);
                if (getTypeNames().size() > 0) {
                    resultString = this.addTypeNamesTags(result, resultString);
                }
                resultStrings.add(resultString);
            }
            else {
                log.debug("discarding non-numeric value for attribute {}; value={}", attributeName,
                          values.get(attributeName));
            }
        } else {
            for (Map.Entry<String, Object> valueEntry: values.entrySet() ) {
                if ( JmxUtils.isNumeric(valueEntry.getValue()) ) {
                    String metricName = this.metricNameStrategy.formatName(result);
                    String resultString = getResultString(metricName, (long)(result.getEpoch()/1000L), valueEntry.getValue());
                    resultString = addTag(resultString, tagName, valueEntry.getKey());
                    resultString = addTags(resultString);

                    if (getTypeNames().size() > 0) {
                        resultString = this.addTypeNamesTags(result, resultString);
                    }
                    resultStrings.add(resultString);
                }
                else {
                    log.debug("discarding non-numeric value for attribute {}; value={}", attributeName,
                              valueEntry.getValue());
                }
            }
        }
        return resultStrings;
    }

    /**
     * Add the tag(s) for typeNames.
     *
     * @param	result - the result of the JMX query.
     * @param	resultString - current form of the metric string.
     * @return	String - the updated metric string with the necessary tag(s) added.
     */
    protected String    addTypeNamesTags (Result result, String resultString) {
        String  retVal = resultString;
        if ( mergeTypeNamesTags ) {
            // Produce a single tag with all the TypeName keys concatenated and all the values joined with '_'.
            retVal = addTag(retVal, StringUtils.join(getTypeNames(), ""), getConcatedTypeNameValues(result.getTypeName()));
        }
        else {
            Map<String, String> typeNameMap = JmxUtils.getTypeNameValueMap(result.getTypeName());
            for ( String oneTypeName : getTypeNames() ) {
                String value = typeNameMap.get(oneTypeName);
                if ( value == null )
                    value = "";
                retVal = addTag(retVal, oneTypeName, value);
            }
        }

        return  retVal;
    }

    /**
     * Write the results of the query.
     *
     * @param   query - the query and its results.
     */
    @Override
    public void doWrite(Query query) throws Exception {
        this.startOutput();
        for (Result result : query.getResults()) {
            for(String resultString: resultParser(result)) {
                if (isDebugEnabled())
                    System.out.println(resultString);

                this.sendOutput(resultString);
            }
        }
        this.finishOutput();
    }

    @Override
    public void validateSetup(Query query) throws ValidationException {
        if (host == null || port == null) {
            throw new ValidationException("Host and port can't be null", query);
        }
    }

    /** 
     * Start the output writer.  At this time, the settings are read from the configuration file and saved for later
     * use.
     */
    @Override
    public void start() throws LifecycleException {
        host = (String) this.getSettings().get(HOST);
        port = (Integer) this.getSettings().get(PORT);
        tags = (Map<String, String>) this.getSettings().get("tags");

        tagName            = this.getStringSetting("tagName", "type");
        mergeTypeNamesTags = this.getBooleanSetting("mergeTypeNamesTags", DEFAULT_MERGE_TYPE_NAMES_TAGS);
        addHostnameTag     = this.getBooleanSetting("addHostnameTag", this.getAddHostnameTagDefault());

        this.setupNamingStrategies();
        this.prepareSender();
    }

    @Override
    public void stop() throws LifecycleException {
        this.shutdownSender();
    }

    /**
     * Set the naming strategies based on the configuration.
     */
    protected void  setupNamingStrategies () throws LifecycleException {
        try {
            String jexlExpr = this.getStringSetting("metricNamingExpression", null);
            if ( jexlExpr != null ) {
                this.metricNameStrategy = new JexlNamingStrategy(jexlExpr);
            }
            else {
                this.metricNameStrategy = new ClassAttributeNamingStrategy();
            }
        }
        catch ( JexlException jexlExc ) {
            throw   new LifecycleException("failed to setup naming strategy", jexlExc);
        }

    }

    /**
     * VALID CHARACTERS:
     *      METRIC, TAGNAME, AND TAG-VALUE:
     *          [-_./a-zA-Z0-9]+
     *
     *
     * SANITIZATION:
     *      - Discard Quotes.
     *      - Replace all other invalid characters with '_'.
     */
    protected String    sanitizeString (String unsanitized) {
        String  sanitized;

        sanitized =
            unsanitized.
                    replaceAll("[\"']", "").
                    replaceAll("[^-_./a-zA-Z0-9]", "_");

        return  sanitized;
    }
}>>>>>>> YOURS
/home/ramdisk/experiment2/projects/jmxtrans/revisions/rev_1a750dd_4d726a9/rev_1a750dd-4d726a9/src/com/googlecode/jmxtrans/model/naming/ClassAttributeNamingStrategy.java;<<<<<<< MINE
=======
package com.googlecode.jmxtrans.model.naming;

import com.googlecode.jmxtrans.model.NamingStrategy;
import com.googlecode.jmxtrans.model.Result;

/**
 * Strategy for naming metrics, tags, and the like given a result.
 */
public class ClassAttributeNamingStrategy implements NamingStrategy {
    protected String    delimiter = ".";

    public void setDelimiter (String delim) {
        this.delimiter = delim;
    }

    public String   getDelimiter () {
        return  this.delimiter;
    }

    @Override
    public String   formatName (Result result) {
        StringBuilder   formatted = new StringBuilder();
        String          attName   = result.getAttributeName();
        String          className = result.getClassNameAlias();

        if ( className == null )
            className = result.getClassName();

        formatted.append(className);
        formatted.append(delimiter);
        formatted.append(attName);

        return  formatted.toString();
    }
}>>>>>>> YOURS
/home/ramdisk/experiment2/projects/jmxtrans/revisions/rev_1a750dd_4d726a9/rev_1a750dd-4d726a9/src/com/googlecode/jmxtrans/model/naming/JexlNamingStrategy.java;<<<<<<< MINE
=======
package com.googlecode.jmxtrans.model.naming;

import com.googlecode.jmxtrans.model.NamingStrategy;
import com.googlecode.jmxtrans.model.Result;

import org.apache.commons.jexl2.Expression;
import org.apache.commons.jexl2.JexlContext;
import org.apache.commons.jexl2.JexlEngine;
import org.apache.commons.jexl2.JexlException;
import org.apache.commons.jexl2.MapContext;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Naming strategy which uses an JEXL expression to format the name from the result, its class name, attribute name,
 * and more.  Note the resulting name can be used for any of a number of purposes.  For example, with OpenTSDB it could
 * be the metric name or a tag name.
 *
 * In the expression, all of the following may be used:
 *      Variables
 *      alias - the classname alias of the MBean.
 *      attribute - the name of the attribute of the MBean queried.
 *      class - the effective classname of the MBean (uses #alias is not null, otherwise uses #realclass).
 *      realclass - the class name of the MBean.
 *      result - the full Result object.
 */
public class JexlNamingStrategy implements NamingStrategy{
    private static final Logger LOG = LoggerFactory.getLogger(JexlNamingStrategy.class);

    public static final String  DEFAULT_EXPRESSION = "class + \".\" + attribute";
    public static final String  VAR__CLASSNAME = "realclass";
    public static final String  VAR__ATTRIBUTE_NAME = "attribute";
    public static final String  VAR__CLASSNAME_ALIAS = "alias";
    public static final String  VAR__EFFECTIVE_CLASSNAME = "class";
    public static final String  VAR__RESULT = "result";

    protected JexlEngine    jexl;
    protected Expression    parsedExpr;


    /**
     * Create a new naming strategy using an JEXL expression and the default expression.
     */
    public  JexlNamingStrategy () throws JexlException {
        jexl = new JexlEngine();
        this.parsedExpr = jexl.createExpression(DEFAULT_EXPRESSION);
    }

    /**
     * Create a new naming strategy using an JEXL expression and the given expression.
     *
     * @param expr - the JEXL expression to use to create names.
     */
    public  JexlNamingStrategy (String expr) throws JexlException {
        jexl = new JexlEngine();
        this.parsedExpr = jexl.createExpression(expr);
    }

    /**
     * Format the name for the given result.
     *
     * @param result - the result of a JMX query.
     * @return String - the formatted string resulting from the expression, or null if the formatting fails.
     */
    @Override
    public String formatName (Result result) {
        String      formatted;
        JexlContext context = new MapContext();

        this.populateContext(context, result);
        try {
            formatted = (String) this.parsedExpr.evaluate(context);
        } catch ( JexlException jexlExc ) {
            LOG.error("error applying JEXL expression to query results", jexlExc);
            formatted = null;
        }

        return formatted;
    }

    public void setExpression (String expr) throws JexlException {
        this.parsedExpr = this.jexl.createExpression(expr);
    }

    /**
     * Populate the context with values from the result.
     *
     * @param context - the expression context used when evaluating JEXL expressions.
     * @param result - the result of a JMX query.
     */
    protected void  populateContext (JexlContext context, Result result) {
        context.set(VAR__CLASSNAME, result.getClassName());
        context.set(VAR__ATTRIBUTE_NAME, result.getAttributeName());
        context.set(VAR__CLASSNAME_ALIAS, result.getClassNameAlias());

        String effectiveClassname = result.getClassNameAlias();
        if ( effectiveClassname == null ) {
            effectiveClassname = result.getClassName();
        }
        context.set(VAR__EFFECTIVE_CLASSNAME, effectiveClassname);

        context.set(VAR__RESULT, result);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment2/projects/jmxtrans/revisions/rev_1a750dd_4d726a9/rev_1a750dd-4d726a9/src/com/googlecode/jmxtrans/model/NamingStrategy.java;<<<<<<< MINE
=======
package com.googlecode.jmxtrans.model;

/**
 * Strategy for naming metrics, tags, and the like given a result.
 */
public interface NamingStrategy {
    String  formatName (Result result);
}>>>>>>> YOURS
/home/ramdisk/experiment2/projects/jmxtrans/revisions/rev_1a750dd_4d726a9/rev_1a750dd-4d726a9/test/com/googlecode/jmxtrans/model/output/OpenTSDBWriterTests.java;<<<<<<< MINE
package com.googlecode.jmxtrans.model.output;

import static org.junit.Assert.*;
import static org.junit.matchers.JUnitMatchers.containsString;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.net.ServerSocket;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.googlecode.jmxtrans.model.Query;
import com.googlecode.jmxtrans.model.Result;

import org.junit.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Tests for {@link OpenTSDBWriter}.
 *
 * TODO:
 *	- Stop using a real socket for testing purposes.  Some machines may not allow for the socket creation.
 */
public class OpenTSDBWriterTests {
	private static final Logger	LOG = LoggerFactory.getLogger(OpenTSDBWriterTests.class);

	protected OpenTSDBWriter	writer;
	protected Query			mockQuery;
	protected Result		mockResult;
	protected ServerSocket		loopbackSocket;

	@Before
	public void	setupTest () {
		this.mockQuery = mock(Query.class);
		this.mockResult = mock(Result.class);

		this.writer = new OpenTSDBWriter();

		this.startLoopbackSocket();

			//
			// Setup common mock interactions.
			//

		when(this.mockResult.getValues()).thenReturn(createValueMap("x-att1-x", "120021"));
		when(this.mockResult.getAttributeName()).thenReturn("X-ATT-X");
		when(this.mockResult.getClassName()).thenReturn("X-DOMAIN.PKG.CLASS-X");
		when(this.mockResult.getTypeName()).thenReturn("Type=x-type-x,Group=x-group-x,Other=x-other-x,Name=x-name-x");

		this.writer.addSetting("typeNames", Arrays.asList(new String[] { "Type", "Group", "Name", "Missing" }));
		this.writer.addSetting("host", "localhost");
		this.writer.addSetting("port", Integer.valueOf(4242));
	}

	@After
	public void	cleanupTest () {
		this.stopLoopbackSocket();
	}

	@Test
	public void	testMergedTypeNameValues1 () throws Exception {
		List<String>	result;

		// Verify the default is the same as the TRUE path.
		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		validateMergedTypeNameValues(result, true);
	}

	@Test
	public void	testMergedTypeNameValues2 () throws Exception {
		List<String>	result;

		this.writer.addSetting("mergeTypeNamesTags", Boolean.TRUE);

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		validateMergedTypeNameValues(result, true);
	}

	@Test
	public void	testMergedTypeNameValues3 () throws Exception {
		List<String>	result;

		// Verify the FALSE path.
		this.writer.addSetting("mergeTypeNamesTags", Boolean.FALSE);

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		validateMergedTypeNameValues(result, false);
	}

	@Test
	public void	testTagSetting () throws Exception {
		List<String>		result;
		Map<String, String>	tagMap;

		when(this.mockResult.getValues()).thenReturn(createValueMap("X-ATT-X", "120021"));

		// Verify empty tag map.
		tagMap = new HashMap<String, String>();
		this.writer.addSetting("tags", tagMap);
		this.writer.setTypeNames(new LinkedList());

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		assertTrue(result.get(0).matches("^X-DOMAIN.PKG.CLASS-X\\.X-ATT-X 0 120021 host=[^ ]*$"));


		// Verify tag map with multiple values.
		tagMap = new HashMap<String, String>();
		tagMap.put("x-tag1-x", "x-tag1val-x");
		tagMap.put("x-tag2-x", "x-tag2val-x");
		tagMap.put("x-tag3-x", "x-tag3val-x");
		this.writer.addSetting("tags", tagMap);

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		assertTrue(result.get(0).matches("^X-DOMAIN.PKG.CLASS-X\\.X-ATT-X 0 120021.*"));
		assertTrue(result.get(0).matches(".*host=.*"));
		assertTrue(result.get(0).matches(".*\\bx-tag1-x=x-tag1val-x\\b.*"));
		assertTrue(result.get(0).matches(".*\\bx-tag2-x=x-tag2val-x\\b.*"));
		assertTrue(result.get(0).matches(".*\\bx-tag3-x=x-tag3val-x\\b.*"));
	}

	@Test
	public void	testEmptyResultValues () throws Exception {
		List<String>		result;

		when(this.mockResult.getValues()).thenReturn(null);

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		assertEquals(0, result.size());
	}

	protected void	startLoopbackSocket() {
		try {
			this.loopbackSocket = new ServerSocket(4242);
		}
		catch ( IOException io_exc ) {
			LOG.warn("Failed to setup test server socket on port 4242", io_exc);
		}
	}

	protected void	stopLoopbackSocket() {
		try {
			if ( this.loopbackSocket != null ) {
				this.loopbackSocket.close();
				this.loopbackSocket = null;
			}
		}
		catch ( IOException io_exc ) {
			LOG.warn("Failed to close test server socket on port 4242", io_exc);
		}
	}

	protected void	validateMergedTypeNameValues (List<String> result, boolean mergedInd) {
		if ( mergedInd ) {
			assertEquals(1, result.size());
			assertTrue(result.get(0).matches("^X-DOMAIN.PKG.CLASS-X\\.X-ATT-X 0 120021.*"));
			assertTrue(result.get(0).matches(".*\\btype=x-att1-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bTypeGroupNameMissing=x-type-x_x-group-x_x-name-x\\b.*"));
		}
		else {
			assertEquals(1, result.size());
			assertTrue(result.get(0).matches("^X-DOMAIN.PKG.CLASS-X\\.X-ATT-X 0 120021.*"));
			assertTrue(result.get(0).matches(".*\\btype=x-att1-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bType=x-type-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bGroup=x-group-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bName=x-name-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bMissing=(\\s.*|$)"));
		}
	}

	protected Map<String, Object>	createValueMap (Object... keysAndValues) {
		Map<String, Object>	result;
		int			iter;

		result = new HashMap<String, Object>();
		iter = 0;
		while ( iter < keysAndValues.length ) {
			if ( iter < ( keysAndValues.length - 1 ) ) {
				result.put(keysAndValues[iter].toString(), keysAndValues[iter + 1]);
				iter += 2;
			}
			else {
				result.put(keysAndValues[iter].toString(), null);
				iter++;
			}
		}

		return	result;
	}
}=======
package com.googlecode.jmxtrans.model.output;

import static org.junit.Assert.*;
import static org.junit.matchers.JUnitMatchers.containsString;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.net.ServerSocket;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.googlecode.jmxtrans.model.Query;
import com.googlecode.jmxtrans.model.Result;

import org.junit.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Tests for {@link OpenTSDBWriter}.
 *
 * TODO:
 *	- Stop using a real socket for testing purposes.  Some machines may not allow for the socket creation.
 */
public class OpenTSDBWriterTests {
	private static final Logger	LOG = LoggerFactory.getLogger(OpenTSDBWriterTests.class);

	protected OpenTSDBWriter	writer;
	protected Query			mockQuery;
	protected Result		mockResult;
	protected ServerSocket		loopbackSocket;

	@Before
	public void	setupTest () {
		this.mockQuery = mock(Query.class);
		this.mockResult = mock(Result.class);

		this.writer = new OpenTSDBWriter();

		this.startLoopbackSocket();

			//
			// Setup common mock interactions.
			//

		when(this.mockResult.getValues()).thenReturn(createValueMap("x-att1-x", "120021"));
		when(this.mockResult.getAttributeName()).thenReturn("X-ATT-X");
		when(this.mockResult.getClassName()).thenReturn("X-DOMAIN.PKG.CLASS-X");
		when(this.mockResult.getTypeName()).thenReturn("Type=x-type-x,Group=x-group-x,Other=x-other-x,Name=x-name-x");

		this.writer.addSetting("typeNames", Arrays.asList(new String[] { "Type", "Group", "Name", "Missing" }));
		this.writer.addSetting("host", "localhost");
		this.writer.addSetting("port", Integer.valueOf(4242));
	}

	@After
	public void	cleanupTest () {
		this.stopLoopbackSocket();
	}

	@Test
	public void	testMergedTypeNameValues1 () throws Exception {
		List<String>	result;

		// Verify the default is the same as the TRUE path.
		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		validateMergedTypeNameValues(result, true);
	}

	@Test
	public void	testMergedTypeNameValues2 () throws Exception {
		List<String>	result;

		this.writer.addSetting("mergeTypeNamesTags", Boolean.TRUE);

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		validateMergedTypeNameValues(result, true);
	}

	@Test
	public void	testMergedTypeNameValues3 () throws Exception {
		List<String>	result;

		// Verify the FALSE path.
		this.writer.addSetting("mergeTypeNamesTags", Boolean.FALSE);

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		validateMergedTypeNameValues(result, false);
	}

	@Test
	public void	testTagSetting () throws Exception {
		List<String>		result;
		Map<String, String>	tagMap;

		when(this.mockResult.getValues()).thenReturn(createValueMap("X-ATT-X", "120021"));

		// Verify empty tag map.
		tagMap = new HashMap<String, String>();
		this.writer.addSetting("tags", tagMap);
		this.writer.setTypeNames(new LinkedList());

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		assertTrue(result.get(0).matches("^X-DOMAIN.PKG.CLASS-X\\.X-ATT-X 0 120021 host=[^ ]*$"));


		// Verify tag map with multiple values.
		tagMap = new HashMap<String, String>();
		tagMap.put("x-tag1-x", "x-tag1val-x");
		tagMap.put("x-tag2-x", "x-tag2val-x");
		tagMap.put("x-tag3-x", "x-tag3val-x");
		this.writer.addSetting("tags", tagMap);

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		assertTrue(result.get(0).matches("^X-DOMAIN.PKG.CLASS-X\\.X-ATT-X 0 120021.*"));
		assertTrue(result.get(0).matches(".*host=.*"));
		assertTrue(result.get(0).matches(".*\\bx-tag1-x=x-tag1val-x\\b.*"));
		assertTrue(result.get(0).matches(".*\\bx-tag2-x=x-tag2val-x\\b.*"));
		assertTrue(result.get(0).matches(".*\\bx-tag3-x=x-tag3val-x\\b.*"));
	}

	@Test
	public void	testEmptyResultValues () throws Exception {
		List<String>		result;

		when(this.mockResult.getValues()).thenReturn(null);

		this.writer.start();
		result = this.writer.resultParser(this.mockResult);
		this.writer.stop();

		assertEquals(0, result.size());
	}

	protected void	startLoopbackSocket() {
		try {
			this.loopbackSocket = new ServerSocket(4242);
		}
		catch ( IOException io_exc ) {
			LOG.warn("Failed to setup test server socket on port 4242", io_exc);
		}
	}

	protected void	stopLoopbackSocket() {
		try {
			if ( this.loopbackSocket != null ) {
				this.loopbackSocket.close();
				this.loopbackSocket = null;
			}
		}
		catch ( IOException io_exc ) {
			LOG.warn("Failed to close test server socket on port 4242", io_exc);
		}
	}

	protected void	validateMergedTypeNameValues (List<String> result, boolean mergedInd) {
		LOG.info("result string = {}", result.get(0));
		if ( mergedInd ) {
			assertEquals(1, result.size());
			assertTrue(result.get(0).matches("^X-DOMAIN.PKG.CLASS-X\\.X-ATT-X 0 120021.*"));
			assertTrue(result.get(0).matches(".*\\btype=x-att1-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bTypeGroupNameMissing=x-type-x_x-group-x_x-name-x\\b.*"));
		}
		else {
			assertEquals(1, result.size());
			assertTrue(result.get(0).matches("^X-DOMAIN.PKG.CLASS-X\\.X-ATT-X 0 120021.*"));
			assertTrue(result.get(0).matches(".*\\btype=x-att1-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bType=x-type-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bGroup=x-group-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bName=x-name-x\\b.*"));
			assertTrue(result.get(0).matches(".*\\bMissing=(\\s.*|$)"));
		}
	}

	protected Map<String, Object>	createValueMap (Object... keysAndValues) {
		Map<String, Object>	result;
		int			iter;

		result = new HashMap<String, Object>();
		iter = 0;
		while ( iter < keysAndValues.length ) {
			if ( iter < ( keysAndValues.length - 1 ) ) {
				result.put(keysAndValues[iter].toString(), keysAndValues[iter + 1]);
				iter += 2;
			}
			else {
				result.put(keysAndValues[iter].toString(), null);
				iter++;
			}
		}

		return	result;
	}
}>>>>>>> YOURS
/home/ramdisk/experiment2/projects/jmxtrans/revisions/rev_fe2250d_92e252b/rev_fe2250d-92e252b/test/com/googlecode/jmxtrans/model/output/LibratoWriterTest.java;<<<<<<< MINE
=======
package com.googlecode.jmxtrans.model.output;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import org.junit.Test;

import java.net.MalformedURLException;
import java.net.URL;

import static org.assertj.core.api.Assertions.assertThat;

public class LibratoWriterTest {

	@Test
	public void httpUserAgentContainsAppropriateInformation() throws MalformedURLException {
		LibratoWriter writer = new LibratoWriter(
				ImmutableList.<String>of(),
				false,
				false,
				new URL(LibratoWriter.DEFAULT_LIBRATO_API_URL),
				1000,
				"username",
				"token",
				null,
				null,
				ImmutableMap.<String, Object>of()
		);

		assertThat(writer.httpUserAgent)
				.startsWith("jmxtrans-standalone/")
				.contains(System.getProperty("os.name"))
				.contains(System.getProperty("os.arch"))
				.contains(System.getProperty("os.version"))
				.contains(System.getProperty("java.vm.name"))
				.contains(System.getProperty("java.version"));
	}
	

}>>>>>>> YOURS
