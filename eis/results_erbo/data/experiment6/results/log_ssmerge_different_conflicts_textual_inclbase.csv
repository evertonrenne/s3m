file;linedbasedConf
/home/ramdisk/experiment6/projects/databus/revisions/rev_3744018_5eec32f/rev_3744018-5eec32f/databus2-relay/databus2-relay-impl/src/test/java/com/linkedin/databus2/relay/TestDatabusRelayMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/ChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/ChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_6a8bc7e_abd8d4e/rev_6a8bc7e-abd8d4e/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/DbusEvent.java;<<<<<<< MINE
/*
 *
 * Copyright 2013 LinkedIn Corp. All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
*/

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
||||||| BASE
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBSingleSourceCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryHelper.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryHelper.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapReadOnlyConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapDBDiskSpaceTriggerThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapDBPeriodicTriggerThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapDBPeriodicTriggerThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/StringUtils.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/StringUtils.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/StringUtils.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/DbusConstants.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus2/relay/config/PhysicalSourceStaticConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus2/relay/config/PhysicalSourceStaticConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/util/TestStringUtils.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-container/src/main/java/com/linkedin/databus2/core/container/request/DatabusRequest.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-container/src/main/java/com/linkedin/databus2/core/container/request/DatabusRequest.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-container/src/main/java/com/linkedin/databus2/core/container/request/DatabusRequest.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-fwk-test/src/main/java/com/linkedin/databus2/test/ClassIntrospectionUtils.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-fwk-test/src/main/java/com/linkedin/databus2/test/ClassIntrospectionUtils.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-fwk-test/src/main/java/com/linkedin/databus2/test/ClassIntrospectionUtils.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-fwk-test/src/main/java/com/linkedin/databus2/test/ClassIntrospectionUtils.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus2-relay/databus2-event-producer-common/src/main/java/com/linkedin/databus2/producers/AbstractEventProducer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
  // used only by tests
  public MultiConsumerCallback(List<DatabusV2ConsumerRegistration> registrations,
          ExecutorService executorService,
          long timeBudgetMs,
          ConsumerCallbackFactory<DatabusCombinedConsumer> callbackFactory
         )
||||||| BASE
  public MultiConsumerCallback(List<DatabusV2ConsumerRegistration> consumers,
          ExecutorService executorService,
          long timeBudgetMs,
          ConsumerCallbackFactory<DatabusCombinedConsumer> callbackFactory
         )
=======
  // used only by tests
  public MultiConsumerCallback(List<DatabusV2ConsumerRegistration> registrations,
                               ExecutorService executorService,
                               long timeBudgetMs,
                               ConsumerCallbackFactory<DatabusCombinedConsumer> callbackFactory)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
                               ConsumerCallbackStats consumerStats,
                               LoggingConsumer loggingConsumer)
||||||| BASE
                               ConsumerCallbackStats consumerStats
                               )
=======
                               ConsumerCallbackStats consumerStats,    // specific to relay or bootstrap mode, not both
                               UnifiedClientStats unifiedClientStats,  // used in both relay and bootstrap mode
                               LoggingConsumer loggingConsumer)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
    // TODO:  Should we sniff registrations list and make sure no LoggingConsumers in there?
    //        Sole non-test caller is DatabusSourcesConnection, so as long as LoggingConsumer
    //        is not available to end-users, no need...
    _loggingConsumer = loggingConsumer;  // may be null in unit tests
||||||| BASE
=======
    _unifiedClientStats = unifiedClientStats;
    _loggingConsumer = loggingConsumer;  // may be null in unit tests
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/DbusEventAvroDecoder.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
      super(consumers, executorService, timeBudgetMs, callbackFactory, consumerStats, null);
||||||| BASE
      super(consumers, executorService, timeBudgetMs, callbackFactory, consumerStats);
=======
      super(consumers, executorService, timeBudgetMs, callbackFactory, consumerStats, unifiedClientStats, null);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/NettyHttpDatabusBootstrapConnection.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/registration/DatabusV2RegistrationImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/registration/DatabusV2RegistrationImpl.java;<<<<<<< MINE
	private RegistrationState _state;
	protected RegistrationId _id;
    private final Logger _log;
	private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
    protected DbusEventsStatisticsCollector _inboundEventsStatsCollector;
    protected DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;
    protected ConsumerCallbackStats _relayConsumerStats;
    protected ConsumerCallbackStats _bootstrapConsumerStats;
	private final List<DatabusCombinedConsumer> _consumers;
	private final List<String> _sources;
	private DatabusSourcesConnection _sourcesConnection;
	private DatabusRegistration _parent = null;
    protected final DatabusHttpClientImpl _client;
	private Status _status = null;
	private DbusKeyCompositeFilterConfig _filterConfig = null;

	private List<DatabusV2ConsumerRegistration> _streamConsumerRawRegistrations;
	private List<DatabusV2ConsumerRegistration> _bootstrapConsumerRawRegistrations;

	/** Suffix Names for Stats Collectors **/
	public static final String STREAM_EVENT_STATS_SUFFIX_NAME = ".inbound";
	public static final String BOOTSTRAP_EVENT_STATS_SUFFIX_NAME = ".inbound.bs";
	public static final String RELAY_CONSUMER_STATS_SUFFIX_NAME = ".callback.relay";
	public static final String BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME = ".callback.bootstrap";

    public class Status extends DatabusComponentStatus
	{
      public Status()
||||||| BASE
	private RegistrationState _state;
	protected RegistrationId _id;
    private final Logger _log;
	private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
    protected DbusEventsStatisticsCollector _inboundEventsStatsCollector;
    protected DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;
    protected ConsumerCallbackStats _relayConsumerStats;
    protected ConsumerCallbackStats _bootstrapConsumerStats;
	private final List<DatabusCombinedConsumer> _consumers;
	private final LoggingConsumer _loggingConsumer;
	private final List<String> _sources;
	private DatabusSourcesConnection _sourcesConnection;
	private DatabusRegistration _parent = null;
    protected final DatabusHttpClientImpl _client;
	private Status _status = null;
	private DbusKeyCompositeFilterConfig _filterConfig = null;

	private List<DatabusV2ConsumerRegistration> _streamConsumerRawRegistrations;
	private List<DatabusV2ConsumerRegistration> _bootstrapConsumerRawRegistrations;

	/** Suffix Names for Stats Collectors **/
	public static final String STREAM_EVENT_STATS_SUFFIX_NAME = ".inbound";
	public static final String BOOTSTRAP_EVENT_STATS_SUFFIX_NAME = ".inbound.bs";
	public static final String RELAY_CONSUMER_STATS_SUFFIX_NAME = ".callback.relay";
	public static final String BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME = ".callback.bootstrap";

    public class Status extends DatabusComponentStatus
	{
      public Status()
=======
  private RegistrationState _state;
  protected RegistrationId _id;
  private final Logger _log;
  private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
  protected DbusEventsStatisticsCollector _inboundEventsStatsCollector;
  protected DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;
  protected ConsumerCallbackStats _relayConsumerStats;
  protected ConsumerCallbackStats _bootstrapConsumerStats;
  protected UnifiedClientStats _unifiedClientStats;
  private final List<DatabusCombinedConsumer> _consumers;
  private final List<String> _sources;
  private DatabusSourcesConnection _sourcesConnection;
  private DatabusRegistration _parent = null;
  protected final DatabusHttpClientImpl _client;
  private Status _status = null;
  private DbusKeyCompositeFilterConfig _filterConfig = null;

  private List<DatabusV2ConsumerRegistration> _streamConsumerRawRegistrations;
  private List<DatabusV2ConsumerRegistration> _bootstrapConsumerRawRegistrations;

  /** Suffix Names for Stats Collectors **/
  public static final String STREAM_EVENT_STATS_SUFFIX_NAME = ".inbound";
  public static final String BOOTSTRAP_EVENT_STATS_SUFFIX_NAME = ".inbound.bs";
  public static final String RELAY_CONSUMER_STATS_SUFFIX_NAME = ".callback.relay";
  public static final String BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME = ".callback.bootstrap";
  public static final String UNIFIED_CLIENT_STATS_SUFFIX_NAME = ".callback.unified";

  public class Status extends DatabusComponentStatus
  {
    public Status()
    {
      super(getStatusName());
    }
  }

  // TODO:  nuke?  no Databus callers at all; is this a public (external) API?
  public DatabusV2RegistrationImpl(RegistrationId id,
                                   DatabusHttpClientImpl client)
  {
    this(id, client, client.getCheckpointPersistenceProvider(), null, null);
  }

  public DatabusV2RegistrationImpl(RegistrationId id,
                                   DatabusHttpClientImpl client,
                                   CheckpointPersistenceProvider ckptProvider)
  {
    this(id, client, ckptProvider, null, null);
  }


  // TODO:  make private?  no other Databus callers except two ctors above; is this a public (external) API?
  public DatabusV2RegistrationImpl(RegistrationId id,
                                   DatabusHttpClientImpl client,
                                   CheckpointPersistenceProvider ckptProvider,
                                   String[] sources,
                                   AbstractDatabusCombinedConsumer[] consumers)
  {
    _id = id;
    _status = new Status();
    _client = client;
    _checkpointPersistenceProvider = ckptProvider;
    _state = RegistrationState.INIT;
    _sources = new ArrayList<String>();
    _consumers = new ArrayList<DatabusCombinedConsumer>();
    _log = Logger.getLogger(getClass().getName() + (null  == _id ? "" : "." + _id.getId()));
    if ( null != sources)
      _sources.addAll(Arrays.asList(sources));
    if ( null != consumers)
      _consumers.addAll(Arrays.asList(consumers));
  }

  /**
   * Add sources to a given registration object
   * Adding an already existent subscription, will be a no-op.
   *
   * This does not create any new the DatabusRegistration object ( only modifies the current one ).
   * Hence the id of the registration remains the same
   *
   * @throws IllegalStateException if this registration has already been started.
   */
  public synchronized void addSubscriptions(String ... sources)
          throws IllegalStateException
  {
    if ( ! _state.isPreStartState())
      throw new IllegalStateException("Cannot add sources when state is running or shut down. Current State :" + _state);

    for (String s : sources)
      if (! _sources.contains(s))
        _sources.add(s);
  }

  /**
   * Remove subscriptions from a given registration object
   * Removing a non-existent subscription, will be a no-op.
   *
   * @throws IllegalStateException if this registration has already been started
   */
  public synchronized void removeSubscriptions(String ... sources)
          throws IllegalStateException
  {
       if ( ! _state.isRunning())
         throw new IllegalStateException("Cannot remove sources when state is running. Current State :" + _state);

       for (String s : sources)
         _sources.remove(s);
  }

  /**
   * Adds the specified consumers associated with this registration.
   * The added consumers will have the same subscription(s) and filter parameters as the other consumers
   * associated with this registration.
   */
  public synchronized void addDatabusConsumers(Collection<DatabusCombinedConsumer> consumers)
      throws IllegalStateException
  {
    if (! _state.isPreStartState())
      throw new IllegalStateException("Cannot add consumers when state is running/shutdown. Current State :" + _state);

    for (DatabusCombinedConsumer c : consumers)
      if (! _consumers.contains(c))
        _consumers.add(c);
  }

  /**
   * Removes the specified consumers associated with this registration.
   */
  public synchronized void removeDatabusConsumers(Collection<AbstractDatabusCombinedConsumer> consumers)
  {
    if (!_state.isRunning())
      throw new IllegalStateException("Cannot remove consumers when state is running. Current State :" + _state);

    _consumers.removeAll(consumers);
  }

  /**
   * Callback when registration is added to client Registration Set.
   * @param state
   */
  public synchronized void onRegister()
  {
    _state = RegistrationState.REGISTERED;
  }

  /**
   * Initialize Statistics Collectors
   */
  protected synchronized void initializeStatsCollectors()
  {
    MBeanServer mbeanServer =  null;

    if ( null != _client )
    {
      mbeanServer = _client.getMbeanServer();
    }

    int ownerId = null == _client ? -1 : _client.getContainerStaticConfig().getId();
    String regId = null != _id ? _id.getId() : "unknownReg";

    initializeStatsCollectors(regId, ownerId, mbeanServer);

    if (null != _client)
    {
      _client.getBootstrapEventsStats().addStatsCollector(regId, _bootstrapEventsStatsCollector );
      _client.getInBoundStatsCollectors().addStatsCollector(regId, _inboundEventsStatsCollector);
      _client.getRelayConsumerStatsCollectors().addStatsCollector(regId, _relayConsumerStats);
      _client.getBootstrapConsumerStatsCollectors().addStatsCollector(regId, _bootstrapConsumerStats);
      _client.getUnifiedClientStatsCollectors().addStatsCollector(regId, _unifiedClientStats);
    }
  }

  /**
   * Initialize Statistics Collectors
   */
  protected void initializeStatsCollectors(String regId, int ownerId, MBeanServer mbeanServer)
  {
    _inboundEventsStatsCollector =
        new DbusEventsStatisticsCollector(ownerId,
                                          regId + STREAM_EVENT_STATS_SUFFIX_NAME,
                                          true,
                                          false,
                                          mbeanServer);
    _bootstrapEventsStatsCollector =
        new DbusEventsStatisticsCollector(ownerId,
                                          regId + BOOTSTRAP_EVENT_STATS_SUFFIX_NAME,
                                          true,
                                          false,
                                          mbeanServer);
    _relayConsumerStats =
        new ConsumerCallbackStats(ownerId, regId + RELAY_CONSUMER_STATS_SUFFIX_NAME,
                                  regId, true, false, new ConsumerCallbackStatsEvent());
    _bootstrapConsumerStats =
        new ConsumerCallbackStats(ownerId, regId + BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME,
                                  regId, true, false, new ConsumerCallbackStatsEvent());
    _unifiedClientStats =
        new UnifiedClientStats(ownerId, regId + UNIFIED_CLIENT_STATS_SUFFIX_NAME,
                               regId, true, false,
                               _client.getClientStaticConfig().getPullerThreadDeadnessThresholdMs(),
                               new UnifiedClientStatsEvent());
  }

  @Override
  public synchronized boolean start()
       throws IllegalStateException, DatabusClientException
  {
    _log.info("Starting registration (" + toString() + ") !!");

    if (_state.isRunning())
    {
      _log.info("Registration (" + _id + ") already started !!");
      return false;
    }


    if ( _state != RegistrationState.REGISTERED)
      throw new IllegalStateException("Registration (" + _id + ") not in startable state !! Current State is :" + _state);

    if ( (null == _sources) || (_sources.isEmpty()))
      throw new DatabusClientException("Registration (" + _id + ") does not have any sources to start !!");

    if ( (null == _consumers) || (_consumers.isEmpty()))
      throw new DatabusClientException("Registration (" + _id + ") does not have any consumers to start !!");

    List<ServerInfo> relays = _client.getRelays();
    List<ServerInfo> bootstrapServers = _client.getBootstrapServices();

    List<DatabusCombinedConsumer> streamConsumers = new ArrayList<DatabusCombinedConsumer>();
    List<DatabusCombinedConsumer> bootstrapConsumers = new ArrayList<DatabusCombinedConsumer>();

    if ( (null == relays) || ( relays.isEmpty()))
      throw new DatabusClientException("No configured relays in the client to start");

    Set<ServerInfo> candidateRelays = new HashSet<ServerInfo>();

    for (ServerInfo s : relays)
    {
      if (canServe(s, _sources))
        candidateRelays.add(s);
    }

    if (candidateRelays.isEmpty())
      throw new DatabusClientException("No candidate relays for source : " + _sources);

    streamConsumers.addAll(_consumers);

    boolean canConsumerBootstrap = false;
    _streamConsumerRawRegistrations = new ArrayList<DatabusV2ConsumerRegistration>();
    _streamConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(streamConsumers, _sources, _filterConfig));

    for (DatabusCombinedConsumer c : _consumers)
    {
      if ( c.canBootstrap())
      {
        canConsumerBootstrap = true;
        bootstrapConsumers.add(c);
      }
    }

    boolean enableBootstrap = _client.getClientStaticConfig().getRuntime().getBootstrap().isEnabled();
    Set<ServerInfo> candidateBootstrapServers = new HashSet<ServerInfo>();

    if (enableBootstrap && canConsumerBootstrap)
    {
      if ( (null == bootstrapServers) || ( bootstrapServers.isEmpty()))
        throw new DatabusClientException("No configured bootstrap servers in the client to start");

      for (ServerInfo s : bootstrapServers)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/registration/DatabusV2RegistrationImpl.java;<<<<<<< MINE
    // TODO:  nuke?  no Databus callers at all; is this a public (external) API?
    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client)
    {
    	this(id, client, client.getCheckpointPersistenceProvider(), null, null);
    }

    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client,
                                     CheckpointPersistenceProvider ckptProvider)
    {
    	this(id, client, ckptProvider, null, null);
    }


    // TODO:  make private?  no other Databus callers except two ctors above; is this a public (external) API?
    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client,
                                     CheckpointPersistenceProvider ckptProvider,
                                     String[] sources,
                                     AbstractDatabusCombinedConsumer[] consumers)
    {
    	_id = id;
    	_status = new Status();
    	_client = client;
    	_checkpointPersistenceProvider = ckptProvider;
    	_state = RegistrationState.INIT;
    	_sources = new ArrayList<String>();
    	_consumers = new ArrayList<DatabusCombinedConsumer>();
        _log = Logger.getLogger(getClass().getName() +
                			(null  == _id ? "" : "." + _id.getId()));
        if ( null != sources)
        	_sources.addAll(Arrays.asList(sources));

    	if ( null != consumers)
    		_consumers.addAll(Arrays.asList(consumers));
    }

    /**
    *
    * Add sources to a given registration object
    * Adding an already existent subscription, will be a no-op.
    *
    * This does not create any new the DatabusRegistration object ( only modifies the current one ).
    * Hence the id of the registration remains the same
    *
    * @throws IllegalStateException if this registration has already been started.
    */
   public synchronized void addSubscriptions(String ... sources)
           throws IllegalStateException
   {
	   	if ( ! _state.isPreStartState())
	   		throw new IllegalStateException("Cannot add sources when state is running or shut down. Current State :" + _state);

	   	for (String s : sources)
	   		if (! _sources.contains(s))
	   			_sources.add(s);
   }

   /**
    *
    * Remove subscriptions from a given registration object
    * Removing a non-existent subscription, will be a no-op.
    *
    * @throws IllegalStateException if this registration has already been started
    */
   public synchronized void removeSubscriptions(String ... sources)
           throws IllegalStateException
   {
	   	if ( ! _state.isRunning())
	   		throw new IllegalStateException("Cannot remove sources when state is running. Current State :" + _state);

	   	for (String s : sources)
	   		_sources.remove(s);
   }

    /**
    *
    * Adds the specified consumers associated with this registration
    * The added consumers will have the same subscription(s) and filter parameters as the other consumers
    * associated with this registration
    *
    */
   public synchronized void addDatabusConsumers(Collection<DatabusCombinedConsumer> consumers)
   		throws IllegalStateException
   {
	   if (! _state.isPreStartState())
		   throw new IllegalStateException("Cannot add consumers when state is running/shutdown. Current State :" + _state);

	   for (DatabusCombinedConsumer c : consumers)
		   if (! _consumers.contains(c))
			   _consumers.add(c);
   }

   /**
    *
    * Removes the specified consumers associated with this registration.
    *
    **/
   public synchronized void removeDatabusConsumers(Collection<AbstractDatabusCombinedConsumer> consumers)
   {

	   if ( ! _state.isRunning())
		   throw new IllegalStateException("Cannot remove consumers when state is running. Current State :" + _state);

	   _consumers.removeAll(consumers);

   }

   /**
    * Callback when registration is added to client Registration Set.
    * @param state
    */
   public synchronized void onRegister()
   {
   	_state = RegistrationState.REGISTERED;
   }

    /**
     * Initialize Statistics Collectors
     */
    protected synchronized void initializeStatsCollectors()
    {
	  MBeanServer mbeanServer =  null;

      if ( null != _client )
	  {
	      mbeanServer = _client.getMbeanServer();
	  }

	  int ownerId = null == _client ? -1 : _client.getContainerStaticConfig().getId();
	  String regId = null != _id ? _id.getId() : "unknownReg";

	  initializeStatsCollectors(regId, ownerId, mbeanServer);

	  if (null != _client)
	  {
        _client.getBootstrapEventsStats().addStatsCollector(regId, _bootstrapEventsStatsCollector );
        _client.getInBoundStatsCollectors().addStatsCollector(regId, _inboundEventsStatsCollector);
        _client.getRelayConsumerStatsCollectors().addStatsCollector(regId, _relayConsumerStats);
        _client.getBootstrapConsumerStatsCollectors().addStatsCollector(regId, _bootstrapConsumerStats);
	  }
    }

    /**
     * Initialize Statistics Collectors
     */
    protected void initializeStatsCollectors(String regId, int ownerId, MBeanServer mbeanServer)
    {
	  _inboundEventsStatsCollector =
	      new DbusEventsStatisticsCollector(ownerId,
	                                        regId + STREAM_EVENT_STATS_SUFFIX_NAME,
	                                        true,
	                                        false,
	                                        mbeanServer);
	  _bootstrapEventsStatsCollector =
	      new DbusEventsStatisticsCollector(ownerId,
	                                        regId + BOOTSTRAP_EVENT_STATS_SUFFIX_NAME,
	                                        true,
	                                        false,
	                                        mbeanServer);
	  _relayConsumerStats =
	      new ConsumerCallbackStats(ownerId, regId + RELAY_CONSUMER_STATS_SUFFIX_NAME,
	                                regId, true, false, new ConsumerCallbackStatsEvent());
      _bootstrapConsumerStats =
          new ConsumerCallbackStats(ownerId, regId + BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME,
                                    regId, true, false, new ConsumerCallbackStatsEvent());
    }

	@Override
	public synchronized boolean start()
			 throws IllegalStateException, DatabusClientException
	{
		_log.info("Starting registration (" + toString() + ") !!");

		if (_state.isRunning())
		{
			_log.info("Registration (" + _id + ") already started !!");
			return false;
		}


		if ( _state != RegistrationState.REGISTERED)
			throw new IllegalStateException("Registration (" + _id + ") not in startable state !! Current State is :" + _state);

		if ( (null == _sources) || (_sources.isEmpty()))
			throw new DatabusClientException("Registration (" + _id + ") does not have any sources to start !!");

		if ( (null == _consumers) || (_consumers.isEmpty()))
			throw new DatabusClientException("Registration (" + _id + ") does not have any consumers to start !!");

		List<ServerInfo> relays = _client.getRelays();
		List<ServerInfo> bootstrapServers = _client.getBootstrapServices();

		List<DatabusCombinedConsumer> streamConsumers = new ArrayList<DatabusCombinedConsumer>();
		List<DatabusCombinedConsumer> bootstrapConsumers = new ArrayList<DatabusCombinedConsumer>();

		if ( (null == relays) || ( relays.isEmpty()))
			throw new DatabusClientException("No configured relays in the client to start");

		Set<ServerInfo> candidateRelays = new HashSet<ServerInfo>();

		for (ServerInfo s : relays)
		{
			if (canServe(s, _sources))
				candidateRelays.add(s);
		}

		if (candidateRelays.isEmpty())
			throw new DatabusClientException("No candidate relays for source : " + _sources);

		streamConsumers.addAll(_consumers);

		boolean canConsumerBootstrap = false;
		_streamConsumerRawRegistrations = new ArrayList<DatabusV2ConsumerRegistration>();
		_streamConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(streamConsumers, _sources, _filterConfig));

		for (DatabusCombinedConsumer c : _consumers)
		{
			if ( c.canBootstrap())
			{
				canConsumerBootstrap = true;
				bootstrapConsumers.add(c);
			}
		}

		boolean enableBootstrap = _client.getClientStaticConfig().getRuntime().getBootstrap().isEnabled();
		Set<ServerInfo> candidateBootstrapServers = new HashSet<ServerInfo>();

		if (enableBootstrap && canConsumerBootstrap)
		{
			if ( (null == bootstrapServers) || ( bootstrapServers.isEmpty()))
				throw new DatabusClientException("No configured bootstrap servers in the client to start");

			for (ServerInfo s : bootstrapServers)
			{
				if (canServe(s,_sources))
					candidateBootstrapServers.add(s);
			}

			if (candidateBootstrapServers.isEmpty())
				throw new DatabusClientException("No candidate bootstrap servers for source : " + _sources);

			_bootstrapConsumerRawRegistrations = new ArrayList<DatabusV2ConsumerRegistration>();;
			_bootstrapConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(bootstrapConsumers, _sources, _filterConfig));
		}

		// All validations done. Setup and start
		initializeStatsCollectors();

		DatabusSourcesConnection.StaticConfig connConfig =
				_client.getClientStaticConfig().getConnection(_sources);


		if (null == connConfig)
			connConfig = _client.getClientStaticConfig().getConnectionDefaults();

			DbusEventBuffer eventBuffer = null;
			{
			  DbusEventBuffer.StaticConfig cfg = connConfig.getEventBuffer();
			  eventBuffer = new DbusEventBuffer(cfg.getMaxSize(),
||||||| BASE
    // TODO:  nuke?  no Databus callers at all; is this a public (external) API?
    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client)
    {
    	this(id, client, client.getCheckpointPersistenceProvider(), null, null);
    }

    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client,
                                     CheckpointPersistenceProvider ckptProvider)
    {
    	this(id, client, ckptProvider, null, null);
    }


    // TODO:  make private?  no other Databus callers except two ctors above; is this a public (external) API?
    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client,
                                     CheckpointPersistenceProvider ckptProvider,
                                     String[] sources,
                                     AbstractDatabusCombinedConsumer[] consumers)
    {
    	_id = id;
    	_status = new Status();
    	_client = client;
    	_checkpointPersistenceProvider = ckptProvider;
    	_state = RegistrationState.INIT;
    	_sources = new ArrayList<String>();
    	_consumers = new ArrayList<DatabusCombinedConsumer>();
        _log = Logger.getLogger(getClass().getName() +
                			(null  == _id ? "" : "." + _id.getId()));
        if ( null != sources)
        	_sources.addAll(Arrays.asList(sources));

    	if ( null != consumers)
    		_consumers.addAll(Arrays.asList(consumers));

    	LoggingConsumer c = null;
    	try {
			c = new LoggingConsumer(client.getClientStaticConfig().getLoggingListener());
		} catch (InvalidConfigException e) {
			_log.error("Unable to instantiate logging consumer",e);
		}
    	_loggingConsumer = c;
    }

    /**
    *
    * Add sources to a given registration object
    * Adding an already existent subscription, will be a no-op.
    *
    * This does not create any new the DatabusRegistration object ( only modifies the current one ).
    * Hence the id of the registration remains the same
    *
    * @throws IllegalStateException if this registration has already been started.
    */
   public synchronized void addSubscriptions(String ... sources)
           throws IllegalStateException
   {
	   	if ( ! _state.isPreStartState())
	   		throw new IllegalStateException("Cannot add sources when state is running/shutdown. Current State :" + _state);

	   	for (String s : sources)
	   		if (! _sources.contains(s))
	   			_sources.add(s);
   }

   /**
    *
    * Remove subscriptions from a given registration object
    * Removing a non-existent subscription, will be a no-op.
    *
    * @throws IllegalStateException if this registration has already been started
    */
   public synchronized void removeSubscriptions(String ... sources)
           throws IllegalStateException
   {
	   	if ( ! _state.isRunning())
	   		throw new IllegalStateException("Cannot remove sources when state is running. Current State :" + _state);

	   	for (String s : sources)
	   		_sources.remove(s);
   }

    /**
    *
    * Adds the specified consumers associated with this registration
    * The added consumers will have the same subscription(s) and filter parameters as the other consumers
    * associated with this registration
    *
    */
   public synchronized void addDatabusConsumers(Collection<DatabusCombinedConsumer> consumers)
   		throws IllegalStateException
   {
	   if (! _state.isPreStartState())
		   throw new IllegalStateException("Cannot add consumers when state is running/shutdown. Current State :" + _state);

	   for (DatabusCombinedConsumer c : consumers)
		   if (! _consumers.contains(c))
			   _consumers.add(c);
   }

   /**
    *
    * Removes the specified consumers associated with this registration.
    *
    **/
   public synchronized void removeDatabusConsumers(Collection<AbstractDatabusCombinedConsumer> consumers)
   {

	   if ( ! _state.isRunning())
		   throw new IllegalStateException("Cannot remove consumers when state is running. Current State :" + _state);

	   _consumers.removeAll(consumers);

   }

   /**
    * Callback when registration is added to client Registration Set.
    * @param state
    */
   public synchronized void onRegister()
   {
   	_state = RegistrationState.REGISTERED;
   }

    /**
     * Initialize Statistics Collectors
     */
    protected synchronized void initializeStatsCollectors()
    {
	  MBeanServer mbeanServer =  null;

      if ( null != _client )
	  {
	      mbeanServer = _client.getMbeanServer();
	  }

	  int ownerId = null == _client ? -1 : _client.getContainerStaticConfig().getId();
	  String regId = null != _id ? _id.getId() : "unknownReg";

	  initializeStatsCollectors(regId, ownerId, mbeanServer);

	  if (null != _client)
	  {
        _client.getBootstrapEventsStats().addStatsCollector(regId, _bootstrapEventsStatsCollector );
        _client.getInBoundStatsCollectors().addStatsCollector(regId, _inboundEventsStatsCollector);
        _client.getRelayConsumerStatsCollectors().addStatsCollector(regId, _relayConsumerStats);
        _client.getBootstrapConsumerStatsCollectors().addStatsCollector(regId, _bootstrapConsumerStats);
	  }
    }

    /**
     * Initialize Statistics Collectors
     */
    protected void initializeStatsCollectors(String regId, int ownerId, MBeanServer mbeanServer)
    {
	  _inboundEventsStatsCollector =
	      new DbusEventsStatisticsCollector(ownerId,
	                                        regId + STREAM_EVENT_STATS_SUFFIX_NAME,
	                                        true,
	                                        false,
	                                        mbeanServer);
	  _bootstrapEventsStatsCollector =
	      new DbusEventsStatisticsCollector(ownerId,
	                                        regId + BOOTSTRAP_EVENT_STATS_SUFFIX_NAME,
	                                        true,
	                                        false,
	                                        mbeanServer);
	  _relayConsumerStats =
	      new ConsumerCallbackStats(ownerId, regId + RELAY_CONSUMER_STATS_SUFFIX_NAME,
	                                regId, true, false, new ConsumerCallbackStatsEvent());
      _bootstrapConsumerStats =
          new ConsumerCallbackStats(ownerId, regId + BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME,
                                    regId, true, false, new ConsumerCallbackStatsEvent());
    }

	@Override
	public synchronized boolean start()
			 throws IllegalStateException, DatabusClientException
	{
		_log.info("Starting registration (" + toString() + ") !!");

		if (_state.isRunning())
		{
			_log.info("Registration (" + _id + ") already started !!");
			return false;
		}


		if ( _state != RegistrationState.REGISTERED)
			throw new IllegalStateException("Registration (" + _id + ") not in startable state !! Current State is :" + _state);

		if ( (null == _sources) || (_sources.isEmpty()))
			throw new DatabusClientException("Registration (" + _id + ") does not have any sources to start !!");

		if ( (null == _consumers) || (_consumers.isEmpty()))
			throw new DatabusClientException("Registration (" + _id + ") does not have any consumers to start !!");

		List<ServerInfo> relays = _client.getRelays();
		List<ServerInfo> bootstrapServers = _client.getBootstrapServices();

		List<DatabusCombinedConsumer> streamConsumers = new ArrayList<DatabusCombinedConsumer>();
		List<DatabusCombinedConsumer> bootstrapConsumers = new ArrayList<DatabusCombinedConsumer>();

		if ( (null == relays) || ( relays.isEmpty()))
			throw new DatabusClientException("No configured relays in the client to start");

		Set<ServerInfo> candidateRelays = new HashSet<ServerInfo>();

		for (ServerInfo s : relays)
		{
			if (canServe(s, _sources))
				candidateRelays.add(s);
		}

		if (candidateRelays.isEmpty())
			throw new DatabusClientException("No candidate relays for source : " + _sources);

		streamConsumers.addAll(_consumers);

		boolean canConsumerBootstrap = false;
		_streamConsumerRawRegistrations = new ArrayList<DatabusV2ConsumerRegistration>();
		_streamConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(streamConsumers, _sources, _filterConfig));
		_streamConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(_loggingConsumer, _sources, _filterConfig));

		for (DatabusCombinedConsumer c : _consumers)
		{
			if ( c.canBootstrap())
			{
				canConsumerBootstrap = true;
				bootstrapConsumers.add(c);
			}
		}

		boolean enableBootstrap = _client.getClientStaticConfig().getRuntime().getBootstrap().isEnabled();
		Set<ServerInfo> candidateBootstrapServers = new HashSet<ServerInfo>();

		if (enableBootstrap && canConsumerBootstrap)
		{
			if ( (null == bootstrapServers) || ( bootstrapServers.isEmpty()))
				throw new DatabusClientException("No configured bootstrap servers in the client to start");

			for (ServerInfo s : bootstrapServers)
			{
				if (canServe(s,_sources))
					candidateBootstrapServers.add(s);
			}

			if (candidateBootstrapServers.isEmpty())
				throw new DatabusClientException("No candidate bootstrap servers for source : " + _sources);

			_bootstrapConsumerRawRegistrations = new ArrayList<DatabusV2ConsumerRegistration>();;
			_bootstrapConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(bootstrapConsumers, _sources, _filterConfig));
			_bootstrapConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(_loggingConsumer, _sources, _filterConfig));

		}

		// All validations done. Setup and start
		initializeStatsCollectors();

		DatabusSourcesConnection.StaticConfig connConfig =
				_client.getClientStaticConfig().getConnection(_sources);


		if (null == connConfig)
			connConfig = _client.getClientStaticConfig().getConnectionDefaults();

			DbusEventBuffer eventBuffer = null;
			{
			  DbusEventBuffer.StaticConfig cfg = connConfig.getEventBuffer();
			  eventBuffer = new DbusEventBuffer(cfg.getMaxSize(),
=======
    if (null == connConfig)
      connConfig = _client.getClientStaticConfig().getConnectionDefaults();

      DbusEventBuffer eventBuffer = null;
      {
        DbusEventBuffer.StaticConfig cfg = connConfig.getEventBuffer();
        eventBuffer = new DbusEventBuffer(cfg.getMaxSize(),
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/registration/DatabusV2RegistrationImpl.java;<<<<<<< MINE
		DatabusSourcesConnection sourcesConnection =
				  new DatabusSourcesConnection(
						  connConfig,
						  subs,
						  candidateRelays,
						  candidateBootstrapServers,
						  _streamConsumerRawRegistrations,
						  _bootstrapConsumerRawRegistrations,
						  eventBuffer,
						  bootstrapBuffer,
						  _client.getDefaultExecutorService(),
						  _client.getContainerStatsCollector(),
						  _inboundEventsStatsCollector,
						  _bootstrapEventsStatsCollector,
						  _relayConsumerStats,
						  _bootstrapConsumerStats,
						  _checkpointPersistenceProvider,
						  _client.getRelayConnFactory(),
						  _client.getBootstrapConnFactory(),
						  _client.getHttpStatsCollector(),
						  null, // This should make sure the checkpoint directory structure is compatible with V2.
						  _client,
						  _id.toString(), // Used to uniquely identify logs and mbean name
						  _client.getEventFactory(),
						  null,
						  connStateFactory);
		return sourcesConnection;
	}


	@Override
	public synchronized void shutdown() throws IllegalStateException
	{

		if (! _state.isRunning())
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in running state to be shutdown. Current state :" + _state);

		_sourcesConnection.unregisterMbeans();
		_sourcesConnection.stop();
		_status.shutdown();
		_state = RegistrationState.SHUTDOWN;

		// remove this registration stats from client stats Collector list.
		_client.getBootstrapEventsStats().removeStatsCollector(_id.getId());
	    _client.getInBoundStatsCollectors().removeStatsCollector(_id.getId());
	    _client.getRelayConsumerStatsCollectors().removeStatsCollector(_id.getId());
	    _client.getBootstrapConsumerStatsCollectors().removeStatsCollector(_id.getId());
	}

	@Override
	public synchronized void pause() throws IllegalStateException
	{

		if ( _state == RegistrationState.PAUSED)
			return;

		if ( (_state != RegistrationState.STARTED) && ( _state != RegistrationState.RESUMED))
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be paused. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().pause();
		_status.pause();
		_state = RegistrationState.PAUSED;

	}

	@Override
	public synchronized void suspendOnError(Throwable ex) throws IllegalStateException
	{
		if ( _state == RegistrationState.SUSPENDED_ON_ERROR)
			return;

		if ( !_state.isRunning())
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be suspended. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().suspendOnError(ex);
		_status.suspendOnError(ex);
		_state = RegistrationState.SUSPENDED_ON_ERROR;

	}

	@Override
	public synchronized void resume() throws IllegalStateException
	{
		if ( _state == RegistrationState.RESUMED)
			return;

		if ( (_state != RegistrationState.PAUSED) && ( _state != RegistrationState.SUSPENDED_ON_ERROR))
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be resumed. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().resume();
		_status.resume();
		_state = RegistrationState.RESUMED;
	}

	@Override
	public RegistrationState getState() {
		return _state;
	}

	@Override
	public synchronized boolean deregister()
			throws IllegalStateException
	{
		if ((_state == RegistrationState.DEREGISTERED) || (_state == RegistrationState.INIT))
			return false;

		if ( _state.isRunning())
			shutdown();

		deregisterFromClient();
		_state = RegistrationState.DEREGISTERED;

		return true;
	}

	protected void deregisterFromClient()
	{
		_client.deregister(this);
	}


	@Override
	public Collection<DatabusSubscription> getSubscriptions()
	{
		return DatabusSubscription.createSubscriptionList(_sources);
	}

	@Override
	public synchronized DatabusComponentStatus getStatus()
	{
		return _status;
	}

	@Override
	public synchronized Logger getLogger() {
		return _log;
	}

	@Override
	public DatabusRegistration getParent() {
		return _parent;
	}


	protected void setParent(DatabusRegistration parent) {
		_parent = parent;
	}

	@Override
	public synchronized DatabusRegistration withRegId(RegistrationId regId)
			throws DatabusClientException, IllegalStateException
	{
		if ( (_id != null) && (_id.equals(regId)))
			return this;

		if (! RegistrationIdGenerator.isIdValid(regId))
			throw new DatabusClientException("Another registration with the same regId (" + regId + ") already present !!");

		if (_state.isRunning())
			throw new IllegalStateException("Cannot update regId when registration is in running state. RegId :" + _id + ", State :" + _state);

		_id = regId;
		_status = new Status(); // Component Status should use the correct component name

		return this;
	}


	@Override
	public synchronized DatabusRegistration withServerSideFilter(
			DbusKeyCompositeFilterConfig filterConfig)
			throws IllegalStateException
	{

		if (_state.isRunning())
			throw new IllegalStateException("Cannot update server-side filter when registration is in running state. RegId :" + _id
					+ ", State :" + _state);

		_filterConfig = filterConfig;
		return this;
	}

	@Override
	public List<DbusPartitionInfo> getPartitions() {
		return null;
	}

	@Override
	public Checkpoint getLastPersistedCheckpoint()
	{
		Checkpoint cp =_checkpointPersistenceProvider.loadCheckpoint(_sources);
		return cp;
	}

	@Override
	public synchronized boolean storeCheckpoint(Checkpoint ckpt)
			throws IllegalStateException
	{
		try
		{
			_checkpointPersistenceProvider.storeCheckpoint(_sources, ckpt);
		} catch (IOException ioe) {
			_log.error("Storing checkpoint failed with exception", ioe);
			return false;
		}
		return true;
	}

	@Override
	public DbusEventsStatisticsCollectorMBean getRelayEventStats()
	{
		return _inboundEventsStatsCollector;
	}

	@Override
	public DbusEventsStatisticsCollectorMBean getBootstrapEventStats()
	{
		return _bootstrapEventsStatsCollector;
	}

	@Override
	public ConsumerCallbackStatsMBean getRelayCallbackStats()
	{
		return _relayConsumerStats;
	}

	@Override
	public ConsumerCallbackStatsMBean getBootstrapCallbackStats()
	{
		return _bootstrapConsumerStats;
	}

	@Override
	public RelayFindMaxSCNResult fetchMaxSCN(FetchMaxSCNRequest request)
			throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}

	@Override
	public RelayFlushMaxSCNResult flush(RelayFindMaxSCNResult fetchSCNResult,
			FlushRequest flushRequest) throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}

	@Override
	public RelayFlushMaxSCNResult flush(FetchMaxSCNRequest maxScnRequest,
			FlushRequest flushRequest) throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}


	protected synchronized String getStatusName()
	{
	  return "Status" + ((_id != null ) ? "_" + _id.getId() : "");
	}

	private static boolean canServe(ServerInfo s, Collection<String> sources)
	{
		List<String> supportedSources = s.getSources();

		for (String src : sources)
		{
			if (! supportedSources.contains(src))
				return false;
		}

		return true;
	}


	@Override
	public synchronized RegistrationId getRegistrationId() {
		return _id;
	}

	@Override
	public synchronized String toString() {
		return "DatabusV2RegistrationImpl [_state=" + _state + ", _id=" + _id
				+ ", _sources=" + _sources + ", _status=" + _status
				+ ", _filterConfig=" + _filterConfig
				+ ", _streamConsumerRawRegistrations="
				+ _streamConsumerRawRegistrations
				+ ", _bootstrapConsumerRawRegistrations="
				+ _bootstrapConsumerRawRegistrations + "]";
	}

	@Override
	public synchronized DbusKeyCompositeFilterConfig getFilterConfig() {
		return _filterConfig;
	}
||||||| BASE
		DatabusSourcesConnection sourcesConnection =
				  new DatabusSourcesConnection(
						  connConfig,
						  subs,
						  candidateRelays,
						  candidateBootstrapServers,
						  _streamConsumerRawRegistrations,
						  _bootstrapConsumerRawRegistrations,
						  eventBuffer,
						  bootstrapBuffer,
						  _client.getDefaultExecutorService(),
						  _client.getContainerStatsCollector(),
						  _inboundEventsStatsCollector,
						  _bootstrapEventsStatsCollector,
						  _relayConsumerStats,
						  _bootstrapConsumerStats,
						  _checkpointPersistenceProvider,
						  _client.getRelayConnFactory(),
						  _client.getBootstrapConnFactory(),
						  _client.getHttpStatsCollector(),
						  null, // This should make sure the checkpoint directory structure is compatible with V2.
						  _client,
						  _id.toString(), // Used to uniquely identify logs and mbean name
						  _client.getEventFactory(),
						  null,
						  connStateFactory);
		return sourcesConnection;
	}


	@Override
	public synchronized void shutdown() throws IllegalStateException
	{

		if (! _state.isRunning())
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in running state to be shutdown. Current state :" + _state);

		_sourcesConnection.unregisterMbeans();
		_sourcesConnection.stop();
		_status.shutdown();
		_state = RegistrationState.SHUTDOWN;

		// remove this registration stats from client stats Collector list.
		_client.getBootstrapEventsStats().removeStatsCollector(_id.getId());
	    _client.getInBoundStatsCollectors().removeStatsCollector(_id.getId());
	    _client.getRelayConsumerStatsCollectors().removeStatsCollector(_id.getId());
	    _client.getBootstrapConsumerStatsCollectors().removeStatsCollector(_id.getId());
	}

	@Override
	public synchronized void pause() throws IllegalStateException
	{

		if ( _state == RegistrationState.PAUSED)
			return;

		if ( (_state != RegistrationState.STARTED) && ( _state != RegistrationState.RESUMED))
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be paused. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().pause();
		_status.pause();
		_state = RegistrationState.PAUSED;

	}

	@Override
	public synchronized void suspendOnError(Throwable ex) throws IllegalStateException
	{
		if ( _state == RegistrationState.SUSPENDED_ON_ERROR)
			return;

		if ( !_state.isRunning())
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be suspended. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().suspendOnError(ex);
		_status.suspendOnError(ex);
		_state = RegistrationState.SUSPENDED_ON_ERROR;

	}

	@Override
	public synchronized void resume() throws IllegalStateException
	{
		if ( _state == RegistrationState.RESUMED)
			return;

		if ( (_state != RegistrationState.PAUSED) && ( _state != RegistrationState.SUSPENDED_ON_ERROR))
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be resumed. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().resume();
		_status.resume();
		_state = RegistrationState.RESUMED;
	}

	@Override
	public RegistrationState getState() {
		return _state;
	}

	@Override
	public synchronized boolean deregister()
			throws IllegalStateException
	{
		if ((_state == RegistrationState.DEREGISTERED) || (_state == RegistrationState.INIT))
			return false;

		if ( _state.isRunning())
			shutdown();

		deregisterFromClient();
		_state = RegistrationState.DEREGISTERED;

		return true;
	}

	protected void deregisterFromClient()
	{
		_client.deregister(this);
	}


	@Override
	public Collection<DatabusSubscription> getSubscriptions()
	{
		return DatabusSubscription.createSubscriptionList(_sources);
	}

	@Override
	public synchronized DatabusComponentStatus getStatus()
	{
		return _status;
	}

	@Override
	public synchronized Logger getLogger() {
		return _log;
	}

	@Override
	public DatabusRegistration getParent() {
		return _parent;
	}


	protected void setParent(DatabusRegistration parent) {
		_parent = parent;
	}

	@Override
	public synchronized DatabusRegistration withRegId(RegistrationId regId)
			throws DatabusClientException, IllegalStateException
	{
		if ( (_id != null) && (_id.equals(regId)))
			return this;

		if (! RegistrationIdGenerator.isIdValid(regId))
			throw new DatabusClientException("Another registration with the same regId (" + regId + ") already present !!");

		if (_state.isRunning())
			throw new IllegalStateException("Cannot update regId when registration is in running state. RegId :" + _id + ", State :" + _state);

		_id = regId;
		_status = new Status(); // Component Status should use the correct component name

		return this;
	}


	@Override
	public synchronized DatabusRegistration withServerSideFilter(
			DbusKeyCompositeFilterConfig filterConfig)
			throws IllegalStateException
	{

		if (_state.isRunning())
			throw new IllegalStateException("Cannot update server-side filter when registration is in running state. RegId :" + _id
					+ ", State :" + _state);

		_filterConfig = filterConfig;
		return this;
	}

	@Override
	public List<DbusPartitionInfo> getPartitions() {
		return null;
	}

	@Override
	public Checkpoint getLastPersistedCheckpoint()
	{
		Checkpoint cp =_checkpointPersistenceProvider.loadCheckpoint(_sources);
		return cp;
	}

	@Override
	public synchronized boolean storeCheckpoint(Checkpoint ckpt)
			throws IllegalStateException
	{
		try
		{
			_checkpointPersistenceProvider.storeCheckpoint(_sources, ckpt);
		} catch (IOException ioe) {
			_log.error("Storing checkpoint failed with exception", ioe);
			return false;
		}
		return true;
	}

	@Override
	public DbusEventsStatisticsCollectorMBean getRelayEventStats()
	{
		return _inboundEventsStatsCollector;
	}

	@Override
	public DbusEventsStatisticsCollectorMBean getBootstrapEventStats()
	{
		return _bootstrapEventsStatsCollector;
	}

	@Override
	public ConsumerCallbackStatsMBean getRelayCallbackStats()
	{
		return _relayConsumerStats;
	}

	@Override
	public ConsumerCallbackStatsMBean getBootstrapCallbackStats()
	{
		return _bootstrapConsumerStats;
	}

	@Override
	public RelayFindMaxSCNResult fetchMaxSCN(FetchMaxSCNRequest request)
			throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}

	@Override
	public RelayFlushMaxSCNResult flush(RelayFindMaxSCNResult fetchSCNResult,
			FlushRequest flushRequest) throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}

	@Override
	public RelayFlushMaxSCNResult flush(FetchMaxSCNRequest maxScnRequest,
			FlushRequest flushRequest) throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}


	protected synchronized String getStatusName()
	{
	  return "Status" + ((_id != null ) ? "_" + _id.getId() : "");
	}

	private static boolean canServe(ServerInfo s, Collection<String> sources)
	{
		List<String> supportedSources = s.getSources();

		for (String src : sources)
		{
			if (! supportedSources.contains(src))
				return false;
		}

		return true;
	}


	@Override
	public synchronized RegistrationId getRegistrationId() {
		return _id;
	}

	@Override
	public synchronized String toString() {
		return "DatabusV2RegistrationImpl [_state=" + _state + ", _id=" + _id
				+ ", _sources=" + _sources + ", _status=" + _status
				+ ", _filterConfig=" + _filterConfig
				+ ", _streamConsumerRawRegistrations="
				+ _streamConsumerRawRegistrations
				+ ", _bootstrapConsumerRawRegistrations="
				+ _bootstrapConsumerRawRegistrations + "]";
	}

	@Override
	public synchronized DbusKeyCompositeFilterConfig getFilterConfig() {
		return _filterConfig;
	}

	public LoggingConsumer getLoggingConsumer() {
		return _loggingConsumer;
	}
=======
    DatabusSourcesConnection sourcesConnection =
          new DatabusSourcesConnection(
              connConfig,
              subs,
              candidateRelays,
              candidateBootstrapServers,
              _streamConsumerRawRegistrations,
              _bootstrapConsumerRawRegistrations,
              eventBuffer,
              bootstrapBuffer,
              _client.getDefaultExecutorService(),
              _client.getContainerStatsCollector(),
              _inboundEventsStatsCollector,
              _bootstrapEventsStatsCollector,
              _relayConsumerStats,
              _bootstrapConsumerStats,
              _unifiedClientStats,
              _checkpointPersistenceProvider,
              _client.getRelayConnFactory(),
              _client.getBootstrapConnFactory(),
              _client.getHttpStatsCollector(),
              null, // This should make sure the checkpoint directory structure is compatible with V2.
              _client,
              _id.toString(), // Used to uniquely identify logs and mbean name
              _client.getEventFactory(),
              null,
              connStateFactory);
    return sourcesConnection;
  }

  @Override
  public synchronized void shutdown() throws IllegalStateException
  {
    if (! _state.isRunning())
      throw new IllegalStateException(
          "Registration (" + _id + ") is not in running state to be shutdown. Current state :" + _state);

    _sourcesConnection.unregisterMbeans();
    _sourcesConnection.stop();
    _status.shutdown();
    _state = RegistrationState.SHUTDOWN;

    // remove this registration stats from client stats Collector list.
    _client.getBootstrapEventsStats().removeStatsCollector(_id.getId());
    _client.getInBoundStatsCollectors().removeStatsCollector(_id.getId());
    _client.getRelayConsumerStatsCollectors().removeStatsCollector(_id.getId());
    _client.getBootstrapConsumerStatsCollectors().removeStatsCollector(_id.getId());
    _client.getUnifiedClientStatsCollectors().removeStatsCollector(_id.getId());
  }

  @Override
  public synchronized void pause() throws IllegalStateException
  {
    if ( _state == RegistrationState.PAUSED)
      return;

    if ( (_state != RegistrationState.STARTED) && ( _state != RegistrationState.RESUMED))
      throw new IllegalStateException(
          "Registration (" + _id + ") is not in correct state to be paused. Current state :" + _state);

    _sourcesConnection.getConnectionStatus().pause();
    _status.pause();
    _state = RegistrationState.PAUSED;
  }

  @Override
  public synchronized void suspendOnError(Throwable ex) throws IllegalStateException
  {
    if ( _state == RegistrationState.SUSPENDED_ON_ERROR)
      return;

    if ( !_state.isRunning())
      throw new IllegalStateException(
          "Registration (" + _id + ") is not in correct state to be suspended. Current state :" + _state);

    _sourcesConnection.getConnectionStatus().suspendOnError(ex);
    _status.suspendOnError(ex);
    _state = RegistrationState.SUSPENDED_ON_ERROR;
  }

  @Override
  public synchronized void resume() throws IllegalStateException
  {
    if ( _state == RegistrationState.RESUMED)
      return;

    if ( (_state != RegistrationState.PAUSED) && ( _state != RegistrationState.SUSPENDED_ON_ERROR))
      throw new IllegalStateException(
          "Registration (" + _id + ") is not in correct state to be resumed. Current state :" + _state);

    _sourcesConnection.getConnectionStatus().resume();
    _status.resume();
    _state = RegistrationState.RESUMED;
  }

  @Override
  public RegistrationState getState()
  {
    return _state;
  }

  @Override
  public synchronized boolean deregister()
      throws IllegalStateException
  {
    if ((_state == RegistrationState.DEREGISTERED) || (_state == RegistrationState.INIT))
      return false;

    if ( _state.isRunning())
      shutdown();

    deregisterFromClient();
    _state = RegistrationState.DEREGISTERED;

    return true;
  }

  protected void deregisterFromClient()
  {
    _client.deregister(this);
  }


  @Override
  public Collection<DatabusSubscription> getSubscriptions()
  {
    return DatabusSubscription.createSubscriptionList(_sources);
  }

  @Override
  public synchronized DatabusComponentStatus getStatus()
  {
    return _status;
  }

  @Override
  public synchronized Logger getLogger()
  {
    return _log;
  }

  @Override
  public DatabusRegistration getParent()
  {
    return _parent;
  }


  protected void setParent(DatabusRegistration parent)
  {
    _parent = parent;
  }

  @Override
  public synchronized DatabusRegistration withRegId(RegistrationId regId)
      throws DatabusClientException, IllegalStateException
  {
    if ( (_id != null) && (_id.equals(regId)))
      return this;

    if (! RegistrationIdGenerator.isIdValid(regId))
      throw new DatabusClientException("Another registration with the same regId (" + regId + ") already present !!");

    if (_state.isRunning())
      throw new IllegalStateException("Cannot update regId when registration is in running state. RegId :" + _id + ", State :" + _state);

    _id = regId;
    _status = new Status(); // Component Status should use the correct component name

    return this;
  }


  @Override
  public synchronized DatabusRegistration withServerSideFilter(DbusKeyCompositeFilterConfig filterConfig)
      throws IllegalStateException
  {
    if (_state.isRunning())
      throw new IllegalStateException("Cannot update server-side filter when registration is in running state. RegId :" + _id
          + ", State :" + _state);

    _filterConfig = filterConfig;
    return this;
  }

  @Override
  public List<DbusPartitionInfo> getPartitions()
  {
    return null;
  }

  @Override
  public Checkpoint getLastPersistedCheckpoint()
  {
    Checkpoint cp =_checkpointPersistenceProvider.loadCheckpoint(_sources);
    return cp;
  }

  @Override
  public synchronized boolean storeCheckpoint(Checkpoint ckpt)
      throws IllegalStateException
  {
    try
    {
      _checkpointPersistenceProvider.storeCheckpoint(_sources, ckpt);
    } catch (IOException ioe) {
      _log.error("Storing checkpoint failed with exception", ioe);
      return false;
    }
    return true;
  }

  @Override
  public DbusEventsStatisticsCollectorMBean getRelayEventStats()
  {
    return _inboundEventsStatsCollector;
  }

  @Override
  public DbusEventsStatisticsCollectorMBean getBootstrapEventStats()
  {
    return _bootstrapEventsStatsCollector;
  }

  @Override
  public ConsumerCallbackStatsMBean getRelayCallbackStats()
  {
    return _relayConsumerStats;
  }

  @Override
  public ConsumerCallbackStatsMBean getBootstrapCallbackStats()
  {
    return _bootstrapConsumerStats;
  }

  @Override
  public UnifiedClientStatsMBean getUnifiedClientStats()
  {
    return _unifiedClientStats;
  }

  @Override
  public RelayFindMaxSCNResult fetchMaxSCN(FetchMaxSCNRequest request)
      throws InterruptedException
  {
    throw new RuntimeException("Not yet supported !!");
  }

  @Override
  public RelayFlushMaxSCNResult flush(RelayFindMaxSCNResult fetchSCNResult,
                                      FlushRequest flushRequest)
  throws InterruptedException
  {
    throw new RuntimeException("Not yet supported !!");
  }

  @Override
  public RelayFlushMaxSCNResult flush(FetchMaxSCNRequest maxScnRequest,
                                      FlushRequest flushRequest)
  throws InterruptedException
  {
    throw new RuntimeException("Not yet supported !!");
  }


  protected synchronized String getStatusName()
  {
    return "Status" + ((_id != null ) ? "_" + _id.getId() : "");
  }

  private static boolean canServe(ServerInfo s, Collection<String> sources)
  {
    List<String> supportedSources = s.getSources();

    for (String src : sources)
    {
      if (! supportedSources.contains(src))
        return false;
    }

    return true;
  }


  @Override
  public synchronized RegistrationId getRegistrationId()
  {
    return _id;
  }

  @Override
  public synchronized String toString()
  {
    return "DatabusV2RegistrationImpl [_state=" + _state + ", _id=" + _id
        + ", _sources=" + _sources + ", _status=" + _status
        + ", _filterConfig=" + _filterConfig
        + ", _streamConsumerRawRegistrations="
        + _streamConsumerRawRegistrations
        + ", _bootstrapConsumerRawRegistrations="
        + _bootstrapConsumerRawRegistrations + "]";
  }

  @Override
  public synchronized DbusKeyCompositeFilterConfig getFilterConfig()
  {
    return _filterConfig;
  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/ClusterFileLoggingClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/ClusterFileLoggingClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/ClusterFileLoggingClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/monitoring/RegistrationStatsInfo.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/RelayDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  public synchronized void registerDatabusStreamListener(
		  					DatabusStreamConsumer[] listeners,
                            List<String> sources,
                            DbusKeyCompositeFilterConfig filterConfig)
          throws DatabusClientException
  {
	  List<DatabusStreamConsumer> listenersList = Arrays.asList(listeners);
	  List<SelectingDatabusCombinedConsumer> sdccListenersList =
			  SelectingDatabusCombinedConsumerFactory.convertListOfStreamConsumers(listenersList);
	  List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
	  for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
	  {
		  dccListenersList.add(sdcc);
	  }

	  DatabusV2ConsumerRegistration consumerReg =
	      new DatabusV2ConsumerRegistration(dccListenersList, sources, filterConfig);

	  registerDatabusListener(consumerReg, _relayGroups, getRelayGroupStreamConsumers(),
	                          DatabusSubscription.createSubscriptionList(sources));
||||||| BASE
  public synchronized void registerDatabusStreamListener(
		  					DatabusStreamConsumer[] listeners,
                            List<String> sources,
                            DbusKeyCompositeFilterConfig filterConfig)
          throws DatabusClientException
  {
	  List<DatabusStreamConsumer> listenersList = Arrays.asList(listeners);
	  List<SelectingDatabusCombinedConsumer> sdccListenersList =
			  SelectingDatabusCombinedConsumerFactory.convertListOfStreamConsumers(listenersList);
	  List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
	  for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
	  {
		  dccListenersList.add(sdcc);
	  }

	  DatabusV2ConsumerRegistration consumerReg =
	      new DatabusV2ConsumerRegistration(dccListenersList, sources, filterConfig);

	  List<DatabusV2ConsumerRegistration> consumers =
	      registerDatabusListener(consumerReg, _relayGroups, getRelayGroupStreamConsumers(), DatabusSubscription.createSubscriptionList(sources));

	  if (1 == consumers.size())
	  {
	    DatabusStreamConsumer logConsumer = listeners[0];
	    if(! (logConsumer instanceof LoggingConsumer)) {
	      // create a new Logging consumer for this list of consumers
	      try {
	        logConsumer = new LoggingConsumer(_clientStaticConfig.getLoggingListener());
	      } catch (InvalidConfigException e) {
	        throw new DatabusClientException(e);
	      }
	      SelectingDatabusCombinedConsumer sdccLogConsumer = new SelectingDatabusCombinedConsumer(logConsumer);
	      DatabusV2ConsumerRegistration loggingReg =
	          new DatabusV2ConsumerRegistration(sdccLogConsumer,	sources,filterConfig);
	      consumers.add(loggingReg);
	    }
	  }
=======
  public synchronized void registerDatabusStreamListener(DatabusStreamConsumer[] listeners,
                                                         List<String> sources,
                                                         DbusKeyCompositeFilterConfig filterConfig)
  throws DatabusClientException
  {
    List<DatabusStreamConsumer> listenersList = Arrays.asList(listeners);
    List<SelectingDatabusCombinedConsumer> sdccListenersList =
        SelectingDatabusCombinedConsumerFactory.convertListOfStreamConsumers(listenersList);
    List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
    for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
    {
      dccListenersList.add(sdcc);
    }

    DatabusV2ConsumerRegistration consumerReg =
        new DatabusV2ConsumerRegistration(dccListenersList, sources, filterConfig);

    registerDatabusListener(consumerReg, _relayGroups, getRelayGroupStreamConsumers(),
                            DatabusSubscription.createSubscriptionList(sources));
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
		List<DatabusBootstrapConsumer> listenersList = Arrays.asList(listeners);
		List<SelectingDatabusCombinedConsumer> sdccListenersList =
				SelectingDatabusCombinedConsumerFactory.convertListOfBootstrapConsumers(listenersList);
		List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
		for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
		{
			dccListenersList.add(sdcc);
		}

		DatabusV2ConsumerRegistration consumerReg =
				new DatabusV2ConsumerRegistration(dccListenersList, sources, filter);

		registerDatabusListener(consumerReg, _relayGroups, getRelayGroupBootstrapConsumers(),
		                        DatabusSubscription.createSubscriptionList(sources));
||||||| BASE
		List<DatabusBootstrapConsumer> listenersList = Arrays.asList(listeners);
		List<SelectingDatabusCombinedConsumer> sdccListenersList =
				SelectingDatabusCombinedConsumerFactory.convertListOfBootstrapConsumers(listenersList);
		List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
		for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
		{
			dccListenersList.add(sdcc);
		}

		DatabusV2ConsumerRegistration consumerReg =
				new DatabusV2ConsumerRegistration(dccListenersList, sources, filter);

		List<DatabusV2ConsumerRegistration> consumers =
				registerDatabusListener(consumerReg, _relayGroups, getRelayGroupBootstrapConsumers(),
						DatabusSubscription.createSubscriptionList(sources));
		if (1 == consumers.size())
		{
		  DatabusBootstrapConsumer logConsumer = listeners[0];
		  if(! (logConsumer instanceof LoggingConsumer)) {
		    // create a new Logging consumer for this list of consumers
		    try {
          logConsumer = new LoggingConsumer(_clientStaticConfig.getLoggingListener());
        } catch (InvalidConfigException e) {
          throw new DatabusClientException(e);
        }
		    SelectingDatabusCombinedConsumer sdccLogConsumer = new SelectingDatabusCombinedConsumer(logConsumer);
		    DatabusV2ConsumerRegistration loggerReg =
		        new DatabusV2ConsumerRegistration(sdccLogConsumer, sources, filter);
		    consumers.add(loggerReg);
		  }
		}
=======
    List<DatabusBootstrapConsumer> listenersList = Arrays.asList(listeners);
    List<SelectingDatabusCombinedConsumer> sdccListenersList =
        SelectingDatabusCombinedConsumerFactory.convertListOfBootstrapConsumers(listenersList);
    List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
    for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
    {
      dccListenersList.add(sdcc);
    }

    DatabusV2ConsumerRegistration consumerReg =
        new DatabusV2ConsumerRegistration(dccListenersList, sources, filter);

    registerDatabusListener(consumerReg, _relayGroups, getRelayGroupBootstrapConsumers(),
                            DatabusSubscription.createSubscriptionList(sources));
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusSourcesConnection.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusSourcesConnection.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusSourcesConnection.java;<<<<<<< MINE
public class DatabusSourcesConnection {
	public static final int MAX_QUEUED_MESSAGES = 10;
	public static final long MESSAGE_QUEUE_POLL_TIMEOUT_MS = 100;
	public static final int MAX_CONNECT_RETRY_NUM = 3;
	public static final long CONNECT_TIMEOUT_MS = 100;
	public static final long REGISTER_TIMEOUT_MS = 1000;

	public final Logger _log;
	private final String _name;
	private final DatabusSourcesConnection.StaticConfig _connectionConfig;
	private final List<DatabusSubscription> _subscriptions;
	private final RelayPullThread _relayPuller;
	private final GenericDispatcher<DatabusCombinedConsumer> _relayDispatcher;
	private final BootstrapPullThread _bootstrapPuller;
	private final GenericDispatcher<DatabusCombinedConsumer> _bootstrapDispatcher;
	private final DbusEventBuffer _dataEventsBuffer;
	private final DbusEventBuffer _bootstrapEventsBuffer;
	private final ExecutorService _ioThreadPool;
	private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
	private final ContainerStatisticsCollector _containerStatisticsCollector;
	/** Statistics collector about databus events */
	private final DbusEventsStatisticsCollector _inboundEventsStatsCollector;
	private final DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;

	private final HttpStatisticsCollector _relayCallsStatsCollector;
	private final HttpStatisticsCollector _localRelayCallsStatsCollector;
	private final DatabusRelayConnectionFactory _relayConnFactory;
	private final DatabusBootstrapConnectionFactory _bootstrapConnFactory;
	private final List<DatabusV2ConsumerRegistration> _relayRegistrations;
	private final ConsumerCallbackStats _relayConsumerStats;
	private final ConsumerCallbackStats _bootstrapConsumerStats;
	private final NannyRunnable _nannyRunnable;
	private final DbusEventFactory _eventFactory;
	private final ConnectionStateFactory _connStateFactory;

	private final List<DatabusV2ConsumerRegistration> _bootstrapRegistrations;
	private final SourcesConnectionStatus _connectionStatus;

	private UncaughtExceptionTrackingThread _relayPullerThread;
	private UncaughtExceptionTrackingThread _relayDispatcherThread;
	private UncaughtExceptionTrackingThread _bootstrapPullerThread;
	private UncaughtExceptionTrackingThread _bootstrapDispatcherThread;
	private final Thread _messageQueuesMonitorThread;
	private Thread _nannyThread;
	private ExecutorService _consumerCallbackExecutor;

	private final boolean _isBootstrapEnabled;
	private final RegistrationId _registrationId;
	private ReentrantLock _v3BootstrapLock = null;

	public ExecutorService getIoThreadPool() {
		return _ioThreadPool;
	}

    public DatabusSourcesConnection(StaticConfig connConfig,
       List<DatabusSubscription> subscriptions,
       Set<ServerInfo> relays,
       Set<ServerInfo> bootstrapServices,
       List<DatabusV2ConsumerRegistration> registrations,
       List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
       DbusEventBuffer dataEventsBuffer,
       DbusEventBuffer bootstrapEventsBuffer,
       ExecutorService ioThreadPool,
       ContainerStatisticsCollector containerStatsCollector,
       DbusEventsStatisticsCollector inboundEventsStatsCollector,
       DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
       ConsumerCallbackStats relayCallbackStats,
       ConsumerCallbackStats bootstrapCallbackStats,
       CheckpointPersistenceProvider checkpointPersistenceProvider,
       DatabusRelayConnectionFactory relayConnFactory,
       DatabusBootstrapConnectionFactory bootstrapConnFactory,
       HttpStatisticsCollector relayCallsStatsCollector,
       RegistrationId registrationId,
       DatabusHttpClientImpl serverHandle,
       DbusEventFactory eventFactory)
    {
      this(connConfig,
          subscriptions,
          relays,
          bootstrapServices,
          registrations,
          bootstrapRegistrations,
          dataEventsBuffer,
          bootstrapEventsBuffer,
          ioThreadPool,
          containerStatsCollector,
          inboundEventsStatsCollector,
          bootstrapEventsStatsCollector,
          relayCallbackStats,
          bootstrapCallbackStats,
          checkpointPersistenceProvider,
          relayConnFactory,
          bootstrapConnFactory,
          relayCallsStatsCollector,
          registrationId,
          serverHandle,
          registrationId != null ? registrationId.toString() : null,
          eventFactory,
          null,
    null);
    }

	public DatabusSourcesConnection(StaticConfig connConfig,
					List<DatabusSubscription> subscriptions,
					Set<ServerInfo> relays,
					Set<ServerInfo> bootstrapServices,
					List<DatabusV2ConsumerRegistration> registrations,
					List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
					DbusEventBuffer dataEventsBuffer,
					DbusEventBuffer bootstrapEventsBuffer,
					ExecutorService ioThreadPool,
					ContainerStatisticsCollector containerStatsCollector,
					DbusEventsStatisticsCollector inboundEventsStatsCollector,
					DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
					ConsumerCallbackStats relayCallbackStats,
					ConsumerCallbackStats bootstrapCallbackStats,
					CheckpointPersistenceProvider checkpointPersistenceProvider,
					DatabusRelayConnectionFactory relayConnFactory,
					DatabusBootstrapConnectionFactory bootstrapConnFactory,
					HttpStatisticsCollector relayCallsStatsCollector,
					RegistrationId registrationId,
					DatabusHttpClientImpl serverHandle,
					DbusEventFactory eventFactory,
					ConnectionStateFactory connStateFactory)
	{
		this(connConfig,
			subscriptions,
			relays,
			bootstrapServices,
			registrations,
			bootstrapRegistrations,
			dataEventsBuffer,
			bootstrapEventsBuffer,
			ioThreadPool,
			containerStatsCollector,
			inboundEventsStatsCollector,
			bootstrapEventsStatsCollector,
			relayCallbackStats,
			bootstrapCallbackStats,
			checkpointPersistenceProvider,
			relayConnFactory,
			bootstrapConnFactory,
			relayCallsStatsCollector,
			registrationId,
			serverHandle,
			registrationId != null ? registrationId.toString() : null,
			eventFactory,
			null,
			connStateFactory);
	}

	public DatabusSourcesConnection(
			DatabusSourcesConnection.StaticConfig connConfig,
			List<DatabusSubscription> subscriptions, Set<ServerInfo> relays,
			Set<ServerInfo> bootstrapServices,
			List<DatabusV2ConsumerRegistration> registrations,
			List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
			DbusEventBuffer dataEventsBuffer,
			DbusEventBuffer bootstrapEventsBuffer,
			ExecutorService ioThreadPool,
			ContainerStatisticsCollector containerStatsCollector,
			DbusEventsStatisticsCollector inboundEventsStatsCollector,
			DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
			ConsumerCallbackStats relayCallbackStats,
			ConsumerCallbackStats bootstrapCallbackStats,
			CheckpointPersistenceProvider checkpointPersistenceProvider,
			DatabusRelayConnectionFactory relayConnFactory,
			DatabusBootstrapConnectionFactory bootstrapConnFactory,
			HttpStatisticsCollector relayCallsStatsCollector,
			RegistrationId registrationId, DatabusHttpClientImpl serverHandle,
			String connRawId, // Unique Name to be used for generating mbean and logger names.
			DbusEventFactory eventFactory,
            ReentrantLock v3BootstrapLock,
			ConnectionStateFactory connStateFactory
			)
	{
		_eventFactory = eventFactory;
		_connectionConfig = connConfig;
		_dataEventsBuffer = dataEventsBuffer;
		_bootstrapEventsBuffer = bootstrapEventsBuffer;
		_subscriptions = subscriptions;
		_ioThreadPool = ioThreadPool;
		_checkpointPersistenceProvider = checkpointPersistenceProvider;
		_containerStatisticsCollector = containerStatsCollector;
		_inboundEventsStatsCollector = inboundEventsStatsCollector;
		_bootstrapEventsStatsCollector = bootstrapEventsStatsCollector;
		_relayConsumerStats = relayCallbackStats;
		_bootstrapConsumerStats = bootstrapCallbackStats;
		_relayConnFactory = relayConnFactory;
		_bootstrapConnFactory = bootstrapConnFactory;
		_relayRegistrations = registrations;
		_bootstrapRegistrations = bootstrapRegistrations;
		_relayCallsStatsCollector = relayCallsStatsCollector;
		_localRelayCallsStatsCollector = null != relayCallsStatsCollector ? relayCallsStatsCollector
				.createForClientConnection(toString()) : null;
		_registrationId = registrationId;
		_name = composeName(connRawId); // will be used as MBean name for
											// example
		_log = Logger.getLogger(DatabusSourcesConnection.class.getName()
				+ ".srcconn-" + _name);
		_connectionStatus = new SourcesConnectionStatus();
		_v3BootstrapLock = v3BootstrapLock;
		_connStateFactory = connStateFactory;

		List<DbusKeyCompositeFilterConfig> relayFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();
		List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();

		if (null != registrations) {
			for (DatabusV2ConsumerRegistration reg : registrations) {
				DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

				if (null != conf)
					relayFilterConfigs.add(conf);
			}
		}

		if (null != bootstrapRegistrations) {
			for (DatabusV2ConsumerRegistration reg : bootstrapRegistrations) {
				DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

				if (null != conf)
					bootstrapFilterConfigs.add(conf);
			}
		}

		int consumerParallelism = connConfig.getConsumerParallelism();
		if (1 == consumerParallelism) {
			_consumerCallbackExecutor = Executors
					.newSingleThreadExecutor(new NamedThreadFactory("callback"));
		} else {
			_consumerCallbackExecutor = Executors.newFixedThreadPool(
					consumerParallelism, new NamedThreadFactory("callback"));
		}

		LoggingConsumer loggingConsumer = null;
		if (serverHandle != null)
		{
		  try
		  {
		    // we intentionally don't use serverHandle.getLoggingListener(); LoggingConsumer
		    // isn't thread-safe, so we need one instance per connection
		    loggingConsumer = new LoggingConsumer(serverHandle.getClientStaticConfig().getLoggingListener());
		  }
		  catch (InvalidConfigException e)
		  {
		    throw new DatabusRuntimeException(e);  // alternatively, declare config exception and let it go
		  }
		}

		MultiConsumerCallback relayAsyncCallback = new MultiConsumerCallback(
				(null != _relayRegistrations ? _relayRegistrations
						: new ArrayList<DatabusV2ConsumerRegistration>()),
				_consumerCallbackExecutor,
				connConfig.getConsumerTimeBudgetMs(),
				new StreamConsumerCallbackFactory(), _relayConsumerStats,
				loggingConsumer);

		MultiConsumerCallback bootstrapAsyncCallback = new MultiConsumerCallback(
				(null != _bootstrapRegistrations ? _bootstrapRegistrations
						: new ArrayList<DatabusV2ConsumerRegistration>()),
				_consumerCallbackExecutor,
				connConfig.getBstConsumerTimeBudgetMs(),
				new BootstrapConsumerCallbackFactory(), _bootstrapConsumerStats,
				loggingConsumer);

		if (_bootstrapEventsBuffer != null) {
			_bootstrapPuller = new BootstrapPullThread(_name
					+ "-BootstrapPuller", this, _bootstrapEventsBuffer, _connStateFactory,
					bootstrapServices, bootstrapFilterConfigs,
					connConfig.getPullerUtilizationPct(),
					ManagementFactory.getPlatformMBeanServer(),
					_eventFactory, _v3BootstrapLock);
		} else {
			_bootstrapPuller = null;
		}

		_relayDispatcher = new RelayDispatcher(_name + "-RelayDispatcher",
				connConfig, getSubscriptions(), checkpointPersistenceProvider,
				dataEventsBuffer, relayAsyncCallback, _bootstrapPuller,
				ManagementFactory.getPlatformMBeanServer(), serverHandle,
				_registrationId);

		_relayPuller = new RelayPullThread(_name + "-RelayPuller", this,
				_dataEventsBuffer, _connStateFactory, relays, relayFilterConfigs,
				connConfig.getConsumeCurrent(),
				connConfig.isReadLatestScnOnErrorEnabled(),
				connConfig.getPullerUtilizationPct(),
				connConfig.getNoEventsConnectionResetTimeSec(),
				ManagementFactory.getPlatformMBeanServer(),
 				_eventFactory);

		_relayPuller.enqueueMessage(LifecycleMessage.createStartMessage());

		if (_bootstrapEventsBuffer != null) {
			_bootstrapDispatcher = new BootstrapDispatcher(_name
					+ "-BootstrapDispatcher", connConfig, getSubscriptions(),
					checkpointPersistenceProvider, bootstrapEventsBuffer,
					bootstrapAsyncCallback, _relayPuller,
					ManagementFactory.getPlatformMBeanServer(), serverHandle,
					_registrationId);
		} else {
			_bootstrapDispatcher = null;
		}

		_messageQueuesMonitorThread = new Thread(new MessageQueuesMonitor());
		_messageQueuesMonitorThread.setDaemon(true);

		_isBootstrapEnabled = !(null == getBootstrapServices()
				|| getBootstrapServices().isEmpty()
				|| null == getBootstrapRegistrations()
				|| 0 == getBootstrapRegistrations().size() || _bootstrapEventsBuffer == null);

		_log.info(" Is Service Empty : "
				+ (null == getBootstrapServices() || getBootstrapServices()
						.isEmpty()));
		_log.info(" Is Consumers Empty : "
				+ (null == getBootstrapRegistrations() || 0 == getBootstrapRegistrations()
						.size()));

		_nannyRunnable = new NannyRunnable();
	}

	// figure out name for the connection - to be used in mbean
	private String composeName(String id) {
		StringBuilder shortSourcesListBuilder = new StringBuilder();
		String separatorChar = "[";
		for (DatabusSubscription sub : getSubscriptions()) {
			shortSourcesListBuilder.append(separatorChar);
			PhysicalPartition p = sub.getPhysicalPartition();
			String sourceName = "AnySource";
			LogicalSource source = sub.getLogicalPartition().getSource();
			if (!source.isAllSourcesWildcard()) {
				sourceName = source.getName();
				int lastDotIdx = sourceName.lastIndexOf('.');
				if (lastDotIdx >= 0)
					sourceName = sourceName.substring(lastDotIdx + 1);
			}
			String partString = "AnyPPart_";
			if (!p.isAnyPartitionWildcard()) {
				partString = p.getId() + "_";
			}
			shortSourcesListBuilder.append(partString + sourceName);
			separatorChar = "_";
		}
		shortSourcesListBuilder.append(']');
		String shortSourcesList = shortSourcesListBuilder.toString();

		return "conn" + shortSourcesList
				+ (id == null ? "" : "_" + id);
	}

	public boolean isBootstrapEnabled() {
		return _isBootstrapEnabled;
	}

	public void start() {
		_log.info("Starting http relay connection for sources:"
				+ _subscriptions);
		_nannyThread = new Thread(_nannyRunnable, _name + ".Nanny");
		_nannyThread.setDaemon(true);

		_connectionStatus.start();
		_messageQueuesMonitorThread.start();
		_nannyThread.start();
	}

	public boolean isRunning() {
		boolean pullThreadRunning = _relayPullerThread.isAlive();
		boolean dispatcherThreadRunning = _relayDispatcherThread.isAlive();

		if (!pullThreadRunning)
			_log.info("Pull thread is DEAD!");
		if (null != _relayPullerThread.getLastException()) {
			_log.error(" Reason: "
					+ _relayPullerThread.getLastException().getMessage(),
					_relayPullerThread.getLastException());
		}

		if (!dispatcherThreadRunning)
			_log.info("Dispatch thread is DEAD!");
		if (null != _relayDispatcherThread.getLastException()) {
			_log.error(" Reason: "
					+ _relayDispatcherThread.getLastException().getMessage(),
					_relayDispatcherThread.getLastException());
		}

		return pullThreadRunning && dispatcherThreadRunning;
	}

	public void await() {
		boolean running = isRunning();
		_log.info("waiting for shutdown: " + running);
		while (running) {
			_relayPuller.awaitShutdown();
			_relayDispatcher.awaitShutdown();

			running = isRunning();
			_log.info("waiting for shutdown: " + running);
		}
	}

	public void stop() {
		_log.info("Stopping ... :" + isRunning());

		if (null != _relayConsumerStats)
			_relayConsumerStats.unregisterAsMbean();
		if (null != _bootstrapConsumerStats)
			_bootstrapConsumerStats.unregisterAsMbean();
		_connectionStatus.shutdown();

	    if (_relayPullerThread.isAlive())
	    {
	      _log.info("shutting down relay puller ...");
	      _relayPuller.awaitShutdown();
	    }
	    if (_relayDispatcherThread.isAlive())
	    {
||||||| BASE
public class DatabusSourcesConnection {
	public static final int MAX_QUEUED_MESSAGES = 10;
	public static final long MESSAGE_QUEUE_POLL_TIMEOUT_MS = 100;
	public static final int MAX_CONNECT_RETRY_NUM = 3;
	public static final long CONNECT_TIMEOUT_MS = 100;
	public static final long REGISTER_TIMEOUT_MS = 1000;

	public final Logger _log;
	private final String _name;
	private final DatabusSourcesConnection.StaticConfig _connectionConfig;
	private final List<DatabusSubscription> _subscriptions;
	private final RelayPullThread _relayPuller;
	private final GenericDispatcher<DatabusCombinedConsumer> _relayDispatcher;
	private final BootstrapPullThread _bootstrapPuller;
	private final GenericDispatcher<DatabusCombinedConsumer> _bootstrapDispatcher;
	private final DbusEventBuffer _dataEventsBuffer;
	private final DbusEventBuffer _bootstrapEventsBuffer;
	private final ExecutorService _ioThreadPool;
	private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
	private final ContainerStatisticsCollector _containerStatisticsCollector;
	/** Statistics collector about databus events */
	private final DbusEventsStatisticsCollector _inboundEventsStatsCollector;
	private final DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;

	private final HttpStatisticsCollector _relayCallsStatsCollector;
	private final HttpStatisticsCollector _localRelayCallsStatsCollector;
	private final DatabusRelayConnectionFactory _relayConnFactory;
	private final DatabusBootstrapConnectionFactory _bootstrapConnFactory;
	private final List<DatabusV2ConsumerRegistration> _relayRegistrations;
	private final ConsumerCallbackStats _relayConsumerStats;
	private final ConsumerCallbackStats _bootstrapConsumerStats;
	private final NannyRunnable _nannyRunnable;
	private final DbusEventFactory _eventFactory;
	private final ConnectionStateFactory _connStateFactory;

	private final List<DatabusV2ConsumerRegistration> _bootstrapRegistrations;
	private final SourcesConnectionStatus _connectionStatus;

	private UncaughtExceptionTrackingThread _relayPullerThread;
	private UncaughtExceptionTrackingThread _relayDispatcherThread;
	private UncaughtExceptionTrackingThread _bootstrapPullerThread;
	private UncaughtExceptionTrackingThread _bootstrapDispatcherThread;
	private final Thread _messageQueuesMonitorThread;
	private Thread _nannyThread;
	private ExecutorService _consumerCallbackExecutor;

	private final boolean _isBootstrapEnabled;
	private final RegistrationId _registrationId;
	private ReentrantLock _v3BootstrapLock = null;

	public ExecutorService getIoThreadPool() {
		return _ioThreadPool;
	}

    public DatabusSourcesConnection(StaticConfig connConfig,
       List<DatabusSubscription> subscriptions,
       Set<ServerInfo> relays,
       Set<ServerInfo> bootstrapServices,
       List<DatabusV2ConsumerRegistration> registrations,
       List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
       DbusEventBuffer dataEventsBuffer,
       DbusEventBuffer bootstrapEventsBuffer,
       ExecutorService ioThreadPool,
       ContainerStatisticsCollector containerStatsCollector,
       DbusEventsStatisticsCollector inboundEventsStatsCollector,
       DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
       ConsumerCallbackStats relayCallbackStats,
       ConsumerCallbackStats bootstrapCallbackStats,
       CheckpointPersistenceProvider checkpointPersistenceProvider,
       DatabusRelayConnectionFactory relayConnFactory,
       DatabusBootstrapConnectionFactory bootstrapConnFactory,
       HttpStatisticsCollector relayCallsStatsCollector,
       RegistrationId registrationId,
       DatabusHttpClientImpl serverHandle,
       DbusEventFactory eventFactory)
    {
      this(connConfig,
          subscriptions,
          relays,
          bootstrapServices,
          registrations,
          bootstrapRegistrations,
          dataEventsBuffer,
          bootstrapEventsBuffer,
          ioThreadPool,
          containerStatsCollector,
          inboundEventsStatsCollector,
          bootstrapEventsStatsCollector,
          relayCallbackStats,
          bootstrapCallbackStats,
          checkpointPersistenceProvider,
          relayConnFactory,
          bootstrapConnFactory,
          relayCallsStatsCollector,
          registrationId,
          serverHandle,
          registrationId != null ? registrationId.toString() : null,
          eventFactory,
          null,
    null);
    }

	public DatabusSourcesConnection(StaticConfig connConfig,
					List<DatabusSubscription> subscriptions,
					Set<ServerInfo> relays,
					Set<ServerInfo> bootstrapServices,
					List<DatabusV2ConsumerRegistration> registrations,
					List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
					DbusEventBuffer dataEventsBuffer,
					DbusEventBuffer bootstrapEventsBuffer,
					ExecutorService ioThreadPool,
					ContainerStatisticsCollector containerStatsCollector,
					DbusEventsStatisticsCollector inboundEventsStatsCollector,
					DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
					ConsumerCallbackStats relayCallbackStats,
					ConsumerCallbackStats bootstrapCallbackStats,
					CheckpointPersistenceProvider checkpointPersistenceProvider,
					DatabusRelayConnectionFactory relayConnFactory,
					DatabusBootstrapConnectionFactory bootstrapConnFactory,
					HttpStatisticsCollector relayCallsStatsCollector,
					RegistrationId registrationId,
					DatabusHttpClientImpl serverHandle,
					DbusEventFactory eventFactory,
					ConnectionStateFactory connStateFactory)
	{
		this(connConfig,
			subscriptions,
			relays,
			bootstrapServices,
			registrations,
			bootstrapRegistrations,
			dataEventsBuffer,
			bootstrapEventsBuffer,
			ioThreadPool,
			containerStatsCollector,
			inboundEventsStatsCollector,
			bootstrapEventsStatsCollector,
			relayCallbackStats,
			bootstrapCallbackStats,
			checkpointPersistenceProvider,
			relayConnFactory,
			bootstrapConnFactory,
			relayCallsStatsCollector,
			registrationId,
			serverHandle,
			registrationId != null ? registrationId.toString() : null,
			eventFactory,
			null,
			connStateFactory);
	}

	public DatabusSourcesConnection(
			DatabusSourcesConnection.StaticConfig connConfig,
			List<DatabusSubscription> subscriptions, Set<ServerInfo> relays,
			Set<ServerInfo> bootstrapServices,
			List<DatabusV2ConsumerRegistration> registrations,
			List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
			DbusEventBuffer dataEventsBuffer,
			DbusEventBuffer bootstrapEventsBuffer,
			ExecutorService ioThreadPool,
			ContainerStatisticsCollector containerStatsCollector,
			DbusEventsStatisticsCollector inboundEventsStatsCollector,
			DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
			ConsumerCallbackStats relayCallbackStats,
			ConsumerCallbackStats bootstrapCallbackStats,
			CheckpointPersistenceProvider checkpointPersistenceProvider,
			DatabusRelayConnectionFactory relayConnFactory,
			DatabusBootstrapConnectionFactory bootstrapConnFactory,
			HttpStatisticsCollector relayCallsStatsCollector,
			RegistrationId registrationId, DatabusHttpClientImpl serverHandle,
			String connRawId, // Unique Name to be used for generating mbean and logger names.
			DbusEventFactory eventFactory,
            ReentrantLock v3BootstrapLock,
			ConnectionStateFactory connStateFactory
			)
	{
		_eventFactory = eventFactory;
		_connectionConfig = connConfig;
		_dataEventsBuffer = dataEventsBuffer;
		_bootstrapEventsBuffer = bootstrapEventsBuffer;
		_subscriptions = subscriptions;
		_ioThreadPool = ioThreadPool;
		_checkpointPersistenceProvider = checkpointPersistenceProvider;
		_containerStatisticsCollector = containerStatsCollector;
		_inboundEventsStatsCollector = inboundEventsStatsCollector;
		_bootstrapEventsStatsCollector = bootstrapEventsStatsCollector;
		_relayConsumerStats = relayCallbackStats;
		_bootstrapConsumerStats = bootstrapCallbackStats;
		_relayConnFactory = relayConnFactory;
		_bootstrapConnFactory = bootstrapConnFactory;
		_relayRegistrations = registrations;
		_bootstrapRegistrations = bootstrapRegistrations;
		_relayCallsStatsCollector = relayCallsStatsCollector;
		_localRelayCallsStatsCollector = null != relayCallsStatsCollector ? relayCallsStatsCollector
				.createForClientConnection(toString()) : null;
		_registrationId = registrationId;
		_name = composeName(connRawId); // will be used as MBean name for
											// example
		_log = Logger.getLogger(DatabusSourcesConnection.class.getName()
				+ ".srcconn-" + _name);
		_connectionStatus = new SourcesConnectionStatus();
		_v3BootstrapLock = v3BootstrapLock;
		_connStateFactory = connStateFactory;

		List<DbusKeyCompositeFilterConfig> relayFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();
		List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();

		if (null != registrations) {
			for (DatabusV2ConsumerRegistration reg : registrations) {
				DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

				if (null != conf)
					relayFilterConfigs.add(conf);
			}
		}

		if (null != bootstrapRegistrations) {
			for (DatabusV2ConsumerRegistration reg : bootstrapRegistrations) {
				DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

				if (null != conf)
					bootstrapFilterConfigs.add(conf);
			}
		}

		int consumerParallelism = connConfig.getConsumerParallelism();
		if (1 == consumerParallelism) {
			_consumerCallbackExecutor = Executors
					.newSingleThreadExecutor(new NamedThreadFactory("callback"));
		} else {
			_consumerCallbackExecutor = Executors.newFixedThreadPool(
					consumerParallelism, new NamedThreadFactory("callback"));
		}

		MultiConsumerCallback relayAsyncCallback = new MultiConsumerCallback(
				(null != _relayRegistrations ? _relayRegistrations
						: new ArrayList<DatabusV2ConsumerRegistration>()),
				_consumerCallbackExecutor,
				connConfig.getConsumerTimeBudgetMs(),
				new StreamConsumerCallbackFactory(), _relayConsumerStats);

		MultiConsumerCallback bootstrapAsyncCallback = new MultiConsumerCallback(
				(null != _bootstrapRegistrations ? _bootstrapRegistrations
						: new ArrayList<DatabusV2ConsumerRegistration>()),
				_consumerCallbackExecutor,
				connConfig.getBstConsumerTimeBudgetMs(),
				new BootstrapConsumerCallbackFactory(), _bootstrapConsumerStats);

		if (_bootstrapEventsBuffer != null) {
			_bootstrapPuller = new BootstrapPullThread(_name
					+ "-BootstrapPuller", this, _bootstrapEventsBuffer, _connStateFactory,
					bootstrapServices, bootstrapFilterConfigs,
					connConfig.getPullerUtilizationPct(),
					ManagementFactory.getPlatformMBeanServer(),
					_eventFactory, _v3BootstrapLock);
		} else {
			_bootstrapPuller = null;
		}

		_relayDispatcher = new RelayDispatcher(_name + "-RelayDispatcher",
				connConfig, getSubscriptions(), checkpointPersistenceProvider,
				dataEventsBuffer, relayAsyncCallback, _bootstrapPuller,
				ManagementFactory.getPlatformMBeanServer(), serverHandle,
				_registrationId);

		_relayPuller = new RelayPullThread(_name + "-RelayPuller", this,
				_dataEventsBuffer, _connStateFactory, relays, relayFilterConfigs,
				connConfig.getConsumeCurrent(),
				connConfig.isReadLatestScnOnErrorEnabled(),
				connConfig.getPullerUtilizationPct(),
				connConfig.getNoEventsConnectionResetTimeSec(),
				ManagementFactory.getPlatformMBeanServer(),
 				_eventFactory);

		_relayPuller.enqueueMessage(LifecycleMessage.createStartMessage());

		if (_bootstrapEventsBuffer != null) {
			_bootstrapDispatcher = new BootstrapDispatcher(_name
					+ "-BootstrapDispatcher", connConfig, getSubscriptions(),
					checkpointPersistenceProvider, bootstrapEventsBuffer,
					bootstrapAsyncCallback, _relayPuller,
					ManagementFactory.getPlatformMBeanServer(), serverHandle,
					_registrationId);
		} else {
			_bootstrapDispatcher = null;
		}

		_messageQueuesMonitorThread = new Thread(new MessageQueuesMonitor());
		_messageQueuesMonitorThread.setDaemon(true);

		_isBootstrapEnabled = !(null == getBootstrapServices()
				|| getBootstrapServices().isEmpty()
				|| null == getBootstrapRegistrations()
				|| 0 == getBootstrapRegistrations().size() || _bootstrapEventsBuffer == null);

		_log.info(" Is Service Empty : "
				+ (null == getBootstrapServices() || getBootstrapServices()
						.isEmpty()));
		_log.info(" Is Consumers Empty : "
				+ (null == getBootstrapRegistrations() || 0 == getBootstrapRegistrations()
						.size()));

		_nannyRunnable = new NannyRunnable();
	}

	// figure out name for the connection - to be used in mbean
	private String composeName(String id) {
		StringBuilder shortSourcesListBuilder = new StringBuilder();
		String separatorChar = "[";
		for (DatabusSubscription sub : getSubscriptions()) {
			shortSourcesListBuilder.append(separatorChar);
			PhysicalPartition p = sub.getPhysicalPartition();
			String sourceName = "AnySource";
			LogicalSource source = sub.getLogicalPartition().getSource();
			if (!source.isAllSourcesWildcard()) {
				sourceName = source.getName();
				int lastDotIdx = sourceName.lastIndexOf('.');
				if (lastDotIdx >= 0)
					sourceName = sourceName.substring(lastDotIdx + 1);
			}
			String partString = "AnyPPart_";
			if (!p.isAnyPartitionWildcard()) {
				partString = p.getId() + "_";
			}
			shortSourcesListBuilder.append(partString + sourceName);
			separatorChar = "_";
		}
		shortSourcesListBuilder.append(']');
		String shortSourcesList = shortSourcesListBuilder.toString();

		return "conn" + shortSourcesList
				+ (id == null ? "" : "_" + id);
	}

	public boolean isBootstrapEnabled() {
		return _isBootstrapEnabled;
	}

	public void start() {
		_log.info("Starting http relay connection for sources:"
				+ _subscriptions);
		_nannyThread = new Thread(_nannyRunnable, _name + ".Nanny");
		_nannyThread.setDaemon(true);

		_connectionStatus.start();
		_messageQueuesMonitorThread.start();
		_nannyThread.start();
	}

	public boolean isRunning() {
		boolean pullThreadRunning = _relayPullerThread.isAlive();
		boolean dispatcherThreadRunning = _relayDispatcherThread.isAlive();

		if (!pullThreadRunning)
			_log.info("Pull thread is DEAD!");
		if (null != _relayPullerThread.getLastException()) {
			_log.error(" Reason: "
					+ _relayPullerThread.getLastException().getMessage(),
					_relayPullerThread.getLastException());
		}

		if (!dispatcherThreadRunning)
			_log.info("Dispatch thread is DEAD!");
		if (null != _relayDispatcherThread.getLastException()) {
			_log.error(" Reason: "
					+ _relayDispatcherThread.getLastException().getMessage(),
					_relayDispatcherThread.getLastException());
		}

		return pullThreadRunning && dispatcherThreadRunning;
	}

	public void await() {
		boolean running = isRunning();
		_log.info("waiting for shutdown: " + running);
		while (running) {
			_relayPuller.awaitShutdown();
			_relayDispatcher.awaitShutdown();

			running = isRunning();
			_log.info("waiting for shutdown: " + running);
		}
	}

	public void stop() {
		_log.info("Stopping ... :" + isRunning());

		if (null != _relayConsumerStats)
			_relayConsumerStats.unregisterAsMbean();
		if (null != _bootstrapConsumerStats)
			_bootstrapConsumerStats.unregisterAsMbean();
		_connectionStatus.shutdown();

	    if (_relayPullerThread.isAlive())
	    {
	      _log.info("shutting down relay puller ...");
	      _relayPuller.awaitShutdown();
	    }
	    if (_relayDispatcherThread.isAlive())
	    {
=======
public class DatabusSourcesConnection
{
  public static final int MAX_QUEUED_MESSAGES = 10;
  public static final long MESSAGE_QUEUE_POLL_TIMEOUT_MS = 100;
  public static final int MAX_CONNECT_RETRY_NUM = 3;
  public static final long CONNECT_TIMEOUT_MS = 100;
  public static final long REGISTER_TIMEOUT_MS = 1000;

  public final Logger _log;
  private final String _name;
  private final DatabusSourcesConnection.StaticConfig _connectionConfig;
  private final List<DatabusSubscription> _subscriptions;
  private final RelayPullThread _relayPuller;
  private final GenericDispatcher<DatabusCombinedConsumer> _relayDispatcher;
  private final BootstrapPullThread _bootstrapPuller;
  private final GenericDispatcher<DatabusCombinedConsumer> _bootstrapDispatcher;
  private final DbusEventBuffer _dataEventsBuffer;
  private final DbusEventBuffer _bootstrapEventsBuffer;
  private final ExecutorService _ioThreadPool;
  private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
  private final ContainerStatisticsCollector _containerStatisticsCollector;
  /** Statistics collector about databus events */
  private final DbusEventsStatisticsCollector _inboundEventsStatsCollector;
  private final DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;

  private final HttpStatisticsCollector _relayCallsStatsCollector;
  private final HttpStatisticsCollector _localRelayCallsStatsCollector;
  private final DatabusRelayConnectionFactory _relayConnFactory;
  private final DatabusBootstrapConnectionFactory _bootstrapConnFactory;
  private final List<DatabusV2ConsumerRegistration> _relayRegistrations;
  private final ConsumerCallbackStats _relayConsumerStats;
  private final ConsumerCallbackStats _bootstrapConsumerStats;
  private final UnifiedClientStats _unifiedClientStats;
  private final NannyRunnable _nannyRunnable;
  private final DbusEventFactory _eventFactory;
  private final ConnectionStateFactory _connStateFactory;

  private final List<DatabusV2ConsumerRegistration> _bootstrapRegistrations;
  private final SourcesConnectionStatus _connectionStatus;

  private UncaughtExceptionTrackingThread _relayPullerThread;
  private UncaughtExceptionTrackingThread _relayDispatcherThread;
  private UncaughtExceptionTrackingThread _bootstrapPullerThread;
  private UncaughtExceptionTrackingThread _bootstrapDispatcherThread;
  private final Thread _messageQueuesMonitorThread;
  private Thread _nannyThread;
  private ExecutorService _consumerCallbackExecutor;

  private final boolean _isBootstrapEnabled;
  private final RegistrationId _registrationId;
  private ReentrantLock _v3BootstrapLock = null;

  public ExecutorService getIoThreadPool()
  {
    return _ioThreadPool;
  }

  public DatabusSourcesConnection(StaticConfig connConfig,
                                  List<DatabusSubscription> subscriptions,
                                  Set<ServerInfo> relays,
                                  Set<ServerInfo> bootstrapServices,
                                  List<DatabusV2ConsumerRegistration> registrations,
                                  List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
                                  DbusEventBuffer dataEventsBuffer,
                                  DbusEventBuffer bootstrapEventsBuffer,
                                  ExecutorService ioThreadPool,
                                  ContainerStatisticsCollector containerStatsCollector,
                                  DbusEventsStatisticsCollector inboundEventsStatsCollector,
                                  DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
                                  ConsumerCallbackStats relayCallbackStats,
                                  ConsumerCallbackStats bootstrapCallbackStats,
                                  UnifiedClientStats unifiedClientStats,
                                  CheckpointPersistenceProvider checkpointPersistenceProvider,
                                  DatabusRelayConnectionFactory relayConnFactory,
                                  DatabusBootstrapConnectionFactory bootstrapConnFactory,
                                  HttpStatisticsCollector relayCallsStatsCollector,
                                  RegistrationId registrationId,
                                  DatabusHttpClientImpl serverHandle,
                                  DbusEventFactory eventFactory,
                                  ConnectionStateFactory connStateFactory)
  {
    this(connConfig,
         subscriptions,
         relays,
         bootstrapServices,
         registrations,
         bootstrapRegistrations,
         dataEventsBuffer,
         bootstrapEventsBuffer,
         ioThreadPool,
         containerStatsCollector,
         inboundEventsStatsCollector,
         bootstrapEventsStatsCollector,
         relayCallbackStats,
         bootstrapCallbackStats,
         unifiedClientStats,
         checkpointPersistenceProvider,
         relayConnFactory,
         bootstrapConnFactory,
         relayCallsStatsCollector,
         registrationId,
         serverHandle,
         registrationId != null ? registrationId.toString() : null,
         eventFactory,
         null,
         connStateFactory);
  }

  public DatabusSourcesConnection(DatabusSourcesConnection.StaticConfig connConfig,
                                  List<DatabusSubscription> subscriptions,
                                  Set<ServerInfo> relays,
                                  Set<ServerInfo> bootstrapServices,
                                  List<DatabusV2ConsumerRegistration> registrations,
                                  List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
                                  DbusEventBuffer dataEventsBuffer,
                                  DbusEventBuffer bootstrapEventsBuffer,
                                  ExecutorService ioThreadPool,
                                  ContainerStatisticsCollector containerStatsCollector,
                                  DbusEventsStatisticsCollector inboundEventsStatsCollector,
                                  DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
                                  ConsumerCallbackStats relayCallbackStats,
                                  ConsumerCallbackStats bootstrapCallbackStats,
                                  UnifiedClientStats unifiedClientStats,
                                  CheckpointPersistenceProvider checkpointPersistenceProvider,
                                  DatabusRelayConnectionFactory relayConnFactory,
                                  DatabusBootstrapConnectionFactory bootstrapConnFactory,
                                  HttpStatisticsCollector relayCallsStatsCollector,
                                  RegistrationId registrationId, DatabusHttpClientImpl serverHandle,
                                  String connRawId, // Unique Name to be used for generating mbean and logger names.
                                  DbusEventFactory eventFactory,
                                  ReentrantLock v3BootstrapLock,
                                  ConnectionStateFactory connStateFactory)
  {
    _eventFactory = eventFactory;
    _connectionConfig = connConfig;
    _dataEventsBuffer = dataEventsBuffer;
    _bootstrapEventsBuffer = bootstrapEventsBuffer;
    _subscriptions = subscriptions;
    _ioThreadPool = ioThreadPool;
    _checkpointPersistenceProvider = checkpointPersistenceProvider;
    _containerStatisticsCollector = containerStatsCollector;
    _inboundEventsStatsCollector = inboundEventsStatsCollector;
    _bootstrapEventsStatsCollector = bootstrapEventsStatsCollector;
    _relayConsumerStats = relayCallbackStats;
    _bootstrapConsumerStats = bootstrapCallbackStats;
    _unifiedClientStats = unifiedClientStats;
    _relayConnFactory = relayConnFactory;
    _bootstrapConnFactory = bootstrapConnFactory;
    _relayRegistrations = registrations;
    _bootstrapRegistrations = bootstrapRegistrations;
    _relayCallsStatsCollector = relayCallsStatsCollector;
    _localRelayCallsStatsCollector = null != relayCallsStatsCollector ?
        relayCallsStatsCollector.createForClientConnection(toString()) : null;
    _registrationId = registrationId;
    _name = composeName(connRawId); // will be used as MBean name for
                      // example
    _log = Logger.getLogger(DatabusSourcesConnection.class.getName() + ".srcconn-" + _name);
    _connectionStatus = new SourcesConnectionStatus();
    _v3BootstrapLock = v3BootstrapLock;
    _connStateFactory = connStateFactory;

    List<DbusKeyCompositeFilterConfig> relayFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();
    List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();

    if (null != registrations) {
      for (DatabusV2ConsumerRegistration reg : registrations) {
        DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

        if (null != conf)
          relayFilterConfigs.add(conf);
      }
    }

    if (null != bootstrapRegistrations) {
      for (DatabusV2ConsumerRegistration reg : bootstrapRegistrations) {
        DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

        if (null != conf)
          bootstrapFilterConfigs.add(conf);
      }
    }

    int consumerParallelism = connConfig.getConsumerParallelism();
    if (1 == consumerParallelism) {
      _consumerCallbackExecutor = Executors
          .newSingleThreadExecutor(new NamedThreadFactory("callback"));
    } else {
      _consumerCallbackExecutor = Executors.newFixedThreadPool(
          consumerParallelism, new NamedThreadFactory("callback"));
    }

    LoggingConsumer loggingConsumer = null;
    if (serverHandle != null)
    {
      try
      {
        // we intentionally don't use serverHandle.getLoggingListener(); LoggingConsumer
        // isn't thread-safe, so we need one instance per connection
        loggingConsumer = new LoggingConsumer(serverHandle.getClientStaticConfig().getLoggingListener());
      }
      catch (InvalidConfigException e)
      {
        throw new DatabusRuntimeException(e);  // alternatively:  declare InvalidConfigException, let it go
      }
    }

    MultiConsumerCallback relayAsyncCallback =
        new MultiConsumerCallback((null != _relayRegistrations) ?
                                      _relayRegistrations :
                                      new ArrayList<DatabusV2ConsumerRegistration>(),
                                  _consumerCallbackExecutor,
                                  connConfig.getConsumerTimeBudgetMs(),
                                  new StreamConsumerCallbackFactory(_relayConsumerStats,
                                                                    _unifiedClientStats),
                                  _relayConsumerStats,
                                  _unifiedClientStats,
                                  loggingConsumer);

    MultiConsumerCallback bootstrapAsyncCallback =
        new MultiConsumerCallback((null != _bootstrapRegistrations) ?
                                      _bootstrapRegistrations :
                                      new ArrayList<DatabusV2ConsumerRegistration>(),
                                  _consumerCallbackExecutor,
                                  connConfig.getBstConsumerTimeBudgetMs(),
                                  new BootstrapConsumerCallbackFactory(_bootstrapConsumerStats,
                                                                       _unifiedClientStats),
                                  _bootstrapConsumerStats,
                                  _unifiedClientStats,
                                  loggingConsumer);

    if (_bootstrapEventsBuffer != null) {
      _bootstrapPuller = new BootstrapPullThread(_name
          + "-BootstrapPuller", this, _bootstrapEventsBuffer, _connStateFactory,
          bootstrapServices, bootstrapFilterConfigs,
          connConfig.getPullerUtilizationPct(),
          ManagementFactory.getPlatformMBeanServer(),
          _eventFactory, _v3BootstrapLock);
    } else {
      _bootstrapPuller = null;
    }

    _relayDispatcher = new RelayDispatcher(_name + "-RelayDispatcher",
        connConfig, getSubscriptions(), checkpointPersistenceProvider,
        dataEventsBuffer, relayAsyncCallback, _bootstrapPuller,
        ManagementFactory.getPlatformMBeanServer(), serverHandle,
        _registrationId);

    _relayPuller = new RelayPullThread(_name + "-RelayPuller", this,
        _dataEventsBuffer, _connStateFactory, relays, relayFilterConfigs,
        connConfig.getConsumeCurrent(),
        connConfig.isReadLatestScnOnErrorEnabled(),
        connConfig.getPullerUtilizationPct(),
        connConfig.getNoEventsConnectionResetTimeSec(),
        ManagementFactory.getPlatformMBeanServer(),
        _eventFactory);

    _relayPuller.enqueueMessage(LifecycleMessage.createStartMessage());

    if (_bootstrapEventsBuffer != null) {
      _bootstrapDispatcher = new BootstrapDispatcher(_name
          + "-BootstrapDispatcher", connConfig, getSubscriptions(),
          checkpointPersistenceProvider, bootstrapEventsBuffer,
          bootstrapAsyncCallback, _relayPuller,
          ManagementFactory.getPlatformMBeanServer(), serverHandle,
          _registrationId);
    } else {
      _bootstrapDispatcher = null;
    }

    _messageQueuesMonitorThread = new Thread(new MessageQueuesMonitor());
    _messageQueuesMonitorThread.setDaemon(true);

    _isBootstrapEnabled = !(null == getBootstrapServices()
        || getBootstrapServices().isEmpty()
        || null == getBootstrapRegistrations()
        || 0 == getBootstrapRegistrations().size() || _bootstrapEventsBuffer == null);

    _log.info(" Is Service Empty : "
        + (null == getBootstrapServices() || getBootstrapServices()
            .isEmpty()));
    _log.info(" Is Consumers Empty : "
        + (null == getBootstrapRegistrations() || 0 == getBootstrapRegistrations()
            .size()));

    _nannyRunnable = new NannyRunnable();
  }

  // figure out name for the connection - to be used in mbean
  private String composeName(String id) {
    StringBuilder shortSourcesListBuilder = new StringBuilder();
    String separatorChar = "[";
    for (DatabusSubscription sub : getSubscriptions()) {
      shortSourcesListBuilder.append(separatorChar);
      PhysicalPartition p = sub.getPhysicalPartition();
      String sourceName = "AnySource";
      LogicalSource source = sub.getLogicalPartition().getSource();
      if (!source.isAllSourcesWildcard()) {
        sourceName = source.getName();
        int lastDotIdx = sourceName.lastIndexOf('.');
        if (lastDotIdx >= 0)
          sourceName = sourceName.substring(lastDotIdx + 1);
      }
      String partString = "AnyPPart_";
      if (!p.isAnyPartitionWildcard()) {
        partString = p.getId() + "_";
      }
      shortSourcesListBuilder.append(partString + sourceName);
      separatorChar = "_";
    }
    shortSourcesListBuilder.append(']');
    String shortSourcesList = shortSourcesListBuilder.toString();

    return "conn" + shortSourcesList + (id == null ? "" : "_" + id);
  }

  public boolean isBootstrapEnabled()
  {
    return _isBootstrapEnabled;
  }

  public void start()
  {
    _log.info("Starting http relay connection for sources:"
        + _subscriptions);
    _nannyThread = new Thread(_nannyRunnable, _name + ".Nanny");
    _nannyThread.setDaemon(true);

    _connectionStatus.start();
    _messageQueuesMonitorThread.start();
    _nannyThread.start();
  }

  public boolean isRunning()
  {
    boolean pullThreadRunning = _relayPullerThread.isAlive();
    boolean dispatcherThreadRunning = _relayDispatcherThread.isAlive();

    if (!pullThreadRunning)
      _log.info("Pull thread is DEAD!");
    if (null != _relayPullerThread.getLastException()) {
      _log.error(" Reason: "
          + _relayPullerThread.getLastException().getMessage(),
          _relayPullerThread.getLastException());
    }

    if (!dispatcherThreadRunning)
      _log.info("Dispatch thread is DEAD!");
    if (null != _relayDispatcherThread.getLastException()) {
      _log.error(" Reason: "
          + _relayDispatcherThread.getLastException().getMessage(),
          _relayDispatcherThread.getLastException());
    }

    return pullThreadRunning && dispatcherThreadRunning;
  }

  public void await()
  {
    boolean running = isRunning();
    _log.info("waiting for shutdown: " + running);
    while (running) {
      _relayPuller.awaitShutdown();
      _relayDispatcher.awaitShutdown();

      running = isRunning();
      _log.info("waiting for shutdown: " + running);
    }
  }

  public void stop()
  {
    _log.info("Stopping ... :" + isRunning());

    unregisterMbeans();
    _connectionStatus.shutdown();

      if (_relayPullerThread.isAlive())
      {
        _log.info("shutting down relay puller ...");
        _relayPuller.awaitShutdown();
      }
      if (_relayDispatcherThread.isAlive())
      {
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusSourcesConnection.java;<<<<<<< MINE
		if (_isBootstrapEnabled) {
	    	if (_bootstrapDispatcherThread.isAlive())
	    	{
	          _log.info("shutting down bootstrap dispatcher ...");
	    	  _bootstrapDispatcher.awaitShutdown();
	    	}
	    	if (_bootstrapPullerThread.isAlive())
	    	{
	          _log.info("shutting down bootstrap puller ...");
	    	  _bootstrapPuller.awaitShutdown();
	    	}
		}

		_consumerCallbackExecutor.shutdown();

		_log.info("Stopped ... ");
	}

	public List<String> getSourcesNames() {
		return DatabusSubscription.getStrList(_subscriptions);
	}

	public List<DatabusSubscription> getSubscriptions() {
		return _subscriptions;
	}

	public ConsumerCallbackStats getRelayConsumerStats() {
		return _relayConsumerStats;
	}

	public ConsumerCallbackStats getBootstrapConsumerStats() {
		return _bootstrapConsumerStats;
	}

	public static void main(String args[]) throws Exception {
	}

	public DatabusComponentStatus getConnectionStatus() {
		return _connectionStatus;
	}

	public BootstrapPullThread getBootstrapPuller() {
		return _bootstrapPuller;
	}

	public GenericDispatcher<DatabusCombinedConsumer> getBootstrapDispatcher() {
		return _bootstrapDispatcher;
	}

	public CheckpointPersistenceProvider getCheckpointPersistenceProvider() {
		return _checkpointPersistenceProvider;
	}

	public ContainerStatisticsCollector getContainerStatisticsCollector() {
		return _containerStatisticsCollector;
	}

	public Set<ServerInfo> getRelays() {
		return (_relayPuller != null) ? _relayPuller.getServers() : null;
	}

	public Set<ServerInfo> getBootstrapServices() {
		return (_bootstrapPuller != null) ? _bootstrapPuller.getServers()
				: null;
	}

	public DbusEventsStatisticsCollector getInboundEventsStatsCollector() {
		return _inboundEventsStatsCollector;
	}

	public GenericDispatcher<DatabusCombinedConsumer> getRelayDispatcher() {
		return _relayDispatcher;
	}

	public DatabusRelayConnectionFactory getRelayConnFactory() {
		return _relayConnFactory;
	}

	public DatabusBootstrapConnectionFactory getBootstrapConnFactory() {
		return _bootstrapConnFactory;
	}

	public DbusEventBuffer getDataEventsBuffer() {
		return _dataEventsBuffer;
	}

	public DbusEventBuffer getBootstrapEventsBuffer() {
		return _bootstrapEventsBuffer;
	}

	public Checkpoint loadPersistentCheckpoint() {
		if (_checkpointPersistenceProvider != null)
			return _checkpointPersistenceProvider.loadCheckpointV3(
					getSubscriptions(), _registrationId);
		Checkpoint cp = Checkpoint.createFlexibleCheckpoint();
		return cp;
	}

	public List<DatabusV2ConsumerRegistration> getBootstrapRegistrations() {
		return _bootstrapRegistrations;
	}

	public DatabusSourcesConnection.StaticConfig getConnectionConfig() {
		return _connectionConfig;
	}

	public List<DatabusV2ConsumerRegistration> getRelayRegistrations() {
		return _relayRegistrations;
	}

	class NannyRunnable implements Runnable {
		public static final int SLEEP_DURATION_MS = 1000;

		@Override
		public void run() {
			while (getConnectionStatus().getStatus() != DatabusComponentStatus.Status.SHUTDOWN) {
				boolean runShutdown = false;
				if (null != _relayPuller
						&& _relayPuller.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the relay puller is shutdown!");
					runShutdown = true;
				}
				if (null != _relayDispatcher
						&& _relayDispatcher.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the relay dispatcher is shutdown!");
					runShutdown = true;
				}
				if (null != _bootstrapPuller
						&& _bootstrapPuller.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the bootstrap puller is shutdown!");
					runShutdown = true;
				}
				if (null != _bootstrapDispatcher
						&& _bootstrapDispatcher.getComponentStatus()
								.getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the bootstrap dispatcher is shutdown!");
					runShutdown = true;
				}

				if (runShutdown) {
					stop();
				}

				try {
					Thread.sleep(SLEEP_DURATION_MS);
				} catch (InterruptedException e) {
					_log.info("nanny: who woke me up?");
				}
			}
		}

	}

	public class SourcesConnectionStatus extends DatabusComponentStatus {
		public SourcesConnectionStatus() {
			super(DatabusSourcesConnection.this._name);
		}

		@Override
		public void start() {
			super.start();

			_relayPullerThread = new UncaughtExceptionTrackingThread(
					_relayPuller, _relayPuller.getName());
			_relayPullerThread.setDaemon(true);
			_relayPullerThread.start();

			_relayDispatcherThread = new UncaughtExceptionTrackingThread(
					_relayDispatcher, _relayDispatcher.getName());
			_relayDispatcherThread.setDaemon(true);
			_relayDispatcherThread.start();

			if (_isBootstrapEnabled) {
				_bootstrapPullerThread = new UncaughtExceptionTrackingThread(
						_bootstrapPuller, _bootstrapPuller.getName());
				_bootstrapPullerThread.setDaemon(true);
				_bootstrapPullerThread.start();

				_bootstrapDispatcherThread = new UncaughtExceptionTrackingThread(
						_bootstrapDispatcher, _bootstrapDispatcher.getName());
				_bootstrapDispatcherThread.setDaemon(true);
				_bootstrapDispatcherThread.start();
			}
		}

		@Override
		public void shutdown()
		{
		  _log.info("shutting down connection ...");
		  _relayPuller.shutdown();
		  _relayDispatcher.shutdown();
		  if (_bootstrapPuller != null)
		  {
		    _bootstrapPuller.shutdown();
		  }
		  if (_bootstrapDispatcher != null)
		  {
		    _bootstrapDispatcher.shutdown();
		  }

		  _relayPullerThread.interrupt();
		  _relayDispatcherThread.interrupt();

		  if (_isBootstrapEnabled)
		  {
		    _bootstrapPullerThread.interrupt();
		    _bootstrapDispatcherThread.interrupt();
		  }

		  super.shutdown();
		  _nannyThread.interrupt();
		  _log.info("connection shut down.");
		}

		@Override
		public void pause() {
			_relayPuller.enqueueMessage(LifecycleMessage.createPauseMessage());
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createPauseMessage());
			}

			super.pause();
		}

		@Override
		public void resume() {
			_relayPuller.enqueueMessage(LifecycleMessage.createResumeMessage());
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createResumeMessage());
			}

			super.resume();
		}

		@Override
		public void suspendOnError(Throwable cause) {
			_relayPuller.enqueueMessage(LifecycleMessage
					.createSuspendOnErroMessage(cause));
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createSuspendOnErroMessage(cause));
			}

			super.suspendOnError(cause);
		}
	}

	public static class StaticConfig {
		private final DbusEventBuffer.StaticConfig _eventBuffer;
		private final DbusEventBuffer.StaticConfig _bstEventBuffer;
		private final long _consumerTimeBudgetMs;
		private final long _bstConsumerTimeBudgetMs;
		private final int _consumerParallelism;
		private final double _checkpointThresholdPct;
		private final Range _keyRange;
		private final BackoffTimerStaticConfig _bsPullerRetriesBeforeCkptCleanup;
		private final BackoffTimerStaticConfig _pullerRetries;
		private final BackoffTimerStaticConfig _bstPullerRetries;
		private final BackoffTimerStaticConfig _dispatcherRetries;
		private final BackoffTimerStaticConfig _bstDispatcherRetries;
		private final int _freeBufferThreshold;
		private final boolean _consumeCurrent;
		private final boolean _readLatestScnOnError;
		private final double _pullerBufferUtilizationPct;
		private final int _id;
		private final boolean _enablePullerMessageQueueLogging;
		private final int _numRetriesOnFallOff;
		private final int _noEventsConnectionResetTimeSec;

		public StaticConfig(DbusEventBuffer.StaticConfig eventBuffer,
				DbusEventBuffer.StaticConfig bstEventBuffer,
				long consumerTimeBudgetMs, long bstConsumerTimeBudgetMs, int consumerParallelism,
				double checkpointThresholdPct, Range keyRange,
				BackoffTimerStaticConfig bsPullerRetriesBeforeCkptCleanup,
				BackoffTimerStaticConfig pullerRetries,
				BackoffTimerStaticConfig bstPullerRetries,
				BackoffTimerStaticConfig dispatcherRetries,
				BackoffTimerStaticConfig bstDispatcherRetries,
				int retriesOnFellOff, int freeBufferThreshold,
				boolean consumeCurrent, boolean readLatestScnOnError,
				double pullerBufferUtilizationPct, int id,
				boolean enablePullerMessageQueueLogging,
				int noEventsConnectionResetTimeSec
				) {
			super();
			_eventBuffer = eventBuffer;
			_bstEventBuffer = bstEventBuffer;
			_consumerTimeBudgetMs = consumerTimeBudgetMs;
			_bstConsumerTimeBudgetMs = bstConsumerTimeBudgetMs;
			_consumerParallelism = consumerParallelism;
			_checkpointThresholdPct = checkpointThresholdPct;
			_keyRange = keyRange;
			_bsPullerRetriesBeforeCkptCleanup = bsPullerRetriesBeforeCkptCleanup;
			_pullerRetries = pullerRetries;
			_bstPullerRetries = bstPullerRetries;
			_dispatcherRetries = dispatcherRetries;
			_bstDispatcherRetries = bstDispatcherRetries;
			_numRetriesOnFallOff = retriesOnFellOff;
			_freeBufferThreshold = (freeBufferThreshold > eventBuffer.getReadBufferSize()) ? eventBuffer.getReadBufferSize()/2:freeBufferThreshold;
			_consumeCurrent = consumeCurrent;
			_readLatestScnOnError = readLatestScnOnError;
			_pullerBufferUtilizationPct = pullerBufferUtilizationPct;
			_id = id;
			_enablePullerMessageQueueLogging = enablePullerMessageQueueLogging;
			_noEventsConnectionResetTimeSec = noEventsConnectionResetTimeSec;

		}


		public int getNoEventsConnectionResetTimeSec() {
			return _noEventsConnectionResetTimeSec;
		}
		public DbusEventBuffer.StaticConfig getBstEventBuffer() {
			return _bstEventBuffer;
		}

		public long getBstConsumerTimeBudgetMs() {
			return _bstConsumerTimeBudgetMs;
		}

		public BackoffTimerStaticConfig getBstDispatcherRetries() {
			return _bstDispatcherRetries;
		}

		public boolean getReadLatestScnOnError() {
			return _readLatestScnOnError;
		}

		public boolean isReadLatestScnOnErrorEnabled() {
			return _readLatestScnOnError;
		}

		public double getPullerUtilizationPct() {
			return _pullerBufferUtilizationPct;
		}

		public int getId() {
			return _id;
		}

		public boolean getConsumeCurrent() {
			return _consumeCurrent;
		}

		/** The relay event buffer static configuration */
		public DbusEventBuffer.StaticConfig getEventBuffer() {
			return _eventBuffer;
		}

		/**
		 * Max time in milliseconds that a consumer should use to process an
		 * event before it is considered failed
		 */
		public long getConsumerTimeBudgetMs() {
			return _consumerTimeBudgetMs;
		}

		/**
		 * Max number of consumers that can be called in parallel to process an
		 * event
		 */
		public int getConsumerParallelism() {
			return _consumerParallelism;
		}

		/**
		 * The percentage of event buffer occupancy that will trigger a
		 * checkpoint attempt. This is to ensure that we can make progress in
		 * large event windows without having to reprocess them entirely in case
		 * of a failure.
		 */
		public double getCheckpointThresholdPct() {
			return _checkpointThresholdPct;
		}

		public Range getKeyRange() {
			return _keyRange;
		}

		/**
		 * Pull requests and error retries configuration when talking to the
		 * relays or bootstrap servers
		 */
		public BackoffTimerStaticConfig getPullerRetries() {
			return _pullerRetries;
		}

		public BackoffTimerStaticConfig getBstPullerRetries() {
			return _bstPullerRetries;
		}

		/** Error retries configuration calling the consumer code */
		public BackoffTimerStaticConfig getDispatcherRetries() {
			return _dispatcherRetries;
		}

		/**
		 * This config controls how many retries will be made on the same
		 * bootstrap Server before switching and clearing the checkpoint
		 */
		public BackoffTimerStaticConfig getBsPullerRetriesBeforeCkptCleanup() {
			return _bsPullerRetriesBeforeCkptCleanup;
		}

		/**
		 * This config controls how many retries will be made when it received
		 * ScnNotFoundException before
		 * bootstrapping/suspending/reading-latest-event
		 */
		public int getNumRetriesOnFallOff() {
			return _numRetriesOnFallOff;
		}

		/**
		 * Minimum number of bytes that need to be available in the buffer
		 * before the Puller's can request for more events. Ideally this is more
		 * than max event size
		 */
		public int getFreeBufferThreshold() {
			return _freeBufferThreshold;
		}

		public boolean isPullerMessageQueueLoggingEnabled() {
			return _enablePullerMessageQueueLogging;
		}

		@Override
		public String toString() {
			return "StaticConfig [_eventBuffer=" + _eventBuffer
					+ ", _bstEventBuffer=" + _bstEventBuffer
					+ ", _consumerTimeBudgetMs=" + _consumerTimeBudgetMs
					+ ", _bstConsumerTimeBudgetMs=" + _bstConsumerTimeBudgetMs
					+ ", _consumerParallelism=" + _consumerParallelism
					+ ", _checkpointThresholdPct=" + _checkpointThresholdPct
					+ ", _keyRange=" + _keyRange
					+ ", _bsPullerRetriesBeforeCkptCleanup="
					+ _bsPullerRetriesBeforeCkptCleanup + ", _pullerRetries="
					+ _pullerRetries + ", _bstPullerRetries=" + _bstPullerRetries + ", _dispatcherRetries="
					+ _dispatcherRetries + ", _bstDispatcherRetries="
					+ _bstDispatcherRetries + ", _freeBufferThreshold="
					+ _freeBufferThreshold
					+ ", _enablePullerMessageQueueLogging="
					+ _enablePullerMessageQueueLogging + "]";
		}
	}

	public static class Config implements ConfigBuilder<StaticConfig> {
		private static final long DEFAULT_KEY_RANGE_MIN = -1L;
		private static final long DEFAULT_KEY_RANGE_MAX = -1L;

		private static final long DEFAULT_MAX_BUFFER_SIZE = 10 * 1024 * 1024;
		private static final int DEFAULT_INIT_READBUFFER_SIZE = 20 * 1024;
		private static final int DEFAULT_MAX_SCNINDEX_SIZE = 1024 * 1024;
		private static final boolean DEFAULT_PULLER_MESSAGE_QUEUE_LOGGING = false;

		private static int DEFAULT_MAX_RETRY_NUM = -1;
		private static int DEFAULT_INIT_SLEEP = 100;
		private static double DEFAULT_SLEEP_INC_FACTOR = 1.1;

		// Default Sleep : InitSleep : 1 sec, then keep incrementing 1.5*prev + 1 sec for
		// subsequent retry, upto 1000 retries. (there is a limit on max sleep set to 1 minute)
		// so at the worst case it will wait for ~16 hours
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_MAX_RETRY_NUM = 1000;
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_INIT_SLEEP = 1 * 1000;
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_DELTA = 1000;
		private static double DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_FACTOR = 1.5;
		private static int DEFAULT_FREE_BUFFER_THRESHOLD=10*1024;

		// Default Config woul be to retry 5 times w
		private static int DEFAULT_RETRY_ON_FELLOFF_MAX_RETRY_NUM = 5;

		private final Logger _log = Logger.getLogger(Config.class);
		private DbusEventBuffer.Config _eventBuffer;
		private DbusEventBuffer.Config _bstEventBuffer = null;
		private long _consumerTimeBudgetMs = 300000;
		private long _bstConsumerTimeBudgetMs = 300000;
		private boolean _setBstConsumerTimeBudgetCalled = false;
		private int _consumerParallelism = 1;
		private double _checkpointThresholdPct;
		private long _keyMin;
		private long _keyMax;
		// Ideally, _bsPullerRetriesBeforeCkptCleanup should be renamed to _bsPullerRetriesBeforeServerSwitch
		// In V3 bootstrap there is no clean-up of checkpoint when switching servers.
		// See BootstrapV3CheckpointHandler.resetForServerChange() method
		private BackoffTimerStaticConfigBuilder _bsPullerRetriesBeforeCkptCleanup;
		private BackoffTimerStaticConfigBuilder _pullerRetries;
		private BackoffTimerStaticConfigBuilder _bstPullerRetries;
		private BackoffTimerStaticConfigBuilder _dispatcherRetries;
		private BackoffTimerStaticConfigBuilder _bstDispatcherRetries = null;
		private int _numRetriesOnFallOff;

		//optimization - depreating the ability to alter the value
		private int _freeBufferThreshold = DEFAULT_FREE_BUFFER_THRESHOLD;
		private boolean _consumeCurrent = false;
		private boolean _readLatestScnOnError = false;
		private double _pullerBufferUtilizationPct = 100.0;
		private int _id;
		private boolean _enablePullerMessageQueueLogging;
		private int _noEventsConnectionResetTimeSec = 15*60; // if there is no events for 15 min - disconnect

		private void makeEvbConfig(DbusEventBuffer.Config evbConfig,
																QueuePolicy qPolicy,
																boolean enableScnIndex,
																double defaultMemUsage)
		{
			evbConfig.setQueuePolicy(qPolicy.toString());
			evbConfig.setEnableScnIndex(enableScnIndex);
			evbConfig.setDefaultMemUsage(defaultMemUsage);
			if (evbConfig.getMaxSize() > DEFAULT_MAX_BUFFER_SIZE) {
	       _log.warn("Setting buffer size to " + DEFAULT_MAX_BUFFER_SIZE + " instead of requested size " + evbConfig.getMaxSize());
				evbConfig.setMaxSize(DEFAULT_MAX_BUFFER_SIZE);
			}

			if (evbConfig.getScnIndexSize() > DEFAULT_MAX_SCNINDEX_SIZE) {
				evbConfig.setScnIndexSize(DEFAULT_MAX_SCNINDEX_SIZE);
			}
		}

		public Config() {
			_eventBuffer = new DbusEventBuffer.Config();
			makeEvbConfig(_eventBuffer, QueuePolicy.BLOCK_ON_WRITE, false, 0.1);

			_checkpointThresholdPct = 75.0;
			_keyMin = DEFAULT_KEY_RANGE_MIN;
			_keyMax = DEFAULT_KEY_RANGE_MAX;

			_pullerRetries = new BackoffTimerStaticConfigBuilder();
			_pullerRetries.setInitSleep(DEFAULT_INIT_SLEEP);
			_pullerRetries.setSleepIncFactor(DEFAULT_SLEEP_INC_FACTOR);
			_pullerRetries.setMaxRetryNum(DEFAULT_MAX_RETRY_NUM);

			_bsPullerRetriesBeforeCkptCleanup = new BackoffTimerStaticConfigBuilder();
			_bsPullerRetriesBeforeCkptCleanup
					.setInitSleep(DEFAULT_BSPULLER_CKPTCLEANUP_INIT_SLEEP);
			_bsPullerRetriesBeforeCkptCleanup
					.setSleepIncDelta(DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_DELTA);
			_bsPullerRetriesBeforeCkptCleanup
					.setMaxRetryNum(DEFAULT_BSPULLER_CKPTCLEANUP_MAX_RETRY_NUM);
			_bsPullerRetriesBeforeCkptCleanup
					.setSleepIncFactor(DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_FACTOR);

			_numRetriesOnFallOff = DEFAULT_RETRY_ON_FELLOFF_MAX_RETRY_NUM;

			_dispatcherRetries = new BackoffTimerStaticConfigBuilder();
			_dispatcherRetries.setSleepIncFactor(1.1);
			_dispatcherRetries.setMaxRetryNum(-1);
			_enablePullerMessageQueueLogging = DEFAULT_PULLER_MESSAGE_QUEUE_LOGGING;
		}

		public Config(Config other) {
			_eventBuffer = new DbusEventBuffer.Config(other.getEventBuffer());
			if (other.hasBstEventBuffer()) {
				_bstEventBuffer = new DbusEventBuffer.Config(other.getBstEventBuffer());
			} else {
				_bstEventBuffer = null;
			}
		}

		public DbusEventBuffer.Config getEventBuffer() {
			return _eventBuffer;
		}

		/**
		 * If anyone other than spring config ever calls this method they should first call hasBstEventBuffer().
		 *
		 * @return a newly constructed DbusEventBuffer.Config object.
		 */
		public DbusEventBuffer.Config getBstEventBuffer() {
			if (_bstEventBuffer != null) {
				return _bstEventBuffer;
			}
			_bstEventBuffer = new DbusEventBuffer.Config();
			makeEvbConfig(_bstEventBuffer, QueuePolicy.BLOCK_ON_WRITE, false, 0.1);
			return _bstEventBuffer;
		}

		public boolean hasBstEventBuffer() {
			return _bstEventBuffer != null;
		}

		public void setEventBuffer(DbusEventBuffer.Config eventBuffer) {
			_eventBuffer = eventBuffer;
		}

		/**
		 * Corrects, checkpointThresholdPct to accommodate largestEventSize by calculating checkpoint threshold pct
		 * override checkpoint threshold pct settings if (between 10 and 90 pct) to set the maximum
		 * @param bufCfg : buffer config; with maxEventSize set
		 * @return checkpointThresholdPct;
		 */
		public double computeSafeCheckpointThresholdPct(DbusEventBuffer.Config bufCfg)
		{
		  int safeMaxEventSize = (int)((100.0 - _checkpointThresholdPct) * bufCfg.maxMaxEventSize() / 100.0);
		  if (DbusEventBuffer.Config.DEFAULT_MAX_EVENT_SIZE == bufCfg.getMaxEventSize())
		  {
		      //maxEventSize not set; return existing checkpointThresholdPct
		    return _checkpointThresholdPct;
		  }
		  else if (safeMaxEventSize >= bufCfg.getMaxEventSize())
		  {
		    //maxEventSize is lesser than safeSize ; return checkpointThresholdPct;
		    return _checkpointThresholdPct;
		  }
		  //case where checkpointThresholdPct has to be computed;
		  return 100.0 - ((double)(bufCfg.getMaxEventSize()+_freeBufferThreshold)/bufCfg.maxMaxEventSize())*100.0;
		}

		private void validateBufferConfig(StaticConfig connConfig,DbusEventBuffer.StaticConfig bufferConfig) throws InvalidConfigException
		{
		  long bufferCapacityInBytes = bufferConfig.getMaxSize();
||||||| BASE
		if (_isBootstrapEnabled) {
	    	if (_bootstrapDispatcherThread.isAlive())
	    	{
	          _log.info("shutting down bootstrap dispatcher ...");
	    	  _bootstrapDispatcher.awaitShutdown();
	    	}
	    	if (_bootstrapPullerThread.isAlive())
	    	{
	          _log.info("shutting down bootstrap puller ...");
	    	  _bootstrapPuller.awaitShutdown();
	    	}
		}

		_consumerCallbackExecutor.shutdown();

		_log.info("Stopped ... ");
	}

	public List<String> getSourcesNames() {
		return DatabusSubscription.getStrList(_subscriptions);
	}

	public List<DatabusSubscription> getSubscriptions() {
		return _subscriptions;
	}

	public ConsumerCallbackStats getRelayConsumerStats() {
		return _relayConsumerStats;
	}

	public ConsumerCallbackStats getBootstrapConsumerStats() {
		return _bootstrapConsumerStats;
	}

	public static void main(String args[]) throws Exception {
	}

	public DatabusComponentStatus getConnectionStatus() {
		return _connectionStatus;
	}

	public BootstrapPullThread getBootstrapPuller() {
		return _bootstrapPuller;
	}

	public GenericDispatcher<DatabusCombinedConsumer> getBootstrapDispatcher() {
		return _bootstrapDispatcher;
	}

	public CheckpointPersistenceProvider getCheckpointPersistenceProvider() {
		return _checkpointPersistenceProvider;
	}

	public ContainerStatisticsCollector getContainerStatisticsCollector() {
		return _containerStatisticsCollector;
	}

	public Set<ServerInfo> getRelays() {
		return (_relayPuller != null) ? _relayPuller.getServers() : null;
	}

	public Set<ServerInfo> getBootstrapServices() {
		return (_bootstrapPuller != null) ? _bootstrapPuller.getServers()
				: null;
	}

	public DbusEventsStatisticsCollector getInboundEventsStatsCollector() {
		return _inboundEventsStatsCollector;
	}

	public GenericDispatcher<DatabusCombinedConsumer> getRelayDispatcher() {
		return _relayDispatcher;
	}

	public DatabusRelayConnectionFactory getRelayConnFactory() {
		return _relayConnFactory;
	}

	public DatabusBootstrapConnectionFactory getBootstrapConnFactory() {
		return _bootstrapConnFactory;
	}

	public DbusEventBuffer getDataEventsBuffer() {
		return _dataEventsBuffer;
	}

	public DbusEventBuffer getBootstrapEventsBuffer() {
		return _bootstrapEventsBuffer;
	}

	public Checkpoint loadPersistentCheckpoint() {
		if (_checkpointPersistenceProvider != null)
			return _checkpointPersistenceProvider.loadCheckpointV3(
					getSubscriptions(), _registrationId);
		Checkpoint cp = Checkpoint.createFlexibleCheckpoint();
		return cp;
	}

	public List<DatabusV2ConsumerRegistration> getBootstrapRegistrations() {
		return _bootstrapRegistrations;
	}

	public DatabusSourcesConnection.StaticConfig getConnectionConfig() {
		return _connectionConfig;
	}

	public List<DatabusV2ConsumerRegistration> getRelayRegistrations() {
		return _relayRegistrations;
	}

	class NannyRunnable implements Runnable {
		public static final int SLEEP_DURATION_MS = 1000;

		@Override
		public void run() {
			while (getConnectionStatus().getStatus() != DatabusComponentStatus.Status.SHUTDOWN) {
				boolean runShutdown = false;
				if (null != _relayPuller
						&& _relayPuller.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the relay puller is shutdown!");
					runShutdown = true;
				}
				if (null != _relayDispatcher
						&& _relayDispatcher.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the relay dispatcher is shutdown!");
					runShutdown = true;
				}
				if (null != _bootstrapPuller
						&& _bootstrapPuller.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the bootstrap puller is shutdown!");
					runShutdown = true;
				}
				if (null != _bootstrapDispatcher
						&& _bootstrapDispatcher.getComponentStatus()
								.getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the bootstrap dispatcher is shutdown!");
					runShutdown = true;
				}

				if (runShutdown) {
					stop();
				}

				try {
					Thread.sleep(SLEEP_DURATION_MS);
				} catch (InterruptedException e) {
					_log.info("nanny: who woke me up?");
				}
			}
		}

	}

	public class SourcesConnectionStatus extends DatabusComponentStatus {
		public SourcesConnectionStatus() {
			super(DatabusSourcesConnection.this._name);
		}

		@Override
		public void start() {
			super.start();

			_relayPullerThread = new UncaughtExceptionTrackingThread(
					_relayPuller, _relayPuller.getName());
			_relayPullerThread.setDaemon(true);
			_relayPullerThread.start();

			_relayDispatcherThread = new UncaughtExceptionTrackingThread(
					_relayDispatcher, _relayDispatcher.getName());
			_relayDispatcherThread.setDaemon(true);
			_relayDispatcherThread.start();

			if (_isBootstrapEnabled) {
				_bootstrapPullerThread = new UncaughtExceptionTrackingThread(
						_bootstrapPuller, _bootstrapPuller.getName());
				_bootstrapPullerThread.setDaemon(true);
				_bootstrapPullerThread.start();

				_bootstrapDispatcherThread = new UncaughtExceptionTrackingThread(
						_bootstrapDispatcher, _bootstrapDispatcher.getName());
				_bootstrapDispatcherThread.setDaemon(true);
				_bootstrapDispatcherThread.start();
			}
		}

		@Override
		public void shutdown()
		{
		  _log.info("shutting down connection ...");
		  _relayPuller.shutdown();
		  _relayDispatcher.shutdown();
		  if (_bootstrapPuller != null)
		  {
		    _bootstrapPuller.shutdown();
		  }
		  if (_bootstrapDispatcher != null)
		  {
		    _bootstrapDispatcher.shutdown();
		  }

		  _relayPullerThread.interrupt();
		  _relayDispatcherThread.interrupt();

		  if (_isBootstrapEnabled)
		  {
		    _bootstrapPullerThread.interrupt();
		    _bootstrapDispatcherThread.interrupt();
		  }

		  super.shutdown();
		  _nannyThread.interrupt();
		  _log.info("connection shut down.");
		}

		@Override
		public void pause() {
			_relayPuller.enqueueMessage(LifecycleMessage.createPauseMessage());
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createPauseMessage());
			}

			super.pause();
		}

		@Override
		public void resume() {
			_relayPuller.enqueueMessage(LifecycleMessage.createResumeMessage());
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createResumeMessage());
			}

			super.resume();
		}

		@Override
		public void suspendOnError(Throwable cause) {
			_relayPuller.enqueueMessage(LifecycleMessage
					.createSuspendOnErroMessage(cause));
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createSuspendOnErroMessage(cause));
			}

			super.suspendOnError(cause);
		}
	}

	public static class StaticConfig {
		private final DbusEventBuffer.StaticConfig _eventBuffer;
		private final DbusEventBuffer.StaticConfig _bstEventBuffer;
		private final long _consumerTimeBudgetMs;
		private final long _bstConsumerTimeBudgetMs;
		private final int _consumerParallelism;
		private final double _checkpointThresholdPct;
		private final Range _keyRange;
		private final BackoffTimerStaticConfig _bsPullerRetriesBeforeCkptCleanup;
		private final BackoffTimerStaticConfig _pullerRetries;
		private final BackoffTimerStaticConfig _bstPullerRetries;
		private final BackoffTimerStaticConfig _dispatcherRetries;
		private final BackoffTimerStaticConfig _bstDispatcherRetries;
		private final int _freeBufferThreshold;
		private final boolean _consumeCurrent;
		private final boolean _readLatestScnOnError;
		private final double _pullerBufferUtilizationPct;
		private final int _id;
		private final boolean _enablePullerMessageQueueLogging;
		private final int _numRetriesOnFallOff;
		private final int _noEventsConnectionResetTimeSec;

		public StaticConfig(DbusEventBuffer.StaticConfig eventBuffer,
				DbusEventBuffer.StaticConfig bstEventBuffer,
				long consumerTimeBudgetMs, long bstConsumerTimeBudgetMs, int consumerParallelism,
				double checkpointThresholdPct, Range keyRange,
				BackoffTimerStaticConfig bsPullerRetriesBeforeCkptCleanup,
				BackoffTimerStaticConfig pullerRetries,
				BackoffTimerStaticConfig bstPullerRetries,
				BackoffTimerStaticConfig dispatcherRetries,
				BackoffTimerStaticConfig bstDispatcherRetries,
				int retriesOnFellOff, int freeBufferThreshold,
				boolean consumeCurrent, boolean readLatestScnOnError,
				double pullerBufferUtilizationPct, int id,
				boolean enablePullerMessageQueueLogging,
				int noEventsConnectionResetTimeSec
				) {
			super();
			_eventBuffer = eventBuffer;
			_bstEventBuffer = bstEventBuffer;
			_consumerTimeBudgetMs = consumerTimeBudgetMs;
			_bstConsumerTimeBudgetMs = bstConsumerTimeBudgetMs;
			_consumerParallelism = consumerParallelism;
			_checkpointThresholdPct = checkpointThresholdPct;
			_keyRange = keyRange;
			_bsPullerRetriesBeforeCkptCleanup = bsPullerRetriesBeforeCkptCleanup;
			_pullerRetries = pullerRetries;
			_bstPullerRetries = bstPullerRetries;
			_dispatcherRetries = dispatcherRetries;
			_bstDispatcherRetries = bstDispatcherRetries;
			_numRetriesOnFallOff = retriesOnFellOff;
			_freeBufferThreshold = (freeBufferThreshold > eventBuffer.getReadBufferSize()) ? eventBuffer.getReadBufferSize()/2:freeBufferThreshold;
			_consumeCurrent = consumeCurrent;
			_readLatestScnOnError = readLatestScnOnError;
			_pullerBufferUtilizationPct = pullerBufferUtilizationPct;
			_id = id;
			_enablePullerMessageQueueLogging = enablePullerMessageQueueLogging;
			_noEventsConnectionResetTimeSec = noEventsConnectionResetTimeSec;

		}


		public int getNoEventsConnectionResetTimeSec() {
			return _noEventsConnectionResetTimeSec;
		}
		public DbusEventBuffer.StaticConfig getBstEventBuffer() {
			return _bstEventBuffer;
		}

		public long getBstConsumerTimeBudgetMs() {
			return _bstConsumerTimeBudgetMs;
		}

		public BackoffTimerStaticConfig getBstDispatcherRetries() {
			return _bstDispatcherRetries;
		}

		public boolean getReadLatestScnOnError() {
			return _readLatestScnOnError;
		}

		public boolean isReadLatestScnOnErrorEnabled() {
			return _readLatestScnOnError;
		}

		public double getPullerUtilizationPct() {
			return _pullerBufferUtilizationPct;
		}

		public int getId() {
			return _id;
		}

		public boolean getConsumeCurrent() {
			return _consumeCurrent;
		}

		/** The relay event buffer static configuration */
		public DbusEventBuffer.StaticConfig getEventBuffer() {
			return _eventBuffer;
		}

		/**
		 * Max time in milliseconds that a consumer should use to process an
		 * event before it is considered failed
		 */
		public long getConsumerTimeBudgetMs() {
			return _consumerTimeBudgetMs;
		}

		/**
		 * Max number of consumers that can be called in parallel to process an
		 * event
		 */
		public int getConsumerParallelism() {
			return _consumerParallelism;
		}

		/**
		 * The percentage of event buffer occupancy that will trigger a
		 * checkpoint attempt. This is to ensure that we can make progress in
		 * large event windows without having to reprocess them entirely in case
		 * of a failure.
		 */
		public double getCheckpointThresholdPct() {
			return _checkpointThresholdPct;
		}

		public Range getKeyRange() {
			return _keyRange;
		}

		/**
		 * Pull requests and error retries configuration when talking to the
		 * relays or bootstrap servers
		 */
		public BackoffTimerStaticConfig getPullerRetries() {
			return _pullerRetries;
		}

		public BackoffTimerStaticConfig getBstPullerRetries() {
			return _bstPullerRetries;
		}

		/** Error retries configuration calling the consumer code */
		public BackoffTimerStaticConfig getDispatcherRetries() {
			return _dispatcherRetries;
		}

		/**
		 * This config controls how many retries will be made on the same
		 * bootstrap Server before switching and clearing the checkpoint
		 */
		public BackoffTimerStaticConfig getBsPullerRetriesBeforeCkptCleanup() {
			return _bsPullerRetriesBeforeCkptCleanup;
		}

		/**
		 * This config controls how many retries will be made when it received
		 * ScnNotFoundException before
		 * bootstrapping/suspending/reading-latest-event
		 */
		public int getNumRetriesOnFallOff() {
			return _numRetriesOnFallOff;
		}

		/**
		 * Minimum number of bytes that need to be available in the buffer
		 * before the Puller's can request for more events. Ideally this is more
		 * than max event size
		 */
		public int getFreeBufferThreshold() {
			return _freeBufferThreshold;
		}

		public boolean isPullerMessageQueueLoggingEnabled() {
			return _enablePullerMessageQueueLogging;
		}

		@Override
		public String toString() {
			return "StaticConfig [_eventBuffer=" + _eventBuffer
					+ ", _bstEventBuffer=" + _bstEventBuffer
					+ ", _consumerTimeBudgetMs=" + _consumerTimeBudgetMs
					+ ", _bstConsumerTimeBudgetMs=" + _bstConsumerTimeBudgetMs
					+ ", _consumerParallelism=" + _consumerParallelism
					+ ", _checkpointThresholdPct=" + _checkpointThresholdPct
					+ ", _keyRange=" + _keyRange
					+ ", _bsPullerRetriesBeforeCkptCleanup="
					+ _bsPullerRetriesBeforeCkptCleanup + ", _pullerRetries="
					+ _pullerRetries + ", _bstPullerRetries=" + _bstPullerRetries + ", _dispatcherRetries="
					+ _dispatcherRetries + ", _bstDispatcherRetries="
					+ _bstDispatcherRetries + ", _freeBufferThreshold="
					+ _freeBufferThreshold
					+ ", _enablePullerMessageQueueLogging="
					+ _enablePullerMessageQueueLogging + "]";
		}
	}

	public static class Config implements ConfigBuilder<StaticConfig> {
		private static final long DEFAULT_KEY_RANGE_MIN = -1L;
		private static final long DEFAULT_KEY_RANGE_MAX = -1L;

		private static final long DEFAULT_MAX_BUFFER_SIZE = 10 * 1024 * 1024;
		private static final int DEFAULT_INIT_READBUFFER_SIZE = 20 * 1024;
		private static final int DEFAULT_MAX_SCNINDEX_SIZE = 1024 * 1024;
		private static final boolean DEFAULT_PULLER_MESSAGE_QUEUE_LOGGING = false;

		private static int DEFAULT_MAX_RETRY_NUM = -1;
		private static int DEFAULT_INIT_SLEEP = 100;
		private static double DEFAULT_SLEEP_INC_FACTOR = 1.1;

		// Default Sleep : InitSleep : 1 sec, then keep incrementing 1.5*prev + 1 sec for
		// subsequent retry, upto 1000 retries. (there is a limit on max sleep set to 1 minute)
		// so at the worst case it will wait for ~16 hours
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_MAX_RETRY_NUM = 1000;
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_INIT_SLEEP = 1 * 1000;
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_DELTA = 1000;
		private static double DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_FACTOR = 1.5;
		private static int DEFAULT_FREE_BUFFER_THRESHOLD=10*1024;

		// Default Config woul be to retry 5 times w
		private static int DEFAULT_RETRY_ON_FELLOFF_MAX_RETRY_NUM = 5;

		private final Logger _log = Logger.getLogger(Config.class);
		private DbusEventBuffer.Config _eventBuffer;
		private DbusEventBuffer.Config _bstEventBuffer = null;
		private long _consumerTimeBudgetMs = 300000;
		private long _bstConsumerTimeBudgetMs = 300000;
		private boolean _setBstConsumerTimeBudgetCalled = false;
		private int _consumerParallelism = 1;
		private double _checkpointThresholdPct;
		private long _keyMin;
		private long _keyMax;
		private BackoffTimerStaticConfigBuilder _bsPullerRetriesBeforeCkptCleanup;
		private BackoffTimerStaticConfigBuilder _pullerRetries;
		private BackoffTimerStaticConfigBuilder _bstPullerRetries;
		private BackoffTimerStaticConfigBuilder _dispatcherRetries;
		private BackoffTimerStaticConfigBuilder _bstDispatcherRetries = null;
		private int _numRetriesOnFallOff;

		//optimization - depreating the ability to alter the value
		private int _freeBufferThreshold = DEFAULT_FREE_BUFFER_THRESHOLD;
		private boolean _consumeCurrent = false;
		private boolean _readLatestScnOnError = false;
		private double _pullerBufferUtilizationPct = 100.0;
		private int _id;
		private boolean _enablePullerMessageQueueLogging;
		private int _noEventsConnectionResetTimeSec = 15*60; // if there is no events for 15 min - disconnect

		private void makeEvbConfig(DbusEventBuffer.Config evbConfig,
																QueuePolicy qPolicy,
																boolean enableScnIndex,
																double defaultMemUsage)
		{
			evbConfig.setQueuePolicy(qPolicy.toString());
			evbConfig.setEnableScnIndex(enableScnIndex);
			evbConfig.setDefaultMemUsage(defaultMemUsage);
			if (evbConfig.getMaxSize() > DEFAULT_MAX_BUFFER_SIZE) {
	       _log.warn("Setting buffer size to " + DEFAULT_MAX_BUFFER_SIZE + " instead of requested size " + evbConfig.getMaxSize());
				evbConfig.setMaxSize(DEFAULT_MAX_BUFFER_SIZE);
			}

			if (evbConfig.getScnIndexSize() > DEFAULT_MAX_SCNINDEX_SIZE) {
				evbConfig.setScnIndexSize(DEFAULT_MAX_SCNINDEX_SIZE);
			}
		}

		public Config() {
			_eventBuffer = new DbusEventBuffer.Config();
			makeEvbConfig(_eventBuffer, QueuePolicy.BLOCK_ON_WRITE, false, 0.1);

			_checkpointThresholdPct = 75.0;
			_keyMin = DEFAULT_KEY_RANGE_MIN;
			_keyMax = DEFAULT_KEY_RANGE_MAX;

			_pullerRetries = new BackoffTimerStaticConfigBuilder();
			_pullerRetries.setInitSleep(DEFAULT_INIT_SLEEP);
			_pullerRetries.setSleepIncFactor(DEFAULT_SLEEP_INC_FACTOR);
			_pullerRetries.setMaxRetryNum(DEFAULT_MAX_RETRY_NUM);

			_bsPullerRetriesBeforeCkptCleanup = new BackoffTimerStaticConfigBuilder();
			_bsPullerRetriesBeforeCkptCleanup
					.setInitSleep(DEFAULT_BSPULLER_CKPTCLEANUP_INIT_SLEEP);
			_bsPullerRetriesBeforeCkptCleanup
					.setSleepIncDelta(DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_DELTA);
			_bsPullerRetriesBeforeCkptCleanup
					.setMaxRetryNum(DEFAULT_BSPULLER_CKPTCLEANUP_MAX_RETRY_NUM);
			_bsPullerRetriesBeforeCkptCleanup
					.setSleepIncFactor(DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_FACTOR);

			_numRetriesOnFallOff = DEFAULT_RETRY_ON_FELLOFF_MAX_RETRY_NUM;

			_dispatcherRetries = new BackoffTimerStaticConfigBuilder();
			_dispatcherRetries.setSleepIncFactor(1.1);
			_dispatcherRetries.setMaxRetryNum(-1);
			_enablePullerMessageQueueLogging = DEFAULT_PULLER_MESSAGE_QUEUE_LOGGING;
		}

		public Config(Config other) {
			_eventBuffer = new DbusEventBuffer.Config(other.getEventBuffer());
			if (other.hasBstEventBuffer()) {
				_bstEventBuffer = new DbusEventBuffer.Config(other.getBstEventBuffer());
			} else {
				_bstEventBuffer = null;
			}
		}

		public DbusEventBuffer.Config getEventBuffer() {
			return _eventBuffer;
		}

		/**
		 * If anyone other than spring config ever calls this method they should first call hasBstEventBuffer().
		 *
		 * @return a newly constructed DbusEventBuffer.Config object.
		 */
		public DbusEventBuffer.Config getBstEventBuffer() {
			if (_bstEventBuffer != null) {
				return _bstEventBuffer;
			}
			_bstEventBuffer = new DbusEventBuffer.Config();
			makeEvbConfig(_bstEventBuffer, QueuePolicy.BLOCK_ON_WRITE, false, 0.1);
			return _bstEventBuffer;
		}

		public boolean hasBstEventBuffer() {
			return _bstEventBuffer != null;
		}

		public void setEventBuffer(DbusEventBuffer.Config eventBuffer) {
			_eventBuffer = eventBuffer;
		}

		/**
		 * Corrects, checkpointThresholdPct to accommodate largestEventSize by calculating checkpoint threshold pct
		 * override checkpoint threshold pct settings if (between 10 and 90 pct) to set the maximum
		 * @param bufCfg : buffer config; with maxEventSize set
		 * @return checkpointThresholdPct;
		 */
		public double computeSafeCheckpointThresholdPct(DbusEventBuffer.Config bufCfg)
		{
		  int safeMaxEventSize = (int)((100.0 - _checkpointThresholdPct) * bufCfg.maxMaxEventSize() / 100.0);
		  if (DbusEventBuffer.Config.DEFAULT_MAX_EVENT_SIZE == bufCfg.getMaxEventSize())
		  {
		      //maxEventSize not set; return existing checkpointThresholdPct
		    return _checkpointThresholdPct;
		  }
		  else if (safeMaxEventSize >= bufCfg.getMaxEventSize())
		  {
		    //maxEventSize is lesser than safeSize ; return checkpointThresholdPct;
		    return _checkpointThresholdPct;
		  }
		  //case where checkpointThresholdPct has to be computed;
		  return 100.0 - ((double)(bufCfg.getMaxEventSize()+_freeBufferThreshold)/bufCfg.maxMaxEventSize())*100.0;
		}

		private void validateBufferConfig(StaticConfig connConfig,DbusEventBuffer.StaticConfig bufferConfig) throws InvalidConfigException
		{
		  long bufferCapacityInBytes = bufferConfig.getMaxSize();
=======
    private void validateBufferConfig(StaticConfig connConfig,DbusEventBuffer.StaticConfig bufferConfig) throws InvalidConfigException
    {
      long bufferCapacityInBytes = bufferConfig.getMaxSize();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestBootstrapPullThread.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestBootstrapPullThread.java;<<<<<<< MINE
		  												boolean throwBSConnException,
				  										boolean muteTransition,
				  										boolean readDataThrowException,
				  										boolean readDataException,
				  										String exceptionName,
				  										int freeReadSpace,
				  										int numBytesRead,
				  										boolean phaseCompleted,
				  										long startScn,
				  										long targetScn,
				  										String... sourceNames)
		throws Exception
  {
	  List<String> sources = Arrays.asList(sourceNames);

	  Properties clientProps = new Properties();

	  clientProps.setProperty("client.container.httpPort", "0");
      clientProps.setProperty("client.container.jmx.rmiEnabled", "false");

	  clientProps.setProperty("client.runtime.bootstrap.enabled", "true");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).name", "bs1");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).port", "10001");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).sources", "source1");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).name", "bs2");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).port", "10002");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).sources", "source1");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).name", "bs3");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).port", "10003");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).sources", "source1");

	  clientProps.setProperty("client.runtime.relay(1).name", "relay1");
	  clientProps.setProperty("client.runtime.relay(1).port", "10001");
	  clientProps.setProperty("client.runtime.relay(1).sources", "source1");
	  clientProps.setProperty("client.runtime.relay(2).name", "relay2");
	  clientProps.setProperty("client.runtime.relay(2).port", "10002");
	  clientProps.setProperty("client.runtime.relay(2).sources", "source1");
	  clientProps.setProperty("client.runtime.relay(3).name", "relay3");
	  clientProps.setProperty("client.runtime.relay(3).port", "10003");
	  clientProps.setProperty("client.runtime.relay(3).sources", "source1");

	  clientProps.setProperty("client.connectionDefaults.eventBuffer.maxSize", "100000");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.maxRetryNum", "9");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncFactor", "1.0");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncDelta", "1");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.initSleep", "1");

	  DatabusHttpClientImpl.Config clientConfBuilder = new DatabusHttpClientImpl.Config();
	  ConfigLoader<DatabusHttpClientImpl.StaticConfig> configLoader =
			  new ConfigLoader<DatabusHttpClientImpl.StaticConfig>("client.", clientConfBuilder);
	  configLoader.loadConfig(clientProps);

	  DatabusHttpClientImpl.StaticConfig clientConf = clientConfBuilder.build();
	  DatabusSourcesConnection.StaticConfig srcConnConf = clientConf.getConnectionDefaults();

	  DatabusHttpClientImpl client = new DatabusHttpClientImpl(clientConf);

	  client.registerDatabusBootstrapListener(new LoggingConsumer(), null, "source1");

	  Assert.assertNotNull(client, "client instantiation ok");

	  DatabusHttpClientImpl.RuntimeConfig clientRtConf = clientConf.getRuntime().build();

	  //we keep the index of the next server we expect to see
	  AtomicInteger serverIdx = new AtomicInteger(-1);

	  //generate the order in which we should see the servers
	  List<ServerInfo> relayOrder = new ArrayList<ServerInfo>(clientRtConf.getRelays());
	  if (LOG.isInfoEnabled())
	  {
		  StringBuilder sb = new StringBuilder();
		  for (ServerInfo serverInfo: relayOrder)
		  {
			  sb.append(serverInfo.getName());
			  sb.append(" ");
		  }
		  LOG.info("Relay order:" + sb.toString());
	  }

	  List<IdNamePair> sourcesResponse = new ArrayList<IdNamePair>();
	  sourcesResponse.add(new IdNamePair(1L, "source1"));

	  Map<Long, List<RegisterResponseEntry>> registerResponse = new HashMap<Long, List<RegisterResponseEntry>>();

	  List<RegisterResponseEntry> regResponse = new ArrayList<RegisterResponseEntry>();
	  regResponse.add(new RegisterResponseEntry(1L, (short)1, SCHEMA$.toString()));
	  registerResponse.put(1L, regResponse);

	  ChunkedBodyReadableByteChannel channel = EasyMock.createMock(ChunkedBodyReadableByteChannel.class);

	  if ( ! readDataException)
	  {
		  EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(null).anyTimes();
		  EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(null).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(null).anyTimes();
	  } else {
		  EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(exceptionName).anyTimes();
		  EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(exceptionName).anyTimes();
		  EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(exceptionName).anyTimes();
	  }

	  if ( phaseCompleted)
	    EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn("true").anyTimes();
	  else
		EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn(null).anyTimes();

	  EasyMock.replay(channel);

	  DbusEventBuffer dbusBuffer = EasyMock.createMock(DbusEventBuffer.class);
	  dbusBuffer.endEvents(false, -1, false, false, null);
	  EasyMock.expectLastCall().anyTimes();
	  EasyMock.expect(dbusBuffer.injectEvent(EasyMock.<DbusEventInternalReadable>notNull())).andReturn(true).anyTimes();
	  EasyMock.expect(dbusBuffer.getEventSerializationVersion()).andReturn(DbusEventFactory.DBUS_EVENT_V1).anyTimes();

	  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull(),
	                                        org.easymock.EasyMock.<List<InternalDatabusEventsListener>>notNull(),
	                                        org.easymock.EasyMock.<DbusEventsStatisticsCollector>isNull()))
	          .andReturn(numBytesRead).anyTimes();

	  if ( readDataThrowException)
	  {
		  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
		          .andThrow(new RuntimeException("dummy")).anyTimes();
	  } else {
		  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
		          .andReturn(numBytesRead).anyTimes();
	  }

	  EasyMock.expect(dbusBuffer.acquireIterator(EasyMock.<String>notNull())).andReturn(null).anyTimes();
	  dbusBuffer.waitForFreeSpace((int)(10000 * 100.0 / clientConf.getPullerBufferUtilizationPct()));
	  EasyMock.expectLastCall().anyTimes();
	  EasyMock.expect(dbusBuffer.getBufferFreeReadSpace()).andReturn(freeReadSpace).anyTimes();

	  EasyMock.replay(dbusBuffer);

	  //This guy succeeds on /sources but fails on /register
	  MockBootstrapConnection mockSuccessConn = new MockBootstrapConnection(startScn, targetScn, channel, serverIdx,
	                                                                        muteTransition);

	  DatabusBootstrapConnectionFactory mockConnFactory =
			  org.easymock.EasyMock.createMock("mockRelayFactory", DatabusBootstrapConnectionFactory.class);

	  //each server should be tried MAX_RETRIES time until all retries are exhausted

	  if ( throwBSConnException )
	  {
		  EasyMock.expect(mockConnFactory.createConnection(
				  EasyMock.<ServerInfo>notNull(),
				  EasyMock.<ActorMessageQueue>notNull(),
				  EasyMock.<RemoteExceptionHandler>notNull())).andThrow(new RuntimeException("Mock Error")).anyTimes();
	  } else if ( failBsConnection) {
		  EasyMock.expect(mockConnFactory.createConnection(
				  EasyMock.<ServerInfo>notNull(),
				  EasyMock.<ActorMessageQueue>notNull(),
				  EasyMock.<RemoteExceptionHandler>notNull())).andReturn(null).anyTimes();
||||||| BASE
		  												boolean throwBSConnException,
				  										boolean muteTransition,
				  										boolean readDataThrowException,
				  										boolean readDataException,
				  										String exceptionName,
				  										int freeReadSpace,
				  										int numBytesRead,
				  										boolean phaseCompleted,
				  										long startScn,
				  										long targetScn,
				  										String... sourceNames)
		throws Exception
  {
	  List<String> sources = Arrays.asList(sourceNames);

	  Properties clientProps = new Properties();

	  clientProps.setProperty("client.container.httpPort", "0");
      clientProps.setProperty("client.container.jmx.rmiEnabled", "false");

	  clientProps.setProperty("client.runtime.bootstrap.enabled", "true");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).name", "bs1");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).port", "10001");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).sources", "source1");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).name", "bs2");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).port", "10002");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).sources", "source1");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).name", "bs3");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).port", "10003");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).sources", "source1");

	  clientProps.setProperty("client.runtime.relay(1).name", "relay1");
	  clientProps.setProperty("client.runtime.relay(1).port", "10001");
	  clientProps.setProperty("client.runtime.relay(1).sources", "source1");
	  clientProps.setProperty("client.runtime.relay(2).name", "relay2");
	  clientProps.setProperty("client.runtime.relay(2).port", "10002");
	  clientProps.setProperty("client.runtime.relay(2).sources", "source1");
	  clientProps.setProperty("client.runtime.relay(3).name", "relay3");
	  clientProps.setProperty("client.runtime.relay(3).port", "10003");
	  clientProps.setProperty("client.runtime.relay(3).sources", "source1");

	  clientProps.setProperty("client.connectionDefaults.eventBuffer.maxSize", "100000");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.maxRetryNum", "9");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncFactor", "1.0");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncDelta", "1");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.initSleep", "1");

	  DatabusHttpClientImpl.Config clientConfBuilder = new DatabusHttpClientImpl.Config();
	  ConfigLoader<DatabusHttpClientImpl.StaticConfig> configLoader =
			  new ConfigLoader<DatabusHttpClientImpl.StaticConfig>("client.", clientConfBuilder);
	  configLoader.loadConfig(clientProps);

	  DatabusHttpClientImpl.StaticConfig clientConf = clientConfBuilder.build();
	  DatabusSourcesConnection.StaticConfig srcConnConf = clientConf.getConnectionDefaults();

	  DatabusHttpClientImpl client = new DatabusHttpClientImpl(clientConf);

	  client.registerDatabusBootstrapListener(new LoggingConsumer(), null, "source1");

	  Assert.assertNotNull(client, "client instantiation ok");

	  DatabusHttpClientImpl.RuntimeConfig clientRtConf = clientConf.getRuntime().build();

	  //we keep the index of the next server we expect to see
	  AtomicInteger serverIdx = new AtomicInteger(-1);

	  //generate the order in which we should see the servers
	  List<ServerInfo> relayOrder = new ArrayList<ServerInfo>(clientRtConf.getRelays());
	  if (LOG.isInfoEnabled())
	  {
		  StringBuilder sb = new StringBuilder();
		  for (ServerInfo serverInfo: relayOrder)
		  {
			  sb.append(serverInfo.getName());
			  sb.append(" ");
		  }
		  LOG.info("Relay order:" + sb.toString());
	  }

	  List<IdNamePair> sourcesResponse = new ArrayList<IdNamePair>();
	  sourcesResponse.add(new IdNamePair(1L, "source1"));

	  Map<Long, List<RegisterResponseEntry>> registerResponse = new HashMap<Long, List<RegisterResponseEntry>>();

	  List<RegisterResponseEntry> regResponse = new ArrayList<RegisterResponseEntry>();
	  regResponse.add(new RegisterResponseEntry(1L, (short)1, SCHEMA$.toString()));
	  registerResponse.put(1L, regResponse);

	  ChunkedBodyReadableByteChannel channel = EasyMock.createMock(ChunkedBodyReadableByteChannel.class);

	  if ( ! readDataException)
	  {
		  EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(null).anyTimes();
		  EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(null).anyTimes();
	  } else {
		  EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(exceptionName).anyTimes();
		  EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(exceptionName).anyTimes();
	  }

	  if ( phaseCompleted)
	    EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn("true").anyTimes();
	  else
		EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn(null).anyTimes();

	  EasyMock.replay(channel);

	  DbusEventBuffer dbusBuffer = EasyMock.createMock(DbusEventBuffer.class);
	  dbusBuffer.endEvents(false, -1, false, false, null);
	  EasyMock.expectLastCall().anyTimes();
	  EasyMock.expect(dbusBuffer.injectEvent(EasyMock.<DbusEventInternalReadable>notNull())).andReturn(true).anyTimes();
	  EasyMock.expect(dbusBuffer.getEventSerializationVersion()).andReturn(DbusEventFactory.DBUS_EVENT_V1).anyTimes();

	  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull(),
	                                        org.easymock.EasyMock.<List<InternalDatabusEventsListener>>notNull(),
	                                        org.easymock.EasyMock.<DbusEventsStatisticsCollector>isNull()))
	          .andReturn(numBytesRead).anyTimes();

	  if ( readDataThrowException)
	  {
		  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
		          .andThrow(new RuntimeException("dummy")).anyTimes();
	  } else {
		  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
		          .andReturn(numBytesRead).anyTimes();
	  }

	  EasyMock.expect(dbusBuffer.acquireIterator(EasyMock.<String>notNull())).andReturn(null).anyTimes();
	  dbusBuffer.waitForFreeSpace((int)(10000 * 100.0 / clientConf.getPullerBufferUtilizationPct()));
	  EasyMock.expectLastCall().anyTimes();
	  EasyMock.expect(dbusBuffer.getBufferFreeReadSpace()).andReturn(freeReadSpace).anyTimes();

	  EasyMock.replay(dbusBuffer);

	  //This guy succeeds on /sources but fails on /register
	  MockBootstrapConnection mockSuccessConn = new MockBootstrapConnection(startScn, targetScn, channel, serverIdx,
	                                                                        muteTransition);

	  DatabusBootstrapConnectionFactory mockConnFactory =
			  org.easymock.EasyMock.createMock("mockRelayFactory", DatabusBootstrapConnectionFactory.class);

	  //each server should be tried MAX_RETRIES time until all retries are exhausted

	  if ( throwBSConnException )
	  {
		  EasyMock.expect(mockConnFactory.createConnection(
				  EasyMock.<ServerInfo>notNull(),
				  EasyMock.<ActorMessageQueue>notNull(),
				  EasyMock.<RemoteExceptionHandler>notNull())).andThrow(new RuntimeException("Mock Error")).anyTimes();
	  } else if ( failBsConnection) {
		  EasyMock.expect(mockConnFactory.createConnection(
				  EasyMock.<ServerInfo>notNull(),
				  EasyMock.<ActorMessageQueue>notNull(),
				  EasyMock.<RemoteExceptionHandler>notNull())).andReturn(null).anyTimes();
=======
                              boolean throwBSConnException,
                              boolean muteTransition,
                              boolean readDataThrowException,
                              boolean readDataException,
                              String exceptionName,
                              int freeReadSpace,
                              int numBytesRead,
                              boolean phaseCompleted,
                              long startScn,
                              long targetScn,
                              String... sourceNames)
  throws Exception
  {
    List<String> sources = Arrays.asList(sourceNames);

    Properties clientProps = new Properties();

    clientProps.setProperty("client.container.httpPort", "0");
    clientProps.setProperty("client.container.jmx.rmiEnabled", "false");

    clientProps.setProperty("client.runtime.bootstrap.enabled", "true");
    clientProps.setProperty("client.runtime.bootstrap.service(1).name", "bs1");
    clientProps.setProperty("client.runtime.bootstrap.service(1).host", "localhost");
    clientProps.setProperty("client.runtime.bootstrap.service(1).port", "10001");
    clientProps.setProperty("client.runtime.bootstrap.service(1).sources", "source1");
    clientProps.setProperty("client.runtime.bootstrap.service(2).name", "bs2");
    clientProps.setProperty("client.runtime.bootstrap.service(2).host", "localhost");
    clientProps.setProperty("client.runtime.bootstrap.service(2).port", "10002");
    clientProps.setProperty("client.runtime.bootstrap.service(2).sources", "source1");
    clientProps.setProperty("client.runtime.bootstrap.service(3).name", "bs3");
    clientProps.setProperty("client.runtime.bootstrap.service(3).host", "localhost");
    clientProps.setProperty("client.runtime.bootstrap.service(3).port", "10003");
    clientProps.setProperty("client.runtime.bootstrap.service(3).sources", "source1");

    clientProps.setProperty("client.runtime.relay(1).name", "relay1");
    clientProps.setProperty("client.runtime.relay(1).port", "10001");
    clientProps.setProperty("client.runtime.relay(1).sources", "source1");
    clientProps.setProperty("client.runtime.relay(2).name", "relay2");
    clientProps.setProperty("client.runtime.relay(2).port", "10002");
    clientProps.setProperty("client.runtime.relay(2).sources", "source1");
    clientProps.setProperty("client.runtime.relay(3).name", "relay3");
    clientProps.setProperty("client.runtime.relay(3).port", "10003");
    clientProps.setProperty("client.runtime.relay(3).sources", "source1");

    clientProps.setProperty("client.connectionDefaults.eventBuffer.maxSize", "100000");
    clientProps.setProperty("client.connectionDefaults.pullerRetries.maxRetryNum", "9");
    clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncFactor", "1.0");
    clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncDelta", "1");
    clientProps.setProperty("client.connectionDefaults.pullerRetries.initSleep", "1");

    DatabusHttpClientImpl.Config clientConfBuilder = new DatabusHttpClientImpl.Config();
    ConfigLoader<DatabusHttpClientImpl.StaticConfig> configLoader =
        new ConfigLoader<DatabusHttpClientImpl.StaticConfig>("client.", clientConfBuilder);
    configLoader.loadConfig(clientProps);

    DatabusHttpClientImpl.StaticConfig clientConf = clientConfBuilder.build();
    DatabusSourcesConnection.StaticConfig srcConnConf = clientConf.getConnectionDefaults();

    DatabusHttpClientImpl client = new DatabusHttpClientImpl(clientConf);

    client.registerDatabusBootstrapListener(new LoggingConsumer(), null, "source1");

    Assert.assertNotNull(client, "client instantiation ok");

    DatabusHttpClientImpl.RuntimeConfig clientRtConf = clientConf.getRuntime().build();

    //we keep the index of the next server we expect to see
    AtomicInteger serverIdx = new AtomicInteger(-1);

    //generate the order in which we should see the servers
    List<ServerInfo> relayOrder = new ArrayList<ServerInfo>(clientRtConf.getRelays());
    if (LOG.isInfoEnabled())
    {
      StringBuilder sb = new StringBuilder();
      for (ServerInfo serverInfo: relayOrder)
      {
        sb.append(serverInfo.getName());
        sb.append(" ");
      }
      LOG.info("Relay order:" + sb.toString());
    }

    List<IdNamePair> sourcesResponse = new ArrayList<IdNamePair>();
    sourcesResponse.add(new IdNamePair(1L, "source1"));

    Map<Long, List<RegisterResponseEntry>> registerResponse = new HashMap<Long, List<RegisterResponseEntry>>();

    List<RegisterResponseEntry> regResponse = new ArrayList<RegisterResponseEntry>();
    regResponse.add(new RegisterResponseEntry(1L, (short)1, SCHEMA$.toString()));
    registerResponse.put(1L, regResponse);

    ChunkedBodyReadableByteChannel channel = EasyMock.createMock(ChunkedBodyReadableByteChannel.class);

    if ( ! readDataException)
    {
      EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(null).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(null).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(null).anyTimes();
    } else {
      EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(exceptionName).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(exceptionName).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(exceptionName).anyTimes();
    }

    if ( phaseCompleted)
      EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn("true").anyTimes();
    else
    EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn(null).anyTimes();

    EasyMock.replay(channel);

    DbusEventBuffer dbusBuffer = EasyMock.createMock(DbusEventBuffer.class);
    dbusBuffer.endEvents(false, -1, false, false, null);
    EasyMock.expectLastCall().anyTimes();
    EasyMock.expect(dbusBuffer.injectEvent(EasyMock.<DbusEventInternalReadable>notNull())).andReturn(true).anyTimes();
    EasyMock.expect(dbusBuffer.getEventSerializationVersion()).andReturn(DbusEventFactory.DBUS_EVENT_V1).anyTimes();

    EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull(),
                                          org.easymock.EasyMock.<List<InternalDatabusEventsListener>>notNull(),
                                          org.easymock.EasyMock.<DbusEventsStatisticsCollector>isNull()))
            .andReturn(numBytesRead).anyTimes();

    if ( readDataThrowException)
    {
      EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
              .andThrow(new RuntimeException("dummy")).anyTimes();
    } else {
      EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
              .andReturn(numBytesRead).anyTimes();
    }

    EasyMock.expect(dbusBuffer.acquireIterator(EasyMock.<String>notNull())).andReturn(null).anyTimes();
    dbusBuffer.waitForFreeSpace((int)(10000 * 100.0 / clientConf.getPullerBufferUtilizationPct()));
    EasyMock.expectLastCall().anyTimes();
    EasyMock.expect(dbusBuffer.getBufferFreeReadSpace()).andReturn(freeReadSpace).anyTimes();

    EasyMock.replay(dbusBuffer);

    //This guy succeeds on /sources but fails on /register
    MockBootstrapConnection mockSuccessConn = new MockBootstrapConnection(startScn, targetScn, channel, serverIdx,
                                                                          muteTransition);

    DatabusBootstrapConnectionFactory mockConnFactory =
        org.easymock.EasyMock.createMock("mockRelayFactory", DatabusBootstrapConnectionFactory.class);

    //each server should be tried MAX_RETRIES time until all retries are exhausted

    if ( throwBSConnException )
    {
      EasyMock.expect(mockConnFactory.createConnection(
          EasyMock.<ServerInfo>notNull(),
          EasyMock.<ActorMessageQueue>notNull(),
          EasyMock.<RemoteExceptionHandler>notNull())).andThrow(new RuntimeException("Mock Error")).anyTimes();
    } else if ( failBsConnection) {
      EasyMock.expect(mockConnFactory.createConnection(
          EasyMock.<ServerInfo>notNull(),
          EasyMock.<ActorMessageQueue>notNull(),
          EasyMock.<RemoteExceptionHandler>notNull())).andReturn(null).anyTimes();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE

    void runPartialWindowCheckpointPersistence(int numEvents,int maxWindowSize,int numFailWindow) throws Exception
||||||| BASE

    public void runPartialWindowCheckpointPersistence(int numEvents,int maxWindowSize,int numFailWindow) throws Exception
=======
    void runPartialWindowCheckpointPersistence(int numEvents,int maxWindowSize,int numFailWindow) throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
||||||| BASE


=======
        log.info("end\n");
    }

    //This is a negative test for DDSDBUS-3421. We expect dispatcher to fail without dataEvents being called.
    @Test
    public void testAbsentSchemaTest() throws Exception
    {
      runAbsentSchemaTest(true);
      runAbsentSchemaTest(false);
    }

    void runAbsentSchemaTest(boolean setSchemaCheck) throws Exception
    {
      /* Experiment setup */
      int numEvents=100; int maxWindowSize=20;
      int payloadSize = 20;
      int numCheckpoints = numEvents/maxWindowSize;

      /* Consumer creation */
      //setup consumer to fail on data callback at the nth event
      DataDecodingConsumer tConsumer = new DataDecodingConsumer();

      HashMap<Long, List<RegisterResponseEntry>> schemaMap =
              new HashMap<Long, List<RegisterResponseEntry>>();

      short srcId=1;
      List<RegisterResponseEntry> l1 = new ArrayList<RegisterResponseEntry>();
      l1.add(new RegisterResponseEntry(1L, srcId,SOURCE1_SCHEMA_STR));

      schemaMap.put(1L, l1);

      Map<Long, IdNamePair> sourcesMap = new HashMap<Long, IdNamePair>();
      List<String> sources = new ArrayList<String>();
      for (int i = 1; i <= 1; ++i)
      {
          IdNamePair sourcePair = new IdNamePair((long)i, "source" + i);
          sources.add(sourcePair.getName());
          sourcesMap.put(sourcePair.getId(), sourcePair);
      }

      long consumerTimeBudgetMs = 60*1000;
      DatabusV2ConsumerRegistration consumerReg = new DatabusV2ConsumerRegistration(tConsumer, sources, null);
      List<DatabusV2ConsumerRegistration> allRegistrations =  Arrays.asList(consumerReg);
      //Single threaded execution of consumer
      MultiConsumerCallback mConsumer = new MultiConsumerCallback(allRegistrations,Executors.newFixedThreadPool(1),
              consumerTimeBudgetMs,new StreamConsumerCallbackFactory(null,null),null,null, null);



      /* Generate events **/
      Vector<DbusEvent> srcTestEvents = new Vector<DbusEvent>();
      Vector<Short> srcIdList = new Vector<Short> ();
      srcIdList.add(srcId);

      DbusEventGenerator evGen = new DbusEventGenerator(0,srcIdList);
      //the schemaIds generated here are random. They will not be the same as those computed in the dispatcher.
      //The result is either the processing will fail early (desired behaviour) or during event decoding in the onDataEvent()
      Assert.assertTrue(evGen.generateEvents(numEvents, maxWindowSize, 512, payloadSize, srcTestEvents) > 0);

      int totalSize=0; int maxSize=0;
      for (DbusEvent e : srcTestEvents)
      {
          totalSize += e.size();
          maxSize = (e.size() > maxSize) ? e.size():maxSize;
      }

      /* Source configuration */
      DatabusSourcesConnection.Config conf = new DatabusSourcesConnection.Config();
      conf.getDispatcherRetries().setMaxRetryNum(1);
      conf.setFreeBufferThreshold(maxSize);
      conf.setConsumerTimeBudgetMs(consumerTimeBudgetMs);
      int freeBufferThreshold = conf.getFreeBufferThreshold();
      DatabusSourcesConnection.StaticConfig connConfig = conf.build();

      //make buffer large enough to hold data; the control events are large that contain checkpoints
      int producerBufferSize =  totalSize*2 + numCheckpoints*10*maxSize*5 + freeBufferThreshold;
      int individualBufferSize = producerBufferSize;
      int indexSize = producerBufferSize / 10;
      int stagingBufferSize = producerBufferSize;

      /*Event Buffer creation */
      TestGenericDispatcherEventBuffer dataEventsBuffer=
          new TestGenericDispatcherEventBuffer(
              getConfig(producerBufferSize, individualBufferSize, indexSize ,
                        stagingBufferSize, AllocationPolicy.HEAP_MEMORY,
                        QueuePolicy.BLOCK_ON_WRITE));

      List<DatabusSubscription> subs = DatabusSubscription.createSubscriptionList(sources);
      /* Generic Dispatcher creation */
      TestDispatcher<DatabusCombinedConsumer> dispatcher = new TestDispatcher<DatabusCombinedConsumer>("rollBackcheck",
              connConfig,
              subs,
              new InMemoryPersistenceProvider(),
              dataEventsBuffer,
              mConsumer,
              false);
      //DDSDBUS-3421; set schema check to true
      dispatcher.setSchemaIdCheck(setSchemaCheck);

      /* Launch writer */
      DbusEventAppender eventProducer = new DbusEventAppender(srcTestEvents, dataEventsBuffer,0 ,null) ;
      Thread tEmitter = new Thread(eventProducer);
      tEmitter.start();

      /* Launch dispatcher */
      Thread tDispatcher = new Thread(dispatcher);
      tDispatcher.start();

      /* Now initialize this  state machine */
      dispatcher.enqueueMessage(SourcesMessage.createSetSourcesIdsMessage(sourcesMap.values()));
      dispatcher.enqueueMessage(SourcesMessage.createSetSourcesSchemasMessage(schemaMap));

      //be generous ; use worst case for num control events
      long waitTimeMs  = (numEvents*1 + numEvents*1) * 4;
      tEmitter.join(waitTimeMs);
      //wait for dispatcher to finish reading the events;
      tDispatcher.join(waitTimeMs);
      Assert.assertFalse(tEmitter.isAlive());

      //asserts
      if (!setSchemaCheck)
      {
        //decoding fails many errors show up;
        Assert.assertTrue(tConsumer.getNumDataEvents() > 0);
        Assert.assertTrue(tConsumer.getNumErrors() > 0);
      }
      else
      {
        //never gets to decoding; but error shows up (exactly one - dispatcher retries set to 1);
        Assert.assertEquals(0, tConsumer.getNumDataEvents());
        Assert.assertEquals(1,tConsumer.getNumErrors());
      }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
        _isRelayDispatcher = isRelayDispatcher;
||||||| BASE
=======
        _isRelayDispatcher = isRelayDispatcher;
        //disable schemaIdCheck at onStartSource() by default, in the interest of many unit tests written without paying attention to same schemaIds being present in events
        _schemaIdCheck=false;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
}

||||||| BASE
=======
}


>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    try
    {
      ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(id,conf);
      ccp.storeCheckpoint(sources, cp);
||||||| BASE
      try
      {
          ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(id,conf);
          ccp.storeCheckpoint(sources, cp);
=======
    try
    {
      ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(id,conf);
      ccp.storeCheckpoint(sources, cp);

      Checkpoint newCp = ccp.loadCheckpoint(sources);
      Assert.assertTrue(newCp != null);
      Assert.assertTrue(newCp.getWindowOffset()==cp.getWindowOffset());
      Assert.assertTrue(newCp.getWindowScn()==cp.getWindowScn());
      Assert.assertTrue(newCp.getConsumptionMode()==cp.getConsumptionMode());

    }
    catch (InvalidConfigException e)
    {
      System.err.println("Invalid config: " + e);
      Assert.assertTrue(false);
    }
    catch (IOException e)
    {
      System.err.println("Error storing checkpoint: " + e);
      Assert.assertTrue(false);
    }
    catch (ClusterCheckpointException e)
    {
      Assert.assertTrue(false);
    }
    finally
    {
      ClusterCheckpointPersistenceProvider.close(clusterName);
    }

  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      Checkpoint newCp = ccp.loadCheckpoint(sources);
      Assert.assertTrue(newCp != null);
      Assert.assertTrue(newCp.getWindowOffset()==cp.getWindowOffset());
      Assert.assertTrue(newCp.getWindowScn()==cp.getWindowScn());
      Assert.assertTrue(newCp.getConsumptionMode()==cp.getConsumptionMode());
||||||| BASE
          Checkpoint newCp = ccp.loadCheckpoint(sources);
          Assert.assertTrue(newCp != null);
          Assert.assertTrue(newCp.getWindowOffset()==cp.getWindowOffset());
          Assert.assertTrue(newCp.getWindowScn()==cp.getWindowScn());
          Assert.assertTrue(newCp.getConsumptionMode()==cp.getConsumptionMode());
          ClusterCheckpointPersistenceProvider.close(clusterName);
=======
  @Test
  public void testFrequencyOfCheckpoints() throws Exception
  {
    Checkpoint cp = new Checkpoint();
    long startWindowScn = 50532L;
    cp.setWindowScn(startWindowScn);
    cp.setWindowOffset(-1);
    cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

    final int checkPointIntervalMs = 75;
    final long delayMs = 31;
    final int numAttemptedWrites = 7;
    // We should write at 0, 31, 62, 93, 123, 155, 186, but only at at 0, 93, 155
    // Persistent provider clock: 0              75           150            225
    // checkpoint store clock     0    31   62       93  123      155  186
    final int expectedActualStores = 3;

    String id = "5";
    String clusterName = "test-cluster-freq";
    ClusterCheckpointPersistenceProvider.createCluster(zkAddr, clusterName);
    ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
    conf.setClusterName(clusterName);
    conf.setZkAddr(zkAddr);
    conf.setCheckpointIntervalMs(checkPointIntervalMs);

    ArrayList<String> sources = new ArrayList<String>(3);
    sources.add("source1");
    sources.add("source2");
    sources.add("source3");
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    }
    catch (InvalidConfigException e)
    {
      System.err.println("Invalid config: " + e);
      Assert.assertTrue(false);
    }
    catch (IOException e)
    {
      System.err.println("Error storing checkpoint: " + e);
      Assert.assertTrue(false);
    }
    catch (ClusterCheckpointException e)
    {
      Assert.assertTrue(false);
    }
    finally
    {
      ClusterCheckpointPersistenceProvider.close(clusterName);
    }
||||||| BASE
      }
      catch (InvalidConfigException e)
      {
          System.err.println("Invalid config: " + e);
          Assert.assertTrue(false);
      }
      catch (IOException e)
      {
          System.err.println("Error storing checkpoint: " + e);
          Assert.assertTrue(false);
      }
      catch (ClusterCheckpointException e)
      {
    	  Assert.assertTrue(false);
      }
=======
    try
    {
      TestFrequencyCPP ccp = new TestFrequencyCPP(id, conf);
      for (int i = 0; i < numAttemptedWrites; ++i)
      {
        cp.setWindowScn(startWindowScn + i);
        ccp.storeCheckpoint(sources, cp);
        Checkpoint newCp = ccp.getStoredCheckpoint();
        // cp integrity checks
        Assert.assertTrue(newCp != null);
        Assert.assertTrue(newCp.getWindowOffset() == cp
            .getWindowOffset());
        Assert.assertTrue(newCp.getConsumptionMode() == cp
            .getConsumptionMode());
        // skipped store test;
        Thread.sleep(delayMs);
      }
      Assert.assertEquals(ccp.getnStores(), expectedActualStores);
    }
    finally
    {
      ClusterCheckpointPersistenceProvider.close(clusterName);
    }
  }

  @Test
  public void testMultipleClusterCheckpointPersistence()
  {
    try
    {
      String[] partitionIds = { "1", "2", "3", "4", "5", "6" };
      String[] clusters = { "tcluster1", "tcluster2", "tcluster3" };
      ArrayList<CheckpointRW> cpRws = new ArrayList<TestClusterCheckpointPersistenceProvider.CheckpointRW>();
      for (String c : clusters)
      {
        // create clusters;
        ClusterCheckpointPersistenceProvider.createCluster(zkAddr, c);
        for (String p : partitionIds)
        {
          cpRws.add(new CheckpointRW(c, p, RngUtils
              .randomPositiveLong()));
        }
      }
      for (CheckpointRW cpRW : cpRws)
      {
        cpRW.start();
      }
      for (CheckpointRW cpRW : cpRws)
      {
        cpRW.join(10000);
        Assert.assertFalse(cpRW.hasError());
      }
    }
    catch (Exception e)
    {
      Assert.assertTrue(false);
    }
  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
  @Test
  public void testFrequencyOfCheckpoints() throws Exception
  {
    Checkpoint cp = new Checkpoint();
    long startWindowScn = 50532L;
    cp.setWindowScn(startWindowScn);
    cp.setWindowOffset(-1);
    cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

    int checkPointIntervalMs = 200;

    String id = "5";
    String clusterName = "test-cluster-freq";
    ClusterCheckpointPersistenceProvider.createCluster(zkAddr, clusterName);
    ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
    conf.setClusterName(clusterName);
    conf.setZkAddr(zkAddr);
    conf.setCheckpointIntervalMs(checkPointIntervalMs);

    ArrayList<String> sources = new ArrayList<String>(3);
    sources.add("source1");
    sources.add("source2");
    sources.add("source3");

    try
||||||| BASE
  @Test
    public void testFrequencyOfCheckpoints() throws Exception
=======
    public boolean hasError()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(
          id, conf);
      long delayMs = 50;
      int numAttemptedWrites = 100;
      int numActualStores = 0;
      int expectedActualStores = (delayMs >= checkPointIntervalMs) ? numAttemptedWrites
          : (int) ((numAttemptedWrites / (checkPointIntervalMs / delayMs)));
      for (int i = 0; i < numAttemptedWrites; ++i)
      {
        cp.setWindowScn(startWindowScn + i);
        ccp.storeCheckpoint(sources, cp);
        Checkpoint newCp = ccp.loadCheckpoint(sources);
        // cp integrity checks
        Assert.assertTrue(newCp != null);
        Assert.assertTrue(newCp.getWindowOffset() == cp
            .getWindowOffset());
        Assert.assertTrue(newCp.getConsumptionMode() == cp
            .getConsumptionMode());
        // skipped store test;
        if (newCp.getWindowScn() == cp.getWindowScn())
        {
          numActualStores++;
        }
        Thread.sleep(delayMs);
      }
      LOG.warn("Num actual stores=" + numActualStores
          + " Num expected stores=" + expectedActualStores);
      Assert.assertTrue((numActualStores == expectedActualStores)
          || (numActualStores == expectedActualStores + 1));
||||||| BASE
        Checkpoint cp = new Checkpoint();
        long startWindowScn = 50532L;
        cp.setWindowScn(startWindowScn);
        cp.setWindowOffset(-1);
        cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

        int checkPointIntervalMs = 200;

        String id = "5";
        String clusterName = "test-cluster-freq";
        ClusterCheckpointPersistenceProvider.createCluster(zkAddr, clusterName);
        ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
        conf.setClusterName(clusterName);
        conf.setZkAddr(zkAddr);
        conf.setCheckpointIntervalMs(checkPointIntervalMs);

        ArrayList<String> sources = new ArrayList<String>(3);
        sources.add("source1");
        sources.add("source2");
        sources.add("source3");
        ClusterCheckpointPersistenceProvider.close(clusterName);

        ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(
                id, conf);
        long delayMs = 50;
        int numAttemptedWrites = 100;
        int numActualStores = 0;
        int expectedActualStores = (delayMs >= checkPointIntervalMs) ? numAttemptedWrites
                : (int) ((numAttemptedWrites / (checkPointIntervalMs / delayMs)));
        for (int i = 0; i < numAttemptedWrites; ++i)
        {
            cp.setWindowScn(startWindowScn + i);
            ccp.storeCheckpoint(sources, cp);
            Checkpoint newCp = ccp.loadCheckpoint(sources);
            // cp integrity checks
            Assert.assertTrue(newCp != null);
            Assert.assertTrue(newCp.getWindowOffset() == cp
                    .getWindowOffset());
            Assert.assertTrue(newCp.getConsumptionMode() == cp
                    .getConsumptionMode());
            // skipped store test;
            if (newCp.getWindowScn() == cp.getWindowScn())
            {
                numActualStores++;
            }
            Thread.sleep(delayMs);
        }
        LOG.warn("Num actual stores=" + numActualStores
                + " Num expected stores=" + expectedActualStores);
        Assert.assertTrue((numActualStores == expectedActualStores)
                || (numActualStores == expectedActualStores + 1));
=======
      return _hasError;
    }

    public String getClusterName()
    {
      return _clusterName;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
  @Test
  public void testMultipleClusterCheckpointPersistence()
  {
    try
||||||| BASE
  @Test
    public void testMultipleClusterCheckpointPersistence()
=======
    @Override
    public void run()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      String[] partitionIds = { "1", "2", "3", "4", "5", "6" };
      String[] clusters = { "tcluster1", "tcluster2", "tcluster3" };
      ArrayList<CheckpointRW> cpRws = new ArrayList<TestClusterCheckpointPersistenceProvider.CheckpointRW>();
      for (String c : clusters)
      {
        // create clusters;
        ClusterCheckpointPersistenceProvider.createCluster(zkAddr, c);
        for (String p : partitionIds)
||||||| BASE
        try
=======
      try
      {
        ArrayList<String> sources = new ArrayList<String>(3);
        sources.add("src1");
        sources.add("src2");
        sources.add("src3");
        long endTimeMs = System.currentTimeMillis() + _durationMs;
        while (System.currentTimeMillis() < endTimeMs)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
          cpRws.add(new CheckpointRW(c, p, RngUtils
              .randomPositiveLong()));
||||||| BASE
            String[] partitionIds = { "1", "2", "3", "4", "5", "6" };
            String[] clusters = { "tcluster1", "tcluster2", "tcluster3" };
            ArrayList<CheckpointRW> cpRws = new ArrayList<TestClusterCheckpointPersistenceProvider.CheckpointRW>();
            for (String c : clusters)
            {
                // create clusters;
                ClusterCheckpointPersistenceProvider.createCluster(zkAddr, c);
                for (String p : partitionIds)
                {
                    cpRws.add(new CheckpointRW(c, p, RngUtils
                            .randomPositiveLong()));
                }
            }
            for (CheckpointRW cpRW : cpRws)
            {
                cpRW.start();
            }
            for (CheckpointRW cpRW : cpRws)
            {
                cpRW.join(10000);
                Assert.assertFalse(cpRW.hasError());
                ClusterCheckpointPersistenceProvider.close(cpRW
                        .getClusterName());
            }
        }
        catch (Exception e)
        {
            Assert.assertTrue(false);
=======
          ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
          conf.setClusterName(_clusterName);
          conf.setZkAddr(zkAddr);
          conf.setCheckpointIntervalMs(_delayMs - 10);

          Checkpoint cp = new Checkpoint();
          cp.setWindowScn(_startScn);
          cp.setWindowOffset(-1);
          cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

          // cluster creation code
          ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(
              _partitionId, conf);
          ccp.storeCheckpoint(sources, cp);

          Checkpoint newCp = ccp.loadCheckpoint(sources);

          Assert.assertTrue(newCp != null);
          Assert.assertTrue(newCp.getWindowOffset() == cp
              .getWindowOffset());
          Assert.assertTrue(newCp.getWindowScn() == cp.getWindowScn());
          Assert.assertTrue(newCp.getConsumptionMode() == cp
              .getConsumptionMode());

          Thread.sleep(_delayMs);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      }
      for (CheckpointRW cpRW : cpRws)
      {
        cpRW.start();
      }
      for (CheckpointRW cpRW : cpRws)
      {
        cpRW.join(10000);
        Assert.assertFalse(cpRW.hasError());
      }
    }
    catch (Exception e)
    {
      Assert.assertTrue(false);
    }
||||||| BASE
=======
      }
      catch (Exception e)
      {
        LOG.error("Exception caught " + e, e);
        _hasError = true;
      }
      finally
      {
        ClusterCheckpointPersistenceProvider.close(_clusterName);
      }
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
  /**
   * thread that writes Checkpoints to clusters
   *
   */
  public class CheckpointRW extends Thread
  {
    private final String _clusterName;
    private final String _partitionId;
    private final long _startScn;
    private final long _durationMs = 5000;
    private final long _delayMs = 200;
    private boolean _hasError = false;
||||||| BASE
    /**
     * thread that writes Checkpoints to clusters
     *
     */
    public class CheckpointRW extends Thread
    {
        private String _clusterName;
        private String _partitionId;
        private long _startScn;
        private long _durationMs = 5000;
        private long _delayMs = 200;
        private boolean _hasError = false;
=======
    private Checkpoint storedCheckpoint = null;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    public CheckpointRW(String cluster, String partitionId, long startScn)
    {
      _clusterName = cluster;
      _partitionId = partitionId;
      _startScn = startScn;
    }

    public boolean hasError()
    {
      return _hasError;
    }

    public String getClusterName()
    {
      return _clusterName;
    }
||||||| BASE
        public CheckpointRW(String cluster, String partitionId, long startScn)
        {
            _clusterName = cluster;
            _partitionId = partitionId;
            _startScn = startScn;
        }
=======
    public TestFrequencyCPP(String id, Config config)
        throws InvalidConfigException, ClusterCheckpointException
    {
      super(id, config);
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    @Override
    public void run()
    {
      try
      {
        ArrayList<String> sources = new ArrayList<String>(3);
        sources.add("src1");
        sources.add("src2");
        sources.add("src3");
        long endTimeMs = System.currentTimeMillis() + _durationMs;
        while (System.currentTimeMillis() < endTimeMs)
        {
          ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
          conf.setClusterName(_clusterName);
          conf.setZkAddr(zkAddr);
          conf.setCheckpointIntervalMs(_delayMs - 10);

          Checkpoint cp = new Checkpoint();
          cp.setWindowScn(_startScn);
          cp.setWindowOffset(-1);
          cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

          // cluster creation code
          ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(
              _partitionId, conf);
          ccp.storeCheckpoint(sources, cp);
||||||| BASE
        public boolean hasError()
        {
            return _hasError;
        }
=======
    @Override
    protected void storeZkRecord(List<String> sourceNames, Checkpoint checkpoint)
    {
      storedCheckpoint = checkpoint;
      nStores++;
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
          Checkpoint newCp = ccp.loadCheckpoint(sources);
||||||| BASE
        public String getClusterName()
        {
            return _clusterName;
        }
=======
    public int getnStores()
    {
      return nStores;
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
          Assert.assertTrue(newCp != null);
          Assert.assertTrue(newCp.getWindowOffset() == cp
              .getWindowOffset());
          Assert.assertTrue(newCp.getWindowScn() == cp.getWindowScn());
          Assert.assertTrue(newCp.getConsumptionMode() == cp
              .getConsumptionMode());
||||||| BASE
        @Override
        public void run()
        {
            try
            {
                ArrayList<String> sources = new ArrayList<String>(3);
                sources.add("src1");
                sources.add("src2");
                sources.add("src3");
                long endTimeMs = System.currentTimeMillis() + _durationMs;
                while (System.currentTimeMillis() < endTimeMs)
                {
                    ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
                    conf.setClusterName(_clusterName);
                    conf.setZkAddr(zkAddr);
                    conf.setCheckpointIntervalMs(_delayMs - 10);

                    Checkpoint cp = new Checkpoint();
                    cp.setWindowScn(_startScn);
                    cp.setWindowOffset(-1);
                    cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

                    // cluster creation code
                    ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(
                            _partitionId, conf);
                    ccp.storeCheckpoint(sources, cp);

                    Checkpoint newCp = ccp.loadCheckpoint(sources);

                    Assert.assertTrue(newCp != null);
                    Assert.assertTrue(newCp.getWindowOffset() == cp
                            .getWindowOffset());
                    Assert.assertTrue(newCp.getWindowScn() == cp.getWindowScn());
                    Assert.assertTrue(newCp.getConsumptionMode() == cp
                            .getConsumptionMode());

                    Thread.sleep(_delayMs);
                }
            }
            catch (Exception e)
            {
                LOG.error("Exception caught " + e, e);
                _hasError = true;
            }
=======
    public Checkpoint getStoredCheckpoint()
    {
      return storedCheckpoint;
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
          Thread.sleep(_delayMs);
        }
      }
      catch (Exception e)
      {
        LOG.error("Exception caught " + e, e);
        _hasError = true;
      }
      finally
      {
        ClusterCheckpointPersistenceProvider.close(_clusterName);
      }
    }
  }
||||||| BASE
        }
    }
=======
  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/main/java/com/linkedin/databus/client/pub/DatabusV3Registration.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/main/java/com/linkedin/databus/client/pub/ConsumerCallbackResult.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus2-example/databus2-example-person/src/main/java/com/linkedin/events/example/person/Person_V1.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus2-example/databus2-example-relay/src/main/java/com/linkedin/databus/relay/example/PersonRelayServer.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerStaticConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerStaticConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerStaticConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerStaticConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/StartSCNRequestProcessor.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/test/java/com/linkedin/databus/bootstrap/server/TestBootstrapSCNProcessor.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/test/java/com/linkedin/databus/bootstrap/server/TestBootstrapSCNProcessor.java;null
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/test/java/com/linkedin/databus/bootstrap/server/TestBootstrapSCNProcessor.java;null
