file;linedbasedConf
/home/ramdisk/experiment6/projects/databus/revisions/rev_3744018_5eec32f/rev_3744018-5eec32f/databus2-relay/databus2-relay-impl/src/test/java/com/linkedin/databus2/relay/TestDatabusRelayMain.java;<<<<<<< MINE
		log.setLevel(Level.DEBUG);
=======
		//log.setLevel(Level.DEBUG);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/ChunkedBodyReadableByteChannel.java;<<<<<<< MINE
  private static final int MAX_CHUNK_SPACE_WAIT_MS = 15000;
=======
  static final int MAX_CHUNK_SPACE_WAIT_MS = 15000;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/ChunkedBodyReadableByteChannel.java;<<<<<<< MINE
      _hasChunksCondition.signalAll();
=======
      signalNoMoreChunks();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
=======
import org.apache.log4j.Level;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
=======
import org.testng.annotations.BeforeClass;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
=======
  @BeforeClass
  public void setupClass()
  {
    TestUtil.setupLogging(true, null, Level.ERROR);
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
    boolean replayerDone = joinThreadWithExpoBackoff(readerThread, ONE_MINUTE_IN_MS);
=======
    boolean replayerDone = joinThreadWithExpoBackoff(replayerThread, ONE_MINUTE_IN_MS);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
    boolean replayerDone = joinThreadWithExpoBackoff(readerThread, ONE_MINUTE_IN_MS);
=======
    boolean replayerDone = joinThreadWithExpoBackoff(replayerThread, ONE_MINUTE_IN_MS);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
    boolean replayerDone = joinThreadWithExpoBackoff(readerThread, ONE_MINUTE_IN_MS);
=======
    boolean replayerDone = joinThreadWithExpoBackoff(replayerThread, ONE_MINUTE_IN_MS);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
    boolean replayerDone = joinThreadWithExpoBackoff(readerThread, ONE_MINUTE_IN_MS);
=======
    boolean replayerDone = joinThreadWithExpoBackoff(replayerThread, ONE_MINUTE_IN_MS);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
    boolean replayerDone = joinThreadWithExpoBackoff(readerThread, 10 * ONE_MINUTE_IN_MS);
=======
    boolean replayerDone = joinThreadWithExpoBackoff(replayerThread, 10 * ONE_MINUTE_IN_MS);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_bf4c533_0afcc46/rev_bf4c533-0afcc46/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestChunkedBodyReadableByteChannel.java;<<<<<<< MINE
=======
  /** Block the writer because of running out of buffer space and check it times out eventually */
  public void testUnblockWriteOnClose()
  {
    ChunkedBodyReadableByteChannel channel = new ChunkedBodyReadableByteChannel();

    StringBuilder megabyte = new StringBuilder(1000000);
    while (megabyte.length() < 1000000)
    {
      megabyte.append("TeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeSt");
    }

    StringBuilder chunkBuilder = new StringBuilder(5200000);
    for (int i = 0; i < 5; ++i)
    {
      chunkBuilder.append(megabyte);
    }
    String chunk = chunkBuilder.toString();
    String chunk2 = "Hello there.";

    HttpResponseReplayer responseReplayer = new HttpResponseReplayer(channel, null, new String[]{chunk2, chunk});

    Thread replayerThread = new Thread(responseReplayer, "replayer");

    replayerThread.start();

    TestUtil.sleep(ChunkedBodyReadableByteChannel.MAX_CHUNK_SPACE_WAIT_MS / 2);
    Assert.assertTrue(replayerThread.isAlive());

    Assert.assertTrue(joinThreadWithExpoBackoff(replayerThread,
                                                ChunkedBodyReadableByteChannel.MAX_CHUNK_SPACE_WAIT_MS));
  }

  @Test
  /** make sure the reader does not hang if the channel is closed while it is reading. */
  public void testUnblockReadOnPrematureClose() throws IOException
  {
    final ChunkedBodyReadableByteChannel channel = new ChunkedBodyReadableByteChannel();

    StringBuilder kilobyte = new StringBuilder(1000);
    while (kilobyte.length() < 1000)
    {
      kilobyte.append("TeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeStTeSt");
    }

    final int chunkNum = 10000;
    String[] chunks = new String[chunkNum];
    for (int i = 0; i < chunkNum; ++i) chunks[i] = kilobyte.toString();

    HttpResponseReplayer responseReplayer = new HttpResponseReplayer(channel, null, chunks);

    Thread replayerThread = new Thread(responseReplayer);
    //a flag if the read is finished
    final AtomicBoolean out = new AtomicBoolean(false);

    //start a thread waiting for data on the channel
    final Thread readerThread = new Thread(new Runnable()
      {

        @Override
        public void run()
        {
          ByteBuffer tmp = ByteBuffer.allocate(10 * 1024 * 1024);
          try
          {
            channel.read(tmp);
            out.set(true);
          }
          catch (IOException ioe)
          {
            out.set(true);
          }
        }
      });
    readerThread.setDaemon(true);

    replayerThread.start();
    readerThread.start();

    TestUtil.sleep(5);

    channel.close();

    boolean replayerDone = joinThreadWithExpoBackoff(replayerThread, 30000);
    Assert.assertTrue(replayerDone);

    boolean readerDone = joinThreadWithExpoBackoff(readerThread, 30000);
    Assert.assertTrue(readerDone);

  }

  @Test
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_6a8bc7e_abd8d4e/rev_6a8bc7e-abd8d4e/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/DbusEvent.java;<<<<<<< MINE
/*
 *
 * Copyright 2013 LinkedIn Corp. All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
*/

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBSingleSourceCleaner.java;<<<<<<< MINE
=======
package com.linkedin.databus.bootstrap.common;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;




import org.apache.log4j.Logger;

import com.linkedin.databus.bootstrap.common.BootstrapCleanerStaticConfig.BootstrapDBType;
import com.linkedin.databus.bootstrap.common.BootstrapCleanerStaticConfig.RetentionStaticConfig;
import com.linkedin.databus.bootstrap.common.BootstrapDBMetaDataDAO.SourceStatusInfo;
import com.linkedin.databus.core.DatabusThreadBase;
import com.linkedin.databus.core.DbusConstants;
import com.linkedin.databus.core.DbusEventFactory;
import com.linkedin.databus.core.DbusEventV1Factory;
import com.linkedin.databus2.core.container.request.BootstrapDatabaseTooOldException;

/*
*
* Copyright 2013 LinkedIn Corp. All rights reserved
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*
*/

public class BootstrapDBSingleSourceCleaner implements Runnable
{
  public static final String MODULE = BootstrapDBSingleSourceCleaner.class.getName();
  public final Logger LOG;

  private final String _name;
  private final String _source;
  private final DatabusThreadBase _applier;
  private final BootstrapCleanerStaticConfig _bootstrapCleanerStaticConfig;
  private final BootstrapReadOnlyConfig _bootstrapReadOnlyConfig;

  private BootstrapDBMetaDataDAO _bootstrapDao = null;
  private SourceStatusInfo _sourceStatusInfo = null;
  private final BootstrapDBCleanerQueryHelper _bootstrapDBCleanerQueryHelper;
  private final BootstrapDBCleanerQueryExecutor _bootstrapDBCleanerQueryExecutor;
  private final DbusEventFactory _eventFactory;
  private BootstrapLogInfo _lastValidLog;
  private volatile boolean _isCleaning = false;

  private static final AtomicInteger _numCleanersRunning = new AtomicInteger(0);
  private static final AtomicInteger _numCleanersRunningHWM = new AtomicInteger(0);

  public BootstrapDBSingleSourceCleaner(String name,
                                        String source,
                                        DatabusThreadBase applier,
                                        BootstrapCleanerStaticConfig bootstrapCleanerStaticConfig,
                                        BootstrapReadOnlyConfig bootstrapReadOnlyConfig)
  throws SQLException
  {
    _name = name;
    _source = source;
    _applier = applier;
    _bootstrapCleanerStaticConfig = bootstrapCleanerStaticConfig;
    _bootstrapReadOnlyConfig = bootstrapReadOnlyConfig;
    LOG = Logger.getLogger(name);

    Connection conn = getOrCreateConnection();
    if (null != source)
    {
      try
      {
        List<SourceStatusInfo> ssil = _bootstrapDao.getSourceIdAndStatusFromName(Arrays.asList(source), false);
        assert(ssil.size() == 1);
        _sourceStatusInfo = ssil.get(0);
      } catch (BootstrapDatabaseTooOldException bto)
      {
        LOG.error(
            "Not expected to receive this exception as activeCheck is turned-off",
            bto);
        throw new RuntimeException(bto);
      }
    }
    _bootstrapDBCleanerQueryHelper = BootstrapDBCleanerQueryHelper.getInstance();
    _bootstrapDBCleanerQueryExecutor = new BootstrapDBCleanerQueryExecutor(_name, conn, _bootstrapDBCleanerQueryHelper);
    _eventFactory = new DbusEventV1Factory();
  }

  /*
   * @return a bootstrapDB connection object. Note: The connection object is
   * still owned by BootstrapConn. SO dont close it
   */
  private Connection getOrCreateConnection() throws SQLException
  {
    Connection conn = null;

    if (_bootstrapDao == null)
    {
      LOG.info("<<<< Creating Bootstrap Connection!! >>>>");
      BootstrapConn dbConn = new BootstrapConn();
      final boolean autoCommit = true;
      _bootstrapDao = new BootstrapDBMetaDataDAO(dbConn,
          _bootstrapReadOnlyConfig.getBootstrapDBHostname(),
          _bootstrapReadOnlyConfig.getBootstrapDBUsername(),
          _bootstrapReadOnlyConfig.getBootstrapDBPassword(),
          _bootstrapReadOnlyConfig.getBootstrapDBName(), autoCommit);
      try
      {
        dbConn.initBootstrapConn(autoCommit,
            _bootstrapReadOnlyConfig.getBootstrapDBUsername(),
            _bootstrapReadOnlyConfig.getBootstrapDBPassword(),
            _bootstrapReadOnlyConfig.getBootstrapDBHostname(),
            _bootstrapReadOnlyConfig.getBootstrapDBName());
      } catch (Exception e)
      {
        LOG.fatal("Unable to open BootstrapDB Connection !!", e);
        throw new RuntimeException(
            "Got exception when getting bootstrap DB Connection.", e);
      }
    }

    try
    {
      conn = _bootstrapDao.getBootstrapConn().getDBConn();
    } catch (SQLException e)
    {
      LOG.fatal("Not able to open BootstrapDB Connection !!", e);
      throw new RuntimeException(
          "Got exception when getting bootstrap DB Connection.", e);
    }
    return conn;
  }

  @Override
  public void run()
  {
    doClean();
  }

  private void doClean()
  {
    try
    {
      incCleanerStats();

      SourceStatusInfo s = _sourceStatusInfo;
      {
        assert(s.getSrcName().equals(_source));
        BootstrapDBType type = _bootstrapCleanerStaticConfig.getBootstrapType(s.getSrcName());

        LOG.info("Cleaner running for source :" + s.getSrcName() + "("
            + s.getSrcId() + ") with bootstrapDB type :" + type);

        BootstrapLogInfo logInfo = _bootstrapDBCleanerQueryExecutor.getThresholdWindowSCN(type, s.getSrcId());

        if (null == logInfo)
        {
          LOG.info("No WindowSCN. Nothing to cleanup for source : "
              + s.getSrcName());
          return;
        }

        LOG.info("LOG info with lowest windowSCN :" + logInfo);

        LOG.info("Begin phase 1 : Gather candidate loginfo :");
        List<BootstrapLogInfo> candidateLogsInfo = _bootstrapDBCleanerQueryExecutor.getCandidateLogsInfo(
            logInfo.getMinWindowSCN(), (short) (s.getSrcId()));
        if ((null == candidateLogsInfo) || (candidateLogsInfo.isEmpty()))
        {
          LOG.info("No logs to cleanup for source :" + s.getSrcName() + "("
              + s.getSrcId() + ")");
          return;
        }
        LOG.info("End phase 1 : Gather candidate loginfo :");

        LOG.info("Initial Candidate Set for Source :" + s.getSrcName()
            + " is :" + candidateLogsInfo);
        RetentionStaticConfig rConf = _bootstrapCleanerStaticConfig.getRetentionConfig(s
            .getSrcName());
        LOG.info("Retention Config for source :" + s.getSrcName() + " is :"
            + rConf);

        LOG.info("Begin phase 2 : Filter based on retention config :");
        long scn = filterCandidateLogInfo((short) s.getSrcId(),
            candidateLogsInfo,
            _bootstrapCleanerStaticConfig.getRetentionConfig(s.getSrcName()));

        LOG.info("Log tables to be deleted for source :" + s.getSrcName() + "("
            + s.getSrcId() + ") are :" + candidateLogsInfo
            + ", Max SCN of deleted logs:" + scn);
        LOG.info("End phase 2 : Filter based on retention config :");

        if ((scn <= 0) || (candidateLogsInfo.isEmpty()))
        {
          LOG.info("Source :" + s.getSrcName() + "(" + s.getSrcId()
              + ") No log tables to be deleted !! MaxSCN : " + scn
              + ", candidateLogs :" + candidateLogsInfo);
          return;
        }

        LOG.info("Begin phase 3 : Updating Meta Info :");
        BootstrapLogInfo firstValidLog = _bootstrapDBCleanerQueryExecutor.getFirstLogTableWithGreaterSCN(
            (short) s.getSrcId(), scn);
        _bootstrapDBCleanerQueryExecutor.updateSource(firstValidLog);
        LOG.info("End phase 3 : Updating Meta Info :");

        LOG.info("Begin phase 4 : Deleting Log tables :");
        // marking logs as done; if any failures; there is a chance that the
        // logs have to be cleaned up later
        _bootstrapDBCleanerQueryExecutor.markDeleted(candidateLogsInfo);
        _bootstrapDBCleanerQueryExecutor.dropTables(candidateLogsInfo);
        LOG.info("End phase 4 : Deleting Log tables :");

        if ((_bootstrapCleanerStaticConfig.getBootstrapType(s.getSrcName()) == BootstrapDBType.BOOTSTRAP_CATCHUP_APPLIER_RUNNING)
            && ((_applier != null) || _bootstrapCleanerStaticConfig.forceTabTableCleanup(s
                .getSrcName())))
        {
          LOG.info("Source :" + s.getSrcName() + "(" + s.getSrcId()
              + ") is running in catchup_applier_running mode. "
              + "Will delete all rows whose scn is less than or equal to "
              + scn);
          if ((null != _applier) && (_applier.isAlive()))
          {
            LOG.info("Begin phase 5 : Pausing Applier and deleting Rows from tab table :");

            LOG.info("Requesting applier to pause !!");
            _applier.pause();
            LOG.info("Applier paused !!");
          }

          try
          {
            // mark ahead of time; if this doesn't work this time; it will next
            // cycle
            _bootstrapDao.updateMinScnOfSnapshot(s.getSrcId(), scn);
            String srcTable = _bootstrapDBCleanerQueryHelper.getSrcTable(s.getSrcId());
            int numRowsDeleted = _bootstrapDBCleanerQueryExecutor.deleteTable(srcTable, scn);
            LOG.info("Number of Rows deleted for source  :" + s.getSrcName()
                + "(" + s.getSrcId() + ") :" + numRowsDeleted);
            if (numRowsDeleted > 0
                && _bootstrapCleanerStaticConfig.isOptimizeTableEnabled(s.getSrcName()))
            {
              LOG.info("Optimizing table to reclaim space for source :"
                  + s.getSrcName() + "(" + s.getSrcId() + ")");
              _bootstrapDBCleanerQueryExecutor.optimizeTable(srcTable);
            }
          } finally
          {
            if ((null != _applier) && (_applier.isAlive()))
            {
              LOG.info("Requesting applier to resume !!");
              _applier.unpause();
              LOG.info("Applier resumed !!");
            }
          }

          LOG.info("End phase 5 : Deleting Rows from tab table :");
        }

        LOG.info("Cleaner done for source :" + s.getSrcName() + "("
            + s.getSrcId() + ")");
      }
    } catch (SQLException ex)
    {
      LOG.error("Got SQL exception while cleaning bootstrapDB !!", ex);
    } catch (InterruptedException ie)
    {
      LOG.error("Got interrupted exception while cleaning bootstrapDB !!", ie);
    } finally
    {
      decCleanerStats();
    }
  }

  public BootstrapDBMetaDataDAO getBootstrapDao()
  {
    return _bootstrapDao;
  }

  public boolean isCleanerRunning()
  {
    return _isCleaning;
  }

  public String getName()
  {
    return _name;
  }

  public void close()
  {
    if (_bootstrapDao != null)
    {
      _bootstrapDao.close();
      _bootstrapDao = null;
    }
  }

  /**
   * A diagnotic to expose the number of cleaners running at a given moment
   */
  public static int getNumCleanersRunningHWM()
  {
    return _numCleanersRunningHWM.get();
  }

  /**
   * Return the milli-second threshold for delete criteria.
   *
   * @param config
   *          RetentionConfig
   * @return milliSecThreshold
   */
  private long getMilliSecTime(RetentionStaticConfig config)
  {
    long qty = config.getRetentionQuantity();
    long milliSecQty = -1;

    switch (config.getRetentiontype())
    {
    case RETENTION_SECONDS:
      milliSecQty = qty * DbusConstants.NUM_MSECS_IN_SEC;
      break;

    default:
      throw new RuntimeException("Retention Config (" + config
          + ") expected to be time based but is not !!");

    }
    return milliSecQty;
  }

  private long filterCandidateLogInfo(short srcId,
      List<BootstrapLogInfo> candidateLogsInfo, RetentionStaticConfig config)
      throws SQLException
  {
    switch (config.getRetentiontype())
    {
    case NO_CLEANUP:
      return -1;
    case RETENTION_LOGS:
    {
      Iterator<BootstrapLogInfo> itr = candidateLogsInfo.iterator();
      BootstrapLogInfo lastValidLog = null;
      int i = 0;
      while (i < config.getRetentionQuantity() && itr.hasNext())
      {
        BootstrapLogInfo log = itr.next();
        LOG.info("Removing the log table :" + log.getLogTable()
            + " from the delete List as it is too recent. Retaining :"
            + config.getRetentionQuantity() + " logs");
        itr.remove();
        lastValidLog = log;
        i++;
      }
      _lastValidLog = lastValidLog;
      break;
    }

    case RETENTION_SECONDS:
    {
      long quantity = config.getRetentionQuantity();
      LOG.info("Retaining tables which could contain events which is less than "
          + quantity + " seconds old !!");
      long currTs = System.currentTimeMillis() * DbusConstants.NUM_NSECS_IN_MSEC;
      long nanoSecQty = getMilliSecTime(config) * DbusConstants.NUM_NSECS_IN_MSEC;
      long threshold = (currTs - nanoSecQty);

      LOG.info("Removing tables from the delete-list whose last row has timestamp newer than :"
          + threshold + " nanosecs");

      Iterator<BootstrapLogInfo> itr = candidateLogsInfo.iterator();
      BootstrapLogInfo lastValidLog = null;
      LOG.info("Timestamp Threshold for src id :" + srcId + " is :" + threshold
          + ", Retention Config " + config + "(" + nanoSecQty + " nanosecs)");

      while (itr.hasNext())
      {
        BootstrapLogInfo log = itr.next();

        long timestamp = _bootstrapDBCleanerQueryExecutor.getNanoTimestampOfLastEventinLog(log, _eventFactory);

        if (timestamp < threshold)
        {
          LOG.info("Reached the log table whose timestamp (" + timestamp
              + ") is less than the threshold (" + threshold + ").");
          break;
        }
        else
        {
          LOG.info("Removing the log table :"
              + log.getLogTable()
              + " from the delete List as it is too recent. Last Event Timestamp :"
              + timestamp + ", threshold :" + threshold);
          lastValidLog = log;
          itr.remove();
        }
      }
      _lastValidLog = lastValidLog;
    }
      break;
    }

    long scn = -1;

    if (!candidateLogsInfo.isEmpty())
      scn = _bootstrapDBCleanerQueryExecutor.getSCNOfLastEventinLog(candidateLogsInfo.get(0), _eventFactory);

    return scn;
  }

  private void incCleanerStats()
  {
    _isCleaning = true;

    // Update HWM
    int curCleanersHwm = _numCleanersRunningHWM.get();
    // Increment internal metrics used for measuring parallelism
    int curCleaners = _numCleanersRunning.incrementAndGet();
    if (curCleanersHwm < curCleaners)
    {
      _numCleanersRunningHWM.set(curCleaners);
    }
  }

  private void decCleanerStats()
  {
    _isCleaning = false;

    // Decrement internal metrics used for measuring parallelism
    _numCleanersRunning.decrementAndGet();
  }
}>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryHelper.java;<<<<<<< MINE
=======
/**
 * This class provides helper queries used for execution in the BootstrapDBCleaner context
 * This is a singleton class, and expected to be held by multiple objects and invoked in
 * various thread contexts. So, the methods are expected to be thread-safe by only operating
 * with thread-local storage
 */
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryHelper.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;<<<<<<< MINE
  public static final Logger LOG = Logger.getLogger(MODULE);
=======
  public final Logger LOG;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;<<<<<<< MINE
=======
  // Used for identifying the source in log4j
  private final String _name;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;<<<<<<< MINE
  public BootstrapDBCleanerQueryExecutor(Connection conn, BootstrapDBCleanerQueryHelper bootstrapDBCleanerQueryHelper)
=======
  public BootstrapDBCleanerQueryExecutor(String name, Connection conn, BootstrapDBCleanerQueryHelper bootstrapDBCleanerQueryHelper)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;<<<<<<< MINE
=======
    _name = name;
    LOG = Logger.getLogger(MODULE + "." + name);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleanerQueryExecutor.java;<<<<<<< MINE
        LOG.error("Unable to delete log table :" + logInfo.getLogTable());
=======
        LOG.error("Unable to delete log table :" + logInfo.getLogTable(), ex);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapConfig.java;<<<<<<< MINE
    LOG.info("Bootstrap service DB username:" + _bootstrapDBUsername);
    LOG.info("Bootstrap service DB password: ***");
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapReadOnlyConfig.java;<<<<<<< MINE
	  return "BootstrapReadOnlyConfig [_bootstrapDBUsername="
	  + _bootstrapDBUsername + ", _bootstrapDBPassword=xxxxxx"
	  + ", _bootstrapDBHostname="
=======
	  return "BootstrapReadOnlyConfig [_bootstrapDBHostname="
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
import java.sql.Connection;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
import java.util.Iterator;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
=======
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
import com.linkedin.databus.bootstrap.common.BootstrapCleanerStaticConfig.BootstrapDBType;
import com.linkedin.databus.bootstrap.common.BootstrapCleanerStaticConfig.RetentionStaticConfig;
import com.linkedin.databus.bootstrap.common.BootstrapDBMetaDataDAO.SourceStatusInfo;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
import com.linkedin.databus.core.DbusEventFactory;
import com.linkedin.databus.core.DbusEventV1Factory;
import com.linkedin.databus2.core.container.request.BootstrapDatabaseTooOldException;
=======
import com.linkedin.databus.core.util.NamedThreadFactory;
import com.linkedin.databus2.core.DatabusException;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
  public static final long MILLISEC_IN_SECONDS = 1000;
  public static final long NANOSEC_IN_MILLISECONDS = 1000000L;
  public static final long MILLISEC_IN_MINUTES = 60 * MILLISEC_IN_SECONDS;
  public static final long MILLISEC_IN_HOUR = 60 * MILLISEC_IN_MINUTES;
  public static final long MILLISEC_IN_DAY = 24 * MILLISEC_IN_HOUR;

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
=======
  private final long TERMINATION_TIMEOUT_IN_MS = 10000;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
  public List<SourceStatusInfo> _sources;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
  private BootstrapDBMetaDataDAO _bootstrapDao = null;
  private final Map<Short, BootstrapLogInfo> _lastValidLogMap = new HashMap<Short, BootstrapLogInfo>();
  private volatile boolean isCleaning = false;
  private final DbusEventFactory _eventFactory;
  private final BootstrapDBCleanerQueryHelper _bootstrapDBCleanerQueryHelper;
  private final BootstrapDBCleanerQueryExecutor _bootstrapDBCleanerQueryExecutor;

  public boolean isCleanerRunning()
  {
    return isCleaning;
  }

  public List<SourceStatusInfo> getSources()
  {
    return _sources;
  }
=======
  private final Map<String, BootstrapDBSingleSourceCleaner> _cleaners;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
  public void setSources(List<SourceStatusInfo> sources)
  {
    this._sources = sources;
  }

  public BootstrapDBMetaDataDAO getBootstrapDao()
  {
    return _bootstrapDao;
  }
=======
  private final ExecutorService _cleanerThreadPoolService;
  private final Map<String, Future<?>> _cleanerFutures;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    _eventFactory = new DbusEventV1Factory();
    Connection conn = getOrCreateConnection();
=======
    _cleaners = new HashMap<String, BootstrapDBSingleSourceCleaner>();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      try
      {
        _sources = _bootstrapDao.getSourceIdAndStatusFromName(sources, false);
      } catch (BootstrapDatabaseTooOldException bto)
=======
      for (String source: sources)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
        LOG.error(
            "Not expected to receive this exception as activeCheck is turned-off",
            bto);
        throw new RuntimeException(bto);
=======
        String perSourceName = name + "_" + source;
        DatabusThreadBase perSourceApplier = _appliers.get(source);
        BootstrapDBSingleSourceCleaner cleaner =
            new BootstrapDBSingleSourceCleaner(perSourceName,
                source,
                perSourceApplier,
                config,
                bootstrapConfig);
        _cleaners.put(source,cleaner);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    _bootstrapDBCleanerQueryHelper = BootstrapDBCleanerQueryHelper.getInstance();
    _bootstrapDBCleanerQueryExecutor = new BootstrapDBCleanerQueryExecutor(conn, _bootstrapDBCleanerQueryHelper);
=======
    ThreadFactory tf = new NamedThreadFactory(name);
    _cleanerThreadPoolService = Executors.newCachedThreadPool(tf);
    _cleanerFutures =  new HashMap<String, Future<?>>();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
  /*
   * @return a bootstrapDB connection object. Note: The connection object is
   * still owned by BootstrapConn. SO dont close it
   */
  public Connection getOrCreateConnection() throws SQLException
=======
  public synchronized void doClean()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    Connection conn = null;

    if (_bootstrapDao == null)
=======
    // Invoke doClean on each of the individual single source cleaners
    for (Map.Entry<String, BootstrapDBSingleSourceCleaner> entry : _cleaners.entrySet())
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      LOG.info("<<<< Creating Bootstrap Connection!! >>>>");
      BootstrapConn dbConn = new BootstrapConn();
      final boolean autoCommit = true;
      _bootstrapDao = new BootstrapDBMetaDataDAO(dbConn,
          _bootstrapConfig.getBootstrapDBHostname(),
          _bootstrapConfig.getBootstrapDBUsername(),
          _bootstrapConfig.getBootstrapDBPassword(),
          _bootstrapConfig.getBootstrapDBName(), autoCommit);
      try
=======
      String source = entry.getKey();
      BootstrapDBSingleSourceCleaner singleSourceCleaner = entry.getValue();
      Future<?> c = _cleanerFutures.get(source);
      if (c != null && !c.isDone())
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
        dbConn.initBootstrapConn(autoCommit,
            _bootstrapConfig.getBootstrapDBUsername(),
            _bootstrapConfig.getBootstrapDBPassword(),
            _bootstrapConfig.getBootstrapDBHostname(),
            _bootstrapConfig.getBootstrapDBName());
      } catch (Exception e)
=======
        LOG.info("Skipping running cleaner as it is already running for source = " + source);
      }
      else
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
        LOG.fatal("Unable to open BootstrapDB Connection !!", e);
        throw new RuntimeException(
            "Got exception when getting bootstrap DB Connection.", e);
=======
        LOG.info("Submitting a cleaner task for source = " + source);
        Future<?> cleaner = _cleanerThreadPoolService.submit(singleSourceCleaner);
        _cleanerFutures.put(source, cleaner);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE

    try
    {
      conn = _bootstrapDao.getBootstrapConn().getDBConn();
    } catch (SQLException e)
    {
      LOG.fatal("Not able to open BootstrapDB Connection !!", e);
      throw new RuntimeException(
          "Got exception when getting bootstrap DB Connection.", e);
    }
    return conn;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
  /**
   * Return the milli-second threshold for delete criteria.
   *
   * @param config
   *          RetentionConfig
   * @return milliSecThreshold
   */
  private long getMilliSecTime(RetentionStaticConfig config)
=======
  public synchronized boolean isAnyCleanerRunning()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    long qty = config.getRetentionQuantity();
    long milliSecQty = -1;

    switch (config.getRetentiontype())
=======
    for (Map.Entry<String, Future<?>> entry : _cleanerFutures.entrySet())
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    case RETENTION_SECONDS:
      milliSecQty = qty * MILLISEC_IN_SECONDS;
      break;

    default:
      throw new RuntimeException("Retention Config (" + config
          + ") expected to be time based but is not !!");

=======
      Future<?> cleanerFuture = entry.getValue();
      if (!cleanerFuture.isDone())
      {
        LOG.debug("Cleaner process is running for source = " + entry.getKey());
        return true;
      }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    return milliSecQty;
=======
    LOG.info("There are no cleaner processes running");
    return false;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
  public long filterCandidateLogInfo(short srcId,
      List<BootstrapLogInfo> candidateLogsInfo, RetentionStaticConfig config)
      throws SQLException
=======
  public synchronized void sleepTillNoCleanerIsRunning()
  throws DatabusException, InterruptedException
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    switch (config.getRetentiontype())
    {
    case NO_CLEANUP:
      return -1;
    case RETENTION_LOGS:
=======
    final long maxWaitTime = TERMINATION_TIMEOUT_IN_MS;
    long waitTime = 0;
    while (isAnyCleanerRunning())
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      Iterator<BootstrapLogInfo> itr = candidateLogsInfo.iterator();
      BootstrapLogInfo lastValidLog = null;
      int i = 0;
      while (i < config.getRetentionQuantity() && itr.hasNext())
=======
      if (waitTime >= TERMINATION_TIMEOUT_IN_MS)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
        BootstrapLogInfo log = itr.next();
        LOG.info("Removing the log table :" + log.getLogTable()
            + " from the delete List as it is too recent. Retaining :"
            + config.getRetentionQuantity() + " logs");
        itr.remove();
        lastValidLog = log;
        i++;
=======
        throw new DatabusException("The cleaners have not terminated within " + maxWaitTime + " ms");
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      _lastValidLogMap.put(srcId, lastValidLog);
      break;
=======
      final long sleepIntervalInMs = 100;
      Thread.sleep(sleepIntervalInMs);
      waitTime += sleepIntervalInMs;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
=======
  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    case RETENTION_SECONDS:
=======
  public void close()
  {
    List<Runnable> incompleteCleaners = _cleanerThreadPoolService.shutdownNow();
    if (incompleteCleaners.size() > 0)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      long quantity = config.getRetentionQuantity();
      LOG.info("Retaining tables which could contain events which is less than "
          + quantity + " seconds old !!");
      long currTs = System.currentTimeMillis() * NANOSEC_IN_MILLISECONDS;
      long nanoSecQty = getMilliSecTime(config) * NANOSEC_IN_MILLISECONDS;
      long threshold = (currTs - nanoSecQty);

      LOG.info("Removing tables from the delete-list whose last row has timestamp newer than :"
          + threshold + " nanosecs");

      Iterator<BootstrapLogInfo> itr = candidateLogsInfo.iterator();
      BootstrapLogInfo lastValidLog = null;
      LOG.info("Timestamp Threshold for src id :" + srcId + " is :" + threshold
          + ", Retention Config " + config + "(" + nanoSecQty + " nanosecs)");

      while (itr.hasNext())
=======
      // The cleaners that have not started as of initiating a shutdown, will not be started
      // Not an error, hence logging for informational purpose
      LOG.info("Number of cleaners that have not completed = " + incompleteCleaners.size());
      LOG.info("Printing out sources for which cleaners what not completed ");
      for (Runnable r: incompleteCleaners)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
        BootstrapLogInfo log = itr.next();

        long timestamp = _bootstrapDBCleanerQueryExecutor.getNanoTimestampOfLastEventinLog(log, _eventFactory);

        if (timestamp < threshold)
        {
          LOG.info("Reached the log table whose timestamp (" + timestamp
              + ") is less than the threshold (" + threshold + ").");
          break;
        }
        else
        {
          LOG.info("Removing the log table :"
              + log.getLogTable()
              + " from the delete List as it is too recent. Last Event Timestamp :"
              + timestamp + ", threshold :" + threshold);
          lastValidLog = log;
          itr.remove();
        }
=======
        BootstrapDBSingleSourceCleaner bsc = (BootstrapDBSingleSourceCleaner) r;
        LOG.error(bsc.getName());
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      _lastValidLogMap.put(srcId, lastValidLog);
    }
      break;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
    long scn = -1;

    if (!candidateLogsInfo.isEmpty())
      scn = _bootstrapDBCleanerQueryExecutor.getSCNOfLastEventinLog(candidateLogsInfo.get(0), _eventFactory);

    return scn;
  }

  public synchronized void doClean()
  {
    DatabusThreadBase applier = null;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      isCleaning = true;

      for (SourceStatusInfo s : _sources)
      {
        BootstrapDBType type = _cleanerConfig.getBootstrapType(s.getSrcName());

        LOG.info("Cleaner running for source :" + s.getSrcName() + "("
            + s.getSrcId() + ") with bootstrapDB type :" + type);

        BootstrapLogInfo logInfo = _bootstrapDBCleanerQueryExecutor.getThresholdWindowSCN(type, s.getSrcId());

        if (null == logInfo)
        {
          LOG.info("No WindowSCN. Nothing to cleanup for source : "
              + s.getSrcName());
          continue;
        }

        LOG.info("LOG info with lowest windowSCN :" + logInfo);

        LOG.info("Begin phase 1 : Gather candidate loginfo :");
        List<BootstrapLogInfo> candidateLogsInfo = _bootstrapDBCleanerQueryExecutor.getCandidateLogsInfo(
            logInfo.getMinWindowSCN(), (short) (s.getSrcId()));
        if ((null == candidateLogsInfo) || (candidateLogsInfo.isEmpty()))
        {
          LOG.info("No logs to cleanup for source :" + s.getSrcName() + "("
              + s.getSrcId() + ")");
          continue;
        }
        LOG.info("End phase 1 : Gather candidate loginfo :");

        LOG.info("Initial Candidate Set for Source :" + s.getSrcName()
            + " is :" + candidateLogsInfo);
        RetentionStaticConfig rConf = _cleanerConfig.getRetentionConfig(s
            .getSrcName());
        LOG.info("Retention Config for source :" + s.getSrcName() + " is :"
            + rConf);

        LOG.info("Begin phase 2 : Filter based on retention config :");
        long scn = filterCandidateLogInfo((short) s.getSrcId(),
            candidateLogsInfo,
            _cleanerConfig.getRetentionConfig(s.getSrcName()));

        LOG.info("Log tables to be deleted for source :" + s.getSrcName() + "("
            + s.getSrcId() + ") are :" + candidateLogsInfo
            + ", Max SCN of deleted logs:" + scn);
        LOG.info("End phase 2 : Filter based on retention config :");

        if ((scn <= 0) || (candidateLogsInfo.isEmpty()))
        {
          LOG.info("Source :" + s.getSrcName() + "(" + s.getSrcId()
              + ") No log tables to be deleted !! MaxSCN : " + scn
              + ", candidateLogs :" + candidateLogsInfo);
          continue;
        }

        LOG.info("Begin phase 3 : Updating Meta Info :");
        BootstrapLogInfo firstValidLog = _bootstrapDBCleanerQueryExecutor.getFirstLogTableWithGreaterSCN(
            (short) s.getSrcId(), scn);
        _bootstrapDBCleanerQueryExecutor.updateSource(firstValidLog);
        LOG.info("End phase 3 : Updating Meta Info :");

        LOG.info("Begin phase 4 : Deleting Log tables :");
        // marking logs as done; if any failures; there is a chance that the
        // logs have to be cleaned up later
        _bootstrapDBCleanerQueryExecutor.markDeleted(candidateLogsInfo);
        _bootstrapDBCleanerQueryExecutor.dropTables(candidateLogsInfo);
        LOG.info("End phase 4 : Deleting Log tables :");

        if ((_cleanerConfig.getBootstrapType(s.getSrcName()) == BootstrapDBType.BOOTSTRAP_CATCHUP_APPLIER_RUNNING)
            && ((_appliers.size() != 0) || _cleanerConfig.forceTabTableCleanup(s
                .getSrcName())))
        {
          LOG.info("Source :" + s.getSrcName() + "(" + s.getSrcId()
              + ") is running in catchup_applier_running mode. "
              + "Will delete all rows whose scn is less than or equal to "
              + scn);
          applier = _appliers.get(s.getSrcName());
          if ((null != applier) && (applier.isAlive()))
          {
            LOG.info("Begin phase 5 : Pausing Applier and deleting Rows from tab table :");

            LOG.info("Requesting applier to pause !!");
            applier.pause();
            LOG.info("Applier paused !!");
          }

          try
          {
            // mark ahead of time; if this doesn't work this time; it will next
            // cycle
            _bootstrapDao.updateMinScnOfSnapshot(s.getSrcId(), scn);
            String srcTable = _bootstrapDBCleanerQueryHelper.getSrcTable(s.getSrcId());
            int numRowsDeleted = _bootstrapDBCleanerQueryExecutor.deleteTable(srcTable, scn);
            LOG.info("Number of Rows deleted for source  :" + s.getSrcName()
                + "(" + s.getSrcId() + ") :" + numRowsDeleted);
            if (numRowsDeleted > 0
                && _cleanerConfig.isOptimizeTableEnabled(s.getSrcName()))
            {
              LOG.info("Optimizing table to reclaim space for source :"
                  + s.getSrcName() + "(" + s.getSrcId() + ")");
              _bootstrapDBCleanerQueryExecutor.optimizeTable(srcTable);
            }
          } finally
          {
            if ((null != applier) && (applier.isAlive()))
            {
              LOG.info("Requesting applier to resume !!");
              applier.unpause();
              LOG.info("Applier resumed !!");
            }
          }

          LOG.info("End phase 5 : Deleting Rows from tab table :");
        }

        LOG.info("Cleaner done for source :" + s.getSrcName() + "("
            + s.getSrcId() + ")");
      }
    } catch (SQLException ex)
    {
      LOG.error("Got SQL exception while cleaning bootstrapDB !!", ex);
    } catch (InterruptedException ie)
=======
      boolean hasTerminated = _cleanerThreadPoolService.awaitTermination(TERMINATION_TIMEOUT_IN_MS, TimeUnit.MILLISECONDS);
      LOG.info("Result of terminating cleaner thread pool service: " + (hasTerminated ? "success" : "failure"));
    } catch (InterruptedException e)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      LOG.error("Got interrupted exception while cleaning bootstrapDB !!", ie);
=======
      LOG.error("Cleaner thread pool service termination has been interrupted", e);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
      isCleaning = false;
=======
      for (Map.Entry<String, BootstrapDBSingleSourceCleaner> entry : _cleaners.entrySet())
      {
        String source = entry.getKey();
        BootstrapDBSingleSourceCleaner singleSourceCleaner = entry.getValue();
        LOG.info("Invoking close on cleaner for source = " + source);
        singleSourceCleaner.close();
      }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-common/databus-bootstrap-common-impl/src/main/java/com/linkedin/databus/bootstrap/common/BootstrapDBCleaner.java;<<<<<<< MINE
  public void close()
  {
    _bootstrapDao.close();
  }

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;<<<<<<< MINE
=======
  private final BootstrapDBCleaner _dbCleaner;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;<<<<<<< MINE
    BootstrapDBCleaner dbCleaner = new BootstrapDBCleaner(dbCleanerName,
=======
    _dbCleaner = new BootstrapDBCleaner(dbCleanerName,
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;<<<<<<< MINE
    _dbPeriodicTriggerThread = new BootstrapDBPeriodicTriggerThread(dbCleaner,
=======
    _dbPeriodicTriggerThread = new BootstrapDBPeriodicTriggerThread(_dbCleaner,
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;<<<<<<< MINE
    _dbDiskSpaceTriggerThread = new BootstrapDBDiskSpaceTriggerThread(dbCleaner,
=======
    _dbDiskSpaceTriggerThread = new BootstrapDBDiskSpaceTriggerThread(_dbCleaner,
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/DatabusBootstrapProducer.java;<<<<<<< MINE
=======


>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapDBDiskSpaceTriggerThread.java;<<<<<<< MINE
          if (!_cleaner.isCleanerRunning())
          {
            _cleaner.doClean();
          }
          else
          {
            LOG.info("Skipping as cleaner is already running !!");
          }
=======
          _cleaner.doClean();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;<<<<<<< MINE
=======
  private boolean _isRunning = false;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;<<<<<<< MINE
    boolean running = true;
=======
    _isRunning = true;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;<<<<<<< MINE
    while (running && !isShutdownRequested())
=======
    while (_isRunning && !isShutdownRequested())
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;<<<<<<< MINE
            running = false;
=======
            _isRunning = false;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;<<<<<<< MINE
=======
  public boolean isRunning()
  {
    return _isRunning;
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapApplierThread.java;<<<<<<< MINE
      SQLException, InterruptedException
=======
      SQLException
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapDBPeriodicTriggerThread.java;<<<<<<< MINE
=======
    LOG.info("PeriodicTrigger Config :" + _config);

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-producer/databus-bootstrap-producer-impl/src/main/java/com/linkedin/databus/bootstrap/producer/BootstrapDBPeriodicTriggerThread.java;<<<<<<< MINE
        if (!_cleaner.isCleanerRunning())
        {
          roundBeginTime = System.currentTimeMillis();
          _cleaner.doClean();
          roundEndTime = System.currentTimeMillis();
        }
        else
        {
          LOG.info("Skipping this round as cleaner is already running !!");
        }
=======
        roundBeginTime = System.currentTimeMillis();
        _cleaner.doClean();
        roundEndTime = System.currentTimeMillis();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/StringUtils.java;<<<<<<< MINE
=======
import java.util.regex.Matcher;
import java.util.regex.Pattern;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/StringUtils.java;<<<<<<< MINE
=======
  private static final Pattern ORA_JDBC_URI_PATTERN =
      Pattern.compile("(jdbc:oracle:thin:)([^/@]*)(/[^@]*)(@.*)");
  private static final Pattern MYSQL_JDBC_PATTERN1 = Pattern.compile("\\((user=|password=)([^)]*)\\)");
  private static final Pattern MYSQL_JDBC_PATTERN2 = Pattern.compile("(user=|password=)([^&]*)");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/util/StringUtils.java;<<<<<<< MINE
=======

  /**
   * Strip username/password information from the JDBC DB uri to be used for logging
   * @param uri     the JDBC URI to sanitize
   * @return the sanitized DB URI
   */
  public static String sanitizeDbUri(String uri)
  {
    String result = uri;
    Matcher m = ORA_JDBC_URI_PATTERN.matcher(uri);
    if (m.matches())
    {
      result = m.group(1) + "*/*" + m.group(4);
    }
    else if (uri.startsWith("jdbc:mysql:"))
    {
      Matcher m1 = MYSQL_JDBC_PATTERN1.matcher(result);
      Matcher m2 = MYSQL_JDBC_PATTERN2.matcher(result);
      if (m1.find())
      {
        result = m1.replaceAll("($1*)");
      }
      else if (m2.find())
      {
        result = m2.replaceAll("$1*");
      }
    }

    return result;
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;<<<<<<< MINE
=======
  //Adding internal bootstrap checkpoint ; to simulate bootstrap server
  private Checkpoint _bootstrapCheckpoint=null;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;<<<<<<< MINE
  public void addBootstrapCheckpointEventToBuffer(long lastScn, long dataEventCount, int numCheckpoints)
=======
  public void addBootstrapCheckpointEventToBuffer(long lastScn, long dataEventCount,int numCheckpoints)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;<<<<<<< MINE
    Checkpoint cp = _bstCheckpointHandler.createInitialBootstrapCheckpoint(null, 0L);
    cp.setBootstrapStartScn(0L);
=======
    Checkpoint cp = (_bootstrapCheckpoint == null) ? _bstCheckpointHandler.createInitialBootstrapCheckpoint(null, 0L): _bootstrapCheckpoint;
    if (cp.getBootstrapStartScn()==Checkpoint.UNSET_BOOTSTRAP_START_SCN)
    {
      cp.setBootstrapStartScn(0L);
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;<<<<<<< MINE
=======
    cp.setSnapshotOffset(dataEventCount);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;<<<<<<< MINE
=======
  public Checkpoint getBootstrapCheckpoint()
  {
    return _bootstrapCheckpoint;
  }

  public void setBootstrapCheckpoint(Checkpoint checkpoint)
  {
    _bootstrapCheckpoint = checkpoint;
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;<<<<<<< MINE
           //note: start should provide the first preceding scn;
           // Test DDSDBUS-1109 by skipping the start() call. The scn Index should be set for streamEvents() to work correctly
          if (_invokeStartOnBuffer)
          {
            _buffer.start(evScn-1);
          }
          _buffer.startEvents();
=======
            //note: start should provide the first preceding scn;
            // Test DDSDBUS-1109 by skipping the start() call. The scn Index should be set for streamEvents() to work correctly
            if (_invokeStartOnBuffer)
            {
              _buffer.start(evScn-1);
            }
            _buffer.startEvents();
            if (_bootstrapCheckpoint != null)
            {
              //add the initial checkpoint event to dispatcher's buffer to simulate bootstrap
              addBootstrapCheckpointEventToBuffer(evScn-1,dataEventCount,1);
            }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/test/DbusEventAppender.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
 *                                  "flexible" checkpoint (see below).
=======
 *                                  "flexible" checkpoint (see below). If the SCN is 0, and tsNescs is greater than 0
 *                                  then the relay may (if capable) stream events that have timestamp greater than
 *                                  or equal to tsNsecs. However, the relay MUST ensure that it does not miss any
 *                                  events that have a timestamp greater than or equal to tsNsecs.
 *                                  TODO: Until we have this capability in the relays we don't have to define the exact behavior
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
 *  <li> {@code tsNsecs}          - optional value that is set to the timestamp of the EOP event in the window of
 *                                  events with the highest SCN that has been successfully consumed. If tsNsecs is
 *                                  greater than 0 then the value of windowScn must not be -1 (see discussion on
 *                                  flexible checkpoints below).
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
 * If a flexible checkpoint has tsNsecs set, the value of tsNsecs must be -1 (unset value).
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
 *   <li> {@code bootstrap_start_tsnsecs}
 *                                     - (optional) the timestamp of the EOP event of the highest window successfully
 *                                       processed by the client before the client fell off the relay. This value
 *                                       is optionally set by the bootstrap client before bootstrapping begins, and
 *                                       is never changed during the entire bootstrap sequence
 *                                       (snapshot and catchup phases).
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
 *
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  public static final long UNSET_BOOTSTRAP_START_NSECS = -1;
  public static final long UNSET_TS_NSECS = -1;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  /**
   * A checkpoint has the tuple (SCN, Timestamp-of-highest-scn) to indicate the point of successful
   * consumption -- The SCN and timestamp being that of the EOW event consumed successfully.
   * However, it is possible to create a checkpoint (e.g. by the operator as a run-book procedure) that
   * has only a timestamp to indicate the last consumption point, but does not have the corresponding SCN.
   * For now, we restrict these checkpoints to have an SCN of 0 (definitely not -1, since -1 will indicate
   * a 'flexible checkpoint')
   */
  public static final long WINDOW_SCN_FOR_PURE_TIMEBASED_CKPT = 0;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  private static final String TS_NSECS             = "tsNsecs";
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  public static final String BOOTSTRAP_START_TSNSECS = "bootstrap_start_tsnsecs";
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  // TODO ALERT XXX WARNING: Do NOT add any more member variables. See DDSDBUS-3070. It is ok to add to internalData
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  public void setTsNsecs(long nsecs)
  {
    internalData.put(TS_NSECS, Long.valueOf(nsecs));
  }

  public long getTsNsecs()
  {
    return number2Long((Number)internalData.get(TS_NSECS), UNSET_TS_NSECS);
  }

  public void setBootstrapStartNsecs(long nsecs)
  {
    internalData.put(BOOTSTRAP_START_TSNSECS, Long.valueOf(nsecs));
  }

  public long getBootstrapStartNsecs()
  {
    return number2Long((Number)internalData.get(BOOTSTRAP_START_TSNSECS), UNSET_BOOTSTRAP_START_NSECS);
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  // TODO Deprecate and remove this method. See DDSDBUS-3070.
  // See toString()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  // This is the method used by databus components to "serialize" a checkpoint for on-the-wire
  // transmission.
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
      endEvents(e.sequence());
=======
      endEvents(e.sequence(), e.timestampInNanos());
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
  public void endEvents(long endWindowScn)
=======
  private void endEvents(long endWindowScn, long nsecs)
  {
    setFullyConsumed(endWindowScn);
    setTsNsecs(nsecs);
  }

  private void setFullyConsumed(long endWindowScn)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
    endEvents(currentWindowScn);
=======
    setFullyConsumed(currentWindowScn);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
    setTsNsecs(UNSET_TS_NSECS);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
        && (getWindowScn() < 0))
=======
        && (getWindowScn() < 0) && getTsNsecs() == UNSET_TS_NSECS)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  public void clearBootstrapStartTsNsecs()
  {
    setBootstrapStartNsecs(UNSET_BOOTSTRAP_START_NSECS);
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
    clearBootstrapStartTsNsecs();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
   * Creates a time-based checkpoint.
   *
   * A very nice API to have for the clients, when we provide the use case for a registration to
   * start receiving relay events X hours before registration time (i,e. neither from the beginning of
   * buffer, nor from latest point).
  public static Checkpoint createTimeBasedCheckpoint(long nsecs)
  throws DatabusRuntimeException
  {
    if (nsecs <= UNSET_TS_NSECS)
    {
      throw new DatabusRuntimeException("Invalid value for timestamp:" + nsecs);
    }
    Checkpoint cp = new Checkpoint();
    cp.setTsNsecs(nsecs);
    cp.setWindowScn(WINDOW_SCN_FOR_PURE_TIMEBASED_CKPT);
    return cp;
  }
   */

  /**
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
  /**
   * Creates an online checkpoint with timestamp and SCN. See DDSDBUS-3332
   * @param lastConsumedScn the sequence number of the last fully consumed window
   * @param tsNanos the timestamp, if available, of the last fully consumed window.
   */
  public static Checkpoint createOnlineConsumptionCheckpoint(long lastConsumedScn, long tsNanos)
  {
    Checkpoint cp = createOnlineConsumptionCheckpoint(lastConsumedScn);
    cp.setTsNsecs(tsNanos);
    return cp;
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
    lhash = Fnv1aHashImpl.addLong32(lhash, getTsNsecs());
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
      lhash = Fnv1aHashImpl.addLong32(lhash, getBootstrapStartNsecs());
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
   * @param ckpt    the checkpoint to validate
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE
=======
      long tsNsecs = getTsNsecs();
      // tsNsecs should be unset.
      if (tsNsecs != UNSET_TS_NSECS)
      {
        throw new InvalidCheckpointException("unexpected tsNsecs:" + tsNsecs, this);
      }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/Checkpoint.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus/core/DbusConstants.java;<<<<<<< MINE
=======
  public static final long  NUM_NSECS_IN_MIN= NUM_NSECS_IN_SEC * 60;

  public static final long  NUM_MSECS_IN_SEC= 1000;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus2/relay/config/PhysicalSourceStaticConfig.java;<<<<<<< MINE
=======
import com.linkedin.databus.core.util.StringUtils;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/main/java/com/linkedin/databus2/relay/config/PhysicalSourceStaticConfig.java;<<<<<<< MINE
    sb.append("name=").append(_name).append(";part=").append(_partiton).append(";uri=").append(_uri)
    .append(";role=").append(_role).append(";rsKey=").append(_resourceKey).append(";#src=").append(_sources.length);
=======
    sb.append("name=").append(_name).append(";part=").append(_partiton).append(";uri=")
    .append(StringUtils.sanitizeDbUri(_uri))
    .append(";role=").append(_role).append(";rsKey=").append(_resourceKey).append(";#src=")
    .append(_sources.length);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/util/TestStringUtils.java;<<<<<<< MINE
=======
/*
 *
 * Copyright 2013 LinkedIn Corp. All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
*/
package com.linkedin.databus.core.util;

import org.testng.Assert;
import org.testng.annotations.Test;

/**
 * Unit tests for {@link StringUtils}
 */
public class TestStringUtils
{

 @Test
 public void testSanitizeDbUri()
 {
   String s = StringUtils.sanitizeDbUri("jdbc:oracle:thin:uSeR/p4ssw0rd@db.company.com:1521/SCHEMA");
   Assert.assertEquals(s, "jdbc:oracle:thin:*/*@db.company.com:1521/SCHEMA");

   s = StringUtils.sanitizeDbUri("jdbc:oracle:thick:uSeR/p4ssw0rd@db.company.com:1521/SCHEMA");
   Assert.assertEquals(s, "jdbc:oracle:thick:uSeR/p4ssw0rd@db.company.com:1521/SCHEMA");

   s = StringUtils.sanitizeDbUri("jdbc:oracle:thin:fancy-uri/v1/v2(123,456,789)@(DESCRIPTION=(LOAD_BALANCE=on)(FAILOVER=on)(ADDRESS=(PROTOCOL=TCP)(HOST=db1.host.com)(PORT=1521))(ADDRESS=(PROTOCOL=TCP)(HOST=db2.host.com)(PORT=1521))(CONNECT_DATA=(FAILOVER_MODE=(TYPE=SELECT)(METHOD=BASIC)(RETRIES=180)(DELAY=5))))");
   Assert.assertEquals(s, "jdbc:oracle:thin:*/*@(DESCRIPTION=(LOAD_BALANCE=on)(FAILOVER=on)(ADDRESS=(PROTOCOL=TCP)(HOST=db1.host.com)(PORT=1521))(ADDRESS=(PROTOCOL=TCP)(HOST=db2.host.com)(PORT=1521))(CONNECT_DATA=(FAILOVER_MODE=(TYPE=SELECT)(METHOD=BASIC)(RETRIES=180)(DELAY=5))))");

   s = StringUtils.sanitizeDbUri("jdbc:mysql://address=(protocol=tcp)(host=localhost)(port=3306)(password=p4ssw0rd)(user=uSeR)/db");
   Assert.assertEquals(s, "jdbc:mysql://address=(protocol=tcp)(host=localhost)(port=3306)(password=*)(user=*)/db");

   s = StringUtils.sanitizeDbUri("jdbc:mysql://localhost:3306/DB?profileSQL=true&user=Godzilla&password=KingKong");
   Assert.assertEquals(s, "jdbc:mysql://localhost:3306/DB?profileSQL=true&user=*&password=*");

   s = StringUtils.sanitizeDbUri("jdbc:MySqL://localhost:3306/DB?profileSQL=true&user=Godzilla&password=KingKong");
   Assert.assertEquals(s, "jdbc:MySqL://localhost:3306/DB?profileSQL=true&user=Godzilla&password=KingKong");
 }

}>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;<<<<<<< MINE

=======
    Assert.assertFalse(cp.getFlexible());
    Assert.assertEquals(cp.getTsNsecs(), Checkpoint.UNSET_TS_NSECS);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;<<<<<<< MINE
=======

    try
    {
      newCp = Checkpoint.createFlexibleCheckpoint();
      newCp.setTsNsecs(1L);
      newCp.assertCheckpoint();
      Assert.fail("InvalidCheckpointException expected");
    }
    catch (InvalidCheckpointException e)
    {
      // ok
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestCheckpoint.java;<<<<<<< MINE
=======

  // Test the case where a manual checkpoint is created with scn set to 0 but timestamp is non-zero.
  @Test
  public void testTimestampBasedCheckpoint() throws Exception
  {
    final long ts = 23534677L;
    Checkpoint cp = Checkpoint.createOnlineConsumptionCheckpoint(0L);
    cp.setTsNsecs(ts);

    Assert.assertTrue(cp.assertCheckpoint());

    String serCp = cp.toString();

    Checkpoint newCp = new Checkpoint(serCp);
    Assert.assertTrue(newCp.assertCheckpoint());
    Assert.assertEquals(newCp.getTsNsecs(), ts);
  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-container/src/main/java/com/linkedin/databus2/core/container/request/DatabusRequest.java;<<<<<<< MINE
=======
      if (_responseThrowable.getMessage() != null)
      {
        _responseContent.addMetadata(DatabusHttpHeaders.DATABUS_ERROR_MESSAGE_HEADER, _responseThrowable.getMessage());
      }
      else
      {
        _responseContent.addMetadata(DatabusHttpHeaders.DATABUS_ERROR_MESSAGE_HEADER, "No message provided");
      }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-container/src/main/java/com/linkedin/databus2/core/container/request/DatabusRequest.java;<<<<<<< MINE
=======
        if (cause.getMessage() != null)
        {
          _responseContent.addMetadata(DatabusHttpHeaders.DATABUS_ERROR_CAUSE_MESSAGE_HEADER,cause.getMessage());
        }
        else
        {
          _responseContent.addMetadata(DatabusHttpHeaders.DATABUS_ERROR_CAUSE_MESSAGE_HEADER,"No message provided");
        }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-container/src/main/java/com/linkedin/databus2/core/container/request/DatabusRequest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-fwk-test/src/main/java/com/linkedin/databus2/test/ClassIntrospectionUtils.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-fwk-test/src/main/java/com/linkedin/databus2/test/ClassIntrospectionUtils.java;<<<<<<< MINE
  Class _classType;
=======
  Class<?> _classType;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-fwk-test/src/main/java/com/linkedin/databus2/test/ClassIntrospectionUtils.java;<<<<<<< MINE
  // =======
      Class<?> superClass = classType.getSuperclass();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-core/databus-core-fwk-test/src/main/java/com/linkedin/databus2/test/ClassIntrospectionUtils.java;<<<<<<< MINE
      Class superClass = classType.getSuperclass();
=======
      Class<?> superClass = classType.getSuperclass();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus2-relay/databus2-event-producer-common/src/main/java/com/linkedin/databus2/producers/AbstractEventProducer.java;<<<<<<< MINE
  private final DbusEventBufferAppendable _eventBuffer;
=======
  protected final DbusEventBufferAppendable _eventBuffer;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;<<<<<<< MINE
=======
import com.linkedin.databus.core.DbusEventPart;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;<<<<<<< MINE
        String schemaName = (null == payloadSchema) ? "unknown source: " + e.srcId() :
=======
        String schemaName = (null == payloadSchema) ? "unknown source: " + e.getSourceId() :
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;<<<<<<< MINE
        String keyStr;
=======
        String keyStr = null;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/LoggingConsumer.java;<<<<<<< MINE
          keyStr = e.isKeyString() ? new String(e.keyBytes(), "UTF-8") : Long.toString(e.key());
=======
          if (e.isKeyString())
          {
            keyStr = new String(e.keyBytes(), "UTF-8");
          }
          else if (e.isKeyNumber())
          {
            keyStr = Long.toString(e.key());
          }
          else if (e.isKeySchema())
          {
            // TODO Fix to use a decoder (DDSDBUS-2076)
            DbusEventPart keyPart = e.getKeyPart();
            keyStr = keyPart.toString();
          }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
=======

import com.linkedin.databus.client.consumer.LoggingConsumer;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
=======
  private final LoggingConsumer _loggingConsumer;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
  // used only by tests
  public MultiConsumerCallback(List<DatabusV2ConsumerRegistration> registrations,
          ExecutorService executorService,
          long timeBudgetMs,
          ConsumerCallbackFactory<DatabusCombinedConsumer> callbackFactory
         )
=======
  // used only by tests
  public MultiConsumerCallback(List<DatabusV2ConsumerRegistration> registrations,
                               ExecutorService executorService,
                               long timeBudgetMs,
                               ConsumerCallbackFactory<DatabusCombinedConsumer> callbackFactory)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
                               ConsumerCallbackStats consumerStats,
                               LoggingConsumer loggingConsumer)
=======
                               ConsumerCallbackStats consumerStats,    // specific to relay or bootstrap mode, not both
                               UnifiedClientStats unifiedClientStats,  // used in both relay and bootstrap mode
                               LoggingConsumer loggingConsumer)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/consumer/MultiConsumerCallback.java;<<<<<<< MINE
    // TODO:  Should we sniff registrations list and make sure no LoggingConsumers in there?
    //        Sole non-test caller is DatabusSourcesConnection, so as long as LoggingConsumer
    //        is not available to end-users, no need...
    _loggingConsumer = loggingConsumer;  // may be null in unit tests
=======
    _unifiedClientStats = unifiedClientStats;
    _loggingConsumer = loggingConsumer;  // may be null in unit tests
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/main/java/com/linkedin/databus/client/DbusEventAvroDecoder.java;<<<<<<< MINE
=======
      g.writeFieldName("partId");
      g.writeNumber(Integer.valueOf(e.getPartitionId()));
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
    TestUtil.setupLogging(true, "TestMultiConsumerCallback-testng.txt", Level.OFF);
=======
    TestUtil.setupLogging(true, "/tmp/TestMultiConsumerCallback.txt", Level.OFF);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting testPerf()");
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting test1StreamConsumerHappyPath()");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting test1StreamConsumerCallFailure()");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting testConsumersWithException()");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting test3IndependentStreamConsumersHappyPath()");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting test3IndependentStreamConsumersWithFailure()");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting test3GroupedStreamConsumersHappyPath()");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting test3GroupedStreamConsumersWithFailure()");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
=======
    LOG.info("\n\nstarting test1ConsumerTimeout()");

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
    log.info("test2ConsumerTimeout: start");
=======
    log.info("\n\nstarting test2ConsumerTimeout()");
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-common/src/test/java/com/linkedin/databus/client/consumer/TestMultiConsumerCallback.java;<<<<<<< MINE
      super(consumers, executorService, timeBudgetMs, callbackFactory, consumerStats, null);
=======
      super(consumers, executorService, timeBudgetMs, callbackFactory, consumerStats, unifiedClientStats, null);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;<<<<<<< MINE
=======
import java.sql.SQLException;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;<<<<<<< MINE
=======
import com.linkedin.databus2.core.container.request.BootstrapDBException;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;<<<<<<< MINE
=======
import com.linkedin.databus2.core.container.request.BootstrapDatabaseTooYoungException;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;<<<<<<< MINE
=======
    if (result==null)
    {
      result = readChannel.getMetadata(DatabusHttpHeaders.DATABUS_ERROR_CLASS_HEADER);
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/RemoteExceptionHandler.java;<<<<<<< MINE
=======
      else if (err.equalsIgnoreCase(BootstrapDatabaseTooYoungException.class.getName()))
      {
        remoteException = new BootstrapDatabaseTooYoungException();
      }
      else if (err.equalsIgnoreCase(BootstrapDBException.class.getName()))
      {
        remoteException = new BootstrapDBException();
      }
      else if (err.equalsIgnoreCase(SQLException.class.getName()))
      {
        remoteException = new SQLException();
      }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/netty/NettyHttpDatabusBootstrapConnection.java;<<<<<<< MINE
=======
        LOG.error("Failed to process /startscn response");
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/registration/DatabusV2RegistrationImpl.java;<<<<<<< MINE
import com.linkedin.databus.client.consumer.LoggingConsumer;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/registration/DatabusV2RegistrationImpl.java;<<<<<<< MINE
	private RegistrationState _state;
	protected RegistrationId _id;
    private final Logger _log;
	private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
    protected DbusEventsStatisticsCollector _inboundEventsStatsCollector;
    protected DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;
    protected ConsumerCallbackStats _relayConsumerStats;
    protected ConsumerCallbackStats _bootstrapConsumerStats;
	private final List<DatabusCombinedConsumer> _consumers;
	private final List<String> _sources;
	private DatabusSourcesConnection _sourcesConnection;
	private DatabusRegistration _parent = null;
    protected final DatabusHttpClientImpl _client;
	private Status _status = null;
	private DbusKeyCompositeFilterConfig _filterConfig = null;

	private List<DatabusV2ConsumerRegistration> _streamConsumerRawRegistrations;
	private List<DatabusV2ConsumerRegistration> _bootstrapConsumerRawRegistrations;

	/** Suffix Names for Stats Collectors **/
	public static final String STREAM_EVENT_STATS_SUFFIX_NAME = ".inbound";
	public static final String BOOTSTRAP_EVENT_STATS_SUFFIX_NAME = ".inbound.bs";
	public static final String RELAY_CONSUMER_STATS_SUFFIX_NAME = ".callback.relay";
	public static final String BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME = ".callback.bootstrap";

    public class Status extends DatabusComponentStatus
	{
      public Status()
=======
  private RegistrationState _state;
  protected RegistrationId _id;
  private final Logger _log;
  private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
  protected DbusEventsStatisticsCollector _inboundEventsStatsCollector;
  protected DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;
  protected ConsumerCallbackStats _relayConsumerStats;
  protected ConsumerCallbackStats _bootstrapConsumerStats;
  protected UnifiedClientStats _unifiedClientStats;
  private final List<DatabusCombinedConsumer> _consumers;
  private final List<String> _sources;
  private DatabusSourcesConnection _sourcesConnection;
  private DatabusRegistration _parent = null;
  protected final DatabusHttpClientImpl _client;
  private Status _status = null;
  private DbusKeyCompositeFilterConfig _filterConfig = null;

  private List<DatabusV2ConsumerRegistration> _streamConsumerRawRegistrations;
  private List<DatabusV2ConsumerRegistration> _bootstrapConsumerRawRegistrations;

  /** Suffix Names for Stats Collectors **/
  public static final String STREAM_EVENT_STATS_SUFFIX_NAME = ".inbound";
  public static final String BOOTSTRAP_EVENT_STATS_SUFFIX_NAME = ".inbound.bs";
  public static final String RELAY_CONSUMER_STATS_SUFFIX_NAME = ".callback.relay";
  public static final String BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME = ".callback.bootstrap";
  public static final String UNIFIED_CLIENT_STATS_SUFFIX_NAME = ".callback.unified";

  public class Status extends DatabusComponentStatus
  {
    public Status()
    {
      super(getStatusName());
    }
  }

  // TODO:  nuke?  no Databus callers at all; is this a public (external) API?
  public DatabusV2RegistrationImpl(RegistrationId id,
                                   DatabusHttpClientImpl client)
  {
    this(id, client, client.getCheckpointPersistenceProvider(), null, null);
  }

  public DatabusV2RegistrationImpl(RegistrationId id,
                                   DatabusHttpClientImpl client,
                                   CheckpointPersistenceProvider ckptProvider)
  {
    this(id, client, ckptProvider, null, null);
  }


  // TODO:  make private?  no other Databus callers except two ctors above; is this a public (external) API?
  public DatabusV2RegistrationImpl(RegistrationId id,
                                   DatabusHttpClientImpl client,
                                   CheckpointPersistenceProvider ckptProvider,
                                   String[] sources,
                                   AbstractDatabusCombinedConsumer[] consumers)
  {
    _id = id;
    _status = new Status();
    _client = client;
    _checkpointPersistenceProvider = ckptProvider;
    _state = RegistrationState.INIT;
    _sources = new ArrayList<String>();
    _consumers = new ArrayList<DatabusCombinedConsumer>();
    _log = Logger.getLogger(getClass().getName() + (null  == _id ? "" : "." + _id.getId()));
    if ( null != sources)
      _sources.addAll(Arrays.asList(sources));
    if ( null != consumers)
      _consumers.addAll(Arrays.asList(consumers));
  }

  /**
   * Add sources to a given registration object
   * Adding an already existent subscription, will be a no-op.
   *
   * This does not create any new the DatabusRegistration object ( only modifies the current one ).
   * Hence the id of the registration remains the same
   *
   * @throws IllegalStateException if this registration has already been started.
   */
  public synchronized void addSubscriptions(String ... sources)
          throws IllegalStateException
  {
    if ( ! _state.isPreStartState())
      throw new IllegalStateException("Cannot add sources when state is running or shut down. Current State :" + _state);

    for (String s : sources)
      if (! _sources.contains(s))
        _sources.add(s);
  }

  /**
   * Remove subscriptions from a given registration object
   * Removing a non-existent subscription, will be a no-op.
   *
   * @throws IllegalStateException if this registration has already been started
   */
  public synchronized void removeSubscriptions(String ... sources)
          throws IllegalStateException
  {
       if ( ! _state.isRunning())
         throw new IllegalStateException("Cannot remove sources when state is running. Current State :" + _state);

       for (String s : sources)
         _sources.remove(s);
  }

  /**
   * Adds the specified consumers associated with this registration.
   * The added consumers will have the same subscription(s) and filter parameters as the other consumers
   * associated with this registration.
   */
  public synchronized void addDatabusConsumers(Collection<DatabusCombinedConsumer> consumers)
      throws IllegalStateException
  {
    if (! _state.isPreStartState())
      throw new IllegalStateException("Cannot add consumers when state is running/shutdown. Current State :" + _state);

    for (DatabusCombinedConsumer c : consumers)
      if (! _consumers.contains(c))
        _consumers.add(c);
  }

  /**
   * Removes the specified consumers associated with this registration.
   */
  public synchronized void removeDatabusConsumers(Collection<AbstractDatabusCombinedConsumer> consumers)
  {
    if (!_state.isRunning())
      throw new IllegalStateException("Cannot remove consumers when state is running. Current State :" + _state);

    _consumers.removeAll(consumers);
  }

  /**
   * Callback when registration is added to client Registration Set.
   * @param state
   */
  public synchronized void onRegister()
  {
    _state = RegistrationState.REGISTERED;
  }

  /**
   * Initialize Statistics Collectors
   */
  protected synchronized void initializeStatsCollectors()
  {
    MBeanServer mbeanServer =  null;

    if ( null != _client )
    {
      mbeanServer = _client.getMbeanServer();
    }

    int ownerId = null == _client ? -1 : _client.getContainerStaticConfig().getId();
    String regId = null != _id ? _id.getId() : "unknownReg";

    initializeStatsCollectors(regId, ownerId, mbeanServer);

    if (null != _client)
    {
      _client.getBootstrapEventsStats().addStatsCollector(regId, _bootstrapEventsStatsCollector );
      _client.getInBoundStatsCollectors().addStatsCollector(regId, _inboundEventsStatsCollector);
      _client.getRelayConsumerStatsCollectors().addStatsCollector(regId, _relayConsumerStats);
      _client.getBootstrapConsumerStatsCollectors().addStatsCollector(regId, _bootstrapConsumerStats);
      _client.getUnifiedClientStatsCollectors().addStatsCollector(regId, _unifiedClientStats);
    }
  }

  /**
   * Initialize Statistics Collectors
   */
  protected void initializeStatsCollectors(String regId, int ownerId, MBeanServer mbeanServer)
  {
    _inboundEventsStatsCollector =
        new DbusEventsStatisticsCollector(ownerId,
                                          regId + STREAM_EVENT_STATS_SUFFIX_NAME,
                                          true,
                                          false,
                                          mbeanServer);
    _bootstrapEventsStatsCollector =
        new DbusEventsStatisticsCollector(ownerId,
                                          regId + BOOTSTRAP_EVENT_STATS_SUFFIX_NAME,
                                          true,
                                          false,
                                          mbeanServer);
    _relayConsumerStats =
        new ConsumerCallbackStats(ownerId, regId + RELAY_CONSUMER_STATS_SUFFIX_NAME,
                                  regId, true, false, new ConsumerCallbackStatsEvent());
    _bootstrapConsumerStats =
        new ConsumerCallbackStats(ownerId, regId + BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME,
                                  regId, true, false, new ConsumerCallbackStatsEvent());
    _unifiedClientStats =
        new UnifiedClientStats(ownerId, regId + UNIFIED_CLIENT_STATS_SUFFIX_NAME,
                               regId, true, false,
                               _client.getClientStaticConfig().getPullerThreadDeadnessThresholdMs(),
                               new UnifiedClientStatsEvent());
  }

  @Override
  public synchronized boolean start()
       throws IllegalStateException, DatabusClientException
  {
    _log.info("Starting registration (" + toString() + ") !!");

    if (_state.isRunning())
    {
      _log.info("Registration (" + _id + ") already started !!");
      return false;
    }


    if ( _state != RegistrationState.REGISTERED)
      throw new IllegalStateException("Registration (" + _id + ") not in startable state !! Current State is :" + _state);

    if ( (null == _sources) || (_sources.isEmpty()))
      throw new DatabusClientException("Registration (" + _id + ") does not have any sources to start !!");

    if ( (null == _consumers) || (_consumers.isEmpty()))
      throw new DatabusClientException("Registration (" + _id + ") does not have any consumers to start !!");

    List<ServerInfo> relays = _client.getRelays();
    List<ServerInfo> bootstrapServers = _client.getBootstrapServices();

    List<DatabusCombinedConsumer> streamConsumers = new ArrayList<DatabusCombinedConsumer>();
    List<DatabusCombinedConsumer> bootstrapConsumers = new ArrayList<DatabusCombinedConsumer>();

    if ( (null == relays) || ( relays.isEmpty()))
      throw new DatabusClientException("No configured relays in the client to start");

    Set<ServerInfo> candidateRelays = new HashSet<ServerInfo>();

    for (ServerInfo s : relays)
    {
      if (canServe(s, _sources))
        candidateRelays.add(s);
    }

    if (candidateRelays.isEmpty())
      throw new DatabusClientException("No candidate relays for source : " + _sources);

    streamConsumers.addAll(_consumers);

    boolean canConsumerBootstrap = false;
    _streamConsumerRawRegistrations = new ArrayList<DatabusV2ConsumerRegistration>();
    _streamConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(streamConsumers, _sources, _filterConfig));

    for (DatabusCombinedConsumer c : _consumers)
    {
      if ( c.canBootstrap())
      {
        canConsumerBootstrap = true;
        bootstrapConsumers.add(c);
      }
    }

    boolean enableBootstrap = _client.getClientStaticConfig().getRuntime().getBootstrap().isEnabled();
    Set<ServerInfo> candidateBootstrapServers = new HashSet<ServerInfo>();

    if (enableBootstrap && canConsumerBootstrap)
    {
      if ( (null == bootstrapServers) || ( bootstrapServers.isEmpty()))
        throw new DatabusClientException("No configured bootstrap servers in the client to start");

      for (ServerInfo s : bootstrapServers)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/registration/DatabusV2RegistrationImpl.java;<<<<<<< MINE
    // TODO:  nuke?  no Databus callers at all; is this a public (external) API?
    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client)
    {
    	this(id, client, client.getCheckpointPersistenceProvider(), null, null);
    }

    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client,
                                     CheckpointPersistenceProvider ckptProvider)
    {
    	this(id, client, ckptProvider, null, null);
    }


    // TODO:  make private?  no other Databus callers except two ctors above; is this a public (external) API?
    public DatabusV2RegistrationImpl(RegistrationId id,
                                     DatabusHttpClientImpl client,
                                     CheckpointPersistenceProvider ckptProvider,
                                     String[] sources,
                                     AbstractDatabusCombinedConsumer[] consumers)
    {
    	_id = id;
    	_status = new Status();
    	_client = client;
    	_checkpointPersistenceProvider = ckptProvider;
    	_state = RegistrationState.INIT;
    	_sources = new ArrayList<String>();
    	_consumers = new ArrayList<DatabusCombinedConsumer>();
        _log = Logger.getLogger(getClass().getName() +
                			(null  == _id ? "" : "." + _id.getId()));
        if ( null != sources)
        	_sources.addAll(Arrays.asList(sources));

    	if ( null != consumers)
    		_consumers.addAll(Arrays.asList(consumers));
    }

    /**
    *
    * Add sources to a given registration object
    * Adding an already existent subscription, will be a no-op.
    *
    * This does not create any new the DatabusRegistration object ( only modifies the current one ).
    * Hence the id of the registration remains the same
    *
    * @throws IllegalStateException if this registration has already been started.
    */
   public synchronized void addSubscriptions(String ... sources)
           throws IllegalStateException
   {
	   	if ( ! _state.isPreStartState())
	   		throw new IllegalStateException("Cannot add sources when state is running or shut down. Current State :" + _state);

	   	for (String s : sources)
	   		if (! _sources.contains(s))
	   			_sources.add(s);
   }

   /**
    *
    * Remove subscriptions from a given registration object
    * Removing a non-existent subscription, will be a no-op.
    *
    * @throws IllegalStateException if this registration has already been started
    */
   public synchronized void removeSubscriptions(String ... sources)
           throws IllegalStateException
   {
	   	if ( ! _state.isRunning())
	   		throw new IllegalStateException("Cannot remove sources when state is running. Current State :" + _state);

	   	for (String s : sources)
	   		_sources.remove(s);
   }

    /**
    *
    * Adds the specified consumers associated with this registration
    * The added consumers will have the same subscription(s) and filter parameters as the other consumers
    * associated with this registration
    *
    */
   public synchronized void addDatabusConsumers(Collection<DatabusCombinedConsumer> consumers)
   		throws IllegalStateException
   {
	   if (! _state.isPreStartState())
		   throw new IllegalStateException("Cannot add consumers when state is running/shutdown. Current State :" + _state);

	   for (DatabusCombinedConsumer c : consumers)
		   if (! _consumers.contains(c))
			   _consumers.add(c);
   }

   /**
    *
    * Removes the specified consumers associated with this registration.
    *
    **/
   public synchronized void removeDatabusConsumers(Collection<AbstractDatabusCombinedConsumer> consumers)
   {

	   if ( ! _state.isRunning())
		   throw new IllegalStateException("Cannot remove consumers when state is running. Current State :" + _state);

	   _consumers.removeAll(consumers);

   }

   /**
    * Callback when registration is added to client Registration Set.
    * @param state
    */
   public synchronized void onRegister()
   {
   	_state = RegistrationState.REGISTERED;
   }

    /**
     * Initialize Statistics Collectors
     */
    protected synchronized void initializeStatsCollectors()
    {
	  MBeanServer mbeanServer =  null;

      if ( null != _client )
	  {
	      mbeanServer = _client.getMbeanServer();
	  }

	  int ownerId = null == _client ? -1 : _client.getContainerStaticConfig().getId();
	  String regId = null != _id ? _id.getId() : "unknownReg";

	  initializeStatsCollectors(regId, ownerId, mbeanServer);

	  if (null != _client)
	  {
        _client.getBootstrapEventsStats().addStatsCollector(regId, _bootstrapEventsStatsCollector );
        _client.getInBoundStatsCollectors().addStatsCollector(regId, _inboundEventsStatsCollector);
        _client.getRelayConsumerStatsCollectors().addStatsCollector(regId, _relayConsumerStats);
        _client.getBootstrapConsumerStatsCollectors().addStatsCollector(regId, _bootstrapConsumerStats);
	  }
    }

    /**
     * Initialize Statistics Collectors
     */
    protected void initializeStatsCollectors(String regId, int ownerId, MBeanServer mbeanServer)
    {
	  _inboundEventsStatsCollector =
	      new DbusEventsStatisticsCollector(ownerId,
	                                        regId + STREAM_EVENT_STATS_SUFFIX_NAME,
	                                        true,
	                                        false,
	                                        mbeanServer);
	  _bootstrapEventsStatsCollector =
	      new DbusEventsStatisticsCollector(ownerId,
	                                        regId + BOOTSTRAP_EVENT_STATS_SUFFIX_NAME,
	                                        true,
	                                        false,
	                                        mbeanServer);
	  _relayConsumerStats =
	      new ConsumerCallbackStats(ownerId, regId + RELAY_CONSUMER_STATS_SUFFIX_NAME,
	                                regId, true, false, new ConsumerCallbackStatsEvent());
      _bootstrapConsumerStats =
          new ConsumerCallbackStats(ownerId, regId + BOOTSTRAP_CONSUMER_STATS_SUFFIX_NAME,
                                    regId, true, false, new ConsumerCallbackStatsEvent());
    }

	@Override
	public synchronized boolean start()
			 throws IllegalStateException, DatabusClientException
	{
		_log.info("Starting registration (" + toString() + ") !!");

		if (_state.isRunning())
		{
			_log.info("Registration (" + _id + ") already started !!");
			return false;
		}


		if ( _state != RegistrationState.REGISTERED)
			throw new IllegalStateException("Registration (" + _id + ") not in startable state !! Current State is :" + _state);

		if ( (null == _sources) || (_sources.isEmpty()))
			throw new DatabusClientException("Registration (" + _id + ") does not have any sources to start !!");

		if ( (null == _consumers) || (_consumers.isEmpty()))
			throw new DatabusClientException("Registration (" + _id + ") does not have any consumers to start !!");

		List<ServerInfo> relays = _client.getRelays();
		List<ServerInfo> bootstrapServers = _client.getBootstrapServices();

		List<DatabusCombinedConsumer> streamConsumers = new ArrayList<DatabusCombinedConsumer>();
		List<DatabusCombinedConsumer> bootstrapConsumers = new ArrayList<DatabusCombinedConsumer>();

		if ( (null == relays) || ( relays.isEmpty()))
			throw new DatabusClientException("No configured relays in the client to start");

		Set<ServerInfo> candidateRelays = new HashSet<ServerInfo>();

		for (ServerInfo s : relays)
		{
			if (canServe(s, _sources))
				candidateRelays.add(s);
		}

		if (candidateRelays.isEmpty())
			throw new DatabusClientException("No candidate relays for source : " + _sources);

		streamConsumers.addAll(_consumers);

		boolean canConsumerBootstrap = false;
		_streamConsumerRawRegistrations = new ArrayList<DatabusV2ConsumerRegistration>();
		_streamConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(streamConsumers, _sources, _filterConfig));

		for (DatabusCombinedConsumer c : _consumers)
		{
			if ( c.canBootstrap())
			{
				canConsumerBootstrap = true;
				bootstrapConsumers.add(c);
			}
		}

		boolean enableBootstrap = _client.getClientStaticConfig().getRuntime().getBootstrap().isEnabled();
		Set<ServerInfo> candidateBootstrapServers = new HashSet<ServerInfo>();

		if (enableBootstrap && canConsumerBootstrap)
		{
			if ( (null == bootstrapServers) || ( bootstrapServers.isEmpty()))
				throw new DatabusClientException("No configured bootstrap servers in the client to start");

			for (ServerInfo s : bootstrapServers)
			{
				if (canServe(s,_sources))
					candidateBootstrapServers.add(s);
			}

			if (candidateBootstrapServers.isEmpty())
				throw new DatabusClientException("No candidate bootstrap servers for source : " + _sources);

			_bootstrapConsumerRawRegistrations = new ArrayList<DatabusV2ConsumerRegistration>();;
			_bootstrapConsumerRawRegistrations.add(new DatabusV2ConsumerRegistration(bootstrapConsumers, _sources, _filterConfig));
		}

		// All validations done. Setup and start
		initializeStatsCollectors();

		DatabusSourcesConnection.StaticConfig connConfig =
				_client.getClientStaticConfig().getConnection(_sources);


		if (null == connConfig)
			connConfig = _client.getClientStaticConfig().getConnectionDefaults();

			DbusEventBuffer eventBuffer = null;
			{
			  DbusEventBuffer.StaticConfig cfg = connConfig.getEventBuffer();
			  eventBuffer = new DbusEventBuffer(cfg.getMaxSize(),
=======
    if (null == connConfig)
      connConfig = _client.getClientStaticConfig().getConnectionDefaults();

      DbusEventBuffer eventBuffer = null;
      {
        DbusEventBuffer.StaticConfig cfg = connConfig.getEventBuffer();
        eventBuffer = new DbusEventBuffer(cfg.getMaxSize(),
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/registration/DatabusV2RegistrationImpl.java;<<<<<<< MINE
		DatabusSourcesConnection sourcesConnection =
				  new DatabusSourcesConnection(
						  connConfig,
						  subs,
						  candidateRelays,
						  candidateBootstrapServers,
						  _streamConsumerRawRegistrations,
						  _bootstrapConsumerRawRegistrations,
						  eventBuffer,
						  bootstrapBuffer,
						  _client.getDefaultExecutorService(),
						  _client.getContainerStatsCollector(),
						  _inboundEventsStatsCollector,
						  _bootstrapEventsStatsCollector,
						  _relayConsumerStats,
						  _bootstrapConsumerStats,
						  _checkpointPersistenceProvider,
						  _client.getRelayConnFactory(),
						  _client.getBootstrapConnFactory(),
						  _client.getHttpStatsCollector(),
						  null, // This should make sure the checkpoint directory structure is compatible with V2.
						  _client,
						  _id.toString(), // Used to uniquely identify logs and mbean name
						  _client.getEventFactory(),
						  null,
						  connStateFactory);
		return sourcesConnection;
	}


	@Override
	public synchronized void shutdown() throws IllegalStateException
	{

		if (! _state.isRunning())
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in running state to be shutdown. Current state :" + _state);

		_sourcesConnection.unregisterMbeans();
		_sourcesConnection.stop();
		_status.shutdown();
		_state = RegistrationState.SHUTDOWN;

		// remove this registration stats from client stats Collector list.
		_client.getBootstrapEventsStats().removeStatsCollector(_id.getId());
	    _client.getInBoundStatsCollectors().removeStatsCollector(_id.getId());
	    _client.getRelayConsumerStatsCollectors().removeStatsCollector(_id.getId());
	    _client.getBootstrapConsumerStatsCollectors().removeStatsCollector(_id.getId());
	}

	@Override
	public synchronized void pause() throws IllegalStateException
	{

		if ( _state == RegistrationState.PAUSED)
			return;

		if ( (_state != RegistrationState.STARTED) && ( _state != RegistrationState.RESUMED))
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be paused. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().pause();
		_status.pause();
		_state = RegistrationState.PAUSED;

	}

	@Override
	public synchronized void suspendOnError(Throwable ex) throws IllegalStateException
	{
		if ( _state == RegistrationState.SUSPENDED_ON_ERROR)
			return;

		if ( !_state.isRunning())
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be suspended. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().suspendOnError(ex);
		_status.suspendOnError(ex);
		_state = RegistrationState.SUSPENDED_ON_ERROR;

	}

	@Override
	public synchronized void resume() throws IllegalStateException
	{
		if ( _state == RegistrationState.RESUMED)
			return;

		if ( (_state != RegistrationState.PAUSED) && ( _state != RegistrationState.SUSPENDED_ON_ERROR))
			throw new IllegalStateException(
					"Registration (" + _id + ") is not in correct state to be resumed. Current state :" + _state);

		_sourcesConnection.getConnectionStatus().resume();
		_status.resume();
		_state = RegistrationState.RESUMED;
	}

	@Override
	public RegistrationState getState() {
		return _state;
	}

	@Override
	public synchronized boolean deregister()
			throws IllegalStateException
	{
		if ((_state == RegistrationState.DEREGISTERED) || (_state == RegistrationState.INIT))
			return false;

		if ( _state.isRunning())
			shutdown();

		deregisterFromClient();
		_state = RegistrationState.DEREGISTERED;

		return true;
	}

	protected void deregisterFromClient()
	{
		_client.deregister(this);
	}


	@Override
	public Collection<DatabusSubscription> getSubscriptions()
	{
		return DatabusSubscription.createSubscriptionList(_sources);
	}

	@Override
	public synchronized DatabusComponentStatus getStatus()
	{
		return _status;
	}

	@Override
	public synchronized Logger getLogger() {
		return _log;
	}

	@Override
	public DatabusRegistration getParent() {
		return _parent;
	}


	protected void setParent(DatabusRegistration parent) {
		_parent = parent;
	}

	@Override
	public synchronized DatabusRegistration withRegId(RegistrationId regId)
			throws DatabusClientException, IllegalStateException
	{
		if ( (_id != null) && (_id.equals(regId)))
			return this;

		if (! RegistrationIdGenerator.isIdValid(regId))
			throw new DatabusClientException("Another registration with the same regId (" + regId + ") already present !!");

		if (_state.isRunning())
			throw new IllegalStateException("Cannot update regId when registration is in running state. RegId :" + _id + ", State :" + _state);

		_id = regId;
		_status = new Status(); // Component Status should use the correct component name

		return this;
	}


	@Override
	public synchronized DatabusRegistration withServerSideFilter(
			DbusKeyCompositeFilterConfig filterConfig)
			throws IllegalStateException
	{

		if (_state.isRunning())
			throw new IllegalStateException("Cannot update server-side filter when registration is in running state. RegId :" + _id
					+ ", State :" + _state);

		_filterConfig = filterConfig;
		return this;
	}

	@Override
	public List<DbusPartitionInfo> getPartitions() {
		return null;
	}

	@Override
	public Checkpoint getLastPersistedCheckpoint()
	{
		Checkpoint cp =_checkpointPersistenceProvider.loadCheckpoint(_sources);
		return cp;
	}

	@Override
	public synchronized boolean storeCheckpoint(Checkpoint ckpt)
			throws IllegalStateException
	{
		try
		{
			_checkpointPersistenceProvider.storeCheckpoint(_sources, ckpt);
		} catch (IOException ioe) {
			_log.error("Storing checkpoint failed with exception", ioe);
			return false;
		}
		return true;
	}

	@Override
	public DbusEventsStatisticsCollectorMBean getRelayEventStats()
	{
		return _inboundEventsStatsCollector;
	}

	@Override
	public DbusEventsStatisticsCollectorMBean getBootstrapEventStats()
	{
		return _bootstrapEventsStatsCollector;
	}

	@Override
	public ConsumerCallbackStatsMBean getRelayCallbackStats()
	{
		return _relayConsumerStats;
	}

	@Override
	public ConsumerCallbackStatsMBean getBootstrapCallbackStats()
	{
		return _bootstrapConsumerStats;
	}

	@Override
	public RelayFindMaxSCNResult fetchMaxSCN(FetchMaxSCNRequest request)
			throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}

	@Override
	public RelayFlushMaxSCNResult flush(RelayFindMaxSCNResult fetchSCNResult,
			FlushRequest flushRequest) throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}

	@Override
	public RelayFlushMaxSCNResult flush(FetchMaxSCNRequest maxScnRequest,
			FlushRequest flushRequest) throws InterruptedException {
		throw new RuntimeException("Not supported yet !!");
	}


	protected synchronized String getStatusName()
	{
	  return "Status" + ((_id != null ) ? "_" + _id.getId() : "");
	}

	private static boolean canServe(ServerInfo s, Collection<String> sources)
	{
		List<String> supportedSources = s.getSources();

		for (String src : sources)
		{
			if (! supportedSources.contains(src))
				return false;
		}

		return true;
	}


	@Override
	public synchronized RegistrationId getRegistrationId() {
		return _id;
	}

	@Override
	public synchronized String toString() {
		return "DatabusV2RegistrationImpl [_state=" + _state + ", _id=" + _id
				+ ", _sources=" + _sources + ", _status=" + _status
				+ ", _filterConfig=" + _filterConfig
				+ ", _streamConsumerRawRegistrations="
				+ _streamConsumerRawRegistrations
				+ ", _bootstrapConsumerRawRegistrations="
				+ _bootstrapConsumerRawRegistrations + "]";
	}

	@Override
	public synchronized DbusKeyCompositeFilterConfig getFilterConfig() {
		return _filterConfig;
	}
=======
    DatabusSourcesConnection sourcesConnection =
          new DatabusSourcesConnection(
              connConfig,
              subs,
              candidateRelays,
              candidateBootstrapServers,
              _streamConsumerRawRegistrations,
              _bootstrapConsumerRawRegistrations,
              eventBuffer,
              bootstrapBuffer,
              _client.getDefaultExecutorService(),
              _client.getContainerStatsCollector(),
              _inboundEventsStatsCollector,
              _bootstrapEventsStatsCollector,
              _relayConsumerStats,
              _bootstrapConsumerStats,
              _unifiedClientStats,
              _checkpointPersistenceProvider,
              _client.getRelayConnFactory(),
              _client.getBootstrapConnFactory(),
              _client.getHttpStatsCollector(),
              null, // This should make sure the checkpoint directory structure is compatible with V2.
              _client,
              _id.toString(), // Used to uniquely identify logs and mbean name
              _client.getEventFactory(),
              null,
              connStateFactory);
    return sourcesConnection;
  }

  @Override
  public synchronized void shutdown() throws IllegalStateException
  {
    if (! _state.isRunning())
      throw new IllegalStateException(
          "Registration (" + _id + ") is not in running state to be shutdown. Current state :" + _state);

    _sourcesConnection.unregisterMbeans();
    _sourcesConnection.stop();
    _status.shutdown();
    _state = RegistrationState.SHUTDOWN;

    // remove this registration stats from client stats Collector list.
    _client.getBootstrapEventsStats().removeStatsCollector(_id.getId());
    _client.getInBoundStatsCollectors().removeStatsCollector(_id.getId());
    _client.getRelayConsumerStatsCollectors().removeStatsCollector(_id.getId());
    _client.getBootstrapConsumerStatsCollectors().removeStatsCollector(_id.getId());
    _client.getUnifiedClientStatsCollectors().removeStatsCollector(_id.getId());
  }

  @Override
  public synchronized void pause() throws IllegalStateException
  {
    if ( _state == RegistrationState.PAUSED)
      return;

    if ( (_state != RegistrationState.STARTED) && ( _state != RegistrationState.RESUMED))
      throw new IllegalStateException(
          "Registration (" + _id + ") is not in correct state to be paused. Current state :" + _state);

    _sourcesConnection.getConnectionStatus().pause();
    _status.pause();
    _state = RegistrationState.PAUSED;
  }

  @Override
  public synchronized void suspendOnError(Throwable ex) throws IllegalStateException
  {
    if ( _state == RegistrationState.SUSPENDED_ON_ERROR)
      return;

    if ( !_state.isRunning())
      throw new IllegalStateException(
          "Registration (" + _id + ") is not in correct state to be suspended. Current state :" + _state);

    _sourcesConnection.getConnectionStatus().suspendOnError(ex);
    _status.suspendOnError(ex);
    _state = RegistrationState.SUSPENDED_ON_ERROR;
  }

  @Override
  public synchronized void resume() throws IllegalStateException
  {
    if ( _state == RegistrationState.RESUMED)
      return;

    if ( (_state != RegistrationState.PAUSED) && ( _state != RegistrationState.SUSPENDED_ON_ERROR))
      throw new IllegalStateException(
          "Registration (" + _id + ") is not in correct state to be resumed. Current state :" + _state);

    _sourcesConnection.getConnectionStatus().resume();
    _status.resume();
    _state = RegistrationState.RESUMED;
  }

  @Override
  public RegistrationState getState()
  {
    return _state;
  }

  @Override
  public synchronized boolean deregister()
      throws IllegalStateException
  {
    if ((_state == RegistrationState.DEREGISTERED) || (_state == RegistrationState.INIT))
      return false;

    if ( _state.isRunning())
      shutdown();

    deregisterFromClient();
    _state = RegistrationState.DEREGISTERED;

    return true;
  }

  protected void deregisterFromClient()
  {
    _client.deregister(this);
  }


  @Override
  public Collection<DatabusSubscription> getSubscriptions()
  {
    return DatabusSubscription.createSubscriptionList(_sources);
  }

  @Override
  public synchronized DatabusComponentStatus getStatus()
  {
    return _status;
  }

  @Override
  public synchronized Logger getLogger()
  {
    return _log;
  }

  @Override
  public DatabusRegistration getParent()
  {
    return _parent;
  }


  protected void setParent(DatabusRegistration parent)
  {
    _parent = parent;
  }

  @Override
  public synchronized DatabusRegistration withRegId(RegistrationId regId)
      throws DatabusClientException, IllegalStateException
  {
    if ( (_id != null) && (_id.equals(regId)))
      return this;

    if (! RegistrationIdGenerator.isIdValid(regId))
      throw new DatabusClientException("Another registration with the same regId (" + regId + ") already present !!");

    if (_state.isRunning())
      throw new IllegalStateException("Cannot update regId when registration is in running state. RegId :" + _id + ", State :" + _state);

    _id = regId;
    _status = new Status(); // Component Status should use the correct component name

    return this;
  }


  @Override
  public synchronized DatabusRegistration withServerSideFilter(DbusKeyCompositeFilterConfig filterConfig)
      throws IllegalStateException
  {
    if (_state.isRunning())
      throw new IllegalStateException("Cannot update server-side filter when registration is in running state. RegId :" + _id
          + ", State :" + _state);

    _filterConfig = filterConfig;
    return this;
  }

  @Override
  public List<DbusPartitionInfo> getPartitions()
  {
    return null;
  }

  @Override
  public Checkpoint getLastPersistedCheckpoint()
  {
    Checkpoint cp =_checkpointPersistenceProvider.loadCheckpoint(_sources);
    return cp;
  }

  @Override
  public synchronized boolean storeCheckpoint(Checkpoint ckpt)
      throws IllegalStateException
  {
    try
    {
      _checkpointPersistenceProvider.storeCheckpoint(_sources, ckpt);
    } catch (IOException ioe) {
      _log.error("Storing checkpoint failed with exception", ioe);
      return false;
    }
    return true;
  }

  @Override
  public DbusEventsStatisticsCollectorMBean getRelayEventStats()
  {
    return _inboundEventsStatsCollector;
  }

  @Override
  public DbusEventsStatisticsCollectorMBean getBootstrapEventStats()
  {
    return _bootstrapEventsStatsCollector;
  }

  @Override
  public ConsumerCallbackStatsMBean getRelayCallbackStats()
  {
    return _relayConsumerStats;
  }

  @Override
  public ConsumerCallbackStatsMBean getBootstrapCallbackStats()
  {
    return _bootstrapConsumerStats;
  }

  @Override
  public UnifiedClientStatsMBean getUnifiedClientStats()
  {
    return _unifiedClientStats;
  }

  @Override
  public RelayFindMaxSCNResult fetchMaxSCN(FetchMaxSCNRequest request)
      throws InterruptedException
  {
    throw new RuntimeException("Not yet supported !!");
  }

  @Override
  public RelayFlushMaxSCNResult flush(RelayFindMaxSCNResult fetchSCNResult,
                                      FlushRequest flushRequest)
  throws InterruptedException
  {
    throw new RuntimeException("Not yet supported !!");
  }

  @Override
  public RelayFlushMaxSCNResult flush(FetchMaxSCNRequest maxScnRequest,
                                      FlushRequest flushRequest)
  throws InterruptedException
  {
    throw new RuntimeException("Not yet supported !!");
  }


  protected synchronized String getStatusName()
  {
    return "Status" + ((_id != null ) ? "_" + _id.getId() : "");
  }

  private static boolean canServe(ServerInfo s, Collection<String> sources)
  {
    List<String> supportedSources = s.getSources();

    for (String src : sources)
    {
      if (! supportedSources.contains(src))
        return false;
    }

    return true;
  }


  @Override
  public synchronized RegistrationId getRegistrationId()
  {
    return _id;
  }

  @Override
  public synchronized String toString()
  {
    return "DatabusV2RegistrationImpl [_state=" + _state + ", _id=" + _id
        + ", _sources=" + _sources + ", _status=" + _status
        + ", _filterConfig=" + _filterConfig
        + ", _streamConsumerRawRegistrations="
        + _streamConsumerRawRegistrations
        + ", _bootstrapConsumerRawRegistrations="
        + _bootstrapConsumerRawRegistrations + "]";
  }

  @Override
  public synchronized DbusKeyCompositeFilterConfig getFilterConfig()
  {
    return _filterConfig;
  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;<<<<<<< MINE
import com.linkedin.databus.client.consumer.LoggingConsumer;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;<<<<<<< MINE
  protected DatabusFileLoggingConsumer createTypedConsumer(String valueDumpFile) throws IOException
=======
  protected DatabusFileLoggingConsumer createTypedConsumer(String valueDumpFile)
  throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;<<<<<<< MINE
    return new DatabusFileLoggingConsumer(valueDumpFile, false);
=======
    return createTypedConsumer(valueDumpFile, null);
  }

  protected DatabusFileLoggingConsumer createTypedConsumer(String valueDumpFile, String eventDumpFile)
  throws IOException
  {
    return new DatabusFileLoggingConsumer(valueDumpFile, null, eventDumpFile, false);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;<<<<<<< MINE
    
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;<<<<<<< MINE
    DatabusFileLoggingConsumer consumer = createTypedConsumer(_valueDumpFile);
=======
    // dump decoded payload values and raw (undecoded) events
    DatabusFileLoggingConsumer consumer = createTypedConsumer(_valueDumpFile, _eventDumpFile);

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;<<<<<<< MINE
    
    if (null != filterConfig)
    	reg.withServerSideFilter(filterConfig);
    
    if (reg instanceof DatabusV2RegistrationImpl)
=======

    if (!(reg instanceof DatabusV2RegistrationImpl))
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;<<<<<<< MINE
    	DatabusV2RegistrationImpl r = (DatabusV2RegistrationImpl)reg;
    	r.getLoggingConsumer().enableEventFileTrace(_eventDumpFile);
    } else {
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/SimpleFileLoggingConsumer.java;<<<<<<< MINE
    
=======

    if (null != filterConfig)
    	reg.withServerSideFilter(filterConfig);

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======
import java.io.IOException;

import org.apache.avro.Schema;
import org.apache.log4j.Logger;

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======
import com.linkedin.databus.core.FileBasedEventTrackingCallback;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
import java.io.IOException;
import org.apache.avro.Schema;
import org.apache.log4j.Logger;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  private ClientFileBasedEventTrackingCallback _fileBasedCallback = null;
=======
  private ClientFileBasedEventTrackingCallback _fileBasedDecodedValueCallback = null;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======
  private FileBasedEventTrackingCallback _fileBasedRawEventCallback = null;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======
    private final String _eventDumpFile;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
    /** The file where to store the JSON values. If null, no values are to be stored. */
=======

    /** The file in which to store the payload values in JSON format. If null, no values are to be stored. */
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
    /** The file where to store the decoded metadata info from v2 event. If null, no metadata are to be stored. */
=======

    /** The file in which to store the decoded metadata info from v2 events. If null, no metadata are to be stored. */
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    	return _metadataDumpFile;
=======
      return _metadataDumpFile;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    public boolean isAppendOnly()
=======
    /** The file in which to store the raw (undecoded) event in JSON format. If null, no raw events will be stored. */
    public String getEventDumpFile()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    	return _append;
=======
      return _eventDumpFile;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
    public StaticConfig(String valueDumpFile, boolean append)
=======

    public boolean isAppendOnly()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
      this(valueDumpFile, null, append);
=======
      return _append;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
    public StaticConfig(String valueDumpFile, String metadataDumpFile, boolean append)
=======

//NOT USED?
//  public StaticConfig(String valueDumpFile, boolean append)
//  {
//    this(valueDumpFile, null, append);
//  }

    public StaticConfig(String valueDumpFile, String metadataDumpFile, String eventDumpFile, boolean append)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    	_valueDumpFile = valueDumpFile;
    	_metadataDumpFile = metadataDumpFile;
    	_append = append;
=======
      _valueDumpFile = valueDumpFile;
      _metadataDumpFile = metadataDumpFile;
      _eventDumpFile = eventDumpFile;
      _append = append;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======
    private String _eventDumpFile;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    	return _metadataDumpFile;
=======
      return _metadataDumpFile;
    }

    public String getEventDumpFile()
    {
      return _eventDumpFile;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    	_metadataDumpFile = metadataDumpFile;
=======
      _metadataDumpFile = metadataDumpFile;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
    public boolean getAppendOnly() {
		return _appendOnly;
	}

	public void setAppendOnly(boolean appendOnly) {
		this._appendOnly = appendOnly;
	}
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
	@Override
=======
    public void setEventDumpFile(String eventDumpFile)
    {
      _eventDumpFile = eventDumpFile;
    }

    public boolean getAppendOnly()
    {
      return _appendOnly;
    }

    public void setAppendOnly(boolean appendOnly)
    {
      this._appendOnly = appendOnly;
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
      return new StaticConfig(_valueDumpFile, _metadataDumpFile, _appendOnly);
=======
      return new StaticConfig(_valueDumpFile, _metadataDumpFile, _eventDumpFile, _appendOnly);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  }
=======
//NOT USED?
//public DatabusFileLoggingConsumer() throws IOException
//{
//  this((String)null, false);
//}
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  public DatabusFileLoggingConsumer(StaticConfigBuilder configBuilder)
         throws IOException, InvalidConfigException
  {
    this(configBuilder.build());
  }
=======
//NOT USED?
//public DatabusFileLoggingConsumer(StaticConfigBuilder configBuilder)
//       throws IOException, InvalidConfigException
//{
//  this(configBuilder.build());
//}
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    this(config.getValueDumpFile(), config.getMetadataDumpFile(), config.isAppendOnly());
=======
    this(config.getValueDumpFile(), config.getMetadataDumpFile(), config.getEventDumpFile(), config.isAppendOnly());
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  public DatabusFileLoggingConsumer(String outputFilename, boolean appendOnly) throws IOException
=======
  public DatabusFileLoggingConsumer(String valueDumpFile, boolean appendOnly) throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    this( outputFilename, null, appendOnly);
=======
    this(valueDumpFile, null, null, appendOnly);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  
  public DatabusFileLoggingConsumer(String outputFilename, String metadataDumpFile, boolean appendOnly) throws IOException
=======

  public DatabusFileLoggingConsumer(String valueDumpFile,
                                    String metadataDumpFile,
                                    String eventDumpFile,
                                    boolean appendOnly)
  throws IOException
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    if (outputFilename != null)
=======
    LOG.info("DatabusFileLoggingConsumer instantiated with payload-value dump file: " + valueDumpFile +
             ", metadata dump file: " + metadataDumpFile +
             ", raw-event dump file: " + eventDumpFile +
             ", appendOnly: " + appendOnly);

    if (valueDumpFile != null)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
      LOG.info("DatabusFileLoggingConsumer instantiated with output file :" + outputFilename + ", appendOnly :" + appendOnly);	
      _fileBasedCallback = new ClientFileBasedEventTrackingCallback(outputFilename, appendOnly);
      _fileBasedCallback.init();
=======
      _fileBasedDecodedValueCallback = new ClientFileBasedEventTrackingCallback(valueDumpFile, appendOnly);
      _fileBasedDecodedValueCallback.init();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
    if( metadataDumpFile != null )
=======

    if (metadataDumpFile != null)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    	LOG.info("DatabusFileLoggingConsumer instantiated with output file: " + metadataDumpFile + ", appendOnly: " + appendOnly);
    	_fileBasedMetadataCallback = new ClientFileBasedMetadataTrackingCallback(metadataDumpFile, appendOnly);
    	_fileBasedMetadataCallback.init();
=======
      _fileBasedMetadataCallback = new ClientFileBasedMetadataTrackingCallback(metadataDumpFile, appendOnly);
      _fileBasedMetadataCallback.init();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  }
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  public DatabusFileLoggingConsumer() throws IOException
  {
    this((String)null, false);
=======
    if (eventDumpFile != null)
    {
      _fileBasedRawEventCallback = new FileBasedEventTrackingCallback(eventDumpFile, appendOnly);
      _fileBasedRawEventCallback.init();
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  public ConsumerCallbackResult onCheckpoint(SCN checkpointScn) {
=======
  public ConsumerCallbackResult onCheckpoint(SCN checkpointScn)
  {
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  protected void LogTypedValue(DbusEvent e, DbusEventDecoder eventDecoder) {
=======
  protected void LogTypedValue(DbusEvent e, DbusEventDecoder eventDecoder)
  {
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
  public ConsumerCallbackResult onDataEvent(DbusEvent e, DbusEventDecoder eventDecoder) {
=======
  public ConsumerCallbackResult onDataEvent(DbusEvent e, DbusEventDecoder eventDecoder)
  {
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    if (_fileBasedCallback != null)
=======

    if (_fileBasedDecodedValueCallback != null)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
      _fileBasedCallback.dumpEventValue(e, eventDecoder);
=======
      _fileBasedDecodedValueCallback.dumpEventValue(e, eventDecoder);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======

    if (_fileBasedRawEventCallback != null)
    {
      _fileBasedRawEventCallback.onEvent(e);
    }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    // The file based logging already done in LoggingConsumer, this one just deserialize if needed
    //_fileBasedCallback.onEvent(e);
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    if (_fileBasedCallback != null)
=======

    if (_fileBasedDecodedValueCallback != null)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
      _fileBasedCallback.dumpEventValue(e, eventDecoder);
=======
      _fileBasedDecodedValueCallback.dumpEventValue(e, eventDecoder);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======

    if (_fileBasedRawEventCallback != null)
    {
      _fileBasedRawEventCallback.onEvent(e);
    }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
=======
    // There are integration tests that rely on this message (they look for "EndBootstrapSequence:" in the logs)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/DatabusFileLoggingConsumer.java;<<<<<<< MINE
    //System.out.println(stage + ": " + info);
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/ClusterFileLoggingClient.java;<<<<<<< MINE
			DatabusRegistration reg = 
				client.registerCluster(cluster, 
						               createConsumerFactory(cluster,_valueDumpFile), 
						               createServerSideFactory(cluster), 
						               createPartitionListener(cluster,_eventDumpFile), 
=======
			DatabusRegistration reg = client.registerCluster(cluster,
						               createConsumerFactory(cluster, _valueDumpFile, _eventDumpFile),
						               createServerSideFactory(cluster),
						               createPartitionListener(cluster),
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/ClusterFileLoggingClient.java;<<<<<<< MINE
	protected abstract DbusClusterConsumerFactory createConsumerFactory(String cluster, String valueFilePrefix);
=======
	protected abstract DbusClusterConsumerFactory createConsumerFactory(String cluster,
	                                                                    String valueFilePrefix,
	                                                                    String eventDumpPrefix);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/generic/ClusterFileLoggingClient.java;<<<<<<< MINE
	protected abstract DbusPartitionListener createPartitionListener(String cluster, String eventDumpPrefix);
=======
	protected abstract DbusPartitionListener createPartitionListener(String cluster);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/monitoring/RegistrationStatsInfo.java;<<<<<<< MINE
	  setParentRegId(reg.getParentRegId());
=======
	  setParentRegId(null != reg.getParentRegistration() ? reg.getParentRegistration().getId() : null);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/RelayDispatcher.java;<<<<<<< MINE
      return createOnlineConsumptionCheckpoint(_lastWindowScn, curState, event);
=======
      return createOnlineConsumptionCheckpoint(_lastWindowScn, _lastEowTsNsecs, curState, event);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  // this instance is not really used, TODO get rid of it
  protected final LoggingConsumer _loggingListener;
=======
  protected final LoggingConsumer _loggingConsumer;  // this instance is not really used, TODO get rid of it
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
    _loggingListener = new LoggingConsumer(_clientStaticConfig.getLoggingListener());
=======
    _loggingConsumer = new LoggingConsumer(_clientStaticConfig.getLoggingListener());
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  public synchronized void registerDatabusStreamListener(
		  					DatabusStreamConsumer[] listeners,
                            List<String> sources,
                            DbusKeyCompositeFilterConfig filterConfig)
          throws DatabusClientException
  {
	  List<DatabusStreamConsumer> listenersList = Arrays.asList(listeners);
	  List<SelectingDatabusCombinedConsumer> sdccListenersList =
			  SelectingDatabusCombinedConsumerFactory.convertListOfStreamConsumers(listenersList);
	  List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
	  for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
	  {
		  dccListenersList.add(sdcc);
	  }

	  DatabusV2ConsumerRegistration consumerReg =
	      new DatabusV2ConsumerRegistration(dccListenersList, sources, filterConfig);

	  registerDatabusListener(consumerReg, _relayGroups, getRelayGroupStreamConsumers(),
	                          DatabusSubscription.createSubscriptionList(sources));
=======
  public synchronized void registerDatabusStreamListener(DatabusStreamConsumer[] listeners,
                                                         List<String> sources,
                                                         DbusKeyCompositeFilterConfig filterConfig)
  throws DatabusClientException
  {
    List<DatabusStreamConsumer> listenersList = Arrays.asList(listeners);
    List<SelectingDatabusCombinedConsumer> sdccListenersList =
        SelectingDatabusCombinedConsumerFactory.convertListOfStreamConsumers(listenersList);
    List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
    for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
    {
      dccListenersList.add(sdcc);
    }

    DatabusV2ConsumerRegistration consumerReg =
        new DatabusV2ConsumerRegistration(dccListenersList, sources, filterConfig);

    registerDatabusListener(consumerReg, _relayGroups, getRelayGroupStreamConsumers(),
                            DatabusSubscription.createSubscriptionList(sources));
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
		List<DatabusBootstrapConsumer> listenersList = Arrays.asList(listeners);
		List<SelectingDatabusCombinedConsumer> sdccListenersList =
				SelectingDatabusCombinedConsumerFactory.convertListOfBootstrapConsumers(listenersList);
		List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
		for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
		{
			dccListenersList.add(sdcc);
		}

		DatabusV2ConsumerRegistration consumerReg =
				new DatabusV2ConsumerRegistration(dccListenersList, sources, filter);

		registerDatabusListener(consumerReg, _relayGroups, getRelayGroupBootstrapConsumers(),
		                        DatabusSubscription.createSubscriptionList(sources));
=======
    List<DatabusBootstrapConsumer> listenersList = Arrays.asList(listeners);
    List<SelectingDatabusCombinedConsumer> sdccListenersList =
        SelectingDatabusCombinedConsumerFactory.convertListOfBootstrapConsumers(listenersList);
    List<DatabusCombinedConsumer> dccListenersList = new ArrayList<DatabusCombinedConsumer>();
    for(SelectingDatabusCombinedConsumer sdcc: sdccListenersList)
    {
      dccListenersList.add(sdcc);
    }

    DatabusV2ConsumerRegistration consumerReg =
        new DatabusV2ConsumerRegistration(dccListenersList, sources, filter);

    registerDatabusListener(consumerReg, _relayGroups, getRelayGroupBootstrapConsumers(),
                            DatabusSubscription.createSubscriptionList(sources));
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
=======
  // TODO:  deprecate this?  returned instance is useless, but RuntimeConfigBuilder needs a managed instance...
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
    return _loggingListener;
=======
    return _loggingConsumer;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
   *
   * @author pganti
   *
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
  /**
   *
   * @author pganti
   *
   */
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusHttpClientImpl.java;<<<<<<< MINE
   *
   * @author pganti
   *
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
=======
  protected long _lastEowTsNsecs = -1;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
=======
              _lastEowTsNsecs = nextEvent.timestampInNanos();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
            LOG.info("skipping empty window: " + nextEvent.sequence());
=======
            if (LOG.isDebugEnabled())
            {
              LOG.debug("skipping empty window: " + nextEvent.sequence());
            }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
=======
                //the first window (startEvents()) can have a eop whose sequence() is non-zero but timestamp 0 e.g. in chained relay .
                //The reason is that the eop's timestamp is the max timestamp of all data events seen so far.
                if (nextEvent.timestampInNanos() > 0)
                {
                  _lastEowTsNsecs = nextEvent.timestampInNanos();
                }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
  public static Checkpoint createOnlineConsumptionCheckpoint(long lastCompleteWindowScn,DispatcherState curState, DbusEvent event)
=======
  public static Checkpoint createOnlineConsumptionCheckpoint(long lastCompleteWindowScn, long lastEowTsNsecs, DispatcherState curState, DbusEvent event)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
      //For online consumption ; this means that a complete event window hasn't been read yet.
=======
      //TODO: What does this mean? "For online consumption ; this means that a complete event window hasn't been read yet."
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
=======
            // TODO: According to DbusEventFactory.createCheckpointEvent, event,sequence() is always 0!
            // Is this even executed? If we send a checkpoint event from the relay, we could be screwed!
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
=======
              // TODO Can't do this math for timestamp. See DDSDBUS-3149
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/GenericDispatcher.java;<<<<<<< MINE
      return Checkpoint.createOnlineConsumptionCheckpoint(windowScn);
=======
      return Checkpoint.createOnlineConsumptionCheckpoint(windowScn, lastEowTsNsecs);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusSourcesConnection.java;<<<<<<< MINE
=======
import com.linkedin.databus.client.consumer.LoggingConsumer;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusSourcesConnection.java;<<<<<<< MINE
=======
import com.linkedin.databus.core.DatabusRuntimeException;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusSourcesConnection.java;<<<<<<< MINE
public class DatabusSourcesConnection {
	public static final int MAX_QUEUED_MESSAGES = 10;
	public static final long MESSAGE_QUEUE_POLL_TIMEOUT_MS = 100;
	public static final int MAX_CONNECT_RETRY_NUM = 3;
	public static final long CONNECT_TIMEOUT_MS = 100;
	public static final long REGISTER_TIMEOUT_MS = 1000;

	public final Logger _log;
	private final String _name;
	private final DatabusSourcesConnection.StaticConfig _connectionConfig;
	private final List<DatabusSubscription> _subscriptions;
	private final RelayPullThread _relayPuller;
	private final GenericDispatcher<DatabusCombinedConsumer> _relayDispatcher;
	private final BootstrapPullThread _bootstrapPuller;
	private final GenericDispatcher<DatabusCombinedConsumer> _bootstrapDispatcher;
	private final DbusEventBuffer _dataEventsBuffer;
	private final DbusEventBuffer _bootstrapEventsBuffer;
	private final ExecutorService _ioThreadPool;
	private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
	private final ContainerStatisticsCollector _containerStatisticsCollector;
	/** Statistics collector about databus events */
	private final DbusEventsStatisticsCollector _inboundEventsStatsCollector;
	private final DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;

	private final HttpStatisticsCollector _relayCallsStatsCollector;
	private final HttpStatisticsCollector _localRelayCallsStatsCollector;
	private final DatabusRelayConnectionFactory _relayConnFactory;
	private final DatabusBootstrapConnectionFactory _bootstrapConnFactory;
	private final List<DatabusV2ConsumerRegistration> _relayRegistrations;
	private final ConsumerCallbackStats _relayConsumerStats;
	private final ConsumerCallbackStats _bootstrapConsumerStats;
	private final NannyRunnable _nannyRunnable;
	private final DbusEventFactory _eventFactory;
	private final ConnectionStateFactory _connStateFactory;

	private final List<DatabusV2ConsumerRegistration> _bootstrapRegistrations;
	private final SourcesConnectionStatus _connectionStatus;

	private UncaughtExceptionTrackingThread _relayPullerThread;
	private UncaughtExceptionTrackingThread _relayDispatcherThread;
	private UncaughtExceptionTrackingThread _bootstrapPullerThread;
	private UncaughtExceptionTrackingThread _bootstrapDispatcherThread;
	private final Thread _messageQueuesMonitorThread;
	private Thread _nannyThread;
	private ExecutorService _consumerCallbackExecutor;

	private final boolean _isBootstrapEnabled;
	private final RegistrationId _registrationId;
	private ReentrantLock _v3BootstrapLock = null;

	public ExecutorService getIoThreadPool() {
		return _ioThreadPool;
	}

    public DatabusSourcesConnection(StaticConfig connConfig,
       List<DatabusSubscription> subscriptions,
       Set<ServerInfo> relays,
       Set<ServerInfo> bootstrapServices,
       List<DatabusV2ConsumerRegistration> registrations,
       List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
       DbusEventBuffer dataEventsBuffer,
       DbusEventBuffer bootstrapEventsBuffer,
       ExecutorService ioThreadPool,
       ContainerStatisticsCollector containerStatsCollector,
       DbusEventsStatisticsCollector inboundEventsStatsCollector,
       DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
       ConsumerCallbackStats relayCallbackStats,
       ConsumerCallbackStats bootstrapCallbackStats,
       CheckpointPersistenceProvider checkpointPersistenceProvider,
       DatabusRelayConnectionFactory relayConnFactory,
       DatabusBootstrapConnectionFactory bootstrapConnFactory,
       HttpStatisticsCollector relayCallsStatsCollector,
       RegistrationId registrationId,
       DatabusHttpClientImpl serverHandle,
       DbusEventFactory eventFactory)
    {
      this(connConfig,
          subscriptions,
          relays,
          bootstrapServices,
          registrations,
          bootstrapRegistrations,
          dataEventsBuffer,
          bootstrapEventsBuffer,
          ioThreadPool,
          containerStatsCollector,
          inboundEventsStatsCollector,
          bootstrapEventsStatsCollector,
          relayCallbackStats,
          bootstrapCallbackStats,
          checkpointPersistenceProvider,
          relayConnFactory,
          bootstrapConnFactory,
          relayCallsStatsCollector,
          registrationId,
          serverHandle,
          registrationId != null ? registrationId.toString() : null,
          eventFactory,
          null,
    null);
    }

	public DatabusSourcesConnection(StaticConfig connConfig,
					List<DatabusSubscription> subscriptions,
					Set<ServerInfo> relays,
					Set<ServerInfo> bootstrapServices,
					List<DatabusV2ConsumerRegistration> registrations,
					List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
					DbusEventBuffer dataEventsBuffer,
					DbusEventBuffer bootstrapEventsBuffer,
					ExecutorService ioThreadPool,
					ContainerStatisticsCollector containerStatsCollector,
					DbusEventsStatisticsCollector inboundEventsStatsCollector,
					DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
					ConsumerCallbackStats relayCallbackStats,
					ConsumerCallbackStats bootstrapCallbackStats,
					CheckpointPersistenceProvider checkpointPersistenceProvider,
					DatabusRelayConnectionFactory relayConnFactory,
					DatabusBootstrapConnectionFactory bootstrapConnFactory,
					HttpStatisticsCollector relayCallsStatsCollector,
					RegistrationId registrationId,
					DatabusHttpClientImpl serverHandle,
					DbusEventFactory eventFactory,
					ConnectionStateFactory connStateFactory)
	{
		this(connConfig,
			subscriptions,
			relays,
			bootstrapServices,
			registrations,
			bootstrapRegistrations,
			dataEventsBuffer,
			bootstrapEventsBuffer,
			ioThreadPool,
			containerStatsCollector,
			inboundEventsStatsCollector,
			bootstrapEventsStatsCollector,
			relayCallbackStats,
			bootstrapCallbackStats,
			checkpointPersistenceProvider,
			relayConnFactory,
			bootstrapConnFactory,
			relayCallsStatsCollector,
			registrationId,
			serverHandle,
			registrationId != null ? registrationId.toString() : null,
			eventFactory,
			null,
			connStateFactory);
	}

	public DatabusSourcesConnection(
			DatabusSourcesConnection.StaticConfig connConfig,
			List<DatabusSubscription> subscriptions, Set<ServerInfo> relays,
			Set<ServerInfo> bootstrapServices,
			List<DatabusV2ConsumerRegistration> registrations,
			List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
			DbusEventBuffer dataEventsBuffer,
			DbusEventBuffer bootstrapEventsBuffer,
			ExecutorService ioThreadPool,
			ContainerStatisticsCollector containerStatsCollector,
			DbusEventsStatisticsCollector inboundEventsStatsCollector,
			DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
			ConsumerCallbackStats relayCallbackStats,
			ConsumerCallbackStats bootstrapCallbackStats,
			CheckpointPersistenceProvider checkpointPersistenceProvider,
			DatabusRelayConnectionFactory relayConnFactory,
			DatabusBootstrapConnectionFactory bootstrapConnFactory,
			HttpStatisticsCollector relayCallsStatsCollector,
			RegistrationId registrationId, DatabusHttpClientImpl serverHandle,
			String connRawId, // Unique Name to be used for generating mbean and logger names.
			DbusEventFactory eventFactory,
            ReentrantLock v3BootstrapLock,
			ConnectionStateFactory connStateFactory
			)
	{
		_eventFactory = eventFactory;
		_connectionConfig = connConfig;
		_dataEventsBuffer = dataEventsBuffer;
		_bootstrapEventsBuffer = bootstrapEventsBuffer;
		_subscriptions = subscriptions;
		_ioThreadPool = ioThreadPool;
		_checkpointPersistenceProvider = checkpointPersistenceProvider;
		_containerStatisticsCollector = containerStatsCollector;
		_inboundEventsStatsCollector = inboundEventsStatsCollector;
		_bootstrapEventsStatsCollector = bootstrapEventsStatsCollector;
		_relayConsumerStats = relayCallbackStats;
		_bootstrapConsumerStats = bootstrapCallbackStats;
		_relayConnFactory = relayConnFactory;
		_bootstrapConnFactory = bootstrapConnFactory;
		_relayRegistrations = registrations;
		_bootstrapRegistrations = bootstrapRegistrations;
		_relayCallsStatsCollector = relayCallsStatsCollector;
		_localRelayCallsStatsCollector = null != relayCallsStatsCollector ? relayCallsStatsCollector
				.createForClientConnection(toString()) : null;
		_registrationId = registrationId;
		_name = composeName(connRawId); // will be used as MBean name for
											// example
		_log = Logger.getLogger(DatabusSourcesConnection.class.getName()
				+ ".srcconn-" + _name);
		_connectionStatus = new SourcesConnectionStatus();
		_v3BootstrapLock = v3BootstrapLock;
		_connStateFactory = connStateFactory;

		List<DbusKeyCompositeFilterConfig> relayFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();
		List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();

		if (null != registrations) {
			for (DatabusV2ConsumerRegistration reg : registrations) {
				DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

				if (null != conf)
					relayFilterConfigs.add(conf);
			}
		}

		if (null != bootstrapRegistrations) {
			for (DatabusV2ConsumerRegistration reg : bootstrapRegistrations) {
				DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

				if (null != conf)
					bootstrapFilterConfigs.add(conf);
			}
		}

		int consumerParallelism = connConfig.getConsumerParallelism();
		if (1 == consumerParallelism) {
			_consumerCallbackExecutor = Executors
					.newSingleThreadExecutor(new NamedThreadFactory("callback"));
		} else {
			_consumerCallbackExecutor = Executors.newFixedThreadPool(
					consumerParallelism, new NamedThreadFactory("callback"));
		}

		LoggingConsumer loggingConsumer = null;
		if (serverHandle != null)
		{
		  try
		  {
		    // we intentionally don't use serverHandle.getLoggingListener(); LoggingConsumer
		    // isn't thread-safe, so we need one instance per connection
		    loggingConsumer = new LoggingConsumer(serverHandle.getClientStaticConfig().getLoggingListener());
		  }
		  catch (InvalidConfigException e)
		  {
		    throw new DatabusRuntimeException(e);  // alternatively, declare config exception and let it go
		  }
		}

		MultiConsumerCallback relayAsyncCallback = new MultiConsumerCallback(
				(null != _relayRegistrations ? _relayRegistrations
						: new ArrayList<DatabusV2ConsumerRegistration>()),
				_consumerCallbackExecutor,
				connConfig.getConsumerTimeBudgetMs(),
				new StreamConsumerCallbackFactory(), _relayConsumerStats,
				loggingConsumer);

		MultiConsumerCallback bootstrapAsyncCallback = new MultiConsumerCallback(
				(null != _bootstrapRegistrations ? _bootstrapRegistrations
						: new ArrayList<DatabusV2ConsumerRegistration>()),
				_consumerCallbackExecutor,
				connConfig.getBstConsumerTimeBudgetMs(),
				new BootstrapConsumerCallbackFactory(), _bootstrapConsumerStats,
				loggingConsumer);

		if (_bootstrapEventsBuffer != null) {
			_bootstrapPuller = new BootstrapPullThread(_name
					+ "-BootstrapPuller", this, _bootstrapEventsBuffer, _connStateFactory,
					bootstrapServices, bootstrapFilterConfigs,
					connConfig.getPullerUtilizationPct(),
					ManagementFactory.getPlatformMBeanServer(),
					_eventFactory, _v3BootstrapLock);
		} else {
			_bootstrapPuller = null;
		}

		_relayDispatcher = new RelayDispatcher(_name + "-RelayDispatcher",
				connConfig, getSubscriptions(), checkpointPersistenceProvider,
				dataEventsBuffer, relayAsyncCallback, _bootstrapPuller,
				ManagementFactory.getPlatformMBeanServer(), serverHandle,
				_registrationId);

		_relayPuller = new RelayPullThread(_name + "-RelayPuller", this,
				_dataEventsBuffer, _connStateFactory, relays, relayFilterConfigs,
				connConfig.getConsumeCurrent(),
				connConfig.isReadLatestScnOnErrorEnabled(),
				connConfig.getPullerUtilizationPct(),
				connConfig.getNoEventsConnectionResetTimeSec(),
				ManagementFactory.getPlatformMBeanServer(),
 				_eventFactory);

		_relayPuller.enqueueMessage(LifecycleMessage.createStartMessage());

		if (_bootstrapEventsBuffer != null) {
			_bootstrapDispatcher = new BootstrapDispatcher(_name
					+ "-BootstrapDispatcher", connConfig, getSubscriptions(),
					checkpointPersistenceProvider, bootstrapEventsBuffer,
					bootstrapAsyncCallback, _relayPuller,
					ManagementFactory.getPlatformMBeanServer(), serverHandle,
					_registrationId);
		} else {
			_bootstrapDispatcher = null;
		}

		_messageQueuesMonitorThread = new Thread(new MessageQueuesMonitor());
		_messageQueuesMonitorThread.setDaemon(true);

		_isBootstrapEnabled = !(null == getBootstrapServices()
				|| getBootstrapServices().isEmpty()
				|| null == getBootstrapRegistrations()
				|| 0 == getBootstrapRegistrations().size() || _bootstrapEventsBuffer == null);

		_log.info(" Is Service Empty : "
				+ (null == getBootstrapServices() || getBootstrapServices()
						.isEmpty()));
		_log.info(" Is Consumers Empty : "
				+ (null == getBootstrapRegistrations() || 0 == getBootstrapRegistrations()
						.size()));

		_nannyRunnable = new NannyRunnable();
	}

	// figure out name for the connection - to be used in mbean
	private String composeName(String id) {
		StringBuilder shortSourcesListBuilder = new StringBuilder();
		String separatorChar = "[";
		for (DatabusSubscription sub : getSubscriptions()) {
			shortSourcesListBuilder.append(separatorChar);
			PhysicalPartition p = sub.getPhysicalPartition();
			String sourceName = "AnySource";
			LogicalSource source = sub.getLogicalPartition().getSource();
			if (!source.isAllSourcesWildcard()) {
				sourceName = source.getName();
				int lastDotIdx = sourceName.lastIndexOf('.');
				if (lastDotIdx >= 0)
					sourceName = sourceName.substring(lastDotIdx + 1);
			}
			String partString = "AnyPPart_";
			if (!p.isAnyPartitionWildcard()) {
				partString = p.getId() + "_";
			}
			shortSourcesListBuilder.append(partString + sourceName);
			separatorChar = "_";
		}
		shortSourcesListBuilder.append(']');
		String shortSourcesList = shortSourcesListBuilder.toString();

		return "conn" + shortSourcesList
				+ (id == null ? "" : "_" + id);
	}

	public boolean isBootstrapEnabled() {
		return _isBootstrapEnabled;
	}

	public void start() {
		_log.info("Starting http relay connection for sources:"
				+ _subscriptions);
		_nannyThread = new Thread(_nannyRunnable, _name + ".Nanny");
		_nannyThread.setDaemon(true);

		_connectionStatus.start();
		_messageQueuesMonitorThread.start();
		_nannyThread.start();
	}

	public boolean isRunning() {
		boolean pullThreadRunning = _relayPullerThread.isAlive();
		boolean dispatcherThreadRunning = _relayDispatcherThread.isAlive();

		if (!pullThreadRunning)
			_log.info("Pull thread is DEAD!");
		if (null != _relayPullerThread.getLastException()) {
			_log.error(" Reason: "
					+ _relayPullerThread.getLastException().getMessage(),
					_relayPullerThread.getLastException());
		}

		if (!dispatcherThreadRunning)
			_log.info("Dispatch thread is DEAD!");
		if (null != _relayDispatcherThread.getLastException()) {
			_log.error(" Reason: "
					+ _relayDispatcherThread.getLastException().getMessage(),
					_relayDispatcherThread.getLastException());
		}

		return pullThreadRunning && dispatcherThreadRunning;
	}

	public void await() {
		boolean running = isRunning();
		_log.info("waiting for shutdown: " + running);
		while (running) {
			_relayPuller.awaitShutdown();
			_relayDispatcher.awaitShutdown();

			running = isRunning();
			_log.info("waiting for shutdown: " + running);
		}
	}

	public void stop() {
		_log.info("Stopping ... :" + isRunning());

		if (null != _relayConsumerStats)
			_relayConsumerStats.unregisterAsMbean();
		if (null != _bootstrapConsumerStats)
			_bootstrapConsumerStats.unregisterAsMbean();
		_connectionStatus.shutdown();

	    if (_relayPullerThread.isAlive())
	    {
	      _log.info("shutting down relay puller ...");
	      _relayPuller.awaitShutdown();
	    }
	    if (_relayDispatcherThread.isAlive())
	    {
=======
public class DatabusSourcesConnection
{
  public static final int MAX_QUEUED_MESSAGES = 10;
  public static final long MESSAGE_QUEUE_POLL_TIMEOUT_MS = 100;
  public static final int MAX_CONNECT_RETRY_NUM = 3;
  public static final long CONNECT_TIMEOUT_MS = 100;
  public static final long REGISTER_TIMEOUT_MS = 1000;

  public final Logger _log;
  private final String _name;
  private final DatabusSourcesConnection.StaticConfig _connectionConfig;
  private final List<DatabusSubscription> _subscriptions;
  private final RelayPullThread _relayPuller;
  private final GenericDispatcher<DatabusCombinedConsumer> _relayDispatcher;
  private final BootstrapPullThread _bootstrapPuller;
  private final GenericDispatcher<DatabusCombinedConsumer> _bootstrapDispatcher;
  private final DbusEventBuffer _dataEventsBuffer;
  private final DbusEventBuffer _bootstrapEventsBuffer;
  private final ExecutorService _ioThreadPool;
  private final CheckpointPersistenceProvider _checkpointPersistenceProvider;
  private final ContainerStatisticsCollector _containerStatisticsCollector;
  /** Statistics collector about databus events */
  private final DbusEventsStatisticsCollector _inboundEventsStatsCollector;
  private final DbusEventsStatisticsCollector _bootstrapEventsStatsCollector;

  private final HttpStatisticsCollector _relayCallsStatsCollector;
  private final HttpStatisticsCollector _localRelayCallsStatsCollector;
  private final DatabusRelayConnectionFactory _relayConnFactory;
  private final DatabusBootstrapConnectionFactory _bootstrapConnFactory;
  private final List<DatabusV2ConsumerRegistration> _relayRegistrations;
  private final ConsumerCallbackStats _relayConsumerStats;
  private final ConsumerCallbackStats _bootstrapConsumerStats;
  private final UnifiedClientStats _unifiedClientStats;
  private final NannyRunnable _nannyRunnable;
  private final DbusEventFactory _eventFactory;
  private final ConnectionStateFactory _connStateFactory;

  private final List<DatabusV2ConsumerRegistration> _bootstrapRegistrations;
  private final SourcesConnectionStatus _connectionStatus;

  private UncaughtExceptionTrackingThread _relayPullerThread;
  private UncaughtExceptionTrackingThread _relayDispatcherThread;
  private UncaughtExceptionTrackingThread _bootstrapPullerThread;
  private UncaughtExceptionTrackingThread _bootstrapDispatcherThread;
  private final Thread _messageQueuesMonitorThread;
  private Thread _nannyThread;
  private ExecutorService _consumerCallbackExecutor;

  private final boolean _isBootstrapEnabled;
  private final RegistrationId _registrationId;
  private ReentrantLock _v3BootstrapLock = null;

  public ExecutorService getIoThreadPool()
  {
    return _ioThreadPool;
  }

  public DatabusSourcesConnection(StaticConfig connConfig,
                                  List<DatabusSubscription> subscriptions,
                                  Set<ServerInfo> relays,
                                  Set<ServerInfo> bootstrapServices,
                                  List<DatabusV2ConsumerRegistration> registrations,
                                  List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
                                  DbusEventBuffer dataEventsBuffer,
                                  DbusEventBuffer bootstrapEventsBuffer,
                                  ExecutorService ioThreadPool,
                                  ContainerStatisticsCollector containerStatsCollector,
                                  DbusEventsStatisticsCollector inboundEventsStatsCollector,
                                  DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
                                  ConsumerCallbackStats relayCallbackStats,
                                  ConsumerCallbackStats bootstrapCallbackStats,
                                  UnifiedClientStats unifiedClientStats,
                                  CheckpointPersistenceProvider checkpointPersistenceProvider,
                                  DatabusRelayConnectionFactory relayConnFactory,
                                  DatabusBootstrapConnectionFactory bootstrapConnFactory,
                                  HttpStatisticsCollector relayCallsStatsCollector,
                                  RegistrationId registrationId,
                                  DatabusHttpClientImpl serverHandle,
                                  DbusEventFactory eventFactory,
                                  ConnectionStateFactory connStateFactory)
  {
    this(connConfig,
         subscriptions,
         relays,
         bootstrapServices,
         registrations,
         bootstrapRegistrations,
         dataEventsBuffer,
         bootstrapEventsBuffer,
         ioThreadPool,
         containerStatsCollector,
         inboundEventsStatsCollector,
         bootstrapEventsStatsCollector,
         relayCallbackStats,
         bootstrapCallbackStats,
         unifiedClientStats,
         checkpointPersistenceProvider,
         relayConnFactory,
         bootstrapConnFactory,
         relayCallsStatsCollector,
         registrationId,
         serverHandle,
         registrationId != null ? registrationId.toString() : null,
         eventFactory,
         null,
         connStateFactory);
  }

  public DatabusSourcesConnection(DatabusSourcesConnection.StaticConfig connConfig,
                                  List<DatabusSubscription> subscriptions,
                                  Set<ServerInfo> relays,
                                  Set<ServerInfo> bootstrapServices,
                                  List<DatabusV2ConsumerRegistration> registrations,
                                  List<DatabusV2ConsumerRegistration> bootstrapRegistrations,
                                  DbusEventBuffer dataEventsBuffer,
                                  DbusEventBuffer bootstrapEventsBuffer,
                                  ExecutorService ioThreadPool,
                                  ContainerStatisticsCollector containerStatsCollector,
                                  DbusEventsStatisticsCollector inboundEventsStatsCollector,
                                  DbusEventsStatisticsCollector bootstrapEventsStatsCollector,
                                  ConsumerCallbackStats relayCallbackStats,
                                  ConsumerCallbackStats bootstrapCallbackStats,
                                  UnifiedClientStats unifiedClientStats,
                                  CheckpointPersistenceProvider checkpointPersistenceProvider,
                                  DatabusRelayConnectionFactory relayConnFactory,
                                  DatabusBootstrapConnectionFactory bootstrapConnFactory,
                                  HttpStatisticsCollector relayCallsStatsCollector,
                                  RegistrationId registrationId, DatabusHttpClientImpl serverHandle,
                                  String connRawId, // Unique Name to be used for generating mbean and logger names.
                                  DbusEventFactory eventFactory,
                                  ReentrantLock v3BootstrapLock,
                                  ConnectionStateFactory connStateFactory)
  {
    _eventFactory = eventFactory;
    _connectionConfig = connConfig;
    _dataEventsBuffer = dataEventsBuffer;
    _bootstrapEventsBuffer = bootstrapEventsBuffer;
    _subscriptions = subscriptions;
    _ioThreadPool = ioThreadPool;
    _checkpointPersistenceProvider = checkpointPersistenceProvider;
    _containerStatisticsCollector = containerStatsCollector;
    _inboundEventsStatsCollector = inboundEventsStatsCollector;
    _bootstrapEventsStatsCollector = bootstrapEventsStatsCollector;
    _relayConsumerStats = relayCallbackStats;
    _bootstrapConsumerStats = bootstrapCallbackStats;
    _unifiedClientStats = unifiedClientStats;
    _relayConnFactory = relayConnFactory;
    _bootstrapConnFactory = bootstrapConnFactory;
    _relayRegistrations = registrations;
    _bootstrapRegistrations = bootstrapRegistrations;
    _relayCallsStatsCollector = relayCallsStatsCollector;
    _localRelayCallsStatsCollector = null != relayCallsStatsCollector ?
        relayCallsStatsCollector.createForClientConnection(toString()) : null;
    _registrationId = registrationId;
    _name = composeName(connRawId); // will be used as MBean name for
                      // example
    _log = Logger.getLogger(DatabusSourcesConnection.class.getName() + ".srcconn-" + _name);
    _connectionStatus = new SourcesConnectionStatus();
    _v3BootstrapLock = v3BootstrapLock;
    _connStateFactory = connStateFactory;

    List<DbusKeyCompositeFilterConfig> relayFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();
    List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs = new ArrayList<DbusKeyCompositeFilterConfig>();

    if (null != registrations) {
      for (DatabusV2ConsumerRegistration reg : registrations) {
        DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

        if (null != conf)
          relayFilterConfigs.add(conf);
      }
    }

    if (null != bootstrapRegistrations) {
      for (DatabusV2ConsumerRegistration reg : bootstrapRegistrations) {
        DbusKeyCompositeFilterConfig conf = reg.getFilterConfig();

        if (null != conf)
          bootstrapFilterConfigs.add(conf);
      }
    }

    int consumerParallelism = connConfig.getConsumerParallelism();
    if (1 == consumerParallelism) {
      _consumerCallbackExecutor = Executors
          .newSingleThreadExecutor(new NamedThreadFactory("callback"));
    } else {
      _consumerCallbackExecutor = Executors.newFixedThreadPool(
          consumerParallelism, new NamedThreadFactory("callback"));
    }

    LoggingConsumer loggingConsumer = null;
    if (serverHandle != null)
    {
      try
      {
        // we intentionally don't use serverHandle.getLoggingListener(); LoggingConsumer
        // isn't thread-safe, so we need one instance per connection
        loggingConsumer = new LoggingConsumer(serverHandle.getClientStaticConfig().getLoggingListener());
      }
      catch (InvalidConfigException e)
      {
        throw new DatabusRuntimeException(e);  // alternatively:  declare InvalidConfigException, let it go
      }
    }

    MultiConsumerCallback relayAsyncCallback =
        new MultiConsumerCallback((null != _relayRegistrations) ?
                                      _relayRegistrations :
                                      new ArrayList<DatabusV2ConsumerRegistration>(),
                                  _consumerCallbackExecutor,
                                  connConfig.getConsumerTimeBudgetMs(),
                                  new StreamConsumerCallbackFactory(_relayConsumerStats,
                                                                    _unifiedClientStats),
                                  _relayConsumerStats,
                                  _unifiedClientStats,
                                  loggingConsumer);

    MultiConsumerCallback bootstrapAsyncCallback =
        new MultiConsumerCallback((null != _bootstrapRegistrations) ?
                                      _bootstrapRegistrations :
                                      new ArrayList<DatabusV2ConsumerRegistration>(),
                                  _consumerCallbackExecutor,
                                  connConfig.getBstConsumerTimeBudgetMs(),
                                  new BootstrapConsumerCallbackFactory(_bootstrapConsumerStats,
                                                                       _unifiedClientStats),
                                  _bootstrapConsumerStats,
                                  _unifiedClientStats,
                                  loggingConsumer);

    if (_bootstrapEventsBuffer != null) {
      _bootstrapPuller = new BootstrapPullThread(_name
          + "-BootstrapPuller", this, _bootstrapEventsBuffer, _connStateFactory,
          bootstrapServices, bootstrapFilterConfigs,
          connConfig.getPullerUtilizationPct(),
          ManagementFactory.getPlatformMBeanServer(),
          _eventFactory, _v3BootstrapLock);
    } else {
      _bootstrapPuller = null;
    }

    _relayDispatcher = new RelayDispatcher(_name + "-RelayDispatcher",
        connConfig, getSubscriptions(), checkpointPersistenceProvider,
        dataEventsBuffer, relayAsyncCallback, _bootstrapPuller,
        ManagementFactory.getPlatformMBeanServer(), serverHandle,
        _registrationId);

    _relayPuller = new RelayPullThread(_name + "-RelayPuller", this,
        _dataEventsBuffer, _connStateFactory, relays, relayFilterConfigs,
        connConfig.getConsumeCurrent(),
        connConfig.isReadLatestScnOnErrorEnabled(),
        connConfig.getPullerUtilizationPct(),
        connConfig.getNoEventsConnectionResetTimeSec(),
        ManagementFactory.getPlatformMBeanServer(),
        _eventFactory);

    _relayPuller.enqueueMessage(LifecycleMessage.createStartMessage());

    if (_bootstrapEventsBuffer != null) {
      _bootstrapDispatcher = new BootstrapDispatcher(_name
          + "-BootstrapDispatcher", connConfig, getSubscriptions(),
          checkpointPersistenceProvider, bootstrapEventsBuffer,
          bootstrapAsyncCallback, _relayPuller,
          ManagementFactory.getPlatformMBeanServer(), serverHandle,
          _registrationId);
    } else {
      _bootstrapDispatcher = null;
    }

    _messageQueuesMonitorThread = new Thread(new MessageQueuesMonitor());
    _messageQueuesMonitorThread.setDaemon(true);

    _isBootstrapEnabled = !(null == getBootstrapServices()
        || getBootstrapServices().isEmpty()
        || null == getBootstrapRegistrations()
        || 0 == getBootstrapRegistrations().size() || _bootstrapEventsBuffer == null);

    _log.info(" Is Service Empty : "
        + (null == getBootstrapServices() || getBootstrapServices()
            .isEmpty()));
    _log.info(" Is Consumers Empty : "
        + (null == getBootstrapRegistrations() || 0 == getBootstrapRegistrations()
            .size()));

    _nannyRunnable = new NannyRunnable();
  }

  // figure out name for the connection - to be used in mbean
  private String composeName(String id) {
    StringBuilder shortSourcesListBuilder = new StringBuilder();
    String separatorChar = "[";
    for (DatabusSubscription sub : getSubscriptions()) {
      shortSourcesListBuilder.append(separatorChar);
      PhysicalPartition p = sub.getPhysicalPartition();
      String sourceName = "AnySource";
      LogicalSource source = sub.getLogicalPartition().getSource();
      if (!source.isAllSourcesWildcard()) {
        sourceName = source.getName();
        int lastDotIdx = sourceName.lastIndexOf('.');
        if (lastDotIdx >= 0)
          sourceName = sourceName.substring(lastDotIdx + 1);
      }
      String partString = "AnyPPart_";
      if (!p.isAnyPartitionWildcard()) {
        partString = p.getId() + "_";
      }
      shortSourcesListBuilder.append(partString + sourceName);
      separatorChar = "_";
    }
    shortSourcesListBuilder.append(']');
    String shortSourcesList = shortSourcesListBuilder.toString();

    return "conn" + shortSourcesList + (id == null ? "" : "_" + id);
  }

  public boolean isBootstrapEnabled()
  {
    return _isBootstrapEnabled;
  }

  public void start()
  {
    _log.info("Starting http relay connection for sources:"
        + _subscriptions);
    _nannyThread = new Thread(_nannyRunnable, _name + ".Nanny");
    _nannyThread.setDaemon(true);

    _connectionStatus.start();
    _messageQueuesMonitorThread.start();
    _nannyThread.start();
  }

  public boolean isRunning()
  {
    boolean pullThreadRunning = _relayPullerThread.isAlive();
    boolean dispatcherThreadRunning = _relayDispatcherThread.isAlive();

    if (!pullThreadRunning)
      _log.info("Pull thread is DEAD!");
    if (null != _relayPullerThread.getLastException()) {
      _log.error(" Reason: "
          + _relayPullerThread.getLastException().getMessage(),
          _relayPullerThread.getLastException());
    }

    if (!dispatcherThreadRunning)
      _log.info("Dispatch thread is DEAD!");
    if (null != _relayDispatcherThread.getLastException()) {
      _log.error(" Reason: "
          + _relayDispatcherThread.getLastException().getMessage(),
          _relayDispatcherThread.getLastException());
    }

    return pullThreadRunning && dispatcherThreadRunning;
  }

  public void await()
  {
    boolean running = isRunning();
    _log.info("waiting for shutdown: " + running);
    while (running) {
      _relayPuller.awaitShutdown();
      _relayDispatcher.awaitShutdown();

      running = isRunning();
      _log.info("waiting for shutdown: " + running);
    }
  }

  public void stop()
  {
    _log.info("Stopping ... :" + isRunning());

    unregisterMbeans();
    _connectionStatus.shutdown();

      if (_relayPullerThread.isAlive())
      {
        _log.info("shutting down relay puller ...");
        _relayPuller.awaitShutdown();
      }
      if (_relayDispatcherThread.isAlive())
      {
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/main/java/com/linkedin/databus/client/DatabusSourcesConnection.java;<<<<<<< MINE
		if (_isBootstrapEnabled) {
	    	if (_bootstrapDispatcherThread.isAlive())
	    	{
	          _log.info("shutting down bootstrap dispatcher ...");
	    	  _bootstrapDispatcher.awaitShutdown();
	    	}
	    	if (_bootstrapPullerThread.isAlive())
	    	{
	          _log.info("shutting down bootstrap puller ...");
	    	  _bootstrapPuller.awaitShutdown();
	    	}
		}

		_consumerCallbackExecutor.shutdown();

		_log.info("Stopped ... ");
	}

	public List<String> getSourcesNames() {
		return DatabusSubscription.getStrList(_subscriptions);
	}

	public List<DatabusSubscription> getSubscriptions() {
		return _subscriptions;
	}

	public ConsumerCallbackStats getRelayConsumerStats() {
		return _relayConsumerStats;
	}

	public ConsumerCallbackStats getBootstrapConsumerStats() {
		return _bootstrapConsumerStats;
	}

	public static void main(String args[]) throws Exception {
	}

	public DatabusComponentStatus getConnectionStatus() {
		return _connectionStatus;
	}

	public BootstrapPullThread getBootstrapPuller() {
		return _bootstrapPuller;
	}

	public GenericDispatcher<DatabusCombinedConsumer> getBootstrapDispatcher() {
		return _bootstrapDispatcher;
	}

	public CheckpointPersistenceProvider getCheckpointPersistenceProvider() {
		return _checkpointPersistenceProvider;
	}

	public ContainerStatisticsCollector getContainerStatisticsCollector() {
		return _containerStatisticsCollector;
	}

	public Set<ServerInfo> getRelays() {
		return (_relayPuller != null) ? _relayPuller.getServers() : null;
	}

	public Set<ServerInfo> getBootstrapServices() {
		return (_bootstrapPuller != null) ? _bootstrapPuller.getServers()
				: null;
	}

	public DbusEventsStatisticsCollector getInboundEventsStatsCollector() {
		return _inboundEventsStatsCollector;
	}

	public GenericDispatcher<DatabusCombinedConsumer> getRelayDispatcher() {
		return _relayDispatcher;
	}

	public DatabusRelayConnectionFactory getRelayConnFactory() {
		return _relayConnFactory;
	}

	public DatabusBootstrapConnectionFactory getBootstrapConnFactory() {
		return _bootstrapConnFactory;
	}

	public DbusEventBuffer getDataEventsBuffer() {
		return _dataEventsBuffer;
	}

	public DbusEventBuffer getBootstrapEventsBuffer() {
		return _bootstrapEventsBuffer;
	}

	public Checkpoint loadPersistentCheckpoint() {
		if (_checkpointPersistenceProvider != null)
			return _checkpointPersistenceProvider.loadCheckpointV3(
					getSubscriptions(), _registrationId);
		Checkpoint cp = Checkpoint.createFlexibleCheckpoint();
		return cp;
	}

	public List<DatabusV2ConsumerRegistration> getBootstrapRegistrations() {
		return _bootstrapRegistrations;
	}

	public DatabusSourcesConnection.StaticConfig getConnectionConfig() {
		return _connectionConfig;
	}

	public List<DatabusV2ConsumerRegistration> getRelayRegistrations() {
		return _relayRegistrations;
	}

	class NannyRunnable implements Runnable {
		public static final int SLEEP_DURATION_MS = 1000;

		@Override
		public void run() {
			while (getConnectionStatus().getStatus() != DatabusComponentStatus.Status.SHUTDOWN) {
				boolean runShutdown = false;
				if (null != _relayPuller
						&& _relayPuller.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the relay puller is shutdown!");
					runShutdown = true;
				}
				if (null != _relayDispatcher
						&& _relayDispatcher.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the relay dispatcher is shutdown!");
					runShutdown = true;
				}
				if (null != _bootstrapPuller
						&& _bootstrapPuller.getComponentStatus().getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the bootstrap puller is shutdown!");
					runShutdown = true;
				}
				if (null != _bootstrapDispatcher
						&& _bootstrapDispatcher.getComponentStatus()
								.getStatus() == DatabusComponentStatus.Status.SHUTDOWN) {
					_log.error("nanny: detected that the bootstrap dispatcher is shutdown!");
					runShutdown = true;
				}

				if (runShutdown) {
					stop();
				}

				try {
					Thread.sleep(SLEEP_DURATION_MS);
				} catch (InterruptedException e) {
					_log.info("nanny: who woke me up?");
				}
			}
		}

	}

	public class SourcesConnectionStatus extends DatabusComponentStatus {
		public SourcesConnectionStatus() {
			super(DatabusSourcesConnection.this._name);
		}

		@Override
		public void start() {
			super.start();

			_relayPullerThread = new UncaughtExceptionTrackingThread(
					_relayPuller, _relayPuller.getName());
			_relayPullerThread.setDaemon(true);
			_relayPullerThread.start();

			_relayDispatcherThread = new UncaughtExceptionTrackingThread(
					_relayDispatcher, _relayDispatcher.getName());
			_relayDispatcherThread.setDaemon(true);
			_relayDispatcherThread.start();

			if (_isBootstrapEnabled) {
				_bootstrapPullerThread = new UncaughtExceptionTrackingThread(
						_bootstrapPuller, _bootstrapPuller.getName());
				_bootstrapPullerThread.setDaemon(true);
				_bootstrapPullerThread.start();

				_bootstrapDispatcherThread = new UncaughtExceptionTrackingThread(
						_bootstrapDispatcher, _bootstrapDispatcher.getName());
				_bootstrapDispatcherThread.setDaemon(true);
				_bootstrapDispatcherThread.start();
			}
		}

		@Override
		public void shutdown()
		{
		  _log.info("shutting down connection ...");
		  _relayPuller.shutdown();
		  _relayDispatcher.shutdown();
		  if (_bootstrapPuller != null)
		  {
		    _bootstrapPuller.shutdown();
		  }
		  if (_bootstrapDispatcher != null)
		  {
		    _bootstrapDispatcher.shutdown();
		  }

		  _relayPullerThread.interrupt();
		  _relayDispatcherThread.interrupt();

		  if (_isBootstrapEnabled)
		  {
		    _bootstrapPullerThread.interrupt();
		    _bootstrapDispatcherThread.interrupt();
		  }

		  super.shutdown();
		  _nannyThread.interrupt();
		  _log.info("connection shut down.");
		}

		@Override
		public void pause() {
			_relayPuller.enqueueMessage(LifecycleMessage.createPauseMessage());
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createPauseMessage());
			}

			super.pause();
		}

		@Override
		public void resume() {
			_relayPuller.enqueueMessage(LifecycleMessage.createResumeMessage());
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createResumeMessage());
			}

			super.resume();
		}

		@Override
		public void suspendOnError(Throwable cause) {
			_relayPuller.enqueueMessage(LifecycleMessage
					.createSuspendOnErroMessage(cause));
			if (_isBootstrapEnabled) {
				_bootstrapPuller.enqueueMessage(LifecycleMessage
						.createSuspendOnErroMessage(cause));
			}

			super.suspendOnError(cause);
		}
	}

	public static class StaticConfig {
		private final DbusEventBuffer.StaticConfig _eventBuffer;
		private final DbusEventBuffer.StaticConfig _bstEventBuffer;
		private final long _consumerTimeBudgetMs;
		private final long _bstConsumerTimeBudgetMs;
		private final int _consumerParallelism;
		private final double _checkpointThresholdPct;
		private final Range _keyRange;
		private final BackoffTimerStaticConfig _bsPullerRetriesBeforeCkptCleanup;
		private final BackoffTimerStaticConfig _pullerRetries;
		private final BackoffTimerStaticConfig _bstPullerRetries;
		private final BackoffTimerStaticConfig _dispatcherRetries;
		private final BackoffTimerStaticConfig _bstDispatcherRetries;
		private final int _freeBufferThreshold;
		private final boolean _consumeCurrent;
		private final boolean _readLatestScnOnError;
		private final double _pullerBufferUtilizationPct;
		private final int _id;
		private final boolean _enablePullerMessageQueueLogging;
		private final int _numRetriesOnFallOff;
		private final int _noEventsConnectionResetTimeSec;

		public StaticConfig(DbusEventBuffer.StaticConfig eventBuffer,
				DbusEventBuffer.StaticConfig bstEventBuffer,
				long consumerTimeBudgetMs, long bstConsumerTimeBudgetMs, int consumerParallelism,
				double checkpointThresholdPct, Range keyRange,
				BackoffTimerStaticConfig bsPullerRetriesBeforeCkptCleanup,
				BackoffTimerStaticConfig pullerRetries,
				BackoffTimerStaticConfig bstPullerRetries,
				BackoffTimerStaticConfig dispatcherRetries,
				BackoffTimerStaticConfig bstDispatcherRetries,
				int retriesOnFellOff, int freeBufferThreshold,
				boolean consumeCurrent, boolean readLatestScnOnError,
				double pullerBufferUtilizationPct, int id,
				boolean enablePullerMessageQueueLogging,
				int noEventsConnectionResetTimeSec
				) {
			super();
			_eventBuffer = eventBuffer;
			_bstEventBuffer = bstEventBuffer;
			_consumerTimeBudgetMs = consumerTimeBudgetMs;
			_bstConsumerTimeBudgetMs = bstConsumerTimeBudgetMs;
			_consumerParallelism = consumerParallelism;
			_checkpointThresholdPct = checkpointThresholdPct;
			_keyRange = keyRange;
			_bsPullerRetriesBeforeCkptCleanup = bsPullerRetriesBeforeCkptCleanup;
			_pullerRetries = pullerRetries;
			_bstPullerRetries = bstPullerRetries;
			_dispatcherRetries = dispatcherRetries;
			_bstDispatcherRetries = bstDispatcherRetries;
			_numRetriesOnFallOff = retriesOnFellOff;
			_freeBufferThreshold = (freeBufferThreshold > eventBuffer.getReadBufferSize()) ? eventBuffer.getReadBufferSize()/2:freeBufferThreshold;
			_consumeCurrent = consumeCurrent;
			_readLatestScnOnError = readLatestScnOnError;
			_pullerBufferUtilizationPct = pullerBufferUtilizationPct;
			_id = id;
			_enablePullerMessageQueueLogging = enablePullerMessageQueueLogging;
			_noEventsConnectionResetTimeSec = noEventsConnectionResetTimeSec;

		}


		public int getNoEventsConnectionResetTimeSec() {
			return _noEventsConnectionResetTimeSec;
		}
		public DbusEventBuffer.StaticConfig getBstEventBuffer() {
			return _bstEventBuffer;
		}

		public long getBstConsumerTimeBudgetMs() {
			return _bstConsumerTimeBudgetMs;
		}

		public BackoffTimerStaticConfig getBstDispatcherRetries() {
			return _bstDispatcherRetries;
		}

		public boolean getReadLatestScnOnError() {
			return _readLatestScnOnError;
		}

		public boolean isReadLatestScnOnErrorEnabled() {
			return _readLatestScnOnError;
		}

		public double getPullerUtilizationPct() {
			return _pullerBufferUtilizationPct;
		}

		public int getId() {
			return _id;
		}

		public boolean getConsumeCurrent() {
			return _consumeCurrent;
		}

		/** The relay event buffer static configuration */
		public DbusEventBuffer.StaticConfig getEventBuffer() {
			return _eventBuffer;
		}

		/**
		 * Max time in milliseconds that a consumer should use to process an
		 * event before it is considered failed
		 */
		public long getConsumerTimeBudgetMs() {
			return _consumerTimeBudgetMs;
		}

		/**
		 * Max number of consumers that can be called in parallel to process an
		 * event
		 */
		public int getConsumerParallelism() {
			return _consumerParallelism;
		}

		/**
		 * The percentage of event buffer occupancy that will trigger a
		 * checkpoint attempt. This is to ensure that we can make progress in
		 * large event windows without having to reprocess them entirely in case
		 * of a failure.
		 */
		public double getCheckpointThresholdPct() {
			return _checkpointThresholdPct;
		}

		public Range getKeyRange() {
			return _keyRange;
		}

		/**
		 * Pull requests and error retries configuration when talking to the
		 * relays or bootstrap servers
		 */
		public BackoffTimerStaticConfig getPullerRetries() {
			return _pullerRetries;
		}

		public BackoffTimerStaticConfig getBstPullerRetries() {
			return _bstPullerRetries;
		}

		/** Error retries configuration calling the consumer code */
		public BackoffTimerStaticConfig getDispatcherRetries() {
			return _dispatcherRetries;
		}

		/**
		 * This config controls how many retries will be made on the same
		 * bootstrap Server before switching and clearing the checkpoint
		 */
		public BackoffTimerStaticConfig getBsPullerRetriesBeforeCkptCleanup() {
			return _bsPullerRetriesBeforeCkptCleanup;
		}

		/**
		 * This config controls how many retries will be made when it received
		 * ScnNotFoundException before
		 * bootstrapping/suspending/reading-latest-event
		 */
		public int getNumRetriesOnFallOff() {
			return _numRetriesOnFallOff;
		}

		/**
		 * Minimum number of bytes that need to be available in the buffer
		 * before the Puller's can request for more events. Ideally this is more
		 * than max event size
		 */
		public int getFreeBufferThreshold() {
			return _freeBufferThreshold;
		}

		public boolean isPullerMessageQueueLoggingEnabled() {
			return _enablePullerMessageQueueLogging;
		}

		@Override
		public String toString() {
			return "StaticConfig [_eventBuffer=" + _eventBuffer
					+ ", _bstEventBuffer=" + _bstEventBuffer
					+ ", _consumerTimeBudgetMs=" + _consumerTimeBudgetMs
					+ ", _bstConsumerTimeBudgetMs=" + _bstConsumerTimeBudgetMs
					+ ", _consumerParallelism=" + _consumerParallelism
					+ ", _checkpointThresholdPct=" + _checkpointThresholdPct
					+ ", _keyRange=" + _keyRange
					+ ", _bsPullerRetriesBeforeCkptCleanup="
					+ _bsPullerRetriesBeforeCkptCleanup + ", _pullerRetries="
					+ _pullerRetries + ", _bstPullerRetries=" + _bstPullerRetries + ", _dispatcherRetries="
					+ _dispatcherRetries + ", _bstDispatcherRetries="
					+ _bstDispatcherRetries + ", _freeBufferThreshold="
					+ _freeBufferThreshold
					+ ", _enablePullerMessageQueueLogging="
					+ _enablePullerMessageQueueLogging + "]";
		}
	}

	public static class Config implements ConfigBuilder<StaticConfig> {
		private static final long DEFAULT_KEY_RANGE_MIN = -1L;
		private static final long DEFAULT_KEY_RANGE_MAX = -1L;

		private static final long DEFAULT_MAX_BUFFER_SIZE = 10 * 1024 * 1024;
		private static final int DEFAULT_INIT_READBUFFER_SIZE = 20 * 1024;
		private static final int DEFAULT_MAX_SCNINDEX_SIZE = 1024 * 1024;
		private static final boolean DEFAULT_PULLER_MESSAGE_QUEUE_LOGGING = false;

		private static int DEFAULT_MAX_RETRY_NUM = -1;
		private static int DEFAULT_INIT_SLEEP = 100;
		private static double DEFAULT_SLEEP_INC_FACTOR = 1.1;

		// Default Sleep : InitSleep : 1 sec, then keep incrementing 1.5*prev + 1 sec for
		// subsequent retry, upto 1000 retries. (there is a limit on max sleep set to 1 minute)
		// so at the worst case it will wait for ~16 hours
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_MAX_RETRY_NUM = 1000;
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_INIT_SLEEP = 1 * 1000;
		private static int DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_DELTA = 1000;
		private static double DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_FACTOR = 1.5;
		private static int DEFAULT_FREE_BUFFER_THRESHOLD=10*1024;

		// Default Config woul be to retry 5 times w
		private static int DEFAULT_RETRY_ON_FELLOFF_MAX_RETRY_NUM = 5;

		private final Logger _log = Logger.getLogger(Config.class);
		private DbusEventBuffer.Config _eventBuffer;
		private DbusEventBuffer.Config _bstEventBuffer = null;
		private long _consumerTimeBudgetMs = 300000;
		private long _bstConsumerTimeBudgetMs = 300000;
		private boolean _setBstConsumerTimeBudgetCalled = false;
		private int _consumerParallelism = 1;
		private double _checkpointThresholdPct;
		private long _keyMin;
		private long _keyMax;
		// Ideally, _bsPullerRetriesBeforeCkptCleanup should be renamed to _bsPullerRetriesBeforeServerSwitch
		// In V3 bootstrap there is no clean-up of checkpoint when switching servers.
		// See BootstrapV3CheckpointHandler.resetForServerChange() method
		private BackoffTimerStaticConfigBuilder _bsPullerRetriesBeforeCkptCleanup;
		private BackoffTimerStaticConfigBuilder _pullerRetries;
		private BackoffTimerStaticConfigBuilder _bstPullerRetries;
		private BackoffTimerStaticConfigBuilder _dispatcherRetries;
		private BackoffTimerStaticConfigBuilder _bstDispatcherRetries = null;
		private int _numRetriesOnFallOff;

		//optimization - depreating the ability to alter the value
		private int _freeBufferThreshold = DEFAULT_FREE_BUFFER_THRESHOLD;
		private boolean _consumeCurrent = false;
		private boolean _readLatestScnOnError = false;
		private double _pullerBufferUtilizationPct = 100.0;
		private int _id;
		private boolean _enablePullerMessageQueueLogging;
		private int _noEventsConnectionResetTimeSec = 15*60; // if there is no events for 15 min - disconnect

		private void makeEvbConfig(DbusEventBuffer.Config evbConfig,
																QueuePolicy qPolicy,
																boolean enableScnIndex,
																double defaultMemUsage)
		{
			evbConfig.setQueuePolicy(qPolicy.toString());
			evbConfig.setEnableScnIndex(enableScnIndex);
			evbConfig.setDefaultMemUsage(defaultMemUsage);
			if (evbConfig.getMaxSize() > DEFAULT_MAX_BUFFER_SIZE) {
	       _log.warn("Setting buffer size to " + DEFAULT_MAX_BUFFER_SIZE + " instead of requested size " + evbConfig.getMaxSize());
				evbConfig.setMaxSize(DEFAULT_MAX_BUFFER_SIZE);
			}

			if (evbConfig.getScnIndexSize() > DEFAULT_MAX_SCNINDEX_SIZE) {
				evbConfig.setScnIndexSize(DEFAULT_MAX_SCNINDEX_SIZE);
			}
		}

		public Config() {
			_eventBuffer = new DbusEventBuffer.Config();
			makeEvbConfig(_eventBuffer, QueuePolicy.BLOCK_ON_WRITE, false, 0.1);

			_checkpointThresholdPct = 75.0;
			_keyMin = DEFAULT_KEY_RANGE_MIN;
			_keyMax = DEFAULT_KEY_RANGE_MAX;

			_pullerRetries = new BackoffTimerStaticConfigBuilder();
			_pullerRetries.setInitSleep(DEFAULT_INIT_SLEEP);
			_pullerRetries.setSleepIncFactor(DEFAULT_SLEEP_INC_FACTOR);
			_pullerRetries.setMaxRetryNum(DEFAULT_MAX_RETRY_NUM);

			_bsPullerRetriesBeforeCkptCleanup = new BackoffTimerStaticConfigBuilder();
			_bsPullerRetriesBeforeCkptCleanup
					.setInitSleep(DEFAULT_BSPULLER_CKPTCLEANUP_INIT_SLEEP);
			_bsPullerRetriesBeforeCkptCleanup
					.setSleepIncDelta(DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_DELTA);
			_bsPullerRetriesBeforeCkptCleanup
					.setMaxRetryNum(DEFAULT_BSPULLER_CKPTCLEANUP_MAX_RETRY_NUM);
			_bsPullerRetriesBeforeCkptCleanup
					.setSleepIncFactor(DEFAULT_BSPULLER_CKPTCLEANUP_SLEEP_INC_FACTOR);

			_numRetriesOnFallOff = DEFAULT_RETRY_ON_FELLOFF_MAX_RETRY_NUM;

			_dispatcherRetries = new BackoffTimerStaticConfigBuilder();
			_dispatcherRetries.setSleepIncFactor(1.1);
			_dispatcherRetries.setMaxRetryNum(-1);
			_enablePullerMessageQueueLogging = DEFAULT_PULLER_MESSAGE_QUEUE_LOGGING;
		}

		public Config(Config other) {
			_eventBuffer = new DbusEventBuffer.Config(other.getEventBuffer());
			if (other.hasBstEventBuffer()) {
				_bstEventBuffer = new DbusEventBuffer.Config(other.getBstEventBuffer());
			} else {
				_bstEventBuffer = null;
			}
		}

		public DbusEventBuffer.Config getEventBuffer() {
			return _eventBuffer;
		}

		/**
		 * If anyone other than spring config ever calls this method they should first call hasBstEventBuffer().
		 *
		 * @return a newly constructed DbusEventBuffer.Config object.
		 */
		public DbusEventBuffer.Config getBstEventBuffer() {
			if (_bstEventBuffer != null) {
				return _bstEventBuffer;
			}
			_bstEventBuffer = new DbusEventBuffer.Config();
			makeEvbConfig(_bstEventBuffer, QueuePolicy.BLOCK_ON_WRITE, false, 0.1);
			return _bstEventBuffer;
		}

		public boolean hasBstEventBuffer() {
			return _bstEventBuffer != null;
		}

		public void setEventBuffer(DbusEventBuffer.Config eventBuffer) {
			_eventBuffer = eventBuffer;
		}

		/**
		 * Corrects, checkpointThresholdPct to accommodate largestEventSize by calculating checkpoint threshold pct
		 * override checkpoint threshold pct settings if (between 10 and 90 pct) to set the maximum
		 * @param bufCfg : buffer config; with maxEventSize set
		 * @return checkpointThresholdPct;
		 */
		public double computeSafeCheckpointThresholdPct(DbusEventBuffer.Config bufCfg)
		{
		  int safeMaxEventSize = (int)((100.0 - _checkpointThresholdPct) * bufCfg.maxMaxEventSize() / 100.0);
		  if (DbusEventBuffer.Config.DEFAULT_MAX_EVENT_SIZE == bufCfg.getMaxEventSize())
		  {
		      //maxEventSize not set; return existing checkpointThresholdPct
		    return _checkpointThresholdPct;
		  }
		  else if (safeMaxEventSize >= bufCfg.getMaxEventSize())
		  {
		    //maxEventSize is lesser than safeSize ; return checkpointThresholdPct;
		    return _checkpointThresholdPct;
		  }
		  //case where checkpointThresholdPct has to be computed;
		  return 100.0 - ((double)(bufCfg.getMaxEventSize()+_freeBufferThreshold)/bufCfg.maxMaxEventSize())*100.0;
		}

		private void validateBufferConfig(StaticConfig connConfig,DbusEventBuffer.StaticConfig bufferConfig) throws InvalidConfigException
		{
		  long bufferCapacityInBytes = bufferConfig.getMaxSize();
=======
    private void validateBufferConfig(StaticConfig connConfig,DbusEventBuffer.StaticConfig bufferConfig) throws InvalidConfigException
    {
      long bufferCapacityInBytes = bufferConfig.getMaxSize();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;<<<<<<< MINE
      assertEquals("one consumer + logging consumer in (S1,S2) or (S1,S3)", 2,
=======
      assertEquals("expect one consumer in (S1,S2) or (S1,S3)", 1,
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;<<<<<<< MINE
      assertTrue("two consumers + 1-2 logging consumer  in (S1,S2) or (S1,S3)", 3 <= consumersNum
                 && consumersNum <= 4);
=======
      assertEquals("expect two consumers in (S1,S2) or (S1,S3)", 2, consumersNum);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;<<<<<<< MINE
      assertEquals("one consumers in (S3,S4,S5)", 1,
=======
      assertEquals("expect one consumer in (S3,S4,S5)", 1,
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;<<<<<<< MINE
      assertTrue("two consumers+ 1-2 logging consumer in (S1,S2) or (S1,S3)", 3 <= consumersNum1 &&
                 consumersNum1 <= 4);
      assertTrue("at least one consumer + logging consumer in (S1,S2)",
                 safeListSize(client.getRelayGroupStreamConsumers().get(ls1))
                 >= 2);
=======
      assertEquals("expect two consumers in (S1,S2) or (S1,S3)", 2, consumersNum1);
      assertTrue("expect at least one consumer in (S1,S2)",
                 safeListSize(client.getRelayGroupStreamConsumers().get(ls1)) >= 1);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;<<<<<<< MINE
      assertTrue("three consumers+ 1-2 logging consumers in (S1,S2) or (S1,S3)", 4 <= consumersNum2 &&
                 consumersNum2 <= 5);
=======
      assertEquals("expect three consumers in (S1,S2) or (S1,S3)", 3, consumersNum2);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestDatabusHttpClient.java;<<<<<<< MINE
      assertEquals("one consumer + 1-2 logging consumer  in (S1,S2) or (S1,S3)", consumersNum3,
                   consumersNum4);
=======
      assertEquals("expect one consumer in (S1,S2) or (S1,S3)", consumersNum3, consumersNum4);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestBootstrapPullThread.java;<<<<<<< MINE
=======
    EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(null).times(2);

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestBootstrapPullThread.java;<<<<<<< MINE
		  												boolean throwBSConnException,
				  										boolean muteTransition,
				  										boolean readDataThrowException,
				  										boolean readDataException,
				  										String exceptionName,
				  										int freeReadSpace,
				  										int numBytesRead,
				  										boolean phaseCompleted,
				  										long startScn,
				  										long targetScn,
				  										String... sourceNames)
		throws Exception
  {
	  List<String> sources = Arrays.asList(sourceNames);

	  Properties clientProps = new Properties();

	  clientProps.setProperty("client.container.httpPort", "0");
      clientProps.setProperty("client.container.jmx.rmiEnabled", "false");

	  clientProps.setProperty("client.runtime.bootstrap.enabled", "true");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).name", "bs1");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).port", "10001");
	  clientProps.setProperty("client.runtime.bootstrap.service(1).sources", "source1");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).name", "bs2");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).port", "10002");
	  clientProps.setProperty("client.runtime.bootstrap.service(2).sources", "source1");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).name", "bs3");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).host", "localhost");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).port", "10003");
	  clientProps.setProperty("client.runtime.bootstrap.service(3).sources", "source1");

	  clientProps.setProperty("client.runtime.relay(1).name", "relay1");
	  clientProps.setProperty("client.runtime.relay(1).port", "10001");
	  clientProps.setProperty("client.runtime.relay(1).sources", "source1");
	  clientProps.setProperty("client.runtime.relay(2).name", "relay2");
	  clientProps.setProperty("client.runtime.relay(2).port", "10002");
	  clientProps.setProperty("client.runtime.relay(2).sources", "source1");
	  clientProps.setProperty("client.runtime.relay(3).name", "relay3");
	  clientProps.setProperty("client.runtime.relay(3).port", "10003");
	  clientProps.setProperty("client.runtime.relay(3).sources", "source1");

	  clientProps.setProperty("client.connectionDefaults.eventBuffer.maxSize", "100000");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.maxRetryNum", "9");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncFactor", "1.0");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncDelta", "1");
	  clientProps.setProperty("client.connectionDefaults.pullerRetries.initSleep", "1");

	  DatabusHttpClientImpl.Config clientConfBuilder = new DatabusHttpClientImpl.Config();
	  ConfigLoader<DatabusHttpClientImpl.StaticConfig> configLoader =
			  new ConfigLoader<DatabusHttpClientImpl.StaticConfig>("client.", clientConfBuilder);
	  configLoader.loadConfig(clientProps);

	  DatabusHttpClientImpl.StaticConfig clientConf = clientConfBuilder.build();
	  DatabusSourcesConnection.StaticConfig srcConnConf = clientConf.getConnectionDefaults();

	  DatabusHttpClientImpl client = new DatabusHttpClientImpl(clientConf);

	  client.registerDatabusBootstrapListener(new LoggingConsumer(), null, "source1");

	  Assert.assertNotNull(client, "client instantiation ok");

	  DatabusHttpClientImpl.RuntimeConfig clientRtConf = clientConf.getRuntime().build();

	  //we keep the index of the next server we expect to see
	  AtomicInteger serverIdx = new AtomicInteger(-1);

	  //generate the order in which we should see the servers
	  List<ServerInfo> relayOrder = new ArrayList<ServerInfo>(clientRtConf.getRelays());
	  if (LOG.isInfoEnabled())
	  {
		  StringBuilder sb = new StringBuilder();
		  for (ServerInfo serverInfo: relayOrder)
		  {
			  sb.append(serverInfo.getName());
			  sb.append(" ");
		  }
		  LOG.info("Relay order:" + sb.toString());
	  }

	  List<IdNamePair> sourcesResponse = new ArrayList<IdNamePair>();
	  sourcesResponse.add(new IdNamePair(1L, "source1"));

	  Map<Long, List<RegisterResponseEntry>> registerResponse = new HashMap<Long, List<RegisterResponseEntry>>();

	  List<RegisterResponseEntry> regResponse = new ArrayList<RegisterResponseEntry>();
	  regResponse.add(new RegisterResponseEntry(1L, (short)1, SCHEMA$.toString()));
	  registerResponse.put(1L, regResponse);

	  ChunkedBodyReadableByteChannel channel = EasyMock.createMock(ChunkedBodyReadableByteChannel.class);

	  if ( ! readDataException)
	  {
		  EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(null).anyTimes();
		  EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(null).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(null).anyTimes();
	  } else {
		  EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(exceptionName).anyTimes();
		  EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(exceptionName).anyTimes();
		  EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(exceptionName).anyTimes();
	  }

	  if ( phaseCompleted)
	    EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn("true").anyTimes();
	  else
		EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn(null).anyTimes();

	  EasyMock.replay(channel);

	  DbusEventBuffer dbusBuffer = EasyMock.createMock(DbusEventBuffer.class);
	  dbusBuffer.endEvents(false, -1, false, false, null);
	  EasyMock.expectLastCall().anyTimes();
	  EasyMock.expect(dbusBuffer.injectEvent(EasyMock.<DbusEventInternalReadable>notNull())).andReturn(true).anyTimes();
	  EasyMock.expect(dbusBuffer.getEventSerializationVersion()).andReturn(DbusEventFactory.DBUS_EVENT_V1).anyTimes();

	  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull(),
	                                        org.easymock.EasyMock.<List<InternalDatabusEventsListener>>notNull(),
	                                        org.easymock.EasyMock.<DbusEventsStatisticsCollector>isNull()))
	          .andReturn(numBytesRead).anyTimes();

	  if ( readDataThrowException)
	  {
		  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
		          .andThrow(new RuntimeException("dummy")).anyTimes();
	  } else {
		  EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
		          .andReturn(numBytesRead).anyTimes();
	  }

	  EasyMock.expect(dbusBuffer.acquireIterator(EasyMock.<String>notNull())).andReturn(null).anyTimes();
	  dbusBuffer.waitForFreeSpace((int)(10000 * 100.0 / clientConf.getPullerBufferUtilizationPct()));
	  EasyMock.expectLastCall().anyTimes();
	  EasyMock.expect(dbusBuffer.getBufferFreeReadSpace()).andReturn(freeReadSpace).anyTimes();

	  EasyMock.replay(dbusBuffer);

	  //This guy succeeds on /sources but fails on /register
	  MockBootstrapConnection mockSuccessConn = new MockBootstrapConnection(startScn, targetScn, channel, serverIdx,
	                                                                        muteTransition);

	  DatabusBootstrapConnectionFactory mockConnFactory =
			  org.easymock.EasyMock.createMock("mockRelayFactory", DatabusBootstrapConnectionFactory.class);

	  //each server should be tried MAX_RETRIES time until all retries are exhausted

	  if ( throwBSConnException )
	  {
		  EasyMock.expect(mockConnFactory.createConnection(
				  EasyMock.<ServerInfo>notNull(),
				  EasyMock.<ActorMessageQueue>notNull(),
				  EasyMock.<RemoteExceptionHandler>notNull())).andThrow(new RuntimeException("Mock Error")).anyTimes();
	  } else if ( failBsConnection) {
		  EasyMock.expect(mockConnFactory.createConnection(
				  EasyMock.<ServerInfo>notNull(),
				  EasyMock.<ActorMessageQueue>notNull(),
				  EasyMock.<RemoteExceptionHandler>notNull())).andReturn(null).anyTimes();
=======
                              boolean throwBSConnException,
                              boolean muteTransition,
                              boolean readDataThrowException,
                              boolean readDataException,
                              String exceptionName,
                              int freeReadSpace,
                              int numBytesRead,
                              boolean phaseCompleted,
                              long startScn,
                              long targetScn,
                              String... sourceNames)
  throws Exception
  {
    List<String> sources = Arrays.asList(sourceNames);

    Properties clientProps = new Properties();

    clientProps.setProperty("client.container.httpPort", "0");
    clientProps.setProperty("client.container.jmx.rmiEnabled", "false");

    clientProps.setProperty("client.runtime.bootstrap.enabled", "true");
    clientProps.setProperty("client.runtime.bootstrap.service(1).name", "bs1");
    clientProps.setProperty("client.runtime.bootstrap.service(1).host", "localhost");
    clientProps.setProperty("client.runtime.bootstrap.service(1).port", "10001");
    clientProps.setProperty("client.runtime.bootstrap.service(1).sources", "source1");
    clientProps.setProperty("client.runtime.bootstrap.service(2).name", "bs2");
    clientProps.setProperty("client.runtime.bootstrap.service(2).host", "localhost");
    clientProps.setProperty("client.runtime.bootstrap.service(2).port", "10002");
    clientProps.setProperty("client.runtime.bootstrap.service(2).sources", "source1");
    clientProps.setProperty("client.runtime.bootstrap.service(3).name", "bs3");
    clientProps.setProperty("client.runtime.bootstrap.service(3).host", "localhost");
    clientProps.setProperty("client.runtime.bootstrap.service(3).port", "10003");
    clientProps.setProperty("client.runtime.bootstrap.service(3).sources", "source1");

    clientProps.setProperty("client.runtime.relay(1).name", "relay1");
    clientProps.setProperty("client.runtime.relay(1).port", "10001");
    clientProps.setProperty("client.runtime.relay(1).sources", "source1");
    clientProps.setProperty("client.runtime.relay(2).name", "relay2");
    clientProps.setProperty("client.runtime.relay(2).port", "10002");
    clientProps.setProperty("client.runtime.relay(2).sources", "source1");
    clientProps.setProperty("client.runtime.relay(3).name", "relay3");
    clientProps.setProperty("client.runtime.relay(3).port", "10003");
    clientProps.setProperty("client.runtime.relay(3).sources", "source1");

    clientProps.setProperty("client.connectionDefaults.eventBuffer.maxSize", "100000");
    clientProps.setProperty("client.connectionDefaults.pullerRetries.maxRetryNum", "9");
    clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncFactor", "1.0");
    clientProps.setProperty("client.connectionDefaults.pullerRetries.sleepIncDelta", "1");
    clientProps.setProperty("client.connectionDefaults.pullerRetries.initSleep", "1");

    DatabusHttpClientImpl.Config clientConfBuilder = new DatabusHttpClientImpl.Config();
    ConfigLoader<DatabusHttpClientImpl.StaticConfig> configLoader =
        new ConfigLoader<DatabusHttpClientImpl.StaticConfig>("client.", clientConfBuilder);
    configLoader.loadConfig(clientProps);

    DatabusHttpClientImpl.StaticConfig clientConf = clientConfBuilder.build();
    DatabusSourcesConnection.StaticConfig srcConnConf = clientConf.getConnectionDefaults();

    DatabusHttpClientImpl client = new DatabusHttpClientImpl(clientConf);

    client.registerDatabusBootstrapListener(new LoggingConsumer(), null, "source1");

    Assert.assertNotNull(client, "client instantiation ok");

    DatabusHttpClientImpl.RuntimeConfig clientRtConf = clientConf.getRuntime().build();

    //we keep the index of the next server we expect to see
    AtomicInteger serverIdx = new AtomicInteger(-1);

    //generate the order in which we should see the servers
    List<ServerInfo> relayOrder = new ArrayList<ServerInfo>(clientRtConf.getRelays());
    if (LOG.isInfoEnabled())
    {
      StringBuilder sb = new StringBuilder();
      for (ServerInfo serverInfo: relayOrder)
      {
        sb.append(serverInfo.getName());
        sb.append(" ");
      }
      LOG.info("Relay order:" + sb.toString());
    }

    List<IdNamePair> sourcesResponse = new ArrayList<IdNamePair>();
    sourcesResponse.add(new IdNamePair(1L, "source1"));

    Map<Long, List<RegisterResponseEntry>> registerResponse = new HashMap<Long, List<RegisterResponseEntry>>();

    List<RegisterResponseEntry> regResponse = new ArrayList<RegisterResponseEntry>();
    regResponse.add(new RegisterResponseEntry(1L, (short)1, SCHEMA$.toString()));
    registerResponse.put(1L, regResponse);

    ChunkedBodyReadableByteChannel channel = EasyMock.createMock(ChunkedBodyReadableByteChannel.class);

    if ( ! readDataException)
    {
      EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(null).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(null).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(null).anyTimes();
    } else {
      EasyMock.expect(channel.getMetadata("x-dbus-error-cause")).andReturn(exceptionName).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-req-id")).andReturn(exceptionName).anyTimes();
      EasyMock.expect(channel.getMetadata("x-dbus-error")).andReturn(exceptionName).anyTimes();
    }

    if ( phaseCompleted)
      EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn("true").anyTimes();
    else
    EasyMock.expect(channel.getMetadata("PhaseCompleted")).andReturn(null).anyTimes();

    EasyMock.replay(channel);

    DbusEventBuffer dbusBuffer = EasyMock.createMock(DbusEventBuffer.class);
    dbusBuffer.endEvents(false, -1, false, false, null);
    EasyMock.expectLastCall().anyTimes();
    EasyMock.expect(dbusBuffer.injectEvent(EasyMock.<DbusEventInternalReadable>notNull())).andReturn(true).anyTimes();
    EasyMock.expect(dbusBuffer.getEventSerializationVersion()).andReturn(DbusEventFactory.DBUS_EVENT_V1).anyTimes();

    EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull(),
                                          org.easymock.EasyMock.<List<InternalDatabusEventsListener>>notNull(),
                                          org.easymock.EasyMock.<DbusEventsStatisticsCollector>isNull()))
            .andReturn(numBytesRead).anyTimes();

    if ( readDataThrowException)
    {
      EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
              .andThrow(new RuntimeException("dummy")).anyTimes();
    } else {
      EasyMock.expect(dbusBuffer.readEvents(EasyMock.<ReadableByteChannel>notNull()))
              .andReturn(numBytesRead).anyTimes();
    }

    EasyMock.expect(dbusBuffer.acquireIterator(EasyMock.<String>notNull())).andReturn(null).anyTimes();
    dbusBuffer.waitForFreeSpace((int)(10000 * 100.0 / clientConf.getPullerBufferUtilizationPct()));
    EasyMock.expectLastCall().anyTimes();
    EasyMock.expect(dbusBuffer.getBufferFreeReadSpace()).andReturn(freeReadSpace).anyTimes();

    EasyMock.replay(dbusBuffer);

    //This guy succeeds on /sources but fails on /register
    MockBootstrapConnection mockSuccessConn = new MockBootstrapConnection(startScn, targetScn, channel, serverIdx,
                                                                          muteTransition);

    DatabusBootstrapConnectionFactory mockConnFactory =
        org.easymock.EasyMock.createMock("mockRelayFactory", DatabusBootstrapConnectionFactory.class);

    //each server should be tried MAX_RETRIES time until all retries are exhausted

    if ( throwBSConnException )
    {
      EasyMock.expect(mockConnFactory.createConnection(
          EasyMock.<ServerInfo>notNull(),
          EasyMock.<ActorMessageQueue>notNull(),
          EasyMock.<RemoteExceptionHandler>notNull())).andThrow(new RuntimeException("Mock Error")).anyTimes();
    } else if ( failBsConnection) {
      EasyMock.expect(mockConnFactory.createConnection(
          EasyMock.<ServerInfo>notNull(),
          EasyMock.<ActorMessageQueue>notNull(),
          EasyMock.<RemoteExceptionHandler>notNull())).andReturn(null).anyTimes();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
      TestUtil.setupLoggingWithTimestampedFile(true, "/tmp/TestGenericDispatcher_", ".log", Level.ERROR);
=======
      TestUtil.setupLoggingWithTimestampedFile(true, "/tmp/TestGenericDispatcher_", ".log", Level.INFO);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
                    mConsumer);
=======
                    mConsumer,
                    true);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
                    mConsumer);
=======
                    mConsumer,
                    true);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE

    void runPartialWindowCheckpointPersistence(int numEvents,int maxWindowSize,int numFailWindow) throws Exception
=======
    void runPartialWindowCheckpointPersistence(int numEvents,int maxWindowSize,int numFailWindow) throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
        //Assumption: generates events with  non-decreasing timestamps
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
                mConsumer);
=======
                mConsumer,
                true);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======


            Assert.assertEquals(cp.getWindowOffset().longValue() , -1L);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
            Assert.assertEquals(cp.getWindowOffset().longValue() , -1L);
=======
            //the latest event seen should be newer (or at least as new) as the checkpoint
            Assert.assertTrue(tConsumer.getLastTsInNanosOfEvent() >= tConsumer.getLastTsInNanosOfWindow());

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
                Assert.assertEquals(cp.getWindowScn(),tConsumer.getLastSeenWindowScn());
=======
              Assert.assertEquals(cp.getWindowScn(),tConsumer.getLastSeenWindowScn());
              //check if the timestamp in checkpoint is the same as checkpoint of last completed window (ts of last event of the window)
              Assert.assertEquals(tConsumer.getLastTsInNanosOfWindow(),cp.getTsNsecs());
            }
            else
            {
              //not even one window was processed before error; expect uninitialized timestamp
              Assert.assertEquals(Checkpoint.UNSET_TS_NSECS,cp.getTsNsecs());
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
    public void testBootstrapParitalWindowScnOrdering() throws Exception
=======
    public void testBootstrapPartialWindowScnOrdering() throws Exception
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
        final long sinceScn = 10L;
=======
        long sinceScn=15000L;
        long startTsNsecs = System.nanoTime();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
        dispatcher.enqueueMessage(CheckpointMessage.createSetCheckpointMessage(initCheckpoint));
=======
        initCheckpoint.setBootstrapStartNsecs(startTsNsecs);
        initCheckpoint.setBootstrapStartScn(0L);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
        //simulate bootstrap server; use this checkpoint as init checkpoint
        eventProducer.setBootstrapCheckpoint(initCheckpoint);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
        Assert.assertTrue(cps.size() > 0);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
            //check if lastSeenCheckpoint by consumer is same as bootstrapsinceScn
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
            //check if progress has been made during bootstrap
            Assert.assertTrue(cp.getSnapshotOffset() > 0);
            //these two values should be unchanged during the course of bootstrap
            Assert.assertEquals(sinceScn,cp.getBootstrapSinceScn().longValue());
            Assert.assertEquals(startTsNsecs,cp.getBootstrapStartNsecs());
            //the tsNsec normally udpdated by client at end of window should be a no-op during bootstrap
            Assert.assertEquals(Checkpoint.UNSET_TS_NSECS,cp.getTsNsecs());
            //the scn passed to consumers during onCheckpoint should be the sinceSCN and not any other interim value
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
            Assert.assertTrue(cp.getSnapshotOffset() > 0);
            Assert.assertEquals(cp.getBootstrapSinceScn().longValue(), sinceScn);
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
        log.info("end\n");
    }

    //This is a negative test for DDSDBUS-3421. We expect dispatcher to fail without dataEvents being called.
    @Test
    public void testAbsentSchemaTest() throws Exception
    {
      runAbsentSchemaTest(true);
      runAbsentSchemaTest(false);
    }

    void runAbsentSchemaTest(boolean setSchemaCheck) throws Exception
    {
      /* Experiment setup */
      int numEvents=100; int maxWindowSize=20;
      int payloadSize = 20;
      int numCheckpoints = numEvents/maxWindowSize;

      /* Consumer creation */
      //setup consumer to fail on data callback at the nth event
      DataDecodingConsumer tConsumer = new DataDecodingConsumer();

      HashMap<Long, List<RegisterResponseEntry>> schemaMap =
              new HashMap<Long, List<RegisterResponseEntry>>();

      short srcId=1;
      List<RegisterResponseEntry> l1 = new ArrayList<RegisterResponseEntry>();
      l1.add(new RegisterResponseEntry(1L, srcId,SOURCE1_SCHEMA_STR));

      schemaMap.put(1L, l1);

      Map<Long, IdNamePair> sourcesMap = new HashMap<Long, IdNamePair>();
      List<String> sources = new ArrayList<String>();
      for (int i = 1; i <= 1; ++i)
      {
          IdNamePair sourcePair = new IdNamePair((long)i, "source" + i);
          sources.add(sourcePair.getName());
          sourcesMap.put(sourcePair.getId(), sourcePair);
      }

      long consumerTimeBudgetMs = 60*1000;
      DatabusV2ConsumerRegistration consumerReg = new DatabusV2ConsumerRegistration(tConsumer, sources, null);
      List<DatabusV2ConsumerRegistration> allRegistrations =  Arrays.asList(consumerReg);
      //Single threaded execution of consumer
      MultiConsumerCallback mConsumer = new MultiConsumerCallback(allRegistrations,Executors.newFixedThreadPool(1),
              consumerTimeBudgetMs,new StreamConsumerCallbackFactory(null,null),null,null, null);



      /* Generate events **/
      Vector<DbusEvent> srcTestEvents = new Vector<DbusEvent>();
      Vector<Short> srcIdList = new Vector<Short> ();
      srcIdList.add(srcId);

      DbusEventGenerator evGen = new DbusEventGenerator(0,srcIdList);
      //the schemaIds generated here are random. They will not be the same as those computed in the dispatcher.
      //The result is either the processing will fail early (desired behaviour) or during event decoding in the onDataEvent()
      Assert.assertTrue(evGen.generateEvents(numEvents, maxWindowSize, 512, payloadSize, srcTestEvents) > 0);

      int totalSize=0; int maxSize=0;
      for (DbusEvent e : srcTestEvents)
      {
          totalSize += e.size();
          maxSize = (e.size() > maxSize) ? e.size():maxSize;
      }

      /* Source configuration */
      DatabusSourcesConnection.Config conf = new DatabusSourcesConnection.Config();
      conf.getDispatcherRetries().setMaxRetryNum(1);
      conf.setFreeBufferThreshold(maxSize);
      conf.setConsumerTimeBudgetMs(consumerTimeBudgetMs);
      int freeBufferThreshold = conf.getFreeBufferThreshold();
      DatabusSourcesConnection.StaticConfig connConfig = conf.build();

      //make buffer large enough to hold data; the control events are large that contain checkpoints
      int producerBufferSize =  totalSize*2 + numCheckpoints*10*maxSize*5 + freeBufferThreshold;
      int individualBufferSize = producerBufferSize;
      int indexSize = producerBufferSize / 10;
      int stagingBufferSize = producerBufferSize;

      /*Event Buffer creation */
      TestGenericDispatcherEventBuffer dataEventsBuffer=
          new TestGenericDispatcherEventBuffer(
              getConfig(producerBufferSize, individualBufferSize, indexSize ,
                        stagingBufferSize, AllocationPolicy.HEAP_MEMORY,
                        QueuePolicy.BLOCK_ON_WRITE));

      List<DatabusSubscription> subs = DatabusSubscription.createSubscriptionList(sources);
      /* Generic Dispatcher creation */
      TestDispatcher<DatabusCombinedConsumer> dispatcher = new TestDispatcher<DatabusCombinedConsumer>("rollBackcheck",
              connConfig,
              subs,
              new InMemoryPersistenceProvider(),
              dataEventsBuffer,
              mConsumer,
              false);
      //DDSDBUS-3421; set schema check to true
      dispatcher.setSchemaIdCheck(setSchemaCheck);

      /* Launch writer */
      DbusEventAppender eventProducer = new DbusEventAppender(srcTestEvents, dataEventsBuffer,0 ,null) ;
      Thread tEmitter = new Thread(eventProducer);
      tEmitter.start();

      /* Launch dispatcher */
      Thread tDispatcher = new Thread(dispatcher);
      tDispatcher.start();

      /* Now initialize this  state machine */
      dispatcher.enqueueMessage(SourcesMessage.createSetSourcesIdsMessage(sourcesMap.values()));
      dispatcher.enqueueMessage(SourcesMessage.createSetSourcesSchemasMessage(schemaMap));

      //be generous ; use worst case for num control events
      long waitTimeMs  = (numEvents*1 + numEvents*1) * 4;
      tEmitter.join(waitTimeMs);
      //wait for dispatcher to finish reading the events;
      tDispatcher.join(waitTimeMs);
      Assert.assertFalse(tEmitter.isAlive());

      //asserts
      if (!setSchemaCheck)
      {
        //decoding fails many errors show up;
        Assert.assertTrue(tConsumer.getNumDataEvents() > 0);
        Assert.assertTrue(tConsumer.getNumErrors() > 0);
      }
      else
      {
        //never gets to decoding; but error shows up (exactly one - dispatcher retries set to 1);
        Assert.assertEquals(0, tConsumer.getNumDataEvents());
        Assert.assertEquals(1,tConsumer.getNumErrors());
      }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
        private CountDownLatch latch = new CountDownLatch(1);
=======
        private final CountDownLatch latch = new CountDownLatch(1);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
}
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
  // TODO Change this class to behave like bootstrap dispatcher or relay dispatcher depending on what we are
  // testing. If bootstrap dispatcher, then we need to override processSysEvents to construct checkpoint when
  // a checkpoint event is received (or better, initialize checkpoint in ctor), and then override createCheckpoint
  // method to call onEvent on the saved checkpoint.
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
    private final boolean _isRelayDispatcher;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
    public TestDispatcher(String name, DatabusSourcesConnection.StaticConfig connConfig,
            List<DatabusSubscription> subsList,
            CheckpointPersistenceProvider checkpointPersistor,
            DbusEventBuffer dataEventsBuffer,
            MultiConsumerCallback asyncCallback) {
=======
    public TestDispatcher(String name,
                          DatabusSourcesConnection.StaticConfig connConfig,
                          List<DatabusSubscription> subsList,
                          CheckpointPersistenceProvider checkpointPersistor,
                          DbusEventBuffer dataEventsBuffer,
                          MultiConsumerCallback asyncCallback,
                          boolean isRelayDispatcher) {
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
        _isRelayDispatcher = isRelayDispatcher;
=======
        _isRelayDispatcher = isRelayDispatcher;
        //disable schemaIdCheck at onStartSource() by default, in the interest of many unit tests written without paying attention to same schemaIds being present in events
        _schemaIdCheck=false;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
       return createOnlineConsumptionCheckpoint(_lastWindowScn,curState,event);
=======
      if (_isRelayDispatcher)
      {
       return createOnlineConsumptionCheckpoint(_lastWindowScn, _lastEowTsNsecs, curState,event);
      }
      else
      {
        // TODO for bootstrap dispatcher: Update the prev checkpoint.
        return createOnlineConsumptionCheckpoint(_lastWindowScn, _lastEowTsNsecs, curState, event);
      }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
class StateVerifyingStreamConsumer extends DelegatingDatabusCombinedConsumer
=======
static class StateVerifyingStreamConsumer extends DelegatingDatabusCombinedConsumer
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
    private long _lastTsInNanosOfEvent=-1;
    private  long _lastTsInNanosOfWindow=-1;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
        _lastTsInNanosOfWindow=_lastTsInNanosOfEvent;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
        _lastTsInNanosOfEvent = e.timestampInNanos();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
=======
    public long getLastTsInNanosOfEvent()
    {
      return _lastTsInNanosOfEvent;
    }

    public long getLastTsInNanosOfWindow()
    {
      return _lastTsInNanosOfWindow;
    }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-http/src/test/java/com/linkedin/databus/client/TestGenericDispatcher.java;<<<<<<< MINE
}

=======
}


>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
*/
=======
 */
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    protected static final Logger LOG = Logger.getLogger(TestClusterCheckpointPersistenceProvider.class);
=======
  protected static final Logger LOG = Logger.getLogger(TestClusterCheckpointPersistenceProvider.class);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
  static final int localZkPort = Utils.getAvailablePort(2193);
=======
  static int localZkPort = Utils.getAvailablePort(2193);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
     TestUtil.setupLoggingWithTimestampedFile(true, "/tmp/TestClusterCheckpointPersistenceProvider_",
                                              ".log", Level.WARN);
     File zkroot = FileUtils.createTempDir("TestClusterCheckpointPersistenceProvider_zkroot");
     LOG.info("starting ZK on port " + localZkPort + " and datadir " + zkroot.getAbsolutePath());

     ZkServer zkServer = TestUtil.startZkServer(zkroot.getAbsolutePath(), 0,
                                                localZkPort , 2000);
     if (zkServer != null)
     {
       _localZkServers  = new Vector<ZkServer>(1);
       _localZkServers.add(zkServer);
     }
=======
    TestUtil.setupLoggingWithTimestampedFile(true, "/tmp/TestClusterCheckpointPersistenceProvider_",
        ".log", Level.WARN);
    File zkroot = FileUtils.createTempDir("TestClusterCheckpointPersistenceProvider_zkroot");
    LOG.info("starting ZK on port " + localZkPort + " and datadir " + zkroot.getAbsolutePath());

    ZkServer zkServer = TestUtil.startZkServer(zkroot.getAbsolutePath(), 0,
        localZkPort , 2000);
    if (zkServer != null)
    {
      _localZkServers  = new Vector<ZkServer>(1);
      _localZkServers.add(zkServer);
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      if (_localZkServers != null)
      {
          TestUtil.stopLocalZookeeper(_localZkServers);
      }
=======
    if (_localZkServers != null)
    {
      TestUtil.stopLocalZookeeper(_localZkServers);
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      Checkpoint cp = new Checkpoint();
      cp.setWindowScn(50532L);
      cp.setWindowOffset(-1);
      cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

      String id = "4";
      String clusterName = "test-cluster-persistence";
	  ClusterCheckpointPersistenceProvider.createCluster(zkAddr,clusterName);
      ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
      conf.setClusterName(clusterName);
      conf.setZkAddr(zkAddr);

      ArrayList<String> sources= new ArrayList<String>(3);
      sources.add("source1");
      sources.add("source2");
      sources.add("source3");
=======
    Checkpoint cp = new Checkpoint();
    cp.setWindowScn(50532L);
    cp.setWindowOffset(-1);
    cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

    String id = "4";
    String clusterName = "test-cluster-persistence";
    ClusterCheckpointPersistenceProvider.createCluster(zkAddr,clusterName);
    ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
    conf.setClusterName(clusterName);
    conf.setZkAddr(zkAddr);

    ArrayList<String> sources= new ArrayList<String>(3);
    sources.add("source1");
    sources.add("source2");
    sources.add("source3");
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    try
    {
      ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(id,conf);
      ccp.storeCheckpoint(sources, cp);
=======
    try
    {
      ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(id,conf);
      ccp.storeCheckpoint(sources, cp);

      Checkpoint newCp = ccp.loadCheckpoint(sources);
      Assert.assertTrue(newCp != null);
      Assert.assertTrue(newCp.getWindowOffset()==cp.getWindowOffset());
      Assert.assertTrue(newCp.getWindowScn()==cp.getWindowScn());
      Assert.assertTrue(newCp.getConsumptionMode()==cp.getConsumptionMode());

    }
    catch (InvalidConfigException e)
    {
      System.err.println("Invalid config: " + e);
      Assert.assertTrue(false);
    }
    catch (IOException e)
    {
      System.err.println("Error storing checkpoint: " + e);
      Assert.assertTrue(false);
    }
    catch (ClusterCheckpointException e)
    {
      Assert.assertTrue(false);
    }
    finally
    {
      ClusterCheckpointPersistenceProvider.close(clusterName);
    }

  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      Checkpoint newCp = ccp.loadCheckpoint(sources);
      Assert.assertTrue(newCp != null);
      Assert.assertTrue(newCp.getWindowOffset()==cp.getWindowOffset());
      Assert.assertTrue(newCp.getWindowScn()==cp.getWindowScn());
      Assert.assertTrue(newCp.getConsumptionMode()==cp.getConsumptionMode());
=======
  @Test
  public void testFrequencyOfCheckpoints() throws Exception
  {
    Checkpoint cp = new Checkpoint();
    long startWindowScn = 50532L;
    cp.setWindowScn(startWindowScn);
    cp.setWindowOffset(-1);
    cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

    final int checkPointIntervalMs = 75;
    final long delayMs = 31;
    final int numAttemptedWrites = 7;
    // We should write at 0, 31, 62, 93, 123, 155, 186, but only at at 0, 93, 155
    // Persistent provider clock: 0              75           150            225
    // checkpoint store clock     0    31   62       93  123      155  186
    final int expectedActualStores = 3;

    String id = "5";
    String clusterName = "test-cluster-freq";
    ClusterCheckpointPersistenceProvider.createCluster(zkAddr, clusterName);
    ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
    conf.setClusterName(clusterName);
    conf.setZkAddr(zkAddr);
    conf.setCheckpointIntervalMs(checkPointIntervalMs);

    ArrayList<String> sources = new ArrayList<String>(3);
    sources.add("source1");
    sources.add("source2");
    sources.add("source3");
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    }
    catch (InvalidConfigException e)
    {
      System.err.println("Invalid config: " + e);
      Assert.assertTrue(false);
    }
    catch (IOException e)
    {
      System.err.println("Error storing checkpoint: " + e);
      Assert.assertTrue(false);
    }
    catch (ClusterCheckpointException e)
    {
      Assert.assertTrue(false);
    }
    finally
    {
      ClusterCheckpointPersistenceProvider.close(clusterName);
    }
=======
    try
    {
      TestFrequencyCPP ccp = new TestFrequencyCPP(id, conf);
      for (int i = 0; i < numAttemptedWrites; ++i)
      {
        cp.setWindowScn(startWindowScn + i);
        ccp.storeCheckpoint(sources, cp);
        Checkpoint newCp = ccp.getStoredCheckpoint();
        // cp integrity checks
        Assert.assertTrue(newCp != null);
        Assert.assertTrue(newCp.getWindowOffset() == cp
            .getWindowOffset());
        Assert.assertTrue(newCp.getConsumptionMode() == cp
            .getConsumptionMode());
        // skipped store test;
        Thread.sleep(delayMs);
      }
      Assert.assertEquals(ccp.getnStores(), expectedActualStores);
    }
    finally
    {
      ClusterCheckpointPersistenceProvider.close(clusterName);
    }
  }

  @Test
  public void testMultipleClusterCheckpointPersistence()
  {
    try
    {
      String[] partitionIds = { "1", "2", "3", "4", "5", "6" };
      String[] clusters = { "tcluster1", "tcluster2", "tcluster3" };
      ArrayList<CheckpointRW> cpRws = new ArrayList<TestClusterCheckpointPersistenceProvider.CheckpointRW>();
      for (String c : clusters)
      {
        // create clusters;
        ClusterCheckpointPersistenceProvider.createCluster(zkAddr, c);
        for (String p : partitionIds)
        {
          cpRws.add(new CheckpointRW(c, p, RngUtils
              .randomPositiveLong()));
        }
      }
      for (CheckpointRW cpRW : cpRws)
      {
        cpRW.start();
      }
      for (CheckpointRW cpRW : cpRws)
      {
        cpRW.join(10000);
        Assert.assertFalse(cpRW.hasError());
      }
    }
    catch (Exception e)
    {
      Assert.assertTrue(false);
    }
  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
  @Test
  public void testFrequencyOfCheckpoints() throws Exception
  {
    Checkpoint cp = new Checkpoint();
    long startWindowScn = 50532L;
    cp.setWindowScn(startWindowScn);
    cp.setWindowOffset(-1);
    cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

    int checkPointIntervalMs = 200;

    String id = "5";
    String clusterName = "test-cluster-freq";
    ClusterCheckpointPersistenceProvider.createCluster(zkAddr, clusterName);
    ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
    conf.setClusterName(clusterName);
    conf.setZkAddr(zkAddr);
    conf.setCheckpointIntervalMs(checkPointIntervalMs);

    ArrayList<String> sources = new ArrayList<String>(3);
    sources.add("source1");
    sources.add("source2");
    sources.add("source3");

    try
=======
    public boolean hasError()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(
          id, conf);
      long delayMs = 50;
      int numAttemptedWrites = 100;
      int numActualStores = 0;
      int expectedActualStores = (delayMs >= checkPointIntervalMs) ? numAttemptedWrites
          : (int) ((numAttemptedWrites / (checkPointIntervalMs / delayMs)));
      for (int i = 0; i < numAttemptedWrites; ++i)
      {
        cp.setWindowScn(startWindowScn + i);
        ccp.storeCheckpoint(sources, cp);
        Checkpoint newCp = ccp.loadCheckpoint(sources);
        // cp integrity checks
        Assert.assertTrue(newCp != null);
        Assert.assertTrue(newCp.getWindowOffset() == cp
            .getWindowOffset());
        Assert.assertTrue(newCp.getConsumptionMode() == cp
            .getConsumptionMode());
        // skipped store test;
        if (newCp.getWindowScn() == cp.getWindowScn())
        {
          numActualStores++;
        }
        Thread.sleep(delayMs);
      }
      LOG.warn("Num actual stores=" + numActualStores
          + " Num expected stores=" + expectedActualStores);
      Assert.assertTrue((numActualStores == expectedActualStores)
          || (numActualStores == expectedActualStores + 1));
=======
      return _hasError;
    }

    public String getClusterName()
    {
      return _clusterName;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
  @Test
  public void testMultipleClusterCheckpointPersistence()
  {
    try
=======
    @Override
    public void run()
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      String[] partitionIds = { "1", "2", "3", "4", "5", "6" };
      String[] clusters = { "tcluster1", "tcluster2", "tcluster3" };
      ArrayList<CheckpointRW> cpRws = new ArrayList<TestClusterCheckpointPersistenceProvider.CheckpointRW>();
      for (String c : clusters)
      {
        // create clusters;
        ClusterCheckpointPersistenceProvider.createCluster(zkAddr, c);
        for (String p : partitionIds)
=======
      try
      {
        ArrayList<String> sources = new ArrayList<String>(3);
        sources.add("src1");
        sources.add("src2");
        sources.add("src3");
        long endTimeMs = System.currentTimeMillis() + _durationMs;
        while (System.currentTimeMillis() < endTimeMs)
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
          cpRws.add(new CheckpointRW(c, p, RngUtils
              .randomPositiveLong()));
=======
          ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
          conf.setClusterName(_clusterName);
          conf.setZkAddr(zkAddr);
          conf.setCheckpointIntervalMs(_delayMs - 10);

          Checkpoint cp = new Checkpoint();
          cp.setWindowScn(_startScn);
          cp.setWindowOffset(-1);
          cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

          // cluster creation code
          ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(
              _partitionId, conf);
          ccp.storeCheckpoint(sources, cp);

          Checkpoint newCp = ccp.loadCheckpoint(sources);

          Assert.assertTrue(newCp != null);
          Assert.assertTrue(newCp.getWindowOffset() == cp
              .getWindowOffset());
          Assert.assertTrue(newCp.getWindowScn() == cp.getWindowScn());
          Assert.assertTrue(newCp.getConsumptionMode() == cp
              .getConsumptionMode());

          Thread.sleep(_delayMs);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
      }
      for (CheckpointRW cpRW : cpRws)
      {
        cpRW.start();
      }
      for (CheckpointRW cpRW : cpRws)
      {
        cpRW.join(10000);
        Assert.assertFalse(cpRW.hasError());
      }
    }
    catch (Exception e)
    {
      Assert.assertTrue(false);
    }
=======
      }
      catch (Exception e)
      {
        LOG.error("Exception caught " + e, e);
        _hasError = true;
      }
      finally
      {
        ClusterCheckpointPersistenceProvider.close(_clusterName);
      }
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
  /**
   * thread that writes Checkpoints to clusters
   *
   */
  public class CheckpointRW extends Thread
  {
    private final String _clusterName;
    private final String _partitionId;
    private final long _startScn;
    private final long _durationMs = 5000;
    private final long _delayMs = 200;
    private boolean _hasError = false;
=======
    private Checkpoint storedCheckpoint = null;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    public CheckpointRW(String cluster, String partitionId, long startScn)
    {
      _clusterName = cluster;
      _partitionId = partitionId;
      _startScn = startScn;
    }

    public boolean hasError()
    {
      return _hasError;
    }

    public String getClusterName()
    {
      return _clusterName;
    }
=======
    public TestFrequencyCPP(String id, Config config)
        throws InvalidConfigException, ClusterCheckpointException
    {
      super(id, config);
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
    @Override
    public void run()
    {
      try
      {
        ArrayList<String> sources = new ArrayList<String>(3);
        sources.add("src1");
        sources.add("src2");
        sources.add("src3");
        long endTimeMs = System.currentTimeMillis() + _durationMs;
        while (System.currentTimeMillis() < endTimeMs)
        {
          ClusterCheckpointPersistenceProvider.Config conf = new ClusterCheckpointPersistenceProvider.Config();
          conf.setClusterName(_clusterName);
          conf.setZkAddr(zkAddr);
          conf.setCheckpointIntervalMs(_delayMs - 10);

          Checkpoint cp = new Checkpoint();
          cp.setWindowScn(_startScn);
          cp.setWindowOffset(-1);
          cp.setConsumptionMode(DbusClientMode.ONLINE_CONSUMPTION);

          // cluster creation code
          ClusterCheckpointPersistenceProvider ccp = new ClusterCheckpointPersistenceProvider(
              _partitionId, conf);
          ccp.storeCheckpoint(sources, cp);
=======
    @Override
    protected void storeZkRecord(List<String> sourceNames, Checkpoint checkpoint)
    {
      storedCheckpoint = checkpoint;
      nStores++;
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
          Checkpoint newCp = ccp.loadCheckpoint(sources);
=======
    public int getnStores()
    {
      return nStores;
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
          Assert.assertTrue(newCp != null);
          Assert.assertTrue(newCp.getWindowOffset() == cp
              .getWindowOffset());
          Assert.assertTrue(newCp.getWindowScn() == cp.getWindowScn());
          Assert.assertTrue(newCp.getConsumptionMode() == cp
              .getConsumptionMode());
=======
    public Checkpoint getStoredCheckpoint()
    {
      return storedCheckpoint;
    }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/test/java/com/linkedin/databus/client/pub/TestClusterCheckpointPersistenceProvider.java;<<<<<<< MINE
          Thread.sleep(_delayMs);
        }
      }
      catch (Exception e)
      {
        LOG.error("Exception caught " + e, e);
        _hasError = true;
      }
      finally
      {
        ClusterCheckpointPersistenceProvider.close(_clusterName);
      }
    }
  }
=======
  }
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/main/java/com/linkedin/databus/client/pub/DatabusV3Registration.java;<<<<<<< MINE
   * Internal-use only. Please do not use. DDSDBUS-2623.
   *
   * This call sets parent registration id for this (child) registration.
   * Applicable for Multi-Partition Consumers only
   *
   * For e.g., if the subscription is for all the partitions on TestDB and TestDB has
   * 2 partitions, then two individual registrations are created for each of the registrations
   * In addition a "parent" registration is created, that assimilates information across
   * all the partitions, and encapsulates the sub-partition level information.
   *
   * @param rid RegistrationId of the parent
   */
  public void setParentRegId(RegistrationId rid);

  /**
   * Internal-use only. Please do not use. DDSDBUS-2623.
   *
   * Get parent registration id of this registration.
   *
   * Applicable for Multi-Partition Consumers only.
   */
  public RegistrationId getParentRegId();
=======
   * Obtains the parent registration if any. Parent registrations are generally creating when consuming from multiple
   * partitions simultaneously.
   * @return the parent registration or null if there isn't any*/
  public DatabusV3Registration getParentRegistration();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-client/databus-client-api/src/main/java/com/linkedin/databus/client/pub/ConsumerCallbackResult.java;<<<<<<< MINE
 *  <li>ERROR_FATAL - callback finished unsuccessfully with an unrecoverable error</li>
=======
 *  <li>ERROR_FATAL - *DO NOT USE* This is not currently supported by the databus library </li>
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus2-example/databus2-example-person/src/main/java/com/linkedin/events/example/person/Person_V1.java;<<<<<<< MINE
  public static final org.apache.avro.Schema SCHEMA$ = org.apache.avro.Schema.parse("{\"type\":\"record\",\"name\":\"Person_V1\",\"namespace\":\"com.linkedin.events.example.person\",\"fields\":[{\"name\":\"txn\",\"type\":[\"long\",\"null\"],\"meta\":\"dbFieldName=TXN;dbFieldPosition=0;\"},{\"name\":\"key\",\"type\":[\"long\",\"null\"],\"meta\":\"dbFieldName=KEY;dbFieldPosition=1;\"},{\"name\":\"firstName\",\"type\":[\"string\",\"null\"],\"meta\":\"dbFieldName=FIRST_NAME;dbFieldPosition=2;\"},{\"name\":\"lastName\",\"type\":[\"string\",\"null\"],\"meta\":\"dbFieldName=LAST_NAME;dbFieldPosition=3;\"},{\"name\":\"birthDate\",\"type\":[\"long\",\"null\"],\"meta\":\"dbFieldName=BIRTH_DATE;dbFieldPosition=4;\"},{\"name\":\"deleted\",\"type\":[\"string\",\"null\"],\"meta\":\"dbFieldName=DELETED;dbFieldPosition=5;\"}],\"meta\":\"dbFieldName=sy$person;\"}");
=======
  public static final org.apache.avro.Schema SCHEMA$ = org.apache.avro.Schema.parse("{\"type\":\"record\",\"name\":\"Person_V1\",\"namespace\":\"com.linkedin.events.example.person\",\"fields\":[{\"name\":\"txn\",\"type\":[\"long\",\"null\"],\"meta\":\"dbFieldName=TXN;dbFieldPosition=0;\"},{\"name\":\"key\",\"type\":[\"long\",\"null\"],\"meta\":\"dbFieldName=KEY;dbFieldPosition=1;\"},{\"name\":\"firstName\",\"type\":[\"string\",\"null\"],\"meta\":\"dbFieldName=FIRST_NAME;dbFieldPosition=2;\"},{\"name\":\"lastName\",\"type\":[\"string\",\"null\"],\"meta\":\"dbFieldName=LAST_NAME;dbFieldPosition=3;\"},{\"name\":\"birthDate\",\"type\":[\"long\",\"null\"],\"meta\":\"dbFieldName=BIRTH_DATE;dbFieldPosition=4;\"},{\"name\":\"deleted\",\"type\":[\"string\",\"null\"],\"meta\":\"dbFieldName=DELETED;dbFieldPosition=5;\"}],\"meta\":\"dbFieldName=sy$person;pk=key;\"}");
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus2-example/databus2-example-relay/src/main/java/com/linkedin/databus/relay/example/PersonRelayServer.java;<<<<<<< MINE
=======
     cli.parseRelayConfig();
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
import com.linkedin.databus2.core.container.request.BootstrapDatabaseTooOldException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
 * 
=======
 *
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
  
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
    
    BootstrapDBCleaner cleaner = new BootstrapDBCleaner("StandAloneCleaner", 
    													_sCleanerConfig, 
    													_sBootstrapConfig, 
    													null, 
=======
    BootstrapDBCleaner cleaner = new BootstrapDBCleaner("StandAloneCleaner",
    													_sCleanerConfig,
    													_sBootstrapConfig,
    													null,
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
    
    
    if ((null == _sSources) || (_sSources.isEmpty()))
    {
    	_sSources = getSourceNames(cleaner.getBootstrapDao().getBootstrapConn().getDBConn());
    	LOG.info("Going to run cleaner for all sources :" + _sSources);
		try
		{
			cleaner.setSources(cleaner.getBootstrapDao().getSourceIdAndStatusFromName(_sSources,false));
		} catch (BootstrapDatabaseTooOldException bto) {
			LOG.error("Not expected to receive this exception as activeCheck is turned-off", bto);
			throw new RuntimeException(bto);
		}	
    }
   
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
      
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
      
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
	  
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
              .withDescription("Comma seperated list of sourceNames. If not provided, will cleanup all sources in the bootstrap DB.")
=======
              .withDescription("Comma seperated list of sourceNames. If not provided, no source will be cleaned up")
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
      
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
      
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
      
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-utils/databus-bootstrap-utils-impl/src/main/java/com/linkedin/databus/bootstrap/utils/BootstrapDBCleanerMain.java;<<<<<<< MINE
  
=======

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerStaticConfig.java;<<<<<<< MINE
=======
    // Margin time for longest transaction.
    // When a bootstrap server needs to filter events by time, it has the timestamp T1 of the last window (say, SCN 'S1')
    // received on the client. However, it is possible that there are older events in a newer window, and vice versa. So
    // the bootstrap server streams events starting from some old timestamp T2. The server chooses T2 such that T2 < T1
    // and there are no events that meet the following criteria
    //   a. event has timestamp T < T2
    //   b. event has SCN S > S1
    // T2 is computed as (T1 - _longestDbTxnTime)
    // Default value of _longestDbTxnTimeHrs is 4 hours.
    private final long _longestDbTxnTimeMins;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerStaticConfig.java;<<<<<<< MINE
			  Map<String, Long> rowsThresholdForSnapshotBypass,
			  Map<String, Boolean> disableSnapshotBypass,
			  boolean predicatePushDown,
              Map<String, Boolean> predicatePushDownBypass,
              int queryTimeoutInSec,
              boolean enableMinScnCheck,
			  BootstrapReadOnlyConfig db) {
=======
                                       Map<String, Long> rowsThresholdForSnapshotBypass,
                                       Map<String, Boolean> disableSnapshotBypass,
                                       boolean predicatePushDown,
                                       Map<String, Boolean> predicatePushDownBypass,
                                       int queryTimeoutInSec,
                                       boolean enableMinScnCheck,
                                       BootstrapReadOnlyConfig db,
                                       long longestDbTxnTimeMins)
    {
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerStaticConfig.java;<<<<<<< MINE
=======
      this._longestDbTxnTimeMins = longestDbTxnTimeMins;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerStaticConfig.java;<<<<<<< MINE
=======
    public long getLongestDbTxnTimeMins()
    {
      return _longestDbTxnTimeMins;
    }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/StartSCNRequestProcessor.java;<<<<<<< MINE
=======

    } catch (RequestProcessingException ex) {
      LOG.error("Got exception while calculating startSCN", ex);
      throw ex;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;<<<<<<< MINE
=======
  public static final long DEFAULT_LONGEST_DB_TXN_TIME_MINS = 240;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;<<<<<<< MINE
=======
  private long longestDbTxnTimeMins = DEFAULT_LONGEST_DB_TXN_TIME_MINS;

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;<<<<<<< MINE
    return new BootstrapServerStaticConfig(
        defaultRowsThresholdForSnapshotBypass, rowsThresholdForSnapshotBypass,
        disableSnapshotBypass, predicatePushDown, predicatePushDownBypass,
        queryTimeoutInSec,enableMinScnCheck, db.build());
=======
    return new BootstrapServerStaticConfig(defaultRowsThresholdForSnapshotBypass,
                                           rowsThresholdForSnapshotBypass,
                                           disableSnapshotBypass,
                                           predicatePushDown,
                                           predicatePushDownBypass,
                                           queryTimeoutInSec,
                                           enableMinScnCheck,
                                           db.build(),
                                           longestDbTxnTimeMins);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;<<<<<<< MINE
=======
  public long getLongestDbTxnTimeMins()
  {
    return longestDbTxnTimeMins;
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;<<<<<<< MINE
=======
  public void setLongestDbTxnTimeMins(long longestDbTxnTimeMins)
  {
    this.longestDbTxnTimeMins = longestDbTxnTimeMins;
  }

>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/main/java/com/linkedin/databus/bootstrap/server/BootstrapServerConfig.java;<<<<<<< MINE
=======
    longestDbTxnTimeMins = DEFAULT_LONGEST_DB_TXN_TIME_MINS;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/test/java/com/linkedin/databus/bootstrap/server/TestBootstrapSCNProcessor.java;<<<<<<< MINE
=======
    final long longestDbTxnTimeMins = 240L;
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/test/java/com/linkedin/databus/bootstrap/server/TestBootstrapSCNProcessor.java;<<<<<<< MINE
    BootstrapServerStaticConfig bssc = new BootstrapServerStaticConfig(defaultRowsThresholdForSnapshotBypass, rowsThresholdForSnapshotBypass, disableSnapshotBypass,  predicatePushDown, predicatePushDownBypass, queryTimeoutInSec, enableMinScnCheck,db);
=======
    BootstrapServerStaticConfig bssc = new BootstrapServerStaticConfig(defaultRowsThresholdForSnapshotBypass,
                                                                       rowsThresholdForSnapshotBypass,
                                                                       disableSnapshotBypass,
                                                                       predicatePushDown,
                                                                       predicatePushDownBypass,
                                                                       queryTimeoutInSec,
                                                                       enableMinScnCheck,
                                                                       db,
                                                                       longestDbTxnTimeMins);
>>>>>>> YOURS
/home/ramdisk/experiment6/projects/databus/revisions/rev_378fe05_120c5f8/rev_378fe05-120c5f8/databus-bootstrap-server/databus-bootstrap-server-impl/src/test/java/com/linkedin/databus/bootstrap/server/TestBootstrapSCNProcessor.java;<<<<<<< MINE
    BootstrapServerStaticConfig bssc2 = new BootstrapServerStaticConfig(defaultRowsThresholdForSnapshotBypass, rowsThresholdForSnapshotBypass, disableSnapshotBypass,  predicatePushDown, predicatePushDownBypass, queryTimeoutInSec,enableMinScnCheck, db);
=======
    BootstrapServerStaticConfig bssc2 = new BootstrapServerStaticConfig(defaultRowsThresholdForSnapshotBypass,
                                                                        rowsThresholdForSnapshotBypass,
                                                                        disableSnapshotBypass,
                                                                        predicatePushDown,
                                                                        predicatePushDownBypass,
                                                                        queryTimeoutInSec,
                                                                        enableMinScnCheck,
                                                                        db,
                                                                        longestDbTxnTimeMins);
>>>>>>> YOURS
