/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_889db1c_34f4ca7/rev_889db1c-34f4ca7/src/test/java/org/elasticsearch/discovery/ZenUnicastDiscoveryTests.java;<<<<<<< MINE
    public void setUP() throws Exception {
        ElasticsearchIntegrationTest.beforeClass();
        currentNumNodes = randomIntBetween(3, 5);
        currentNumOfUnicastHosts = randomIntBetween(1, currentNumNodes);
        currentBaseHttpPort = 25000 + randomInt(100);
    }

    @Override
    protected Settings nodeSettings(int nodeOrdinal) {
        ImmutableSettings.Builder builder = ImmutableSettings.settingsBuilder()
                .put(super.nodeSettings(nodeOrdinal))
                .put("discovery.type", "zen")
                .put("discovery.zen.ping.multicast.enabled", false)
                .put("http.enabled", false); // just to make test quicker


        String[] unicastHosts = new String[currentNumOfUnicastHosts];
        if (internalCluster().getDefaultSettings().get("node.mode").equals("local")) {
            builder.put(LocalTransport.TRANSPORT_LOCAL_ADDRESS, "unicast_test_" + nodeOrdinal);
            for (int i = 0; i < unicastHosts.length; i++) {
                unicastHosts[i] = "unicast_test_" + i;
            }
        } else {
            // we need to pin the node ports so we'd know where to point things
            builder.put("transport.tcp.port", currentBaseHttpPort + nodeOrdinal);
            for (int i = 0; i < unicastHosts.length; i++) {
                unicastHosts[i] = "localhost:" + (currentBaseHttpPort + i);
            }
        }
        builder.putArray("discovery.zen.ping.unicast.hosts", unicastHosts);
        return builder.build();
=======
    public void clearConfig() {
        discoveryConfig = null;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_0662940_c8839ee/rev_0662940-c8839ee/src/main/java/org/elasticsearch/cloud/aws/InternalAwsS3Service.java;<<<<<<< MINE
    public synchronized AmazonS3 client(String endpoint, String region, String account, String key) {
        if (endpoint == null) {
=======
    public AmazonS3 client(String region, String account, String key) {
        return client(region, account, key, null);
    }

    @Override
    public synchronized AmazonS3 client(String region, String account, String key, Integer maxRetries) {
        String endpoint;
        if (region == null) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c046d2_a5ab49d/rev_7c046d2-a5ab49d/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java;<<<<<<< MINE
        protected Aggregator createUnmapped(AggregationContext aggregationContext, Aggregator parent, List<Reducer> reducers,
                Map<String, Object> metaData) throws IOException {
            final InternalAggregation aggregation = new InternalGeoHashGrid(name, requiredSize,
                    Collections.<InternalGeoHashGrid.Bucket> emptyList(), reducers, metaData);
            return new NonCollectingAggregator(name, aggregationContext, parent, reducers, metaData) {
=======
        protected Aggregator createUnmapped(AggregationContext aggregationContext, Aggregator parent, Map<String, Object> metaData) throws IOException {
            final InternalAggregation aggregation = new InternalGeoHashGrid(name, requiredSize, Collections.<InternalGeoHashGrid.Bucket>emptyList(), metaData);
            return new NonCollectingAggregator(name, aggregationContext, parent, metaData) {
                @Override
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c046d2_a5ab49d/rev_7c046d2-a5ab49d/src/main/java/org/elasticsearch/search/aggregations/metrics/percentiles/InternalPercentileRanks.java;<<<<<<< MINE
    protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed,
            List<Reducer> reducers, Map<String, Object> metaData) {
        return new InternalPercentileRanks(name, keys, merged, keyed, valueFormatter, reducers, metaData);
=======
    @Override
    protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed, Map<String, Object> metaData) {
        return new InternalPercentileRanks(name, keys, merged, keyed, valueFormatter, metaData);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c046d2_a5ab49d/rev_7c046d2-a5ab49d/src/main/java/org/elasticsearch/search/aggregations/metrics/percentiles/InternalPercentiles.java;<<<<<<< MINE
    protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed,
            List<Reducer> reducers, Map<String, Object> metaData) {
        return new InternalPercentiles(name, keys, merged, keyed, valueFormatter, reducers, metaData);
=======
    @Override
    protected AbstractInternalPercentiles createReduced(String name, double[] keys, TDigestState merged, boolean keyed, Map<String, Object> metaData) {
        return new InternalPercentiles(name, keys, merged, keyed, valueFormatter, metaData);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c046d2_a5ab49d/rev_7c046d2-a5ab49d/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/InternalTopHits.java;<<<<<<< MINE
            return new InternalTopHits(name, new InternalSearchHits(hits, reducedTopDocs.totalHits, reducedTopDocs.getMaxScore()),
                    reducers(), getMetaData());
=======
            return new InternalTopHits(name, from, size, reducedTopDocs, new InternalSearchHits(hits, reducedTopDocs.totalHits, reducedTopDocs.getMaxScore()));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_be93884_a608db1/rev_be93884-a608db1/src/main/java/org/elasticsearch/search/SearchModule.java;<<<<<<< MINE
        return ImmutableList.of(new TransportSearchModule(), new HighlightModule(), new SuggestModule(), new FunctionScoreModule(), new AggregationModule());
=======
        return ImmutableList.of(
                new SearchServiceModule(settings),
                new TransportSearchModule(),
                new HighlightModule(),
                new SuggestModule(),
                new FunctionScoreModule(),
                new AggregationModule());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/UnmappedSignificantTerms.java;<<<<<<< MINE
    public UnmappedSignificantTerms create(List<InternalSignificantTerms.Bucket> buckets) {
        return new UnmappedSignificantTerms(this.name, this.requiredSize, this.minDocCount, this.reducers(), this.metaData);
    }

    @Override
    public InternalSignificantTerms.Bucket createBucket(InternalAggregations aggregations, InternalSignificantTerms.Bucket prototype) {
        throw new UnsupportedOperationException("not supported for UnmappedSignificantTerms");
    }

    @Override
    protected UnmappedSignificantTerms create(long subsetSize, long supersetSize, List<Bucket> buckets, InternalSignificantTerms prototype) {
        throw new UnsupportedOperationException("not supported for UnmappedSignificantTerms");
    }

    @Override
    public InternalAggregation doReduce(ReduceContext reduceContext) {
        for (InternalAggregation aggregation : reduceContext.aggregations()) {
=======
    public InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
        for (InternalAggregation aggregation : aggregations) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/GlobalOrdinalsSignificantTermsAggregator.java;<<<<<<< MINE
    public GlobalOrdinalsSignificantTermsAggregator(String name, AggregatorFactories factories,
            ValuesSource.Bytes.WithOrdinals.FieldData valuesSource, BucketCountThresholds bucketCountThresholds,
            IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent,
            SignificantTermsAggregatorFactory termsAggFactory, List<Reducer> reducers, Map<String, Object> metaData) throws IOException {
=======
    public GlobalOrdinalsSignificantTermsAggregator(String name, AggregatorFactories factories, ValuesSource.Bytes.WithOrdinals.FieldData valuesSource,
                                                    BucketCountThresholds bucketCountThresholds,
                                                    IncludeExclude.OrdinalsFilter includeExclude, AggregationContext aggregationContext, Aggregator parent,
                                                    SignificantTermsAggregatorFactory termsAggFactory, Map<String, Object> metaData) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/GlobalOrdinalsSignificantTermsAggregator.java;<<<<<<< MINE
        public WithHash(String name, AggregatorFactories factories, ValuesSource.Bytes.WithOrdinals.FieldData valuesSource, BucketCountThresholds bucketCountThresholds, IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent, SignificantTermsAggregatorFactory termsAggFactory, List<Reducer> reducers, Map<String, Object> metaData) throws IOException {
            super(name, factories, valuesSource, bucketCountThresholds, includeExclude, aggregationContext, parent, termsAggFactory, reducers, metaData);
=======
        public WithHash(String name, AggregatorFactories factories, ValuesSource.Bytes.WithOrdinals.FieldData valuesSource, BucketCountThresholds bucketCountThresholds, IncludeExclude.OrdinalsFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SignificantTermsAggregatorFactory termsAggFactory, Map<String, Object> metaData) throws IOException {
            super(name, factories, valuesSource, bucketCountThresholds, includeExclude, aggregationContext, parent, termsAggFactory, metaData);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantStringTermsAggregator.java;<<<<<<< MINE
            IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent,
 SignificantTermsAggregatorFactory termsAggFactory, List<Reducer> reducers, Map<String, Object> metaData)
            throws IOException {
=======
            IncludeExclude.StringFilter includeExclude, AggregationContext aggregationContext, Aggregator parent,
            SignificantTermsAggregatorFactory termsAggFactory, Map<String, Object> metaData) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/UnmappedTerms.java;<<<<<<< MINE
    public InternalAggregation doReduce(ReduceContext reduceContext) {
        for (InternalAggregation agg : reduceContext.aggregations()) {
=======
    public InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
        for (InternalAggregation agg : aggregations) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringTermsAggregator.java;<<<<<<< MINE
 IncludeExclude includeExclude, AggregationContext aggregationContext,
            Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, List<Reducer> reducers,
            Map<String, Object> metaData) throws IOException {
=======
            IncludeExclude.StringFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, Map<String, Object> metaData) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/GlobalOrdinalsStringTermsAggregator.java;<<<<<<< MINE
                                               IncludeExclude includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException {
        super(name, factories, aggregationContext, parent, order, bucketCountThresholds, collectionMode, showTermDocCountError, reducers,
                metaData);
=======
                                               IncludeExclude.OrdinalsFilter includeExclude, AggregationContext aggregationContext, Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, Map<String, Object> metaData) throws IOException {
        super(name, factories, aggregationContext, parent, order, bucketCountThresholds, collectionMode, showTermDocCountError, metaData);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/GlobalOrdinalsStringTermsAggregator.java;<<<<<<< MINE
                        Terms.Order order, BucketCountThresholds bucketCountThresholds, IncludeExclude includeExclude, AggregationContext aggregationContext,
                        Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, List<Reducer> reducers, Map<String, Object> metaData) throws IOException {
            super(name, factories, valuesSource, order, bucketCountThresholds, includeExclude, aggregationContext, parent, collectionMode, showTermDocCountError, reducers, metaData);
=======
                        Terms.Order order, BucketCountThresholds bucketCountThresholds, IncludeExclude.OrdinalsFilter includeExclude, AggregationContext aggregationContext,
                        Aggregator parent, SubAggCollectionMode collectionMode, boolean showTermDocCountError, Map<String, Object> metaData) throws IOException {
            super(name, factories, valuesSource, order, bucketCountThresholds, includeExclude, aggregationContext, parent, collectionMode, showTermDocCountError, metaData);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/min/InternalMin.java;<<<<<<< MINE
    public InternalMin doReduce(ReduceContext reduceContext) {
=======
    public InternalMin reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/percentiles/AbstractInternalPercentiles.java;<<<<<<< MINE
    public AbstractInternalPercentiles doReduce(ReduceContext reduceContext) {
        List<InternalAggregation> aggregations = reduceContext.aggregations();
=======
    public AbstractInternalPercentiles reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/InternalExtendedStats.java;<<<<<<< MINE
    public InternalExtendedStats doReduce(ReduceContext reduceContext) {
=======
    public InternalExtendedStats reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/InternalExtendedStats.java;<<<<<<< MINE
        final InternalStats stats = super.doReduce(reduceContext);
        return new InternalExtendedStats(name, stats.getCount(), stats.getSum(), stats.getMin(), stats.getMax(), sumOfSqrs, sigma,
                valueFormatter, reducers(), getMetaData());
=======
        final InternalStats stats = super.reduce(aggregations, reduceContext);
        return new InternalExtendedStats(name, stats.getCount(), stats.getSum(), stats.getMin(), stats.getMax(), sumOfSqrs, sigma, valueFormatter, getMetaData());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/InternalStats.java;<<<<<<< MINE
    public InternalStats doReduce(ReduceContext reduceContext) {
=======
    public InternalStats reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/max/InternalMax.java;<<<<<<< MINE
    public InternalMax doReduce(ReduceContext reduceContext) {
=======
    public InternalMax reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/sum/InternalSum.java;<<<<<<< MINE
    public InternalSum doReduce(ReduceContext reduceContext) {
=======
    public InternalSum reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/avg/InternalAvg.java;<<<<<<< MINE
    public InternalAvg doReduce(ReduceContext reduceContext) {
=======
    public InternalAvg reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/InternalTopHits.java;<<<<<<< MINE
    public InternalAggregation doReduce(ReduceContext reduceContext) {
        List<InternalAggregation> aggregations = reduceContext.aggregations();
=======
    public InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/geobounds/InternalGeoBounds.java;<<<<<<< MINE
    public InternalAggregation doReduce(ReduceContext reduceContext) {
=======
    public InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/cardinality/InternalCardinality.java;<<<<<<< MINE
    public InternalAggregation doReduce(ReduceContext reduceContext) {
        List<InternalAggregation> aggregations = reduceContext.aggregations();
=======
    public InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e19d20b_fcc09f6/rev_e19d20b-fcc09f6/src/main/java/org/elasticsearch/search/aggregations/metrics/valuecount/InternalValueCount.java;<<<<<<< MINE
    public InternalAggregation doReduce(ReduceContext reduceContext) {
=======
    public InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_6ac4d6d_4f8ea78/rev_6ac4d6d-4f8ea78/src/main/java/org/elasticsearch/index/translog/Translog.java;<<<<<<< MINE
     * Returns the translog file with the given id as a Path. This
     * will return a filename.
=======
     * Returns the translog filename for the given id.
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_3bb8ff2_528f648/rev_3bb8ff2-528f648/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java;<<<<<<< MINE
    public NestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper, AggregationContext aggregationContext, Aggregator parentAggregator, List<Reducer> reducers, Map<String, Object> metaData, FilterCachingPolicy filterCachingPolicy) throws IOException {
        super(name, factories, aggregationContext, parentAggregator, reducers, metaData);
=======
    public NestedAggregator(String name, AggregatorFactories factories, ObjectMapper objectMapper, AggregationContext aggregationContext, Aggregator parentAggregator, Map<String, Object> metaData, QueryCachingPolicy filterCachingPolicy) throws IOException {
        super(name, factories, aggregationContext, parentAggregator, metaData);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_3bb8ff2_528f648/rev_3bb8ff2-528f648/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java;<<<<<<< MINE
            return new NestedAggregator(name, factories, objectMapper, context, parent, reducers, metaData, filterCachingPolicy);
=======
            return new NestedAggregator(name, factories, objectMapper, context, parent, metaData, queryCachingPolicy);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_3bb8ff2_528f648/rev_3bb8ff2-528f648/src/main/java/org/elasticsearch/search/aggregations/AggregationModule.java;<<<<<<< MINE
        aggParsers.add(AvgParser.class);
        aggParsers.add(SumParser.class);
        aggParsers.add(MinParser.class);
        aggParsers.add(MaxParser.class);
        aggParsers.add(StatsParser.class);
        aggParsers.add(ExtendedStatsParser.class);
        aggParsers.add(ValueCountParser.class);
        aggParsers.add(PercentilesParser.class);
        aggParsers.add(PercentileRanksParser.class);
        aggParsers.add(CardinalityParser.class);

        aggParsers.add(GlobalParser.class);
        aggParsers.add(MissingParser.class);
        aggParsers.add(FilterParser.class);
        aggParsers.add(FiltersParser.class);
        aggParsers.add(TermsParser.class);
        aggParsers.add(SignificantTermsParser.class);
        aggParsers.add(RangeParser.class);
        aggParsers.add(DateRangeParser.class);
        aggParsers.add(IpRangeParser.class);
        aggParsers.add(HistogramParser.class);
        aggParsers.add(DateHistogramParser.class);
        aggParsers.add(GeoDistanceParser.class);
        aggParsers.add(GeoHashGridParser.class);
        aggParsers.add(NestedParser.class);
        aggParsers.add(ReverseNestedParser.class);
        aggParsers.add(TopHitsParser.class);
        aggParsers.add(GeoBoundsParser.class);
        aggParsers.add(ScriptedMetricParser.class);
        aggParsers.add(ChildrenParser.class);

        reducerParsers.add(DerivativeParser.class);
        reducerParsers.add(MaxBucketParser.class);
        reducerParsers.add(MovAvgParser.class);
=======
        parsers.add(AvgParser.class);
        parsers.add(SumParser.class);
        parsers.add(MinParser.class);
        parsers.add(MaxParser.class);
        parsers.add(StatsParser.class);
        parsers.add(ExtendedStatsParser.class);
        parsers.add(ValueCountParser.class);
        parsers.add(PercentilesParser.class);
        parsers.add(PercentileRanksParser.class);
        parsers.add(CardinalityParser.class);

        parsers.add(GlobalParser.class);
        parsers.add(MissingParser.class);
        parsers.add(FilterParser.class);
        parsers.add(FiltersParser.class);
        parsers.add(SamplerParser.class);
        parsers.add(TermsParser.class);
        parsers.add(SignificantTermsParser.class);
        parsers.add(RangeParser.class);
        parsers.add(DateRangeParser.class);
        parsers.add(IpRangeParser.class);
        parsers.add(HistogramParser.class);
        parsers.add(DateHistogramParser.class);
        parsers.add(GeoDistanceParser.class);
        parsers.add(GeoHashGridParser.class);
        parsers.add(NestedParser.class);
        parsers.add(ReverseNestedParser.class);
        parsers.add(TopHitsParser.class);
        parsers.add(GeoBoundsParser.class);
        parsers.add(ScriptedMetricParser.class);
        parsers.add(ChildrenParser.class);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_d596f5c_23ac32e/rev_d596f5c-23ac32e/src/main/java/org/elasticsearch/index/engine/EngineConfig.java;<<<<<<< MINE
    public EngineConfig(ShardId shardId, ThreadPool threadPool, ShardIndexingService indexingService, IndexSettingsService indexSettingsService, IndicesWarmer warmer, Store store, SnapshotDeletionPolicy deletionPolicy, MergePolicyProvider mergePolicyProvider, MergeSchedulerProvider mergeScheduler, Analyzer analyzer, Similarity similarity, CodecService codecService, Engine.FailedEngineListener failedEngineListener, TranslogRecoveryPerformer translogRecoveryPerformer) {
=======
    public EngineConfig(ShardId shardId, ThreadPool threadPool, ShardIndexingService indexingService,
            IndexSettingsService indexSettingsService, IndicesWarmer warmer, Store store, SnapshotDeletionPolicy deletionPolicy,
            Translog translog, MergePolicyProvider mergePolicyProvider, MergeSchedulerProvider mergeScheduler, Analyzer analyzer,
            Similarity similarity, CodecService codecService, Engine.FailedEngineListener failedEngineListener,
            TranslogRecoveryPerformer translogRecoveryPerformer, QueryCache filterCache, QueryCachingPolicy filterCachingPolicy) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_d596f5c_23ac32e/rev_d596f5c-23ac32e/src/main/java/org/elasticsearch/index/engine/EngineConfig.java;<<<<<<< MINE
        this.ignoreUnknownTranslog = indexSettings.getAsBoolean(INDEX_IGNORE_UNKNOWN_TRANSLOG, false);
=======
        this.filterCache = filterCache;
        this.filterCachingPolicy = filterCachingPolicy;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_fc73540_97ffb2b/rev_fc73540-97ffb2b/src/test/java/org/elasticsearch/test/rest/test/FileUtilsTests.java;<<<<<<< MINE
        yamlSuites = FileUtils.findYamlSuites("/rest-api-spec/test", "get/10_basic.yaml");
=======
        yamlSuites = FileUtils.findYamlSuites(null, "/rest-api-spec/test", "get/10_basic.yaml");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_fc73540_97ffb2b/rev_fc73540-97ffb2b/src/test/java/org/elasticsearch/test/rest/test/FileUtilsTests.java;<<<<<<< MINE
        yamlSuites = FileUtils.findYamlSuites("/rest-api-spec/test", "get/10_basic");
=======
        yamlSuites = FileUtils.findYamlSuites(null, "/rest-api-spec/test", "get/10_basic");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_fc73540_97ffb2b/rev_fc73540-97ffb2b/src/test/java/org/elasticsearch/test/rest/test/FileUtilsTests.java;<<<<<<< MINE
        yamlSuites = FileUtils.findYamlSuites("/rest-api-spec/test", "get", "index");
=======
        yamlSuites = FileUtils.findYamlSuites(null, "/rest-api-spec/test", "get", "index");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_fc73540_97ffb2b/rev_fc73540-97ffb2b/src/test/java/org/elasticsearch/test/rest/test/FileUtilsTests.java;<<<<<<< MINE
        yamlSuites = FileUtils.findYamlSuites("/rest-api-spec/test", "indices.optimize/10_basic", "index");
=======
        yamlSuites = FileUtils.findYamlSuites(null, "/rest-api-spec/test", "indices.optimize/10_basic", "index");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_fc73540_97ffb2b/rev_fc73540-97ffb2b/src/test/java/org/elasticsearch/test/rest/test/FileUtilsTests.java;<<<<<<< MINE
        yamlSuites = FileUtils.findYamlSuites("/rest-api-spec/test", "get/10_basic", dir.toAbsolutePath().toString());
=======
        yamlSuites = FileUtils.findYamlSuites(dir.getFileSystem(), "/rest-api-spec/test", dir.toAbsolutePath().toString());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_fc73540_97ffb2b/rev_fc73540-97ffb2b/src/test/java/org/elasticsearch/test/rest/test/FileUtilsTests.java;<<<<<<< MINE
        assertThat(yamlSuites.size(), equalTo(2));
        assertThat(yamlSuites.containsKey("get"), equalTo(true));
        assertThat(yamlSuites.get("get").size(), equalTo(1));
        assertSingleFile(yamlSuites.get("get"), "get", "10_basic.yaml");
=======
        assertThat(yamlSuites.size(), equalTo(1));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_fc73540_97ffb2b/rev_fc73540-97ffb2b/src/test/java/org/elasticsearch/test/rest/test/FileUtilsTests.java;<<<<<<< MINE
        yamlSuites = FileUtils.findYamlSuites("/rest-api-spec/test", "get/10_basic", dir.resolve("test_loading").toAbsolutePath().toString());
=======
        yamlSuites = FileUtils.findYamlSuites(dir.getFileSystem(), "/rest-api-spec/test", dir.resolve("test_loading").toAbsolutePath().toString());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_fc73540_97ffb2b/rev_fc73540-97ffb2b/src/test/java/org/elasticsearch/test/rest/test/FileUtilsTests.java;<<<<<<< MINE
        assertThat(yamlSuites.size(), equalTo(2));
        assertThat(yamlSuites.containsKey("get"), equalTo(true));
        assertThat(yamlSuites.get("get").size(), equalTo(1));
        assertSingleFile(yamlSuites.get("get"), "get", "10_basic.yaml");
=======
        assertThat(yamlSuites.size(), equalTo(1));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b2e63bd_5a0c456/rev_b2e63bd-5a0c456/src/main/java/org/elasticsearch/index/query/RangeQueryParser.java;<<<<<<< MINE
        RangeQueryBuilder rangeQuery = new RangeQueryBuilder(fieldName);
        rangeQuery.from(from)
            .to(to)
            .includeLower(includeLower)
            .includeUpper(includeUpper)
            .timeZone(timeZone)
            .boost(boost)
            .queryName(queryName)
            .format(format);
        rangeQuery.validate();
        return rangeQuery;
=======
        Query query = null;
        FieldMapper mapper = parseContext.fieldMapper(fieldName);
        if (mapper != null) {
            if (mapper instanceof DateFieldMapper) {
                if ((from instanceof Number || to instanceof Number) && timeZone != null) {
                    throw new QueryParsingException(parseContext,
                            "[range] time_zone when using ms since epoch format as it's UTC based can not be applied to [" + fieldName
                                    + "]");
                }
                query = ((DateFieldMapper) mapper).rangeQuery(from, to, includeLower, includeUpper, timeZone, forcedDateParser, parseContext);
            } else  {
                if (timeZone != null) {
                    throw new QueryParsingException(parseContext, "[range] time_zone can not be applied to non date field ["
                            + fieldName + "]");
                }
                //LUCENE 4 UPGRADE Mapper#rangeQuery should use bytesref as well?
                query = mapper.rangeQuery(from, to, includeLower, includeUpper, parseContext);
            }
        }
        if (query == null) {
            query = new TermRangeQuery(fieldName, BytesRefs.toBytesRef(from), BytesRefs.toBytesRef(to), includeLower, includeUpper);
        }
        query.setBoost(boost);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
        return query;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b2e63bd_5a0c456/rev_b2e63bd-5a0c456/src/main/java/org/elasticsearch/index/query/TermQueryParser.java;<<<<<<< MINE
        TermQueryBuilder termQuery = new TermQueryBuilder(fieldName, value);
        if (boost != 1.0f) {
            termQuery.boost(boost);
=======
        if (value == null) {
            throw new QueryParsingException(parseContext, "No value specified for term query");
        }

        Query query = null;
        FieldMapper mapper = parseContext.fieldMapper(fieldName);
        if (mapper != null) {
            query = mapper.termQuery(value, parseContext);
        }
        if (query == null) {
            query = new TermQuery(new Term(fieldName, BytesRefs.toBytesRef(value)));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b2e63bd_5a0c456/rev_b2e63bd-5a0c456/src/main/java/org/elasticsearch/index/query/SpanTermQueryParser.java;<<<<<<< MINE
        SpanTermQueryBuilder result = new SpanTermQueryBuilder(fieldName, value);
        result.boost(boost).queryName(queryName);
        result.validate();
        return result;
=======
        BytesRef valueBytes = null;
        FieldMapper mapper = parseContext.fieldMapper(fieldName);
        if (mapper != null) {
            fieldName = mapper.names().indexName();
            valueBytes = mapper.indexedValueForSearch(value);
        }
        if (valueBytes == null) {
            valueBytes = new BytesRef(value);
        }

        SpanTermQuery query = new SpanTermQuery(new Term(fieldName, valueBytes));
        query.setBoost(boost);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
        return query;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b1f6d1a_39a20c3/rev_b1f6d1a-39a20c3/src/main/java/org/elasticsearch/index/query/RangeQueryParser.java;<<<<<<< MINE
                            format = parser.text();
=======
                            forcedDateParser = new DateMathParser(Joda.forPattern(parser.text()));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b1f6d1a_39a20c3/rev_b1f6d1a-39a20c3/src/main/java/org/elasticsearch/index/query/RangeQueryParser.java;<<<<<<< MINE
        RangeQueryBuilder rangeQuery = new RangeQueryBuilder(fieldName);
        rangeQuery.from(from)
            .to(to)
            .includeLower(includeLower)
            .includeUpper(includeUpper)
            .timeZone(timeZone)
            .boost(boost)
            .queryName(queryName)
            .format(format);
        rangeQuery.validate();
        return rangeQuery;
    }

    @Override
    public RangeQueryBuilder getBuilderPrototype() {
        return RangeQueryBuilder.PROTOTYPE;
=======
        Query query = null;
        FieldMapper mapper = parseContext.fieldMapper(fieldName);
        if (mapper != null) {
            if (mapper instanceof DateFieldMapper) {
                query = ((DateFieldMapper) mapper).fieldType().rangeQuery(from, to, includeLower, includeUpper, timeZone, forcedDateParser, parseContext);
            } else  {
                if (timeZone != null) {
                    throw new QueryParsingException(parseContext, "[range] time_zone can not be applied to non date field ["
                            + fieldName + "]");
                }
                //LUCENE 4 UPGRADE Mapper#rangeQuery should use bytesref as well?
                query = mapper.rangeQuery(from, to, includeLower, includeUpper, parseContext);
            }
        }
        if (query == null) {
            query = new TermRangeQuery(fieldName, BytesRefs.toBytesRef(from), BytesRefs.toBytesRef(to), includeLower, includeUpper);
        }
        query.setBoost(boost);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
        return query;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b1f6d1a_39a20c3/rev_b1f6d1a-39a20c3/src/main/java/org/elasticsearch/index/query/SpanTermQueryParser.java;<<<<<<< MINE
        SpanTermQueryBuilder result = new SpanTermQueryBuilder(fieldName, value);
        result.boost(boost).queryName(queryName);
        result.validate();
        return result;
    }
=======
        BytesRef valueBytes = null;
        FieldMapper mapper = parseContext.fieldMapper(fieldName);
        if (mapper != null) {
            fieldName = mapper.fieldType().names().indexName();
            valueBytes = mapper.indexedValueForSearch(value);
        }
        if (valueBytes == null) {
            valueBytes = new BytesRef(value);
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_dae9750_a138f62/rev_dae9750-a138f62/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java;<<<<<<< MINE
     *
     * If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index cannot be
=======
     * <p/>
     * If the index does need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index cannot be
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_71f84b3_49bef19/rev_71f84b3-49bef19/core/src/main/java/org/elasticsearch/index/query/SpanTermQueryParser.java;<<<<<<< MINE
        SpanTermQueryBuilder result = new SpanTermQueryBuilder(fieldName, value);
        result.boost(boost).queryName(queryName);
        result.validate();
        return result;
    }
=======
        BytesRef valueBytes = null;
        MappedFieldType fieldType = parseContext.fieldMapper(fieldName);
        if (fieldType != null) {
            fieldName = fieldType.names().indexName();
            valueBytes = fieldType.indexedValueForSearch(value);
        }
        if (valueBytes == null) {
            valueBytes = new BytesRef(value);
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_71f84b3_49bef19/rev_71f84b3-49bef19/core/src/main/java/org/elasticsearch/index/query/TermQueryParser.java;<<<<<<< MINE
        TermQueryBuilder termQuery = new TermQueryBuilder(fieldName, value);
        if (boost != 1.0f) {
            termQuery.boost(boost);
=======
        if (value == null) {
            throw new QueryParsingException(parseContext, "No value specified for term query");
        }

        Query query = null;
        MappedFieldType fieldType = parseContext.fieldMapper(fieldName);
        if (fieldType != null) {
            query = fieldType.termQuery(value, parseContext);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_71f84b3_49bef19/rev_71f84b3-49bef19/core/src/main/java/org/elasticsearch/index/query/RangeQueryParser.java;<<<<<<< MINE
        RangeQueryBuilder rangeQuery = new RangeQueryBuilder(fieldName);
        rangeQuery.from(from)
            .to(to)
            .includeLower(includeLower)
            .includeUpper(includeUpper)
            .timeZone(timeZone)
            .boost(boost)
            .queryName(queryName)
            .format(format);
        rangeQuery.validate();
        return rangeQuery;
    }

    @Override
    public RangeQueryBuilder getBuilderPrototype() {
        return RangeQueryBuilder.PROTOTYPE;
=======
        Query query = null;
        MappedFieldType mapper = parseContext.fieldMapper(fieldName);
        if (mapper != null) {
            if (mapper instanceof DateFieldMapper.DateFieldType) {
                query = ((DateFieldMapper.DateFieldType) mapper).rangeQuery(from, to, includeLower, includeUpper, timeZone, forcedDateParser, parseContext);
            } else  {
                if (timeZone != null) {
                    throw new QueryParsingException(parseContext, "[range] time_zone can not be applied to non date field ["
                            + fieldName + "]");
                }
                //LUCENE 4 UPGRADE Mapper#rangeQuery should use bytesref as well?
                query = mapper.rangeQuery(from, to, includeLower, includeUpper, parseContext);
            }
        }
        if (query == null) {
            query = new TermRangeQuery(fieldName, BytesRefs.toBytesRef(from), BytesRefs.toBytesRef(to), includeLower, includeUpper);
        }
        query.setBoost(boost);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
        return query;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_9210aea_9e19090/rev_9210aea-9e19090/core/src/main/java/org/elasticsearch/index/shard/ShadowIndexShard.java;<<<<<<< MINE
                            ShardGetService getService, ShardSearchService searchService,
=======
                            ShardSearchService searchService,
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_9210aea_9e19090/rev_9210aea-9e19090/core/src/main/java/org/elasticsearch/index/shard/ShadowIndexShard.java;<<<<<<< MINE
                indexingService, getService, searchService, shardWarmerService, shardFilterCache,
=======
                indexingService, searchService, shardWarmerService, shardFilterCache,
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_11492b8_cdd1325/rev_11492b8-cdd1325/core/src/main/java/org/elasticsearch/index/query/ExistsQueryParser.java;<<<<<<< MINE
    @Override
    public ExistsQueryBuilder getBuilderPrototype() {
        return ExistsQueryBuilder.PROTOTYPE;
=======
    public static Query newFilter(QueryParseContext parseContext, String fieldPattern, String queryName) {
        final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType)parseContext.mapperService().fullName(FieldNamesFieldMapper.NAME);
        if (fieldNamesFieldType == null) {
            // can only happen when no types exist, so no docs exist either
            return Queries.newMatchNoDocsQuery();
        }

        ObjectMapper objectMapper = parseContext.getObjectMapper(fieldPattern);
        if (objectMapper != null) {
            // automatic make the object mapper pattern
            fieldPattern = fieldPattern + ".*";
        }

        Collection<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);
        if (fields.isEmpty()) {
            // no fields exists, so we should not match anything
            return Queries.newMatchNoDocsQuery();
        }

        BooleanQuery boolFilter = new BooleanQuery();
        for (String field : fields) {
            MappedFieldType fieldType = parseContext.fieldMapper(field);
            Query filter = null;
            if (fieldNamesFieldType.isEnabled()) {
                final String f;
                if (fieldType != null) {
                    f = fieldType.names().indexName();
                } else {
                    f = field;
                }
                filter = fieldNamesFieldType.termQuery(f, parseContext);
            }
            // if _field_names are not indexed, we need to go the slow way
            if (filter == null && fieldType != null) {
                filter = fieldType.rangeQuery(null, null, true, true, parseContext);
            }
            if (filter == null) {
                filter = new TermRangeQuery(field, null, null, true, true);
            }
            boolFilter.add(filter, BooleanClause.Occur.SHOULD);
        }

        if (queryName != null) {
            parseContext.addNamedQuery(queryName, boolFilter);
        }
        return new ConstantScoreQuery(boolFilter);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_33668a8_f4a143d/rev_33668a8-f4a143d/core/src/main/java/org/elasticsearch/index/query/RegexpQueryBuilder.java;<<<<<<< MINE
        builder.startObject(NAME);
        if (boost == -1 && rewrite == null && queryName != null) {
            builder.field(name, regexp);
        } else {
            builder.startObject(name);
            builder.field("value", regexp);
            if (flags != -1) {
                builder.field("flags_value", flags);
            }
            if (maxDetermizedStatesSet) {
                builder.field("max_determinized_states", maxDeterminizedStates);
            }
            if (boost != -1) {
                builder.field("boost", boost);
            }
            if (rewrite != null) {
                builder.field("rewrite", rewrite);
            }
            if (queryName != null) {
                builder.field("name", queryName);
            }
            builder.endObject();
=======
        builder.startObject(RegexpQueryParser.NAME);
        builder.startObject(name);
        builder.field("value", regexp);
        if (flags != -1) {
            builder.field("flags_value", flags);
        }
        if (maxDetermizedStatesSet) {
            builder.field("max_determinized_states", maxDeterminizedStates);
        }
        if (boost != -1) {
            builder.field("boost", boost);
        }
        if (rewrite != null) {
            builder.field("rewrite", rewrite);
        }
        if (queryName != null) {
            builder.field("_name", queryName);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_9d47e80_f5f7325/rev_9d47e80-f5f7325/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java;<<<<<<< MINE
    public boolean doEquals(RangeQueryBuilder other) {
        return Objects.equals(fieldName, other.fieldName) &&
               Objects.equals(from, other.from) &&
               Objects.equals(to, other.to) &&
               Objects.equals(timeZone, other.timeZone) &&
               Objects.equals(includeLower, other.includeLower) &&
               Objects.equals(includeUpper, other.includeUpper) &&
               Objects.equals(boost, other.boost) &&
               Objects.equals(queryName, other.queryName) &&
               Objects.equals(format, other.format);
=======
    protected void doXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject(RangeQueryParser.NAME);
        builder.startObject(name);
        builder.field("from", from);
        builder.field("to", to);
        if (timeZone != null) {
            builder.field("time_zone", timeZone);
        }
        if (format != null) {
            builder.field("format", format);
        }
        builder.field("include_lower", includeLower);
        builder.field("include_upper", includeUpper);
        if (boost != -1) {
            builder.field("boost", boost);
        }
        builder.endObject();
        if (queryName != null) {
            builder.field("_name", queryName);
        }
        builder.endObject();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_88e3d6c_90f32d4/rev_88e3d6c-90f32d4/core/src/main/java/org/elasticsearch/index/query/ConstantScoreQueryParser.java;<<<<<<< MINE
                if (INNER_QUERY_FIELD.match(currentFieldName)) {
                    query = parseContext.parseInnerFilterToQueryBuilder();
=======
                if (parseContext.parseFieldMatcher().match(currentFieldName, INNER_QUERY_FIELD)) {
                    filter = parseContext.parseInnerFilter();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_88e3d6c_90f32d4/rev_88e3d6c-90f32d4/core/src/main/java/org/elasticsearch/index/query/NotQueryParser.java;<<<<<<< MINE
                if (QUERY_FIELD.match(currentFieldName)) {
                    query = parseContext.parseInnerFilterToQueryBuilder();
=======
                if (parseContext.parseFieldMatcher().match(currentFieldName, QUERY_FIELD)) {
                    query = parseContext.parseInnerFilter();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8776463_219f481/rev_8776463-219f481/core/src/main/java/org/elasticsearch/index/query/ExistsQueryParser.java;<<<<<<< MINE
    @Override
    public ExistsQueryBuilder getBuilderPrototype() {
        return ExistsQueryBuilder.PROTOTYPE;
=======
    public static Query newFilter(QueryParseContext parseContext, String fieldPattern, String queryName) {
        final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType)parseContext.mapperService().fullName(FieldNamesFieldMapper.NAME);
        if (fieldNamesFieldType == null) {
            // can only happen when no types exist, so no docs exist either
            return Queries.newMatchNoDocsQuery();
        }

        ObjectMapper objectMapper = parseContext.getObjectMapper(fieldPattern);
        if (objectMapper != null) {
            // automatic make the object mapper pattern
            fieldPattern = fieldPattern + ".*";
        }

        Collection<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);
        if (fields.isEmpty()) {
            // no fields exists, so we should not match anything
            return Queries.newMatchNoDocsQuery();
        }

        BooleanQuery boolFilter = new BooleanQuery();
        for (String field : fields) {
            MappedFieldType fieldType = parseContext.fieldMapper(field);
            Query filter = null;
            if (fieldNamesFieldType.isEnabled()) {
                final String f;
                if (fieldType != null) {
                    f = fieldType.names().indexName();
                } else {
                    f = field;
                }
                filter = fieldNamesFieldType.termQuery(f, parseContext);
            }
            // if _field_names are not indexed, we need to go the slow way
            if (filter == null && fieldType != null) {
                filter = fieldType.rangeQuery(null, null, true, true);
            }
            if (filter == null) {
                filter = new TermRangeQuery(field, null, null, true, true);
            }
            boolFilter.add(filter, BooleanClause.Occur.SHOULD);
        }

        if (queryName != null) {
            parseContext.addNamedQuery(queryName, boolFilter);
        }
        return new ConstantScoreQuery(boolFilter);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8776463_219f481/rev_8776463-219f481/core/src/main/java/org/elasticsearch/index/query/MissingQueryParser.java;<<<<<<< MINE
    @Override
    public MissingQueryBuilder getBuilderPrototype() {
        return MissingQueryBuilder.PROTOTYPE;
=======
    public static Query newFilter(QueryParseContext parseContext, String fieldPattern, boolean existence, boolean nullValue, String queryName) {
        if (!existence && !nullValue) {
            throw new QueryParsingException(parseContext, "missing must have either existence, or null_value, or both set to true");
        }

        final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType)parseContext.mapperService().fullName(FieldNamesFieldMapper.NAME);
        if (fieldNamesFieldType == null) {
            // can only happen when no types exist, so no docs exist either
            return Queries.newMatchNoDocsQuery();
        }

        ObjectMapper objectMapper = parseContext.getObjectMapper(fieldPattern);
        if (objectMapper != null) {
            // automatic make the object mapper pattern
            fieldPattern = fieldPattern + ".*";
        }

        Collection<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);
        if (fields.isEmpty()) {
            if (existence) {
                // if we ask for existence of fields, and we found none, then we should match on all
                return Queries.newMatchAllQuery();
            }
            return null;
        }

        Query existenceFilter = null;
        Query nullFilter = null;

        if (existence) {
            BooleanQuery boolFilter = new BooleanQuery();
            for (String field : fields) {
                MappedFieldType fieldType = parseContext.fieldMapper(field);
                Query filter = null;
                if (fieldNamesFieldType.isEnabled()) {
                    final String f;
                    if (fieldType != null) {
                        f = fieldType.names().indexName();
                    } else {
                        f = field;
                    }
                    filter = fieldNamesFieldType.termQuery(f, parseContext);
                }
                // if _field_names are not indexed, we need to go the slow way
                if (filter == null && fieldType != null) {
                    filter = fieldType.rangeQuery(null, null, true, true);
                }
                if (filter == null) {
                    filter = new TermRangeQuery(field, null, null, true, true);
                }
                boolFilter.add(filter, BooleanClause.Occur.SHOULD);
            }

            existenceFilter = boolFilter;
            existenceFilter = Queries.not(existenceFilter);;
        }

        if (nullValue) {
            for (String field : fields) {
                MappedFieldType fieldType = parseContext.fieldMapper(field);
                if (fieldType != null) {
                    nullFilter = fieldType.nullValueQuery();
                }
            }
        }

        Query filter;
        if (nullFilter != null) {
            if (existenceFilter != null) {
                BooleanQuery combined = new BooleanQuery();
                combined.add(existenceFilter, BooleanClause.Occur.SHOULD);
                combined.add(nullFilter, BooleanClause.Occur.SHOULD);
                // cache the not filter as well, so it will be faster
                filter = combined;
            } else {
                filter = nullFilter;
            }
        } else {
            filter = existenceFilter;
        }

        if (filter == null) {
            return null;
        }

        if (queryName != null) {
            parseContext.addNamedQuery(queryName, existenceFilter);
        }
        return new ConstantScoreQuery(filter);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8776463_219f481/rev_8776463-219f481/core/src/main/java/org/elasticsearch/index/query/RangeQueryParser.java;<<<<<<< MINE
        RangeQueryBuilder rangeQuery = new RangeQueryBuilder(fieldName);
        rangeQuery.from(from);
        rangeQuery.to(to);
        rangeQuery.includeLower(includeLower);
        rangeQuery.includeUpper(includeUpper);
        rangeQuery.timeZone(timeZone);
        rangeQuery.boost(boost);
        rangeQuery.queryName(queryName);
        rangeQuery.format(format);
        return rangeQuery;
    }

    @Override
    public RangeQueryBuilder getBuilderPrototype() {
        return RangeQueryBuilder.PROTOTYPE;
=======
        Query query = null;
        MappedFieldType mapper = parseContext.fieldMapper(fieldName);
        if (mapper != null) {
            if (mapper instanceof DateFieldMapper.DateFieldType) {
                query = ((DateFieldMapper.DateFieldType) mapper).rangeQuery(from, to, includeLower, includeUpper, timeZone, forcedDateParser);
            } else  {
                if (timeZone != null) {
                    throw new QueryParsingException(parseContext, "[range] time_zone can not be applied to non date field ["
                            + fieldName + "]");
                }
                //LUCENE 4 UPGRADE Mapper#rangeQuery should use bytesref as well?
                query = mapper.rangeQuery(from, to, includeLower, includeUpper);
            }
        }
        if (query == null) {
            query = new TermRangeQuery(fieldName, BytesRefs.toBytesRef(from), BytesRefs.toBytesRef(to), includeLower, includeUpper);
        }
        query.setBoost(boost);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
        return query;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_99398ad_caca13c/rev_99398ad-caca13c/core/src/test/java/org/elasticsearch/test/transport/AssertingLocalTransport.java;<<<<<<< MINE
    public AssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version, NamedWriteableRegistry namedWriteableRegistry) {
        super(settings, threadPool, version, namedWriteableRegistry);
        final long seed = settings.getAsLong(ElasticsearchIntegrationTest.SETTING_INDEX_SEED, 0l);
=======
    public AssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version) {
        super(settings, threadPool, version);
        final long seed = settings.getAsLong(ESIntegTestCase.SETTING_INDEX_SEED, 0l);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java;<<<<<<< MINE
    public void writeIntArray(int[] value) throws IOException {
        writeVInt(value.length);
        for (int i=0; i<value.length; i++) {
            writeInt(value[i]);
=======
    public void writeIntArray(int[] values) throws IOException {
        writeVInt(values.length);
        for (int value : values) {
            writeInt(value);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java;<<<<<<< MINE
    public void writeLongArray(long[] value) throws IOException {
        writeVInt(value.length);
        for (int i=0; i<value.length; i++) {
            writeLong(value[i]);
=======
    public void writeLongArray(long[] values) throws IOException {
        writeVInt(values.length);
        for (long value : values) {
            writeLong(value);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java;<<<<<<< MINE
    public void writeFloatArray(float[] value) throws IOException {
        writeVInt(value.length);
        for (int i=0; i<value.length; i++) {
            writeFloat(value[i]);
=======
    public void writeFloatArray(float[] values) throws IOException {
        writeVInt(values.length);
        for (float value : values) {
            writeFloat(value);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java;<<<<<<< MINE
    public void writeDoubleArray(double[] value) throws IOException {
        writeVInt(value.length);
        for (int i=0; i<value.length; i++) {
            writeDouble(value[i]);
=======
    public void writeDoubleArray(double[] values) throws IOException {
        writeVInt(values.length);
        for (double value : values) {
            writeDouble(value);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/test/transport/AssertingLocalTransport.java;<<<<<<< MINE
    public AssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version) {
        super(settings, threadPool, version);
=======
    public AssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version, NamedWriteableRegistry namedWriteableRegistry) {
        super(settings, threadPool, version, namedWriteableRegistry);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/benchmark/transport/BenchmarkNettyLargeMessages.java;<<<<<<< MINE
                new NettyTransport(settings, threadPool, networkService, BigArrays.NON_RECYCLING_INSTANCE, Version.CURRENT), threadPool
=======
                new NettyTransport(settings, threadPool, networkService, BigArrays.NON_RECYCLING_INSTANCE, Version.CURRENT, new NamedWriteableRegistry()), threadPool
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/benchmark/transport/BenchmarkNettyLargeMessages.java;<<<<<<< MINE
                new NettyTransport(settings, threadPool, networkService, BigArrays.NON_RECYCLING_INSTANCE, Version.CURRENT), threadPool
=======
                new NettyTransport(settings, threadPool, networkService, BigArrays.NON_RECYCLING_INSTANCE, Version.CURRENT, new NamedWriteableRegistry()), threadPool
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/benchmark/transport/TransportBenchmark.java;<<<<<<< MINE
                return new LocalTransport(settings, threadPool, Version.CURRENT);
=======
                return new LocalTransport(settings, threadPool, Version.CURRENT, new NamedWriteableRegistry());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/benchmark/transport/TransportBenchmark.java;<<<<<<< MINE
                return new NettyTransport(settings, threadPool, new NetworkService(Settings.EMPTY), BigArrays.NON_RECYCLING_INSTANCE, Version.CURRENT);
=======
                return new NettyTransport(settings, threadPool, new NetworkService(Settings.EMPTY), BigArrays.NON_RECYCLING_INSTANCE, Version.CURRENT, new NamedWriteableRegistry());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/transport/local/SimpleLocalTransportTests.java;<<<<<<< MINE
    protected MockTransportService build(Settings settings, Version version) {
        MockTransportService transportService = new MockTransportService(Settings.EMPTY, new LocalTransport(settings, threadPool, version), threadPool);
=======
    protected MockTransportService build(Settings settings, Version version, NamedWriteableRegistry namedWriteableRegistry) {
        MockTransportService transportService = new MockTransportService(Settings.EMPTY, new LocalTransport(settings, threadPool, version, namedWriteableRegistry), threadPool);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/transport/netty/SimpleNettyTransportTests.java;<<<<<<< MINE
    protected MockTransportService build(Settings settings, Version version) {
=======
    protected MockTransportService build(Settings settings, Version version, NamedWriteableRegistry namedWriteableRegistry) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportIT.java;<<<<<<< MINE
        public ExceptionThrowingNettyTransport(Settings settings, ThreadPool threadPool, NetworkService networkService, BigArrays bigArrays, Version version) {
            super(settings, threadPool, networkService, bigArrays, version);
=======
        public ExceptionThrowingNettyTransport(Settings settings, ThreadPool threadPool, NetworkService networkService, BigArrays bigArrays, Version version, NamedWriteableRegistry namedWriteableRegistry) {
            super(settings, threadPool, networkService, bigArrays, version, namedWriteableRegistry);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_b763265_6f13171/rev_b763265-6f13171/core/src/test/java/org/elasticsearch/plugins/PluggableTransportModuleIT.java;<<<<<<< MINE
        public CountingAssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version) {
            super(settings, threadPool, version);
=======
        public CountingAssertingLocalTransport(Settings settings, ThreadPool threadPool, Version version, NamedWriteableRegistry namedWriteableRegistry) {
            super(settings, threadPool, version, namedWriteableRegistry);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8ac439f_4010e7e/rev_8ac439f-4010e7e/core/src/main/java/org/elasticsearch/index/query/TermsQueryBuilder.java;<<<<<<< MINE
     * Sets the index name to lookup the terms from.
     */
    public TermsQueryBuilder lookupIndex(String lookupIndex) {
        this.lookupIndex = lookupIndex;
        return this;
    }

    /**
     * Sets the index type to lookup the terms from.
=======
     * Sets the minimum number of matches across the provided terms. Defaults to <tt>1</tt>.
     * @deprecated use [bool] query instead
     */
    @Deprecated
    public TermsQueryBuilder minimumShouldMatch(String minimumShouldMatch) {
        this.minimumShouldMatch = minimumShouldMatch;
        return this;
    }

    /**
     * Disables <tt>Similarity#coord(int,int)</tt> in scoring. Defaults to <tt>false</tt>.
     * @deprecated use [bool] query instead
     */
    @Deprecated
    public TermsQueryBuilder disableCoord(boolean disableCoord) {
        this.disableCoord = disableCoord;
        return this;
    }

    /**
     * Sets the filter name for the filter that can be used when searching for matched_filters per hit.
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8ac439f_4010e7e/rev_8ac439f-4010e7e/core/src/main/java/org/elasticsearch/index/query/TermsQueryBuilder.java;<<<<<<< MINE
        printBoostAndQueryName(builder);
        builder.endObject();
    }
=======
        if (minimumShouldMatch != null) {
            builder.field("minimum_should_match", minimumShouldMatch);
        }

        if (disableCoord != null) {
            builder.field("disable_coord", disableCoord);
        }

        if (boost != -1) {
            builder.field("boost", boost);
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8ac439f_4010e7e/rev_8ac439f-4010e7e/core/src/main/java/org/elasticsearch/index/query/TermsLookupQueryBuilder.java;<<<<<<< MINE
        super(name, (Object[]) null);
    }

=======
        this.name = name;
    }

    /**
     * Sets the filter name for the filter that can be used when searching for matched_filters per hit.
     */
    public TermsLookupQueryBuilder queryName(String queryName) {
        this.queryName = queryName;
        return this;
    }

    /**
     * Sets the index name to lookup the terms from.
     */
    public TermsLookupQueryBuilder lookupIndex(String lookupIndex) {
        this.lookupIndex = lookupIndex;
        return this;
    }

    /**
     * Sets the index type to lookup the terms from.
     */
    public TermsLookupQueryBuilder lookupType(String lookupType) {
        this.lookupType = lookupType;
        return this;
    }

    /**
     * Sets the doc id to lookup the terms from.
     */
    public TermsLookupQueryBuilder lookupId(String lookupId) {
        this.lookupId = lookupId;
        return this;
    }

    /**
     * Sets the path within the document to lookup the terms from.
     */
    public TermsLookupQueryBuilder lookupPath(String lookupPath) {
        this.lookupPath = lookupPath;
        return this;
    }

    public TermsLookupQueryBuilder lookupRouting(String lookupRouting) {
        this.lookupRouting = lookupRouting;
        return this;
    }

>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8ac439f_4010e7e/rev_8ac439f-4010e7e/core/src/main/java/org/elasticsearch/index/query/TermsLookupQueryBuilder.java;<<<<<<< MINE
    public String getWriteableName() {
        return TermsQueryBuilder.NAME;
=======
    public void doXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject(TermsQueryParser.NAME);

        builder.startObject(name);
        if (lookupIndex != null) {
            builder.field("index", lookupIndex);
        }
        builder.field("type", lookupType);
        builder.field("id", lookupId);
        if (lookupRouting != null) {
            builder.field("routing", lookupRouting);
        }
        builder.field("path", lookupPath);
        builder.endObject();

        if (queryName != null) {
            builder.field("_name", queryName);
        }

        builder.endObject();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_260a929_34635a4/rev_260a929-34635a4/core/src/main/java/org/elasticsearch/index/query/GeoPolygonQueryParser.java;<<<<<<< MINE
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("normalize".equals(currentFieldName)) {
                    normalizeLat = parser.booleanValue();
                    normalizeLon = parser.booleanValue();
=======
                } else if ("coerce".equals(currentFieldName) || (indexCreatedBeforeV2_0 && "normalize".equals(currentFieldName))) {
                    coerce = parser.booleanValue();
                    if (coerce == true) {
                        ignoreMalformed = true;
                    }
                } else if ("ignore_malformed".equals(currentFieldName) && coerce == false) {
                    ignoreMalformed = parser.booleanValue();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_260a929_34635a4/rev_260a929-34635a4/core/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryParser.java;<<<<<<< MINE
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("normalize".equals(currentFieldName)) {
                    normalize = parser.booleanValue();
=======
                } else if ("coerce".equals(currentFieldName) || (indexCreatedBeforeV2_0 && "normalize".equals(currentFieldName))) {
                    coerce = parser.booleanValue();
                    if (coerce == true) {
                        ignoreMalformed = true;
                    }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_260a929_34635a4/rev_260a929-34635a4/core/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryParser.java;<<<<<<< MINE
        if (normalize) {
            // Special case: if the difference bettween the left and right is 360 and the right is greater than the left, we are asking for
=======
        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes
        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {
            if (topLeft.lat() > 90.0 || topLeft.lat() < -90.0) {
                throw new QueryParsingException(parseContext, "illegal latitude value [{}] for [{}]", topLeft.lat(), NAME);
            }
            if (topLeft.lon() > 180.0 || topLeft.lon() < -180) {
                throw new QueryParsingException(parseContext, "illegal longitude value [{}] for [{}]", topLeft.lon(), NAME);
            }
            if (bottomRight.lat() > 90.0 || bottomRight.lat() < -90.0) {
                throw new QueryParsingException(parseContext, "illegal latitude value [{}] for [{}]", bottomRight.lat(), NAME);
            }
            if (bottomRight.lon() > 180.0 || bottomRight.lon() < -180) {
                throw new QueryParsingException(parseContext, "illegal longitude value [{}] for [{}]", bottomRight.lon(), NAME);
            }
        }

        if (coerce) {
            // Special case: if the difference between the left and right is 360 and the right is greater than the left, we are asking for
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_260a929_34635a4/rev_260a929-34635a4/core/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryParser.java;<<<<<<< MINE
        if (normalizeLat || normalizeLon) {
            GeoUtils.normalizePoint(point, normalizeLat, normalizeLon);
        }

        MappedFieldType fieldType = context.fieldMapper(fieldName);
=======
        MappedFieldType fieldType = parseContext.fieldMapper(fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_260a929_34635a4/rev_260a929-34635a4/core/src/main/java/org/elasticsearch/index/query/GeoDistanceRangeQueryParser.java;<<<<<<< MINE
        if (normalizeLat || normalizeLon) {
            GeoUtils.normalizePoint(point, normalizeLat, normalizeLon);
        }

        MappedFieldType fieldType = context.fieldMapper(fieldName);
=======
        MappedFieldType fieldType = parseContext.fieldMapper(fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_3843ae4_501a199/rev_3843ae4-501a199/core/src/main/java/org/elasticsearch/index/query/TermsQueryBuilder.java;<<<<<<< MINE
     * Sets the execution mode for the terms filter. Cane be either "plain", "bool"
     * "and". Defaults to "plain".
     * @deprecated elasticsearch now makes better decisions on its own
     */
    @Deprecated
    public TermsQueryBuilder execution(String execution) {
        this.execution = execution;
        return this;
    }

    /**
     * Sets the index name to lookup the terms from.
=======
||||||| /home/ramdisk/experiment5/fstmerge_tmp1510604588563/fstmerge_base_7066243459522100690.java
     * Sets the execution mode for the terms filter. Cane be either "plain", "bool"
     * "and". Defaults to "plain".
     * @deprecated elasticsearch now makes better decisions on its own
     */
    @Deprecated
    public TermsQueryBuilder execution(String execution) {
        this.execution = execution;
        return this;
    }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_3843ae4_501a199/rev_3843ae4-501a199/core/src/main/java/org/elasticsearch/index/query/TermsQueryBuilder.java;<<<<<<< MINE
        builder.startObject(NAME);
        if (values == null) {
            builder.startObject(name);
            if (lookupIndex != null) {
                builder.field("index", lookupIndex);
            }
            builder.field("type", lookupType);
            builder.field("id", lookupId);
            if (lookupRouting != null) {
                builder.field("routing", lookupRouting);
            }
            builder.field("path", lookupPath);
            builder.endObject();
        } else {
            builder.field(name, values);
        }
        if (execution != null) {
            builder.field("execution", execution);
        }

=======
        builder.startObject(TermsQueryParser.NAME);
        builder.field(name, values);

>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_59cb67c_cc12501/rev_59cb67c-cc12501/core/src/main/java/org/elasticsearch/index/query/QueryStringQueryParser.java;<<<<<<< MINE
        qpSettings.queryTypes(context.queryTypes());

        MapperQueryParser queryParser = context.queryParser(qpSettings);
=======
        MapperQueryParser queryParser = parseContext.queryParser(qpSettings);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_084a610_db5e225/rev_084a610-db5e225/core/src/main/java/org/elasticsearch/index/query/HasChildQueryParser.java;<<<<<<< MINE
            ParsedQuery parsedQuery = new ParsedQuery(innerQuery, context.copyNamedQueries());
            InnerHitsContext.ParentChildInnerHits parentChildInnerHits = new InnerHitsContext.ParentChildInnerHits(innerHits.v2(), parsedQuery, null, context.mapperService(), childDocMapper);
            String name = innerHits.v1() != null ? innerHits.v1() : childType;
            context.addInnerHits(name, parentChildInnerHits);
=======
            ParsedQuery parsedQuery = new ParsedQuery(innerQuery, parseContext.copyNamedQueries());
            InnerHitsContext.ParentChildInnerHits parentChildInnerHits = new InnerHitsContext.ParentChildInnerHits(innerHits.getSubSearchContext(), parsedQuery, null, parseContext.mapperService(), childDocMapper);
            String name = innerHits.getName() != null ? innerHits.getName() : childType;
            parseContext.addInnerHits(name, parentChildInnerHits);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95f3817_821021f/rev_95f3817-821021f/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/heuristics/JLHScore.java;<<<<<<< MINE
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher) throws IOException, QueryShardException {
=======
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher, SearchContext context)
                throws IOException, QueryParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95f3817_821021f/rev_95f3817-821021f/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/heuristics/PercentageScore.java;<<<<<<< MINE
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher) throws IOException, QueryShardException {
=======
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher, SearchContext context)
                throws IOException, QueryParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95f3817_821021f/rev_95f3817-821021f/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/heuristics/NXYSignificanceHeuristic.java;<<<<<<< MINE
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher) throws IOException, QueryShardException {
=======
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher, SearchContext context)
                throws IOException, QueryParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95f3817_821021f/rev_95f3817-821021f/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/heuristics/GND.java;<<<<<<< MINE
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher) throws IOException, QueryShardException {
=======
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher, SearchContext context)
                throws IOException, QueryParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95f3817_821021f/rev_95f3817-821021f/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/heuristics/ScriptHeuristic.java;<<<<<<< MINE
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher) throws IOException, QueryShardException {
=======
        public SignificanceHeuristic parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher, SearchContext context)
                throws IOException, QueryParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_107a4b1_da554fc/rev_107a4b1-da554fc/core/src/main/java/org/elasticsearch/index/query/FilteredQueryParser.java;<<<<<<< MINE
    @Override
    public FilteredQueryBuilder getBuilderPrototype() {
        return FilteredQueryBuilder.PROTOTYPE;
    }

=======
        BooleanQuery filteredQuery = Queries.filtered(query, filter);
        filteredQuery.setBoost(boost);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, filteredQuery);
        }
        return filteredQuery;
    }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ea83007_b98cd5f/rev_ea83007-b98cd5f/core/src/main/java/org/elasticsearch/index/query/ExistsQueryParser.java;<<<<<<< MINE
    @Override
    public ExistsQueryBuilder getBuilderPrototype() {
        return ExistsQueryBuilder.PROTOTYPE;
=======
    public static Query newFilter(QueryParseContext parseContext, String fieldPattern, String queryName) {
        final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType)parseContext.mapperService().fullName(FieldNamesFieldMapper.NAME);
        if (fieldNamesFieldType == null) {
            // can only happen when no types exist, so no docs exist either
            return Queries.newMatchNoDocsQuery();
        }

        ObjectMapper objectMapper = parseContext.getObjectMapper(fieldPattern);
        if (objectMapper != null) {
            // automatic make the object mapper pattern
            fieldPattern = fieldPattern + ".*";
        }

        Collection<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);
        if (fields.isEmpty()) {
            // no fields exists, so we should not match anything
            return Queries.newMatchNoDocsQuery();
        }

        BooleanQuery.Builder boolFilterBuilder = new BooleanQuery.Builder();
        for (String field : fields) {
            MappedFieldType fieldType = parseContext.fieldMapper(field);
            Query filter = null;
            if (fieldNamesFieldType.isEnabled()) {
                final String f;
                if (fieldType != null) {
                    f = fieldType.names().indexName();
                } else {
                    f = field;
                }
                filter = fieldNamesFieldType.termQuery(f, parseContext);
            }
            // if _field_names are not indexed, we need to go the slow way
            if (filter == null && fieldType != null) {
                filter = fieldType.rangeQuery(null, null, true, true);
            }
            if (filter == null) {
                filter = new TermRangeQuery(field, null, null, true, true);
            }
            boolFilterBuilder.add(filter, BooleanClause.Occur.SHOULD);
        }

        BooleanQuery boolFilter = boolFilterBuilder.build();
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, boolFilter);
        }
        return new ConstantScoreQuery(boolFilter);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ea83007_b98cd5f/rev_ea83007-b98cd5f/core/src/main/java/org/elasticsearch/index/query/MissingQueryParser.java;<<<<<<< MINE
    @Override
    public MissingQueryBuilder getBuilderPrototype() {
        return MissingQueryBuilder.PROTOTYPE;
=======
    public static Query newFilter(QueryParseContext parseContext, String fieldPattern, boolean existence, boolean nullValue, String queryName) {
        if (!existence && !nullValue) {
            throw new QueryParsingException(parseContext, "missing must have either existence, or null_value, or both set to true");
        }

        final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType)parseContext.mapperService().fullName(FieldNamesFieldMapper.NAME);
        if (fieldNamesFieldType == null) {
            // can only happen when no types exist, so no docs exist either
            return Queries.newMatchNoDocsQuery();
        }

        ObjectMapper objectMapper = parseContext.getObjectMapper(fieldPattern);
        if (objectMapper != null) {
            // automatic make the object mapper pattern
            fieldPattern = fieldPattern + ".*";
        }

        Collection<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);
        if (fields.isEmpty()) {
            if (existence) {
                // if we ask for existence of fields, and we found none, then we should match on all
                return Queries.newMatchAllQuery();
            }
            return null;
        }

        Query existenceFilter = null;
        Query nullFilter = null;

        if (existence) {
            BooleanQuery.Builder boolFilter = new BooleanQuery.Builder();
            for (String field : fields) {
                MappedFieldType fieldType = parseContext.fieldMapper(field);
                Query filter = null;
                if (fieldNamesFieldType.isEnabled()) {
                    final String f;
                    if (fieldType != null) {
                        f = fieldType.names().indexName();
                    } else {
                        f = field;
                    }
                    filter = fieldNamesFieldType.termQuery(f, parseContext);
                }
                // if _field_names are not indexed, we need to go the slow way
                if (filter == null && fieldType != null) {
                    filter = fieldType.rangeQuery(null, null, true, true);
                }
                if (filter == null) {
                    filter = new TermRangeQuery(field, null, null, true, true);
                }
                boolFilter.add(filter, BooleanClause.Occur.SHOULD);
            }

            existenceFilter = boolFilter.build();
            existenceFilter = Queries.not(existenceFilter);;
        }

        if (nullValue) {
            for (String field : fields) {
                MappedFieldType fieldType = parseContext.fieldMapper(field);
                if (fieldType != null) {
                    nullFilter = fieldType.nullValueQuery();
                }
            }
        }

        Query filter;
        if (nullFilter != null) {
            if (existenceFilter != null) {
                filter = new BooleanQuery.Builder()
                    .add(existenceFilter, BooleanClause.Occur.SHOULD)
                    .add(nullFilter, BooleanClause.Occur.SHOULD)
                    .build();
            } else {
                filter = nullFilter;
            }
        } else {
            filter = existenceFilter;
        }

        if (filter == null) {
            return null;
        }

        if (queryName != null) {
            parseContext.addNamedQuery(queryName, existenceFilter);
        }
        return new ConstantScoreQuery(filter);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ea83007_b98cd5f/rev_ea83007-b98cd5f/core/src/main/java/org/elasticsearch/index/query/SpanContainingQueryParser.java;<<<<<<< MINE
        SpanContainingQueryBuilder query = new SpanContainingQueryBuilder(big, little);
        query.boost(boost).queryName(queryName);
=======
        Query query = new SpanContainingQuery(big, little);
        if (boost != 1.0F) {
            query.setBoost(boost);
        }
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ea83007_b98cd5f/rev_ea83007-b98cd5f/core/src/main/java/org/elasticsearch/index/query/SpanWithinQueryParser.java;<<<<<<< MINE
        SpanWithinQueryBuilder query = new SpanWithinQueryBuilder(big, little);
        query.boost(boost).queryName(queryName);
=======
        Query query = new SpanWithinQuery(big, little);
        if (boost != 1.0F) {
            query.setBoost(boost);
        }
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_083c774_f208aaa/rev_083c774-f208aaa/core/src/main/java/org/elasticsearch/index/query/ScriptQueryParser.java;<<<<<<< MINE
    @Override
    public ScriptQueryBuilder getBuilderPrototype() {
        return ScriptQueryBuilder.PROTOTYPE;
=======
    static class ScriptQuery extends Query {

        private final Script script;

        private final SearchScript searchScript;

        public ScriptQuery(Script script, ScriptService scriptService, SearchLookup searchLookup) {
            this.script = script;
            this.searchScript = scriptService.search(searchLookup, script, ScriptContext.Standard.SEARCH);
        }

        @Override
        public String toString(String field) {
            StringBuilder buffer = new StringBuilder();
            buffer.append("ScriptFilter(");
            buffer.append(script);
            buffer.append(")");
            return buffer.toString();
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (!super.equals(obj))
                return false;
            ScriptQuery other = (ScriptQuery) obj;
            return Objects.equals(script, other.script);
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = super.hashCode();
            result = prime * result + Objects.hashCode(script);
            return result;
        }

        @Override
        public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
            return new RandomAccessWeight(this) {
                @Override
                protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {
                    final LeafSearchScript leafScript = searchScript.getLeafSearchScript(context);
                    return new Bits() {

                        @Override
                        public boolean get(int doc) {
                            leafScript.setDocument(doc);
                            Object val = leafScript.run();
                            if (val == null) {
                                return false;
                            }
                            if (val instanceof Boolean) {
                                return (Boolean) val;
                            }
                            if (val instanceof Number) {
                                return ((Number) val).longValue() != 0;
                            }
                            throw new IllegalArgumentException("Can't handle type [" + val + "] in script filter");
                        }

                        @Override
                        public int length() {
                            return context.reader().maxDoc();
                        }

                    };
                }
            };
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_678e1be_73d84e4/rev_678e1be-73d84e4/core/src/main/java/org/elasticsearch/index/query/HasChildQueryParser.java;<<<<<<< MINE
        HasChildQueryBuilder hasChildQueryBuilder = new HasChildQueryBuilder(childType, iqb, maxChildren, minChildren, shortCircuitParentDocSet, scoreType, queryInnerHits);
        hasChildQueryBuilder.queryName(queryName);
        hasChildQueryBuilder.boost(boost);
        return hasChildQueryBuilder;
=======
        if (!queryFound) {
            throw new QueryParsingException(parseContext, "[has_child] requires 'query' field");
        }
        if (childType == null) {
            throw new QueryParsingException(parseContext, "[has_child] requires 'type' field");
        }

        Query innerQuery = iq.asQuery(childType);

        if (innerQuery == null) {
            return null;
        }
        innerQuery.setBoost(boost);

        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);
        if (childDocMapper == null) {
            throw new QueryParsingException(parseContext, "[has_child] No mapping for for type [" + childType + "]");
        }
        ParentFieldMapper parentFieldMapper = childDocMapper.parentFieldMapper();
        if (parentFieldMapper.active() == false) {
            throw new QueryParsingException(parseContext, "[has_child] _parent field has no parent type configured");
        }

        if (innerHits != null) {
            ParsedQuery parsedQuery = new ParsedQuery(innerQuery, parseContext.copyNamedQueries());
            InnerHitsContext.ParentChildInnerHits parentChildInnerHits = new InnerHitsContext.ParentChildInnerHits(innerHits.getSubSearchContext(), parsedQuery, null, parseContext.mapperService(), childDocMapper);
            String name = innerHits.getName() != null ? innerHits.getName() : childType;
            parseContext.addInnerHits(name, parentChildInnerHits);
        }

        String parentType = parentFieldMapper.type();
        DocumentMapper parentDocMapper = parseContext.mapperService().documentMapper(parentType);
        if (parentDocMapper == null) {
            throw new QueryParsingException(parseContext, "[has_child]  Type [" + childType + "] points to a non existent parent type ["
                    + parentType + "]");
        }

        if (maxChildren > 0 && maxChildren < minChildren) {
            throw new QueryParsingException(parseContext, "[has_child] 'max_children' is less than 'min_children'");
        }

        // wrap the query with type query
        innerQuery = Queries.filtered(innerQuery, childDocMapper.typeFilter());

        final Query query;
        final ParentChildIndexFieldData parentChildIndexFieldData = parseContext.getForField(parentFieldMapper.fieldType());
        query = joinUtilHelper(parentType, parentChildIndexFieldData, parentDocMapper.typeFilter(), scoreType, innerQuery, minChildren, maxChildren);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
        query.setBoost(boost);
        return query;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8d2a2f8_c10f116/rev_8d2a2f8-c10f116/core/src/main/java/org/elasticsearch/index/query/QueryFilterBuilder.java;<<<<<<< MINE
        builder.field(NAME);
        queryBuilder.toXContent(builder, params);
    }

    @Override
    protected Query doToQuery(QueryShardContext context) throws IOException {
        // inner query builder can potentially be `null`, in that case we ignore it
        Query innerQuery = this.queryBuilder.toQuery(context);
        if (innerQuery == null) {
            return null;
        }
        return new ConstantScoreQuery(innerQuery);
    }

    @Override
    protected void setFinalBoost(Query query) {
        //no-op this query doesn't support boost
    }

    @Override
    public QueryValidationException validate() {
        return validateInnerQuery(queryBuilder, null);
    }

    @Override
    protected int doHashCode() {
        return Objects.hash(queryBuilder);
    }

    @Override
    protected boolean doEquals(QueryFilterBuilder other) {
        return Objects.equals(queryBuilder, other.queryBuilder);
    }

    @Override
    protected QueryFilterBuilder doReadFrom(StreamInput in) throws IOException {
        QueryBuilder innerQueryBuilder = in.readQuery();
        return new QueryFilterBuilder(innerQueryBuilder);
    }

    @Override
    protected void doWriteTo(StreamOutput out) throws IOException {
        out.writeQuery(queryBuilder);
    }

    @Override
    public String getWriteableName() {
        return NAME;
=======
        builder.field(QueryFilterParser.NAME);
        queryBuilder.toXContent(builder, params);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8d2a2f8_c10f116/rev_8d2a2f8-c10f116/core/src/main/java/org/elasticsearch/index/query/QueryFilterParser.java;<<<<<<< MINE
/**
 * Parser for query filter
 * @deprecated use any query instead directly, possible since queries and filters are merged.
 */
=======
// TODO: remove when https://github.com/elastic/elasticsearch/issues/13326 is fixed
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8d2a2f8_c10f116/rev_8d2a2f8-c10f116/core/src/main/java/org/elasticsearch/index/query/QueryFilterParser.java;<<<<<<< MINE
    public QueryFilterBuilder getBuilderPrototype() {
        return QueryFilterBuilder.PROTOTYPE;
=======
    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {
        return parseContext.parseInnerQuery();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8d2a2f8_c10f116/rev_8d2a2f8-c10f116/core/src/main/java/org/elasticsearch/index/query/HasChildQueryParser.java;<<<<<<< MINE
    @Override
    public HasChildQueryBuilder getBuilderPrototype() {
        return HasChildQueryBuilder.PROTOTYPE;
=======
    public static Query joinUtilHelper(String parentType, ParentChildIndexFieldData parentChildIndexFieldData, Query toQuery, ScoreType scoreType, Query innerQuery, int minChildren, int maxChildren) throws IOException {
        ScoreMode scoreMode;
        // TODO: move entirely over from ScoreType to org.apache.lucene.join.ScoreMode, when we drop the 1.x parent child code.
        switch (scoreType) {
            case NONE:
                scoreMode = ScoreMode.None;
                break;
            case MIN:
                scoreMode = ScoreMode.Min;
                break;
            case MAX:
                scoreMode = ScoreMode.Max;
                break;
            case SUM:
                scoreMode = ScoreMode.Total;
                break;
            case AVG:
                scoreMode = ScoreMode.Avg;
                break;
            default:
                throw new UnsupportedOperationException("score type [" + scoreType + "] not supported");
        }
        // 0 in pre 2.x p/c impl means unbounded
        if (maxChildren == 0) {
            maxChildren = Integer.MAX_VALUE;
        }
        return new LateParsingQuery(toQuery, innerQuery, minChildren, maxChildren, parentType, scoreMode, parentChildIndexFieldData);
    }

    final static class LateParsingQuery extends Query {

        private final Query toQuery;
        private final Query innerQuery;
        private final int minChildren;
        private final int maxChildren;
        private final String parentType;
        private final ScoreMode scoreMode;
        private final ParentChildIndexFieldData parentChildIndexFieldData;
        private final Object identity = new Object();

        LateParsingQuery(Query toQuery, Query innerQuery, int minChildren, int maxChildren, String parentType, ScoreMode scoreMode, ParentChildIndexFieldData parentChildIndexFieldData) {
            this.toQuery = toQuery;
            this.innerQuery = innerQuery;
            this.minChildren = minChildren;
            this.maxChildren = maxChildren;
            this.parentType = parentType;
            this.scoreMode = scoreMode;
            this.parentChildIndexFieldData = parentChildIndexFieldData;
        }

        @Override
        public Query rewrite(IndexReader reader) throws IOException {
            IndexSearcher indexSearcher = new IndexSearcher(reader);
            String joinField = ParentFieldMapper.joinField(parentType);
            IndexParentChildFieldData indexParentChildFieldData = parentChildIndexFieldData.loadGlobal(indexSearcher.getIndexReader());
            MultiDocValues.OrdinalMap ordinalMap = ParentChildIndexFieldData.getOrdinalMap(indexParentChildFieldData, parentType);
            return JoinUtil.createJoinQuery(joinField, innerQuery, toQuery, indexSearcher, scoreMode, ordinalMap, minChildren, maxChildren);
        }

        // Even though we only cache rewritten queries it is good to let all queries implement hashCode() and equals():

        // We can't check for actually equality here, since we need to IndexReader for this, but
        // that isn't available on all cases during query parse time, so instead rely on identity:
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            if (!super.equals(o)) return false;

            LateParsingQuery that = (LateParsingQuery) o;
            return identity.equals(that.identity);
        }

        @Override
        public int hashCode() {
            int result = super.hashCode();
            result = 31 * result + identity.hashCode();
            return result;
        }

        @Override
        public String toString(String s) {
            return "LateParsingQuery {parentType=" + parentType + "}";
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_d49a744_2c618a1/rev_d49a744-2c618a1/core/src/main/java/org/elasticsearch/index/query/HasChildQueryParser.java;<<<<<<< MINE
        HasChildQueryBuilder hasChildQueryBuilder = new HasChildQueryBuilder(childType, iqb, maxChildren, minChildren, scoreType, queryInnerHits);
        hasChildQueryBuilder.queryName(queryName);
        hasChildQueryBuilder.boost(boost);
        return hasChildQueryBuilder;
=======
        if (!queryFound) {
            throw new QueryParsingException(parseContext, "[has_child] requires 'query' field");
        }
        if (childType == null) {
            throw new QueryParsingException(parseContext, "[has_child] requires 'type' field");
        }

        Query innerQuery = iq.asQuery(childType);

        if (innerQuery == null) {
            return null;
        }
        innerQuery.setBoost(boost);

        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);
        if (childDocMapper == null) {
            throw new QueryParsingException(parseContext, "[has_child] No mapping for for type [" + childType + "]");
        }
        ParentFieldMapper parentFieldMapper = childDocMapper.parentFieldMapper();
        if (parentFieldMapper.active() == false) {
            throw new QueryParsingException(parseContext, "[has_child] _parent field has no parent type configured");
        }

        if (innerHits != null) {
            ParsedQuery parsedQuery = new ParsedQuery(innerQuery, parseContext.copyNamedQueries());
            InnerHitsContext.ParentChildInnerHits parentChildInnerHits = new InnerHitsContext.ParentChildInnerHits(innerHits.getSubSearchContext(), parsedQuery, null, parseContext.mapperService(), childDocMapper);
            String name = innerHits.getName() != null ? innerHits.getName() : childType;
            parseContext.addInnerHits(name, parentChildInnerHits);
        }

        String parentType = parentFieldMapper.type();
        DocumentMapper parentDocMapper = parseContext.mapperService().documentMapper(parentType);
        if (parentDocMapper == null) {
            throw new QueryParsingException(parseContext, "[has_child]  Type [" + childType + "] points to a non existent parent type ["
                    + parentType + "]");
        }

        if (maxChildren > 0 && maxChildren < minChildren) {
            throw new QueryParsingException(parseContext, "[has_child] 'max_children' is less than 'min_children'");
        }

        // wrap the query with type query
        innerQuery = Queries.filtered(innerQuery, childDocMapper.typeFilter());

        final Query query;
        final ParentChildIndexFieldData parentChildIndexFieldData = parseContext.getForField(parentFieldMapper.fieldType());
        query = joinUtilHelper(parentType, parentChildIndexFieldData, parentDocMapper.typeFilter(), scoreMode, innerQuery, minChildren, maxChildren);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
        query.setBoost(boost);
        return query;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_d49a744_2c618a1/rev_d49a744-2c618a1/core/src/main/java/org/elasticsearch/index/query/HasChildQueryParser.java;<<<<<<< MINE
    @Override
    public HasChildQueryBuilder getBuilderPrototype() {
        return HasChildQueryBuilder.PROTOTYPE;
=======
    public static Query joinUtilHelper(String parentType, ParentChildIndexFieldData parentChildIndexFieldData, Query toQuery, ScoreMode scoreMode, Query innerQuery, int minChildren, int maxChildren) throws IOException {
        return new LateParsingQuery(toQuery, innerQuery, minChildren, maxChildren, parentType, scoreMode, parentChildIndexFieldData);
    }

    public static ScoreMode parseScoreMode(String scoreModeString) {
        if ("none".equals(scoreModeString)) {
            return ScoreMode.None;
        } else if ("min".equals(scoreModeString)) {
            return ScoreMode.Min;
        } else if ("max".equals(scoreModeString)) {
            return ScoreMode.Max;
        } else if ("avg".equals(scoreModeString)) {
            return ScoreMode.Avg;
        } else if ("total".equals(scoreModeString)) {
            return ScoreMode.Total;
        }
        throw new IllegalArgumentException("No score mode for child query [" + scoreModeString + "] found");
    }

    final static class LateParsingQuery extends Query {

        private final Query toQuery;
        private final Query innerQuery;
        private final int minChildren;
        private final int maxChildren;
        private final String parentType;
        private final ScoreMode scoreMode;
        private final ParentChildIndexFieldData parentChildIndexFieldData;
        private final Object identity = new Object();

        LateParsingQuery(Query toQuery, Query innerQuery, int minChildren, int maxChildren, String parentType, ScoreMode scoreMode, ParentChildIndexFieldData parentChildIndexFieldData) {
            this.toQuery = toQuery;
            this.innerQuery = innerQuery;
            this.minChildren = minChildren;
            this.maxChildren = maxChildren;
            this.parentType = parentType;
            this.scoreMode = scoreMode;
            this.parentChildIndexFieldData = parentChildIndexFieldData;
        }

        @Override
        public Query rewrite(IndexReader reader) throws IOException {
            if (getBoost() != 1.0F) {
                return super.rewrite(reader);
            }
            String joinField = ParentFieldMapper.joinField(parentType);
            IndexSearcher indexSearcher = new IndexSearcher(reader);
            indexSearcher.setQueryCache(null);
            IndexParentChildFieldData indexParentChildFieldData = parentChildIndexFieldData.loadGlobal(indexSearcher.getIndexReader());
            MultiDocValues.OrdinalMap ordinalMap = ParentChildIndexFieldData.getOrdinalMap(indexParentChildFieldData, parentType);
            return JoinUtil.createJoinQuery(joinField, innerQuery, toQuery, indexSearcher, scoreMode, ordinalMap, minChildren, maxChildren);
        }

        // Even though we only cache rewritten queries it is good to let all queries implement hashCode() and equals():

        // We can't check for actually equality here, since we need to IndexReader for this, but
        // that isn't available on all cases during query parse time, so instead rely on identity:
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            if (!super.equals(o)) return false;

            LateParsingQuery that = (LateParsingQuery) o;
            return identity.equals(that.identity);
        }

        @Override
        public int hashCode() {
            int result = super.hashCode();
            result = 31 * result + identity.hashCode();
            return result;
        }

        @Override
        public String toString(String s) {
            return "LateParsingQuery {parentType=" + parentType + "}";
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_adaa998_4095906/rev_adaa998-4095906/core/src/main/java/org/elasticsearch/index/query/GeoDistanceRangeQueryParser.java;<<<<<<< MINE
                    geohash = parser.text();
=======
                    point.resetFromGeoHash(parser.text());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_8fb1aa9_d498006/rev_8fb1aa9-d498006/core/src/main/java/org/elasticsearch/index/query/functionscore/random/RandomScoreFunctionParser.java;<<<<<<< MINE
            seed = Longs.hashCode(context.nowInMillis());
=======
            seed = hash(parseContext.nowInMillis());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_37b46fb_5b3118f/rev_37b46fb-5b3118f/core/src/test/java/org/elasticsearch/test/geo/RandomShapeGenerator.java;<<<<<<< MINE
        return createShape(r, nearPoint, within, st, ST_VALIDATE);
=======
        ShapeBuilder shape;
        short i=0;
        do {
            shape = createShape(r, nearPoint, within, st, ST_VALIDATE);
            if (shape != null) {
                return shape;
            }
        } while (++i != 100);
        throw new InvalidShapeException("Unable to create a valid random shape with provided seed");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_37b46fb_5b3118f/rev_37b46fb-5b3118f/core/src/test/java/org/elasticsearch/test/geo/RandomShapeGenerator.java;<<<<<<< MINE
     * see: {@link org.elasticsearch.search.geo.GeoShapeIntegrationTests#testShapeFilterWithRandomGeoCollection}
=======
     * see: {@link org.elasticsearch.search.geo.GeoShapeIntegrationIT#testShapeFilterWithRandomGeoCollection}
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_37b46fb_5b3118f/rev_37b46fb-5b3118f/core/src/test/java/org/elasticsearch/test/geo/RandomShapeGenerator.java;<<<<<<< MINE
                    } catch (InvalidShapeException e) {
                        // jts bug rarely results in an invalid shape, if it does happen we try again instead of returning null
                        return createShape(r, nearPoint, within, st, validate);
=======
                    } catch (Throwable e) {
                        // jts bug may occasionally misinterpret coordinate order causing an unhelpful ('geom' assertion)
                        // or InvalidShapeException
                        if (e instanceof InvalidShapeException || e instanceof AssertionError) {
                            return null;
                        }
                        // throw any other exception
                        throw e;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/functionscore/fieldvaluefactor/FieldValueFactorFunctionParser.java;<<<<<<< MINE
    public ScoreFunction parse(QueryShardContext context, XContentParser parser) throws IOException, QueryParsingException {
        QueryParseContext parseContext = context.parseContext();
=======
    public ScoreFunction parse(QueryParseContext parseContext, XContentParser parser) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/functionscore/random/RandomScoreFunctionParser.java;<<<<<<< MINE
    public ScoreFunction parse(QueryShardContext context, XContentParser parser) throws IOException, QueryParsingException {
        QueryParseContext parseContext = context.parseContext();
=======
    public ScoreFunction parse(QueryParseContext parseContext, XContentParser parser) throws IOException, ParsingException {

>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/functionscore/DecayFunctionParser.java;<<<<<<< MINE
    public ScoreFunction parse(QueryShardContext context, XContentParser parser) throws IOException, QueryParsingException {
=======
    public ScoreFunction parse(QueryParseContext parseContext, XContentParser parser) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/functionscore/DecayFunctionParser.java;<<<<<<< MINE
            throw new QueryParsingException(context.parseContext(), "unknown field [{}]", fieldName);
=======
            throw new ParsingException(parseContext, "unknown field [{}]", fieldName);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/functionscore/DecayFunctionParser.java;<<<<<<< MINE
            throw new QueryParsingException(context.parseContext(), "field [{}] is of type [{}], but only numeric types are supported.", fieldName, fieldType);
=======
            throw new ParsingException(parseContext, "field [{}] is of type [{}], but only numeric types are supported.", fieldName, fieldType);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/support/InnerHitsQueryParserHelper.java;<<<<<<< MINE
    public InnerHitsSubSearchContext parse(XContentParser parser) throws IOException {
=======
    public InnerHitsSubSearchContext parse(QueryParseContext parserContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/support/InnerHitsQueryParserHelper.java;<<<<<<< MINE
            throw new IOException("Failed to parse [_inner_hits]");
=======
            throw new ParsingException(parserContext, "Failed to parse [_inner_hits]", e);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/ExistsQueryParser.java;<<<<<<< MINE
    public ExistsQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/TypeQueryParser.java;<<<<<<< MINE
    public TypeQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/TypeQueryParser.java;<<<<<<< MINE
        String currentFieldName = null;
        XContentParser.Token token;
        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token.isValue()) {
                if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("value".equals(currentFieldName)) {
                    type = parser.utf8Bytes();
                }
            } else {
                throw new QueryParsingException(parseContext, "[type] filter doesn't support [" + currentFieldName + "]");
            }
=======
        XContentParser.Token token = parser.nextToken();
        if (token != XContentParser.Token.FIELD_NAME) {
            throw new ParsingException(parseContext, "[type] filter should have a value field, and the type name");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/TypeQueryParser.java;<<<<<<< MINE

        if (type == null) {
            throw new QueryParsingException(parseContext, "[type] filter needs to be provided with a value for the type");
=======
        String fieldName = parser.currentName();
        if (!fieldName.equals("value")) {
            throw new ParsingException(parseContext, "[type] filter should have a value field, and the type name");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/TypeQueryParser.java;<<<<<<< MINE
        return new TypeQueryBuilder(type)
                .boost(boost)
                .queryName(queryName);
    }

    @Override
    public TypeQueryBuilder getBuilderPrototype() {
        return TypeQueryBuilder.PROTOTYPE;
=======
        token = parser.nextToken();
        if (token != XContentParser.Token.VALUE_STRING) {
            throw new ParsingException(parseContext, "[type] filter should have a value field, and the type name");
        }
        BytesRef type = parser.utf8Bytes();
        // move to the next token
        parser.nextToken();

        Query filter;
        //LUCENE 4 UPGRADE document mapper should use bytesref as well? 
        DocumentMapper documentMapper = parseContext.mapperService().documentMapper(type.utf8ToString());
        if (documentMapper == null) {
            filter = new TermQuery(new Term(TypeFieldMapper.NAME, type));
        } else {
            filter = documentMapper.typeFilter();
        }
        return filter;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/ConstantScoreQueryParser.java;<<<<<<< MINE
    public ConstantScoreQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryParser.java;<<<<<<< MINE
    public QueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryParser.java;<<<<<<< MINE
            throw new QueryParsingException(parseContext, "geo_distance requires 'distance' to be specified");
=======
            throw new ParsingException(parseContext, "geo_distance requires 'distance' to be specified");
        } else if (vDistance instanceof Number) {
            distance = DistanceUnit.DEFAULT.convert(((Number) vDistance).doubleValue(), unit);
        } else {
            distance = DistanceUnit.parse((String) vDistance, unit, DistanceUnit.DEFAULT);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryParser.java;<<<<<<< MINE
        GeoDistanceQueryBuilder qb = new GeoDistanceQueryBuilder(fieldName);
        if (vDistance instanceof Number) {
            qb.distance(((Number) vDistance).doubleValue(), unit);
        } else {
            qb.distance((String) vDistance, unit);
=======
        MappedFieldType fieldType = parseContext.fieldMapper(fieldName);
        if (fieldType == null) {
            throw new ParsingException(parseContext, "failed to find geo_point field [" + fieldName + "]");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoDistanceQueryParser.java;<<<<<<< MINE
        qb.point(point);
        qb.coerce(coerce);
        qb.ignoreMalformed(ignoreMalformed);
        qb.optimizeBbox(optimizeBbox);
        qb.geoDistance(geoDistance);
        qb.boost(boost);
        qb.queryName(queryName);
        return qb;
    }
=======
        if (!(fieldType instanceof GeoPointFieldMapper.GeoPointFieldType)) {
            throw new ParsingException(parseContext, "field [" + fieldName + "] is not a geo_point field");
        }
        GeoPointFieldMapper.GeoPointFieldType geoFieldType = ((GeoPointFieldMapper.GeoPointFieldType) fieldType);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoDistanceRangeQueryParser.java;<<<<<<< MINE
    public GeoDistanceRangeQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoDistanceRangeQueryParser.java;<<<<<<< MINE
        GeoDistanceRangeQueryBuilder queryBuilder = new GeoDistanceRangeQueryBuilder(fieldName);

        if (boost != null) {
            queryBuilder.boost(boost);
        }

        if (queryName != null) {
            queryBuilder.queryName(queryName);
        }

        if (point != null) {
            queryBuilder.point(point.lat(), point.lon());
=======
        // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed on 2.x created indexes
        if (!indexCreatedBeforeV2_0 && !ignoreMalformed) {
            if (point.lat() > 90.0 || point.lat() < -90.0) {
                throw new ParsingException(parseContext, "illegal latitude value [{}] for [{}]", point.lat(), NAME);
            }
            if (point.lon() > 180.0 || point.lon() < -180) {
                throw new ParsingException(parseContext, "illegal longitude value [{}] for [{}]", point.lon(), NAME);
            }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoDistanceRangeQueryParser.java;<<<<<<< MINE
        if (optimizeBbox != null) {
            queryBuilder.optimizeBbox(optimizeBbox);
=======
        MappedFieldType fieldType = parseContext.fieldMapper(fieldName);
        if (fieldType == null) {
            throw new ParsingException(parseContext, "failed to find geo_point field [" + fieldName + "]");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoDistanceRangeQueryParser.java;<<<<<<< MINE

        if (coerce != null) {
            queryBuilder.coerce(coerce);
=======
        if (!(fieldType instanceof GeoPointFieldMapper.GeoPointFieldType)) {
            throw new ParsingException(parseContext, "field [" + fieldName + "] is not a geo_point field");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanFirstQueryParser.java;<<<<<<< MINE
    public SpanFirstQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanFirstQueryParser.java;<<<<<<< MINE
                    QueryBuilder query = parseContext.parseInnerQueryBuilder();
                    if (!(query instanceof SpanQueryBuilder)) {
                        throw new QueryParsingException(parseContext, "spanFirst [match] must be of type span query");
=======
                    Query query = parseContext.parseInnerQuery();
                    if (!(query instanceof SpanQuery)) {
                        throw new ParsingException(parseContext, "spanFirst [match] must be of type span query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanFirstQueryParser.java;<<<<<<< MINE
        if (end == null) {
            throw new QueryParsingException(parseContext, "spanFirst must have [end] set for it");
=======
        if (end == -1) {
            throw new ParsingException(parseContext, "spanFirst must have [end] set for it");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/WildcardQueryParser.java;<<<<<<< MINE
    public WildcardQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanTermQueryParser.java;<<<<<<< MINE
    public SpanTermQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/HasChildQueryParser.java;<<<<<<< MINE
    public QueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/HasChildQueryParser.java;<<<<<<< MINE
        HasChildQueryBuilder hasChildQueryBuilder = new HasChildQueryBuilder(childType, iqb, maxChildren, minChildren, scoreMode, queryInnerHits);
        hasChildQueryBuilder.queryName(queryName);
        hasChildQueryBuilder.boost(boost);
        return hasChildQueryBuilder;
=======
        if (!queryFound) {
            throw new ParsingException(parseContext, "[has_child] requires 'query' field");
        }
        if (childType == null) {
            throw new ParsingException(parseContext, "[has_child] requires 'type' field");
        }

        Query innerQuery = iq.asQuery(childType);

        if (innerQuery == null) {
            return null;
        }
        innerQuery.setBoost(boost);

        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);
        if (childDocMapper == null) {
            throw new ParsingException(parseContext, "[has_child] No mapping for for type [" + childType + "]");
        }
        ParentFieldMapper parentFieldMapper = childDocMapper.parentFieldMapper();
        if (parentFieldMapper.active() == false) {
            throw new ParsingException(parseContext, "[has_child] _parent field has no parent type configured");
        }

        if (innerHits != null) {
            ParsedQuery parsedQuery = new ParsedQuery(innerQuery, parseContext.copyNamedQueries());
            InnerHitsContext.ParentChildInnerHits parentChildInnerHits = new InnerHitsContext.ParentChildInnerHits(innerHits.getSubSearchContext(), parsedQuery, null, parseContext.mapperService(), childDocMapper);
            String name = innerHits.getName() != null ? innerHits.getName() : childType;
            parseContext.addInnerHits(name, parentChildInnerHits);
        }

        String parentType = parentFieldMapper.type();
        DocumentMapper parentDocMapper = parseContext.mapperService().documentMapper(parentType);
        if (parentDocMapper == null) {
            throw new ParsingException(parseContext, "[has_child]  Type [" + childType + "] points to a non existent parent type ["
                    + parentType + "]");
        }

        if (maxChildren > 0 && maxChildren < minChildren) {
            throw new ParsingException(parseContext, "[has_child] 'max_children' is less than 'min_children'");
        }

        // wrap the query with type query
        innerQuery = Queries.filtered(innerQuery, childDocMapper.typeFilter());

        final Query query;
        final ParentChildIndexFieldData parentChildIndexFieldData = parseContext.getForField(parentFieldMapper.fieldType());
        query = joinUtilHelper(parentType, parentChildIndexFieldData, parentDocMapper.typeFilter(), scoreMode, innerQuery, minChildren, maxChildren);
        if (queryName != null) {
            parseContext.addNamedQuery(queryName, query);
        }
        query.setBoost(boost);
        return query;
    }

    public static Query joinUtilHelper(String parentType, ParentChildIndexFieldData parentChildIndexFieldData, Query toQuery, ScoreMode scoreMode, Query innerQuery, int minChildren, int maxChildren) throws IOException {
        return new LateParsingQuery(toQuery, innerQuery, minChildren, maxChildren, parentType, scoreMode, parentChildIndexFieldData);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxQueryParser.java;<<<<<<< MINE
    public Query parse(QueryShardContext context) throws IOException, QueryParsingException {
        QueryParseContext parseContext = context.parseContext();
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/MissingQueryParser.java;<<<<<<< MINE
    public MissingQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/MissingQueryParser.java;<<<<<<< MINE
    @Override
    public MissingQueryBuilder getBuilderPrototype() {
        return MissingQueryBuilder.PROTOTYPE;
=======
    public static Query newFilter(QueryParseContext parseContext, String fieldPattern, boolean existence, boolean nullValue, String queryName) {
        if (!existence && !nullValue) {
            throw new ParsingException(parseContext, "missing must have either existence, or null_value, or both set to true");
        }

        final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType)parseContext.mapperService().fullName(FieldNamesFieldMapper.NAME);
        if (fieldNamesFieldType == null) {
            // can only happen when no types exist, so no docs exist either
            return Queries.newMatchNoDocsQuery();
        }

        ObjectMapper objectMapper = parseContext.getObjectMapper(fieldPattern);
        if (objectMapper != null) {
            // automatic make the object mapper pattern
            fieldPattern = fieldPattern + ".*";
        }

        Collection<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);
        if (fields.isEmpty()) {
            if (existence) {
                // if we ask for existence of fields, and we found none, then we should match on all
                return Queries.newMatchAllQuery();
            }
            return null;
        }

        Query existenceFilter = null;
        Query nullFilter = null;

        if (existence) {
            BooleanQuery.Builder boolFilter = new BooleanQuery.Builder();
            for (String field : fields) {
                MappedFieldType fieldType = parseContext.fieldMapper(field);
                Query filter = null;
                if (fieldNamesFieldType.isEnabled()) {
                    final String f;
                    if (fieldType != null) {
                        f = fieldType.names().indexName();
                    } else {
                        f = field;
                    }
                    filter = fieldNamesFieldType.termQuery(f, parseContext);
                }
                // if _field_names are not indexed, we need to go the slow way
                if (filter == null && fieldType != null) {
                    filter = fieldType.rangeQuery(null, null, true, true);
                }
                if (filter == null) {
                    filter = new TermRangeQuery(field, null, null, true, true);
                }
                boolFilter.add(filter, BooleanClause.Occur.SHOULD);
            }

            existenceFilter = boolFilter.build();
            existenceFilter = Queries.not(existenceFilter);;
        }

        if (nullValue) {
            for (String field : fields) {
                MappedFieldType fieldType = parseContext.fieldMapper(field);
                if (fieldType != null) {
                    nullFilter = fieldType.nullValueQuery();
                }
            }
        }

        Query filter;
        if (nullFilter != null) {
            if (existenceFilter != null) {
                filter = new BooleanQuery.Builder()
                    .add(existenceFilter, BooleanClause.Occur.SHOULD)
                    .add(nullFilter, BooleanClause.Occur.SHOULD)
                    .build();
            } else {
                filter = nullFilter;
            }
        } else {
            filter = existenceFilter;
        }

        if (filter == null) {
            return null;
        }

        if (queryName != null) {
            parseContext.addNamedQuery(queryName, existenceFilter);
        }
        return new ConstantScoreQuery(filter);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/TermQueryParser.java;<<<<<<< MINE
    public TermQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/TermQueryParser.java;<<<<<<< MINE
        TermQueryBuilder termQuery = new TermQueryBuilder(fieldName, value);
        termQuery.boost(boost);
        if (queryName != null) {
            termQuery.queryName(queryName);
=======
        if (value == null) {
            throw new ParsingException(parseContext, "No value specified for term query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanNotQueryParser.java;<<<<<<< MINE
    public SpanNotQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanNotQueryParser.java;<<<<<<< MINE
                    QueryBuilder query = parseContext.parseInnerQueryBuilder();
                    if (!(query instanceof SpanQueryBuilder)) {
                        throw new QueryParsingException(parseContext, "spanNot [include] must be of type span query");
=======
                    Query query = parseContext.parseInnerQuery();
                    if (!(query instanceof SpanQuery)) {
                        throw new ParsingException(parseContext, "spanNot [include] must be of type span query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanNotQueryParser.java;<<<<<<< MINE
                    QueryBuilder query = parseContext.parseInnerQueryBuilder();
                    if (!(query instanceof SpanQueryBuilder)) {
                        throw new QueryParsingException(parseContext, "spanNot [exclude] must be of type span query");
=======
                    Query query = parseContext.parseInnerQuery();
                    if (!(query instanceof SpanQuery)) {
                        throw new ParsingException(parseContext, "spanNot [exclude] must be of type span query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/BoostingQueryParser.java;<<<<<<< MINE
    public BoostingQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/BoostingQueryParser.java;<<<<<<< MINE
        if (!positiveQueryFound) {
            throw new QueryParsingException(parseContext, "[boosting] query requires 'positive' query to be set'");
=======
        if (positiveQuery == null && !positiveQueryFound) {
            throw new ParsingException(parseContext, "[boosting] query requires 'positive' query to be set'");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/BoostingQueryParser.java;<<<<<<< MINE
        if (!negativeQueryFound) {
            throw new QueryParsingException(parseContext, "[boosting] query requires 'negative' query to be set'");
=======
        if (negativeQuery == null && !negativeQueryFound) {
            throw new ParsingException(parseContext, "[boosting] query requires 'negative' query to be set'");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/BoostingQueryParser.java;<<<<<<< MINE
        if (negativeBoost < 0) {
            throw new QueryParsingException(parseContext, "[boosting] query requires 'negative_boost' to be set to be a positive value'");
=======
        if (negativeBoost == -1) {
            throw new ParsingException(parseContext, "[boosting] query requires 'negative_boost' to be set'");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/RangeQueryParser.java;<<<<<<< MINE
    public RangeQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/RangeQueryParser.java;<<<<<<< MINE
        RangeQueryBuilder rangeQuery = new RangeQueryBuilder(fieldName);
        rangeQuery.from(from);
        rangeQuery.to(to);
        rangeQuery.includeLower(includeLower);
        rangeQuery.includeUpper(includeUpper);
        if (timeZone != null) {
            rangeQuery.timeZone(timeZone);
=======
        Query query = null;
        MappedFieldType mapper = parseContext.fieldMapper(fieldName);
        if (mapper != null) {
            if (mapper instanceof DateFieldMapper.DateFieldType) {
                query = ((DateFieldMapper.DateFieldType) mapper).rangeQuery(from, to, includeLower, includeUpper, timeZone, forcedDateParser);
            } else  {
                if (timeZone != null) {
                    throw new ParsingException(parseContext, "[range] time_zone can not be applied to non date field ["
                            + fieldName + "]");
                }
                //LUCENE 4 UPGRADE Mapper#rangeQuery should use bytesref as well?
                query = mapper.rangeQuery(from, to, includeLower, includeUpper);
            }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/QueryFilterParser.java;<<<<<<< MINE
    public QueryFilterBuilder getBuilderPrototype() {
        return QueryFilterBuilder.PROTOTYPE;
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
        return parseContext.parseInnerQuery();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/MatchQueryParser.java;<<<<<<< MINE
    public MatchQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/MatchQueryParser.java;<<<<<<< MINE
                        analyzer = parser.text();
=======
                        String analyzer = parser.text();
                        if (parseContext.analysisService().analyzer(analyzer) == null) {
                            throw new ParsingException(parseContext, "[match] analyzer [" + parser.text() + "] not found");
                        }
                        matchQuery.setAnalyzer(analyzer);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/MatchQueryParser.java;<<<<<<< MINE
                        operator = Operator.fromString(parser.text());
=======
                        String op = parser.text();
                        if ("or".equalsIgnoreCase(op)) {
                            matchQuery.setOccur(BooleanClause.Occur.SHOULD);
                        } else if ("and".equalsIgnoreCase(op)) {
                            matchQuery.setOccur(BooleanClause.Occur.MUST);
                        } else {
                            throw new ParsingException(parseContext, "text query requires operator to be either 'and' or 'or', not ["
                                    + op + "]");
                        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanContainingQueryParser.java;<<<<<<< MINE
    public SpanContainingQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanContainingQueryParser.java;<<<<<<< MINE
                    QueryBuilder query = parseContext.parseInnerQueryBuilder();
                    if (!(query instanceof SpanQueryBuilder<?>)) {
                        throw new QueryParsingException(parseContext, "span_containing [big] must be of type span query");
=======
                    Query query = parseContext.parseInnerQuery();
                    if (!(query instanceof SpanQuery)) {
                        throw new ParsingException(parseContext, "span_containing [big] must be of type span query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanContainingQueryParser.java;<<<<<<< MINE
                    QueryBuilder query = parseContext.parseInnerQueryBuilder();
                    if (!(query instanceof SpanQueryBuilder<?>)) {
                        throw new QueryParsingException(parseContext, "span_containing [little] must be of type span query");
=======
                    Query query = parseContext.parseInnerQuery();
                    if (!(query instanceof SpanQuery)) {
                        throw new ParsingException(parseContext, "span_containing [little] must be of type span query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/RegexpQueryParser.java;<<<<<<< MINE
    public RegexpQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/NotQueryParser.java;<<<<<<< MINE
    public NotQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/NotQueryParser.java;<<<<<<< MINE
            throw new QueryParsingException(parseContext, "query is required when using `not` query");
=======
            throw new ParsingException(parseContext, "filter is required when using `not` query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoShapeQueryParser.java;<<<<<<< MINE
    public GeoShapeQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/GeoShapeQueryParser.java;<<<<<<< MINE
        GeoShapeQueryBuilder builder;
        if (shape != null) {
            builder = new GeoShapeQueryBuilder(fieldName, shape);
=======

        if (shape == null) {
            throw new ParsingException(parseContext, "No Shape defined");
        } else if (shapeRelation == null) {
            throw new ParsingException(parseContext, "No Shape Relation defined");
        }

        MappedFieldType fieldType = parseContext.fieldMapper(fieldName);
        if (fieldType == null) {
            throw new ParsingException(parseContext, "Failed to find geo_shape field [" + fieldName + "]");
        }

        // TODO: This isn't the nicest way to check this
        if (!(fieldType instanceof GeoShapeFieldMapper.GeoShapeFieldType)) {
            throw new ParsingException(parseContext, "Field [" + fieldName + "] is not a geo_shape");
        }

        GeoShapeFieldMapper.GeoShapeFieldType shapeFieldType = (GeoShapeFieldMapper.GeoShapeFieldType) fieldType;

        PrefixTreeStrategy strategy = shapeFieldType.defaultStrategy();
        if (strategyName != null) {
            strategy = shapeFieldType.resolveStrategy(strategyName);
        }
        Query query;
        if (strategy instanceof RecursivePrefixTreeStrategy && shapeRelation == ShapeRelation.DISJOINT) {
            // this strategy doesn't support disjoint anymore: but it did before, including creating lucene fieldcache (!)
            // in this case, execute disjoint as exists && !intersects
            BooleanQuery.Builder bool = new BooleanQuery.Builder();
            Query exists = ExistsQueryParser.newFilter(parseContext, fieldName, null);
            Filter intersects = strategy.makeFilter(getArgs(shape, ShapeRelation.INTERSECTS));
            bool.add(exists, BooleanClause.Occur.MUST);
            bool.add(intersects, BooleanClause.Occur.MUST_NOT);
            query = new ConstantScoreQuery(bool.build());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/FieldMaskingSpanQueryParser.java;<<<<<<< MINE
    public FieldMaskingSpanQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/FieldMaskingSpanQueryParser.java;<<<<<<< MINE
                    QueryBuilder query = parseContext.parseInnerQueryBuilder();
                    if (!(query instanceof SpanQueryBuilder)) {
                        throw new QueryParsingException(parseContext, "[field_masking_span] query must be of type span query");
=======
                    Query query = parseContext.parseInnerQuery();
                    if (!(query instanceof SpanQuery)) {
                        throw new ParsingException(parseContext, "[field_masking_span] query] must be of type span query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/PrefixQueryParser.java;<<<<<<< MINE
    public PrefixQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanWithinQueryParser.java;<<<<<<< MINE
    public SpanWithinQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanWithinQueryParser.java;<<<<<<< MINE
                    QueryBuilder query = parseContext.parseInnerQueryBuilder();
                    if (query instanceof SpanQueryBuilder == false) {
                        throw new QueryParsingException(parseContext, "span_within [big] must be of type span query");
=======
                    Query query = parseContext.parseInnerQuery();
                    if (query instanceof SpanQuery == false) {
                        throw new ParsingException(parseContext, "span_within [big] must be of type span query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/SpanWithinQueryParser.java;<<<<<<< MINE
                    QueryBuilder query = parseContext.parseInnerQueryBuilder();
                    if (query instanceof SpanQueryBuilder == false) {
                        throw new QueryParsingException(parseContext, "span_within [little] must be of type span query");
=======
                    Query query = parseContext.parseInnerQuery();
                    if (query instanceof SpanQuery == false) {
                        throw new ParsingException(parseContext, "span_within [little] must be of type span query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/MatchAllQueryParser.java;<<<<<<< MINE
    public MatchAllQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/FuzzyQueryParser.java;<<<<<<< MINE
    public QueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/FuzzyQueryParser.java;<<<<<<< MINE
            throw new QueryParsingException(parseContext, "no value specified for fuzzy query");
=======
            throw new ParsingException(parseContext, "No value specified for fuzzy query");
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/NestedQueryParser.java;<<<<<<< MINE
    public NestedQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
    public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/test/java/org/elasticsearch/indices/IndicesModuleTests.java;<<<<<<< MINE
        public QueryBuilder getBuilderPrototype() {
=======
        public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/test/java/org/elasticsearch/index/query/plugin/DummyQueryParserPlugin.java;<<<<<<< MINE
        public QueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, QueryParsingException {
=======
        public Query parse(QueryParseContext parseContext) throws IOException, ParsingException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_197313c_c8d1f7a/rev_197313c-c8d1f7a/core/src/main/java/org/elasticsearch/index/query/NestedQueryParser.java;<<<<<<< MINE
    @Override
    public NestedQueryBuilder getBuilderPrototype() {
        return PROTOTYPE;
=======
    public static class ToBlockJoinQueryBuilder extends NestedInnerQueryParseSupport {

        private ScoreMode scoreMode;
        private InnerHitsSubSearchContext innerHits;

        public ToBlockJoinQueryBuilder(QueryParseContext parseContext) throws IOException {
            super(parseContext);
        }

        public void setScoreMode(ScoreMode scoreMode) {
            this.scoreMode = scoreMode;
        }

        public void setInnerHits(InnerHitsSubSearchContext innerHits) {
            this.innerHits = innerHits;
        }

        @Nullable
        public ToParentBlockJoinQuery build() throws IOException {
            Query innerQuery;
            if (queryFound) {
                innerQuery = getInnerQuery();
            } else if (filterFound) {
                Query innerFilter = getInnerFilter();
                if (innerFilter != null) {
                    innerQuery = new ConstantScoreQuery(getInnerFilter());
                } else {
                    innerQuery = null;
                }
            } else {
                throw new ParsingException(parseContext, "[nested] requires either 'query' or 'filter' field");
            }

            if (innerHits != null) {
                ParsedQuery parsedQuery = new ParsedQuery(innerQuery, parseContext.copyNamedQueries());
                InnerHitsContext.NestedInnerHits nestedInnerHits = new InnerHitsContext.NestedInnerHits(innerHits.getSubSearchContext(), parsedQuery, null, getParentObjectMapper(), nestedObjectMapper);
                String name = innerHits.getName() != null ? innerHits.getName() : path;
                parseContext.addInnerHits(name, nestedInnerHits);
            }

            if (innerQuery != null) {
                return new ToParentBlockJoinQuery(Queries.filtered(innerQuery, childFilter), parentFilter, scoreMode);
            } else {
                return null;
            }
        }

>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7d887a1_86f201e/rev_7d887a1-86f201e/core/src/main/java/org/elasticsearch/index/query/MatchQueryBuilder.java;<<<<<<< MINE
     * Get the (optional) number of term expansions when using fuzzy or prefix type query.
     */
    public int maxExpansions() {
        return this.maxExpansions;
    }

    /**
     * Sets an optional cutoff value in [0..1] (or absolute number >=1) representing the
=======
     * Set a cutoff value in [0..1] (or absolute number &gt;=1) representing the
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7d887a1_86f201e/rev_7d887a1-86f201e/core/src/main/java/org/elasticsearch/index/query/QueryParser.java;<<<<<<< MINE
     * Parses the into a query from the current parser location. Will be at
     * "START_OBJECT" location, and should end when the token is at the matching
     * "END_OBJECT".
     * <p/>
     * Returns <tt>null</tt> if this query should be ignored in the context of
     * the DSL.
=======
     * Parses the into a query from the current parser location. Will be at "START_OBJECT" location,
     * and should end when the token is at the matching "END_OBJECT".
     * <p>
     * Returns <tt>null</tt> if this query should be ignored in the context of the DSL.
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c597127_2fd1cde/rev_c597127-2fd1cde/core/src/main/java/org/elasticsearch/index/shard/ShadowIndexShard.java;<<<<<<< MINE
    @Inject
    public ShadowIndexShard(ShardId shardId, @IndexSettings Settings indexSettings,
                            IndicesLifecycle indicesLifecycle, Store store,
                            ThreadPool threadPool, MapperService mapperService,
                            IndexQueryParserService queryParserService, IndexCache indexCache,
                            IndexAliasesService indexAliasesService, IndicesQueryCache indicesQueryCache,
                            CodecService codecService, TermVectorsService termVectorsService, IndexFieldDataService indexFieldDataService,
                            @Nullable IndicesWarmer warmer,
                            SimilarityService similarityService,
                            EngineFactory factory,
                            ShardPath path, BigArrays bigArrays, IndexSearcherWrappingService wrappingService,
                            IndexingMemoryController indexingMemoryController) throws IOException {
        super(shardId, indexSettings, indicesLifecycle, store,
              threadPool, mapperService, queryParserService, indexCache, indexAliasesService,
              indicesQueryCache, codecService,
              termVectorsService, indexFieldDataService,
              warmer, similarityService,
              factory, path, bigArrays, wrappingService,
              indexingMemoryController);
=======
    public ShadowIndexShard(ShardId shardId, @IndexSettings Settings indexSettings, ShardPath path, Store store, IndexServicesProvider provider) throws IOException {
        super(shardId, indexSettings, path, store, provider);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_108f5c5_a798f4f/rev_108f5c5-a798f4f/core/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java;<<<<<<< MINE
        builder.strategy = SpatialStrategy.RECURSIVE.readFrom(in);
=======
        if (in.readBoolean()) {
            builder.strategy = SpatialStrategy.RECURSIVE.readFrom(in);
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_9492223_50368b3/rev_9492223-50368b3/core/src/main/java/org/elasticsearch/index/mapper/Mapper.java;<<<<<<< MINE
            public ParserContext(String type, AnalysisService analysisService, SimilarityLookupService similarityLookupService,
                                 MapperService mapperService, Map<String, TypeParser> typeParsers,
=======
            public ParserContext(String type, AnalysisService analysisService,  Function<String, SimilarityProvider> similarityLookupService,
                                 MapperService mapperService, Function<String, TypeParser> typeParsers,
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/test/java/org/elasticsearch/document/ShardInfoIT.java;<<<<<<< MINE
    private void assertShardInfo(ActionWriteResponse response) {
=======
    private void assertShardInfo(ReplicationResponse response) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/test/java/org/elasticsearch/document/ShardInfoIT.java;<<<<<<< MINE
    private void assertShardInfo(ActionWriteResponse response, int expectedTotal, int expectedSuccessful) {
=======
    private void assertShardInfo(ReplicationResponse response, int expectedTotal, int expectedSuccessful) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/update/UpdateResponse.java;<<<<<<< MINE
    public UpdateResponse(ShardId shardId, String type, String id, long version, boolean created) {
        this(new ShardInfo(0, 0), shardId, type, id, SequenceNumbersService.UNASSIGNED_SEQ_NO, version, created);
=======
    public UpdateResponse(ShardId shardId, String type, String id, long version, boolean created) {
        this(new ShardInfo(0, 0), shardId, type, id, version, created);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/update/UpdateResponse.java;<<<<<<< MINE
    public UpdateResponse(ShardInfo shardInfo, ShardId shardId, String type, String id, long seqNo, long version, boolean created) {
        super(shardId, type, id, seqNo, version);
=======
    public UpdateResponse(ShardInfo shardInfo, ShardId shardId, String type, String id, long version, boolean created) {
        super(shardId, type, id, version);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/delete/DeleteResponse.java;<<<<<<< MINE
    public DeleteResponse(ShardId shardId, String type, String id, long seqNo, long version, boolean found) {
        super(shardId, type, id, seqNo, version);
=======
    public DeleteResponse(ShardId shardId, String type, String id, long version, boolean found) {
        super(shardId, type, id, version);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/delete/DeleteResponse.java;<<<<<<< MINE
    /**
=======

    /**
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/index/IndexResponse.java;<<<<<<< MINE
    public IndexResponse(ShardId shardId, String type, String id, long seqNo, long version, boolean created) {
        super(shardId, type, id, seqNo, version);
=======
    public IndexResponse(ShardId shardId, String type, String id, long version, boolean created) {
        super(shardId, type, id, version);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/index/IndexResponse.java;<<<<<<< MINE
        builder.append("index=").append(index);
        builder.append(",type=").append(type);
        builder.append(",id=").append(id);
        builder.append(",version=").append(version);
=======
        builder.append("index=").append(getIndex());
        builder.append(",type=").append(getType());
        builder.append(",id=").append(getId());
        builder.append(",version=").append(getVersion());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java;<<<<<<< MINE
    public BulkItemResponse(int id, String opType, ActionWriteResponse response) {
=======
    public BulkItemResponse(int id, String opType, DocWriteResponse response) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java;<<<<<<< MINE
        if (response instanceof IndexResponse) {
            return ((IndexResponse) response).getIndex();
        } else if (response instanceof DeleteResponse) {
            return ((DeleteResponse) response).getIndex();
        } else if (response instanceof UpdateResponse) {
            return ((UpdateResponse) response).getIndex();
        }
        return null;
=======
        return response.getIndex();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java;<<<<<<< MINE
        if (response instanceof IndexResponse) {
            return ((IndexResponse) response).getType();
        } else if (response instanceof DeleteResponse) {
            return ((DeleteResponse) response).getType();
        } else if (response instanceof UpdateResponse) {
            return ((UpdateResponse) response).getType();
        }
        return null;
=======
        return response.getType();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java;<<<<<<< MINE
        if (response instanceof IndexResponse) {
            return ((IndexResponse) response).getId();
        } else if (response instanceof DeleteResponse) {
            return ((DeleteResponse) response).getId();
        } else if (response instanceof UpdateResponse) {
            return ((UpdateResponse) response).getId();
        }
        return null;
=======
        return response.getId();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java;<<<<<<< MINE
        if (response instanceof IndexResponse) {
            return ((IndexResponse) response).getVersion();
        } else if (response instanceof DeleteResponse) {
            return ((DeleteResponse) response).getVersion();
        } else if (response instanceof UpdateResponse) {
            return ((UpdateResponse) response).getVersion();
        }
        return -1;
=======
        return response.getVersion();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_95e8a39_fafeb3a/rev_95e8a39-fafeb3a/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java;<<<<<<< MINE
    public <T extends ActionWriteResponse> T getResponse() {
=======
    public <T extends DocWriteResponse> T getResponse() {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_99e328c_7bca97b/rev_99e328c-7bca97b/core/src/main/java/org/elasticsearch/index/translog/TranslogConfig.java;<<<<<<< MINE
        this.type = TranslogWriter.Type.fromString(indexSettings.get(INDEX_TRANSLOG_FS_TYPE, TranslogWriter.Type.BUFFERED.name()));
        this.bufferSizeBytes = (int) indexSettings.getAsBytesSize(INDEX_TRANSLOG_BUFFER_SIZE, IndexingMemoryController.SHARD_TRANSLOG_BUFFER).bytes();
=======
        this.type = TranslogWriter.Type.fromString(indexSettings.getSettings().get(INDEX_TRANSLOG_FS_TYPE, TranslogWriter.Type.BUFFERED.name()));
        this.bufferSize = (int) indexSettings.getSettings().getAsBytesSize(INDEX_TRANSLOG_BUFFER_SIZE, IndexingMemoryController.INACTIVE_SHARD_TRANSLOG_BUFFER).bytes(); // Not really interesting, updated by IndexingMemoryController...
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_5f4afe8_7e3ccf2/rev_5f4afe8-7e3ccf2/core/src/main/java/org/elasticsearch/index/translog/TranslogConfig.java;<<<<<<< MINE
        return syncOnEachOperation;
    }

    /**
     * Returns the current translog buffer size.
     */
    public int getBufferSizeBytes() {
        return bufferSizeBytes;
    }

    /**
     * Returns the current async fsync interval
     */
    public TimeValue getSyncInterval() {
        return syncInterval;
=======
        return indexSettings.getTranslogSyncInterval().millis() == 0;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e9e300c_5c88164/rev_e9e300c-5c88164/core/src/main/java/org/elasticsearch/action/support/single/shard/SingleShardRequest.java;<<<<<<< MINE
    public SingleShardRequest(String index) {
=======
    protected SingleShardRequest(String index) {
        this.index = index;
    }

    protected SingleShardRequest(ActionRequest<?> request) {
        super(request);
    }

    protected SingleShardRequest(ActionRequest<?> request, String index) {
        super(request);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e9e300c_5c88164/rev_e9e300c-5c88164/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java;<<<<<<< MINE
    public ReplicationRequest(ShardId shardId) {
=======
    public ReplicationRequest(ActionRequest<?> request, ShardId shardId) {
        super(request);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e9e300c_5c88164/rev_e9e300c-5c88164/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java;<<<<<<< MINE
    protected ReplicationRequest(T request) {
=======
    protected ReplicationRequest(Request request) {
        this(request, request);
    }

    /**
     * Copy constructor that creates a new request that is a copy of the one provided as an argument.
     * The new request will inherit though headers and context from the original request that caused it.
     */
    protected ReplicationRequest(Request request, ActionRequest<?> originalRequest) {
        super(originalRequest);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e9e300c_5c88164/rev_e9e300c-5c88164/core/src/main/java/org/elasticsearch/rest/action/admin/indices/get/RestGetIndicesAction.java;<<<<<<< MINE
    public RestGetIndicesAction(Settings settings, RestController controller, Client client) {
        super(settings, client);
=======
    public RestGetIndicesAction(Settings settings, RestController controller, Client client, IndexScopedSettings indexScopedSettings) {
        super(settings, controller, client);
        this.indexScopedSettings = indexScopedSettings;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e9e300c_5c88164/rev_e9e300c-5c88164/core/src/main/java/org/elasticsearch/rest/action/admin/indices/settings/RestGetSettingsAction.java;<<<<<<< MINE
    public RestGetSettingsAction(Settings settings, RestController controller, Client client) {
        super(settings, client);
=======
    public RestGetSettingsAction(Settings settings, RestController controller, Client client, IndexScopedSettings indexScopedSettings) {
        super(settings, controller, client);
        this.indexScopedSettings = indexScopedSettings;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_245022f_9649c79/rev_245022f-9649c79/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java;<<<<<<< MINE
     * Writes the given {@link SmoothingModel} to the stream
     */
    public void writePhraseSuggestionSmoothingModel(SmoothingModel smoothinModel) throws IOException {
        writeNamedWriteable(smoothinModel);
    }

    /**
=======
     * Writes a {@link Task.Status} to the current stream.
     */
    public void writeTaskStatus(Task.Status status) throws IOException {
        writeNamedWriteable(status);
    }

    /**
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e5a5067_77a1649/rev_e5a5067-77a1649/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FilterParser.java;<<<<<<< MINE
    public FilterAggregator.FilterAggregatorBuilder parse(String aggregationName, XContentParser parser, QueryParseContext context)
            throws IOException {
        QueryBuilder<?> filter = context.parseInnerQueryBuilder();

        if (filter == null) {
            throw new ParsingException(null, "filter cannot be null in filter aggregation [{}]", aggregationName);
        }

        FilterAggregator.FilterAggregatorBuilder factory = new FilterAggregator.FilterAggregatorBuilder(aggregationName,
                filter == null ? new MatchAllQueryBuilder() : filter);
        return factory;
    }
=======
    public AggregatorFactory parse(String aggregationName, XContentParser parser, SearchContext context) throws IOException {
        ParsedQuery filter = context.getQueryShardContext().parseInnerFilter(parser);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_04681ef_bbeb09e/rev_04681ef-bbeb09e/core/src/main/java/org/elasticsearch/search/suggest/phrase/PhraseSuggestParser.java;<<<<<<< MINE
    public SuggestionSearchContext.SuggestionContext parse(XContentParser parser, QueryShardContext shardContext) throws IOException {
        MapperService mapperService = shardContext.getMapperService();
        PhraseSuggestionContext suggestion = new PhraseSuggestionContext(suggester);
=======
    public SuggestionSearchContext.SuggestionContext parse(XContentParser parser, QueryShardContext shardContext) throws IOException {
        MapperService mapperService = shardContext.getMapperService();
        ScriptService scriptService = shardContext.getScriptService();
        PhraseSuggestionContext suggestion = new PhraseSuggestionContext(shardContext);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_04681ef_bbeb09e/rev_04681ef-bbeb09e/core/src/main/java/org/elasticsearch/search/suggest/term/TermSuggestionBuilder.java;<<<<<<< MINE
    protected SuggestionContext innerBuild(QueryShardContext context) throws IOException {
        TermSuggestionContext suggestionContext = new TermSuggestionContext(TermSuggester.PROTOTYPE);
        return fillSuggestionContext(suggestionContext);
    }

    @Override
=======
    protected SuggestionContext build(QueryShardContext context) throws IOException {
        // NORELEASE
        throw new UnsupportedOperationException();
    }

    @Override
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_04681ef_bbeb09e/rev_04681ef-bbeb09e/core/src/main/java/org/elasticsearch/search/suggest/term/TermSuggestParser.java;<<<<<<< MINE
    public SuggestionSearchContext.SuggestionContext parse(XContentParser parser, MapperService mapperService, IndexFieldDataService fieldDataService) throws IOException {
=======
    public SuggestionSearchContext.SuggestionContext parse(XContentParser parser, QueryShardContext shardContext) throws IOException {
        MapperService mapperService = shardContext.getMapperService();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_04681ef_bbeb09e/rev_04681ef-bbeb09e/core/src/main/java/org/elasticsearch/search/suggest/SuggestionBuilder.java;<<<<<<< MINE
    public SuggestionContext build(QueryShardContext context, @Nullable String globalText) throws IOException {
        SuggestionContext suggestionContext = innerBuild(context);
        // copy over common settings to each suggestion builder
        SuggestUtils.suggestionToSuggestionContext(this, context.getMapperService(), suggestionContext);
        SuggestUtils.verifySuggestion(context.getMapperService(), new BytesRef(globalText), suggestionContext);
        suggestionContext.setShardContext(context);
        // TODO make field mandatory in the builder, then remove this
        if (suggestionContext.getField() == null) {
            throw new IllegalArgumentException("The required field option is missing");
        }
        return suggestionContext;
    }

    protected abstract SuggestionContext innerBuild(QueryShardContext context) throws IOException;

    public String getSuggesterName() {
=======
    protected abstract SuggestionContext build(QueryShardContext context) throws IOException;

    /**
     * Transfers the text, prefix, regex, analyzer, fieldname, size and shard size settings from the
     * original {@link SuggestionBuilder} to the target {@link SuggestionContext}
     */
    protected void populateCommonFields(MapperService mapperService,
            SuggestionSearchContext.SuggestionContext suggestionContext) throws IOException {

        if (analyzer != null) {
            Analyzer luceneAnalyzer = mapperService.analysisService().analyzer(analyzer);
            if (luceneAnalyzer == null) {
                throw new IllegalArgumentException("Analyzer [" + luceneAnalyzer + "] doesn't exists");
            }
            suggestionContext.setAnalyzer(luceneAnalyzer);
        }

        if (fieldname != null) {
            suggestionContext.setField(fieldname);
        }

        if (size != null) {
            suggestionContext.setSize(size);
        }

        if (shardSize != null) {
            suggestionContext.setShardSize(shardSize);
        } else {
            // if no shard size is set in builder, use size (or at least 5)
            suggestionContext.setShardSize(Math.max(suggestionContext.getSize(), 5));
        }

        if (text != null) {
            suggestionContext.setText(BytesRefs.toBytesRef(text));
        }
        if (prefix != null) {
            suggestionContext.setPrefix(BytesRefs.toBytesRef(prefix));
        }
        if (regex != null) {
            suggestionContext.setRegex(BytesRefs.toBytesRef(regex));
        }
        if (text != null && prefix == null) {
            suggestionContext.setPrefix(BytesRefs.toBytesRef(text));
        } else if (text == null && prefix != null) {
            suggestionContext.setText(BytesRefs.toBytesRef(prefix));
        } else if (text == null && regex != null) {
            suggestionContext.setText(BytesRefs.toBytesRef(regex));
        }
    }

    private String getSuggesterName() {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
        otherRouting = new ShardRouting(routing,
                randomBoolean() ? routing.version() : routing.version() + 1,
                randomBoolean() ? routing.primaryTerm() : routing.primaryTerm() + 1);
=======
        otherRouting = new ShardRouting(routing);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.index() + "a", otherRouting.id(), otherRouting.currentNodeId(),
                            otherRouting.relocatingNodeId(), otherRouting.restoreSource(), otherRouting.primaryTerm(), otherRouting.primary(),
                            otherRouting.state(), otherRouting.version(), otherRouting.unassignedInfo());
=======
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.getIndexName() + "a", otherRouting.id(), otherRouting.currentNodeId(), otherRouting.relocatingNodeId(),
                            otherRouting.restoreSource(), otherRouting.primary(), otherRouting.state(), otherRouting.unassignedInfo());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.index(), otherRouting.id() + 1, otherRouting.currentNodeId(),
                            otherRouting.relocatingNodeId(), otherRouting.restoreSource(), otherRouting.primaryTerm(), otherRouting.primary(),
                            otherRouting.state(), otherRouting.version(), otherRouting.unassignedInfo());
=======
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.getIndexName(), otherRouting.id() + 1, otherRouting.currentNodeId(), otherRouting.relocatingNodeId(),
                            otherRouting.restoreSource(), otherRouting.primary(), otherRouting.state(), otherRouting.unassignedInfo());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.index(), otherRouting.id(), otherRouting.currentNodeId() == null ? "1" : otherRouting.currentNodeId() + "_1", otherRouting.relocatingNodeId(),
                            otherRouting.restoreSource(), otherRouting.primaryTerm(), otherRouting.primary(), otherRouting.state(),
                            otherRouting.version(), otherRouting.unassignedInfo());
=======
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.getIndexName(), otherRouting.id(), otherRouting.currentNodeId() == null ? "1" : otherRouting.currentNodeId() + "_1", otherRouting.relocatingNodeId(),
                            otherRouting.restoreSource(), otherRouting.primary(), otherRouting.state(), otherRouting.unassignedInfo());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
                            otherRouting.restoreSource(), otherRouting.primaryTerm(), otherRouting.primary(), otherRouting.state(),
                            otherRouting.version(), otherRouting.unassignedInfo());
=======
                            otherRouting.restoreSource(), otherRouting.primary(), otherRouting.state(), otherRouting.unassignedInfo());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
                            otherRouting.primaryTerm(), otherRouting.primary(), otherRouting.state(), otherRouting.version(),
                            otherRouting.unassignedInfo());
=======
                            otherRouting.primary(), otherRouting.state(), otherRouting.unassignedInfo());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.index(), otherRouting.id(), otherRouting.currentNodeId(),
                            otherRouting.relocatingNodeId(), otherRouting.restoreSource(), otherRouting.primaryTerm(),
                            otherRouting.primary() == false, otherRouting.state(), otherRouting.version(), otherRouting.unassignedInfo());
=======
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.getIndexName(), otherRouting.id(), otherRouting.currentNodeId(), otherRouting.relocatingNodeId(),
                            otherRouting.restoreSource(), otherRouting.primary() == false, otherRouting.state(), otherRouting.unassignedInfo());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.index(), otherRouting.id(), otherRouting.currentNodeId(),
                            otherRouting.relocatingNodeId(), otherRouting.restoreSource(), otherRouting.primaryTerm(), otherRouting.primary(),
                            newState, otherRouting.version(), unassignedInfo);
=======
                    otherRouting = TestShardRouting.newShardRouting(otherRouting.getIndexName(), otherRouting.id(), otherRouting.currentNodeId(), otherRouting.relocatingNodeId(),
                            otherRouting.restoreSource(), otherRouting.primary(), newState, unassignedInfo);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/test/java/org/elasticsearch/cluster/routing/ShardRoutingTests.java;<<<<<<< MINE
                otherRouting = TestShardRouting.newShardRouting(otherRouting.index(), otherRouting.id(), otherRouting.currentNodeId(),
                        otherRouting.relocatingNodeId(), otherRouting.restoreSource(), otherRouting.primaryTerm(), otherRouting.primary(),
                        otherRouting.state(), otherRouting.version(),
=======
                otherRouting = TestShardRouting.newShardRouting(otherRouting.getIndexName(), otherRouting.id(), otherRouting.currentNodeId(), otherRouting.relocatingNodeId(),
                        otherRouting.restoreSource(), otherRouting.primary(), otherRouting.state(),
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java;<<<<<<< MINE
        this(copy, copy.version(), copy.primaryTerm());
    }

    public ShardRouting(ShardRouting copy, long version) {
        this(copy, version, copy.primaryTerm());
    }

    public ShardRouting(ShardRouting copy, long version, long primaryTerm) {
        this(copy.index(), copy.id(), copy.currentNodeId(), copy.relocatingNodeId(), copy.restoreSource(), primaryTerm, copy.primary(), copy.state(), version, copy.unassignedInfo(), copy.allocationId(), true, copy.getExpectedShardSize());
=======
        this(copy.index(), copy.id(), copy.currentNodeId(), copy.relocatingNodeId(), copy.restoreSource(), copy.primary(), copy.state(), copy.unassignedInfo(), copy.allocationId(), true, copy.getExpectedShardSize());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java;<<<<<<< MINE
    ShardRouting(String index, int shardId, String currentNodeId,
                 String relocatingNodeId, RestoreSource restoreSource, long primaryTerm, boolean primary, ShardRoutingState state, long version,
=======
    ShardRouting(Index index, int shardId, String currentNodeId,
                 String relocatingNodeId, RestoreSource restoreSource, boolean primary, ShardRoutingState state,
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java;<<<<<<< MINE
    public static ShardRouting newUnassigned(String index, int shardId, RestoreSource restoreSource, long primaryTerm, boolean primary, UnassignedInfo unassignedInfo) {
        return new ShardRouting(index, shardId, null, null, restoreSource, primaryTerm, primary, ShardRoutingState.UNASSIGNED, 0, unassignedInfo, null, true, UNAVAILABLE_EXPECTED_SHARD_SIZE);
=======
    public static ShardRouting newUnassigned(Index index, int shardId, RestoreSource restoreSource, boolean primary, UnassignedInfo unassignedInfo) {
        return new ShardRouting(index, shardId, null, null, restoreSource, primary, ShardRoutingState.UNASSIGNED, unassignedInfo, null, true, UNAVAILABLE_EXPECTED_SHARD_SIZE);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java;<<<<<<< MINE
     * Initializes an unassigned shard on a node. If the shard is primary, it's term is incremented.
=======
     * Initializes an unassigned shard on a node.
     *
     * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java;<<<<<<< MINE
        allocationId = AllocationId.newInitializing();
        if (primary) {
            primaryTerm++;
        }
=======
        if (existingAllocationId == null) {
            allocationId = AllocationId.newInitializing();
        } else {
            allocationId = AllocationId.newInitializing(existingAllocationId);
        }
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java;<<<<<<< MINE
        out.writeVLong(seqNo);
        out.writeVLong(primaryTerm);
=======
        out.writeVLong(routedBasedOnClusterVersion);
    }

    @Override
    public Task createTask(long id, String type, String action, String parentTaskNode, long parentTaskId) {
        return new ReplicationTask(id, type, action, getDescription(), parentTaskNode, parentTaskId);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/test/framework/src/main/java/org/elasticsearch/cluster/routing/TestShardRouting.java;<<<<<<< MINE
    public static ShardRouting newShardRouting(String index, int shardId, String currentNodeId, long primaryTerm, boolean primary,
                                               ShardRoutingState state, long version) {
        return new ShardRouting(index, shardId, currentNodeId, null, null, primaryTerm, primary, state, version, buildUnassignedInfo(state), buildAllocationId(state), true, -1);
=======
    public static ShardRouting newShardRouting(String index, int shardId, String currentNodeId, boolean primary, ShardRoutingState state) {
        return newShardRouting(new Index(index, IndexMetaData.INDEX_UUID_NA_VALUE), shardId, currentNodeId,primary, state);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/test/framework/src/main/java/org/elasticsearch/cluster/routing/TestShardRouting.java;<<<<<<< MINE
    public static ShardRouting newShardRouting(String index, int shardId, String currentNodeId, String relocatingNodeId,
                                               long primaryTerm, boolean primary, ShardRoutingState state, long version) {
        return new ShardRouting(index, shardId, currentNodeId, relocatingNodeId, null, primaryTerm, primary, state, version, buildUnassignedInfo(state), buildAllocationId(state), true, -1);
=======
    public static ShardRouting newShardRouting(Index index, int shardId, String currentNodeId, boolean primary, ShardRoutingState state) {
        return new ShardRouting(index, shardId, currentNodeId, null, null, primary, state, buildUnassignedInfo(state), buildAllocationId(state), true, -1);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/test/framework/src/main/java/org/elasticsearch/cluster/routing/TestShardRouting.java;<<<<<<< MINE
    public static ShardRouting newShardRouting(String index, int shardId, String currentNodeId, String relocatingNodeId,
                                               long primaryTerm, boolean primary, ShardRoutingState state, AllocationId allocationId, long version) {
        return new ShardRouting(index, shardId, currentNodeId, relocatingNodeId, null, primaryTerm, primary, state, version, buildUnassignedInfo(state), allocationId, true, -1);
=======
    public static ShardRouting newShardRouting(String index, int shardId, String currentNodeId, String relocatingNodeId, boolean primary, ShardRoutingState state) {
        return newShardRouting(new Index(index, IndexMetaData.INDEX_UUID_NA_VALUE), shardId, currentNodeId, relocatingNodeId, primary, state);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/test/framework/src/main/java/org/elasticsearch/cluster/routing/TestShardRouting.java;<<<<<<< MINE
    public static ShardRouting newShardRouting(String index, int shardId, String currentNodeId, String relocatingNodeId,
                                               RestoreSource restoreSource, long primaryTerm, boolean primary,
                                               ShardRoutingState state, long version) {
        return new ShardRouting(index, shardId, currentNodeId, relocatingNodeId, restoreSource, primaryTerm, primary, state, version, buildUnassignedInfo(state), buildAllocationId(state), true, -1);
=======
    public static ShardRouting newShardRouting(Index index, int shardId, String currentNodeId, String relocatingNodeId, boolean primary, ShardRoutingState state) {
        return new ShardRouting(index, shardId, currentNodeId, relocatingNodeId, null, primary, state, buildUnassignedInfo(state), buildAllocationId(state), true, -1);
    }

    public static ShardRouting newShardRouting(String index, int shardId, String currentNodeId, String relocatingNodeId, boolean primary, ShardRoutingState state, AllocationId allocationId) {
        return newShardRouting(new Index(index, IndexMetaData.INDEX_UUID_NA_VALUE), shardId, currentNodeId, relocatingNodeId, primary, state, allocationId);
    }

    public static ShardRouting newShardRouting(Index index, int shardId, String currentNodeId, String relocatingNodeId, boolean primary, ShardRoutingState state, AllocationId allocationId) {
        return new ShardRouting(index, shardId, currentNodeId, relocatingNodeId, null, primary, state, buildUnassignedInfo(state), allocationId, true, -1);
    }

    public static ShardRouting newShardRouting(String index, int shardId, String currentNodeId, String relocatingNodeId, RestoreSource restoreSource, boolean primary, ShardRoutingState state) {
        return newShardRouting(new Index(index, IndexMetaData.INDEX_UUID_NA_VALUE), shardId, currentNodeId, relocatingNodeId, restoreSource, primary, state);
    }

    public static ShardRouting newShardRouting(Index index, int shardId, String currentNodeId, String relocatingNodeId, RestoreSource restoreSource, boolean primary, ShardRoutingState state) {
        return new ShardRouting(index, shardId, currentNodeId, relocatingNodeId, restoreSource, primary, state, buildUnassignedInfo(state), buildAllocationId(state), true, -1);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_4d0feff_b5aee20/rev_4d0feff-b5aee20/test/framework/src/main/java/org/elasticsearch/cluster/routing/TestShardRouting.java;<<<<<<< MINE
                                               String relocatingNodeId, RestoreSource restoreSource, long primaryTerm, boolean primary,
                                               ShardRoutingState state, long version, UnassignedInfo unassignedInfo) {
        return new ShardRouting(index, shardId, currentNodeId, relocatingNodeId, restoreSource, primaryTerm, primary, state, version, unassignedInfo, buildAllocationId(state), true, -1);
=======
                                               String relocatingNodeId, RestoreSource restoreSource, boolean primary, ShardRoutingState state,
                                               UnassignedInfo unassignedInfo) {
        return newShardRouting(new Index(index, IndexMetaData.INDEX_UUID_NA_VALUE), shardId, currentNodeId, relocatingNodeId, restoreSource, primary, state, unassignedInfo);
    }

    public static ShardRouting newShardRouting(Index index, int shardId, String currentNodeId,
                                               String relocatingNodeId, RestoreSource restoreSource, boolean primary, ShardRoutingState state,
                                               UnassignedInfo unassignedInfo) {
        return new ShardRouting(index, shardId, currentNodeId, relocatingNodeId, restoreSource, primary, state, unassignedInfo, buildAllocationId(state), true, -1);
    }

    public static void relocate(ShardRouting shardRouting, String relocatingNodeId, long expectedShardSize) {
        shardRouting.relocate(relocatingNodeId, expectedShardSize);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_687aade_0b0a251/rev_687aade-0b0a251/core/src/main/java/org/elasticsearch/common/cli/Terminal.java;<<<<<<< MINE
        public PrintWriter getWriter() {
            return console.writer();
        }

        @Override
        public void doPrint(String msg) {
            console.printf("%s", msg);
            console.flush();
=======
        public PrintWriter getWriter() {
            return console.writer();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java;<<<<<<< MINE
        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(newNode("node1")).put(newNode("node2"))).build();
        RoutingTable prevRoutingTable = routingTable;
        routingTable = strategy.reroute(clusterState, "reroute").routingTable();
        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();
=======
        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(newNode("node1"))).build();
        RoutingAllocation.Result result = strategy.reroute(clusterState, "reroute");
        clusterState = ClusterState.builder(clusterState).routingResult(result).build();

        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes()).put(newNode("node2"))).build();
        result = strategy.reroute(clusterState, "reroute");
        clusterState = ClusterState.builder(clusterState).routingResult(result).build();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java;<<<<<<< MINE
        prevRoutingTable = routingTable;
        routingTable = strategy.applyStartedShards(clusterState, routingNodes.node("node1").shardsWithState(INITIALIZING)).routingTable();
        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();
=======
        result = strategy.applyStartedShards(clusterState, routingNodes.node("node1").shardsWithState(INITIALIZING));
        clusterState = ClusterState.builder(clusterState).routingResult(result).build();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java;<<<<<<< MINE
        prevRoutingTable = routingTable;
        routingTable = strategy.applyStartedShards(clusterState, routingNodes.node("node2").shardsWithState(INITIALIZING)).routingTable();
        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();
=======
        result = strategy.applyStartedShards(clusterState, routingNodes.node("node2").shardsWithState(INITIALIZING));
        clusterState = ClusterState.builder(clusterState).routingResult(result).build();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java;<<<<<<< MINE
        prevRoutingTable = routingTable;
        routingTable = strategy.reroute(clusterState, "reroute").routingTable();
        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();
=======
        RoutingTable prevRoutingTable = clusterState.routingTable();
        result = strategy.reroute(clusterState, "reroute");
        clusterState = ClusterState.builder(clusterState).routingResult(result).build();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java;<<<<<<< MINE
        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();
=======
        clusterState = ClusterState.builder(clusterState).routingResult(rerouteResult).build();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java;<<<<<<< MINE
        clusterState = ClusterState.builder(clusterState).routingTable(rerouteResult.routingTable()).build();
=======
        clusterState = ClusterState.builder(clusterState).routingResult(rerouteResult).build();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java;<<<<<<< MINE
                        .numberOfReplicas(2))
=======
                        .numberOfReplicas(2)
                        .primaryTerm(0, 1))
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java;<<<<<<< MINE
                        .numberOfReplicas(3))
=======
                        .numberOfReplicas(3)
                        .primaryTerm(0, 2)
                        .primaryTerm(1, 2))
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java;<<<<<<< MINE
                        .put(IndexTemplateMetaData.builder("foo")
                                .template("bar")
                                .order(1)
                                .settings(settingsBuilder()
                                        .put("setting1", "value1")
                                        .put("setting2", "value2"))
                                .putAlias(newAliasMetaDataBuilder("alias-bar1"))
                                .putAlias(newAliasMetaDataBuilder("alias-bar2").filter("{\"term\":{\"user\":\"kimchy\"}}"))
                                .putAlias(newAliasMetaDataBuilder("alias-bar3").routing("routing-bar")))
=======
                .put(IndexTemplateMetaData.builder("foo")
                        .template("bar")
                        .order(1)
                        .settings(settingsBuilder()
                                .put("setting1", "value1")
                                .put("setting2", "value2"))
                        .putAlias(newAliasMetaDataBuilder("alias-bar1"))
                        .putAlias(newAliasMetaDataBuilder("alias-bar2").filter("{\"term\":{\"user\":\"kimchy\"}}"))
                        .putAlias(newAliasMetaDataBuilder("alias-bar3").routing("routing-bar")))
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java;<<<<<<< MINE
                        .put(IndexTemplateMetaData.builder("foo")
                                .template("bar")
                                .order(1)
                                .settings(settingsBuilder()
                                        .put("setting1", "value1")
                                        .put("setting2", "value2"))
                                .putAlias(newAliasMetaDataBuilder("alias-bar1"))
                                .putAlias(newAliasMetaDataBuilder("alias-bar2").filter("{\"term\":{\"user\":\"kimchy\"}}"))
                                .putAlias(newAliasMetaDataBuilder("alias-bar3").routing("routing-bar")))
=======
                .put(IndexTemplateMetaData.builder("foo")
                        .template("bar")
                        .order(1)
                        .settings(settingsBuilder()
                                .put("setting1", "value1")
                                .put("setting2", "value2"))
                        .putAlias(newAliasMetaDataBuilder("alias-bar1"))
                        .putAlias(newAliasMetaDataBuilder("alias-bar2").filter("{\"term\":{\"user\":\"kimchy\"}}"))
                        .putAlias(newAliasMetaDataBuilder("alias-bar3").routing("routing-bar")))
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/main/java/org/elasticsearch/index/shard/IllegalIndexShardStateException.java;<<<<<<< MINE
    public IllegalIndexShardStateException(ShardId shardId, IndexShardState currentState, String msg) {
        this(shardId, currentState, msg, null);
=======
    public IllegalIndexShardStateException(ShardId shardId, IndexShardState currentState, String msg, Object... args) {
        this(shardId, currentState, msg, null, args);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7c8cdf4_b8227a7/rev_7c8cdf4-b8227a7/core/src/main/java/org/elasticsearch/index/shard/IllegalIndexShardStateException.java;<<<<<<< MINE
    public IllegalIndexShardStateException(ShardId shardId, IndexShardState currentState, String msg, Throwable ex) {
        super("CurrentState[" + currentState + "] " + msg, ex);
=======
    public IllegalIndexShardStateException(ShardId shardId, IndexShardState currentState, String msg, Throwable ex, Object... args) {
        super("CurrentState[" + currentState + "] " + msg, ex, args);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c1f7171_2232a7c/rev_c1f7171-2232a7c/plugins/repository-s3/src/test/java/org/elasticsearch/cloud/aws/TestAwsS3Service.java;<<<<<<< MINE
    public synchronized AmazonS3 client() {
        return cachedWrapper(super.client());
    }

    @Override
    public synchronized AmazonS3 client(String endpoint, String protocol, String region, String account, String key) {
        return cachedWrapper(super.client(endpoint, protocol, region, account, key));
    }

    @Override
    public synchronized AmazonS3 client(String endpoint, String protocol, String region, String account, String key, Integer maxRetries, Boolean pathStyleAccess) {
        return cachedWrapper(super.client(endpoint, protocol, region, account, key, maxRetries, pathStyleAccess));
=======
    public synchronized AmazonS3 client(String endpoint, Protocol protocol, String region, String account, String key, Integer maxRetries) {
        return cachedWrapper(super.client(endpoint, protocol, region, account, key, maxRetries));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_dcd2642_d3d57da/rev_dcd2642-d3d57da/core/src/main/java/org/elasticsearch/index/mapper/ParsedDocument.java;<<<<<<< MINE
    public ParsedDocument(Field uid, Field version, Field seqNo, String id, String type, String routing, long timestamp, long ttl, List<Document> documents, BytesReference source, Mapping dynamicMappingsUpdate) {
        this.uid = uid;
=======
    public ParsedDocument(Field version, String id, String type, String routing, long timestamp, long ttl, List<Document> documents, BytesReference source, Mapping dynamicMappingsUpdate) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewObj.java;<<<<<<< MINE
                expression.analyze(variables);
                arguments.set(argument, expression.cast(variables));
=======
                expression.internal = true;
                expression.analyze(settings, definition, variables);
                arguments.set(argument, expression.cast(settings, definition, variables));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCall.java;<<<<<<< MINE
                expression.analyze(variables);
                arguments.set(argument, expression.cast(variables));
=======
                expression.internal = true;
                expression.analyze(settings, definition, variables);
                arguments.set(argument, expression.cast(settings, definition, variables));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java;<<<<<<< MINE
    AExpression cast(Variables variables) {
        final Cast cast = AnalyzerCaster.getLegalCast(location, actual, expected, explicit);
=======
    AExpression cast(final CompilerSettings settings, final Definition definition, final Variables variables) {
        final Cast cast = AnalyzerCaster.getLegalCast(definition, location, actual, expected, explicit, internal);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java;<<<<<<< MINE
        expression.expected = rtn ? Definition.OBJECT_TYPE : expression.actual;
        expression = expression.cast(variables);
=======
        expression.expected = rtn ? definition.getType("Object") : expression.actual;
        expression.internal = rtn;
        expression = expression.cast(settings, definition, variables);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SReturn.java;<<<<<<< MINE
    void analyze(Variables variables) {
        expression.expected = Definition.OBJECT_TYPE;
        expression.analyze(variables);
        expression = expression.cast(variables);
=======
    void analyze(final CompilerSettings settings, final Definition definition, final Variables variables) {
        expression.expected = definition.getType("Object");
        expression.internal = true;
        expression.analyze(settings, definition, variables);
        expression = expression.cast(settings, definition, variables);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java;<<<<<<< MINE
                    adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_NOT_CALL);
=======
                    adapter.invokeStatic(DEF_TYPE, DEF_NOT_CALL);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java;<<<<<<< MINE
                    adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_NEG_CALL);
=======
                    adapter.invokeStatic(DEF_TYPE, DEF_NEG_CALL);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
            promote = AnalyzerCaster.promoteNumeric(last.after, expression.actual, true, true);
=======
            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
            promote = AnalyzerCaster.promoteNumeric(last.after, expression.actual, true, true);
=======
            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
            promote = AnalyzerCaster.promoteNumeric(last.after, expression.actual, true, true);
=======
            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
            promote = AnalyzerCaster.promoteNumeric(last.after, expression.actual, true, true);
=======
            promote = AnalyzerCaster.promoteNumeric(definition, last.after, expression.actual, true);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
            promote = AnalyzerCaster.promoteNumeric(last.after, false, true);
=======
            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
            promote = AnalyzerCaster.promoteNumeric(last.after, false, true);
=======
            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
            promote = AnalyzerCaster.promoteNumeric(last.after, false, true);
=======
            promote = AnalyzerCaster.promoteNumeric(definition, last.after, false);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
        there = AnalyzerCaster.getLegalCast(location, last.after, promote, false);
        back = AnalyzerCaster.getLegalCast(location, promote, last.after, true);
=======
        there = AnalyzerCaster.getLegalCast(definition, location, last.after, promote, false, false);
        back = AnalyzerCaster.getLegalCast(definition, location, promote, last.after, true, false);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java;<<<<<<< MINE
                    expression.write(adapter);
                    adapter.writeBinaryInstruction(location, promote, operation);
=======
                    expression.write(settings, definition, adapter);
                    adapter.writeBinaryInstruction(location, promote, operation);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java;<<<<<<< MINE
            adapter.writeBinaryInstruction(definition, location, actual, operation);
=======
            adapter.writeBinaryInstruction(location, actual, operation);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCast.java;<<<<<<< MINE
        cast = AnalyzerCaster.getLegalCast(location, before, after, true);
=======
        cast = AnalyzerCaster.getLegalCast(definition, location, before, after, true, false);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefCall.java;<<<<<<< MINE
            expression.analyze(variables);
=======
            expression.internal = true;
            expression.analyze(settings, definition, variables);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java;<<<<<<< MINE
                    } else if (!left.isNull && operation == Operation.EQ) {
                        adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_EQ_CALL);
=======
                    } else if (!left.isNull && (operation == Operation.EQ || operation == Operation.NE)) {
                        adapter.invokeStatic(DEF_TYPE, DEF_EQ_CALL);
                        writejump = false;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java;<<<<<<< MINE
                    } else if (!left.isNull && operation == Operation.NE) {
                        adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_EQ_CALL);
=======
                    } else if (!left.isNull && (operation == Operation.EQ || operation == Operation.NE)) {
                        adapter.invokeStatic(DEF_TYPE, DEF_EQ_CALL);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java;<<<<<<< MINE
                    adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_LT_CALL);
=======
                    adapter.invokeStatic(DEF_TYPE, DEF_LT_CALL);
                    writejump = false;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java;<<<<<<< MINE
                    adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_LTE_CALL);
=======
                    adapter.invokeStatic(DEF_TYPE, DEF_LTE_CALL);
                    writejump = false;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java;<<<<<<< MINE
                    adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_GT_CALL);
=======
                    adapter.invokeStatic(DEF_TYPE, DEF_GT_CALL);
                    writejump = false;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java;<<<<<<< MINE
                    adapter.invokeStatic(Definition.DEF_UTIL_TYPE.type, DEF_GTE_CALL);
=======
                    adapter.invokeStatic(DEF_TYPE, DEF_GTE_CALL);
                    writejump = false;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java;<<<<<<< MINE
                    } else if (operation == Operation.EQ) {
                        adapter.invokeStatic(Definition.UTILITY_TYPE.type, CHECKEQUALS);
=======
                    } else if (operation == Operation.EQ || operation == Operation.NE) {
                        adapter.invokeStatic(UTILITY_TYPE, CHECKEQUALS);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce9b365_4e45443/rev_ce9b365-4e45443/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java;<<<<<<< MINE
                    } else if (operation == Operation.NE) {
                        adapter.invokeStatic(Definition.UTILITY_TYPE.type, CHECKEQUALS);
=======
                    } else if (operation == Operation.EQ || operation == Operation.NE) {
                        adapter.invokeStatic(UTILITY_TYPE, CHECKEQUALS);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_9a0d0d7_d8056c8/rev_9a0d0d7-d8056c8/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/STry.java;<<<<<<< MINE
    public STry(int line, int offset, String location, SBlock block, List<SCatch> catches) {
        super(line, offset, location);
=======
    public STry(Location location, SBlock block, List<SCatch> traps) {
        super(location);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_23d7cdd_da74323/rev_23d7cdd-da74323/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java;<<<<<<< MINE
    "\3\20\3\20\3\20\3\20\5\20\u011c\n\20\3\21\3\21\7\21\u0120\n\21\f\21\16"+
    "\21\u0123\13\21\3\21\3\21\3\21\7\21\u0128\n\21\f\21\16\21\u012b\13\21"+
    "\3\21\3\21\3\21\3\21\3\21\3\21\6\21\u0133\n\21\r\21\16\21\u0134\3\21\3"+
    "\21\7\21\u0139\n\21\f\21\16\21\u013c\13\21\5\21\u013e\n\21\5\21\u0140"+
    "\n\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22"+
    "\3\22\3\22\3\22\5\22\u0152\n\22\3\23\3\23\3\23\3\23\5\23\u0158\n\23\3"+
    "\24\3\24\3\24\3\24\3\24\5\24\u015f\n\24\3\25\3\25\3\25\3\25\3\26\3\26"+
    "\3\26\3\26\7\26\u0169\n\26\f\26\16\26\u016c\13\26\5\26\u016e\n\26\3\26"+
    "\3\26\3\27\3\27\5\27\u0174\n\27\3\27\2\3\34\30\2\4\6\b\n\f\16\20\22\24"+
    "\26\30\32\34\36 \"$&(*,\2\16\4\2\26\26KK\3\3\r\r\3\2\66A\3\2\34\36\3\2"+
    "\37 \3\2!#\3\2$\'\3\2(+\3\2\64\65\3\2BE\4\2\32\33\37 \3\2LM\u019b\2\61"+
    "\3\2\2\2\4{\3\2\2\2\6\177\3\2\2\2\b\u0081\3\2\2\2\n\u008a\3\2\2\2\f\u008e"+
    "\3\2\2\2\16\u0090\3\2\2\2\20\u0092\3\2\2\2\22\u009b\3\2\2\2\24\u00a3\3"+
    "\2\2\2\26\u00a7\3\2\2\2\30\u00ac\3\2\2\2\32\u00b3\3\2\2\2\34\u00be\3\2"+
    "\2\2\36\u011b\3\2\2\2 \u013f\3\2\2\2\"\u0151\3\2\2\2$\u0157\3\2\2\2&\u015e"+
    "\3\2\2\2(\u0160\3\2\2\2*\u0164\3\2\2\2,\u0173\3\2\2\2.\60\5\4\3\2/.\3"+
    "\2\2\2\60\63\3\2\2\2\61/\3\2\2\2\61\62\3\2\2\2\62\64\3\2\2\2\63\61\3\2"+
    "\2\2\64\65\7\2\2\3\65\3\3\2\2\2\66\67\7\16\2\2\678\7\t\2\289\5\34\17\2"+
    "9:\7\n\2\2:>\5\6\4\2;<\7\17\2\2<?\5\6\4\2=?\6\3\2\2>;\3\2\2\2>=\3\2\2"+
    "\2?|\3\2\2\2@A\7\20\2\2AB\7\t\2\2BC\5\34\17\2CF\7\n\2\2DG\5\6\4\2EG\5"+
    "\n\6\2FD\3\2\2\2FE\3\2\2\2G|\3\2\2\2HI\7\21\2\2IJ\5\b\5\2JK\7\20\2\2K"+
    "L\7\t\2\2LM\5\34\17\2MN\7\n\2\2NO\5\32\16\2O|\3\2\2\2PQ\7\22\2\2QS\7\t"+
    "\2\2RT\5\f\7\2SR\3\2\2\2ST\3\2\2\2TU\3\2\2\2UW\7\r\2\2VX\5\34\17\2WV\3"+
    "\2\2\2WX\3\2\2\2XY\3\2\2\2Y[\7\r\2\2Z\\\5\16\b\2[Z\3\2\2\2[\\\3\2\2\2"+
    "\\]\3\2\2\2]`\7\n\2\2^a\5\6\4\2_a\5\n\6\2`^\3\2\2\2`_\3\2\2\2a|\3\2\2"+
    "\2bc\5\20\t\2cd\5\32\16\2d|\3\2\2\2ef\7\23\2\2f|\5\32\16\2gh\7\24\2\2"+
    "h|\5\32\16\2ij\7\25\2\2jk\5\34\17\2kl\5\32\16\2l|\3\2\2\2mn\7\27\2\2n"+
    "p\5\b\5\2oq\5\30\r\2po\3\2\2\2qr\3\2\2\2rp\3\2\2\2rs\3\2\2\2s|\3\2\2\2"+
    "tu\7\31\2\2uv\5\34\17\2vw\5\32\16\2w|\3\2\2\2xy\5\34\17\2yz\5\32\16\2"+
    "z|\3\2\2\2{\66\3\2\2\2{@\3\2\2\2{H\3\2\2\2{P\3\2\2\2{b\3\2\2\2{e\3\2\2"+
    "\2{g\3\2\2\2{i\3\2\2\2{m\3\2\2\2{t\3\2\2\2{x\3\2\2\2|\5\3\2\2\2}\u0080"+
    "\5\b\5\2~\u0080\5\4\3\2\177}\3\2\2\2\177~\3\2\2\2\u0080\7\3\2\2\2\u0081"+
    "\u0085\7\5\2\2\u0082\u0084\5\4\3\2\u0083\u0082\3\2\2\2\u0084\u0087\3\2"+
    "\2\2\u0085\u0083\3\2\2\2\u0085\u0086\3\2\2\2\u0086\u0088\3\2\2\2\u0087"+
    "\u0085\3\2\2\2\u0088\u0089\7\6\2\2\u0089\t\3\2\2\2\u008a\u008b\7\r\2\2"+
    "\u008b\13\3\2\2\2\u008c\u008f\5\20\t\2\u008d\u008f\5\34\17\2\u008e\u008c"+
    "\3\2\2\2\u008e\u008d\3\2\2\2\u008f\r\3\2\2\2\u0090\u0091\5\34\17\2\u0091"+
    "\17\3\2\2\2\u0092\u0093\5\22\n\2\u0093\u0098\5\26\f\2\u0094\u0095\7\f"+
    "\2\2\u0095\u0097\5\26\f\2\u0096\u0094\3\2\2\2\u0097\u009a\3\2\2\2\u0098"+
    "\u0096\3\2\2\2\u0098\u0099\3\2\2\2\u0099\21\3\2\2\2\u009a\u0098\3\2\2"+
    "\2\u009b\u00a0\7J\2\2\u009c\u009d\7\7\2\2\u009d\u009f\7\b\2\2\u009e\u009c"+
    "\3\2\2\2\u009f\u00a2\3\2\2\2\u00a0\u009e\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1"+
    "\23\3\2\2\2\u00a2\u00a0\3\2\2\2\u00a3\u00a4\7J\2\2\u00a4\u00a5\7\63\2"+
    "\2\u00a5\u00a6\t\2\2\2\u00a6\25\3\2\2\2\u00a7\u00aa\7K\2\2\u00a8\u00a9"+
    "\7\66\2\2\u00a9\u00ab\5\34\17\2\u00aa\u00a8\3\2\2\2\u00aa\u00ab\3\2\2"+
    "\2\u00ab\27\3\2\2\2\u00ac\u00ad\7\30\2\2\u00ad\u00ae\7\t\2\2\u00ae\u00af"+
    "\7J\2\2\u00af\u00b0\7K\2\2\u00b0\u00b1\7\n\2\2\u00b1\u00b2\5\b\5\2\u00b2"+
    "\31\3\2\2\2\u00b3\u00b4\t\3\2\2\u00b4\33\3\2\2\2\u00b5\u00b6\b\17\1\2"+
    "\u00b6\u00b7\5 \21\2\u00b7\u00b8\t\4\2\2\u00b8\u00b9\5\34\17\3\u00b9\u00ba"+
    "\b\17\1\2\u00ba\u00bf\3\2\2\2\u00bb\u00bc\5\36\20\2\u00bc\u00bd\b\17\1"+
    "\2\u00bd\u00bf\3\2\2\2\u00be\u00b5\3\2\2\2\u00be\u00bb\3\2\2\2\u00bf\u00fb"+
    "\3\2\2\2\u00c0\u00c1\f\16\2\2\u00c1\u00c2\t\5\2\2\u00c2\u00c3\5\34\17"+
    "\17\u00c3\u00c4\b\17\1\2\u00c4\u00fa\3\2\2\2\u00c5\u00c6\f\r\2\2\u00c6"+
    "\u00c7\t\6\2\2\u00c7\u00c8\5\34\17\16\u00c8\u00c9\b\17\1\2\u00c9\u00fa"+
    "\3\2\2\2\u00ca\u00cb\f\f\2\2\u00cb\u00cc\t\7\2\2\u00cc\u00cd\5\34\17\r"+
    "\u00cd\u00ce\b\17\1\2\u00ce\u00fa\3\2\2\2\u00cf\u00d0\f\13\2\2\u00d0\u00d1"+
    "\t\b\2\2\u00d1\u00d2\5\34\17\f\u00d2\u00d3\b\17\1\2\u00d3\u00fa\3\2\2"+
    "\2\u00d4\u00d5\f\n\2\2\u00d5\u00d6\t\t\2\2\u00d6\u00d7\5\34\17\13\u00d7"+
    "\u00d8\b\17\1\2\u00d8\u00fa\3\2\2\2\u00d9\u00da\f\t\2\2\u00da\u00db\7"+
    ",\2\2\u00db\u00dc\5\34\17\n\u00dc\u00dd\b\17\1\2\u00dd\u00fa\3\2\2\2\u00de"+
    "\u00df\f\b\2\2\u00df\u00e0\7-\2\2\u00e0\u00e1\5\34\17\t\u00e1\u00e2\b"+
    "\17\1\2\u00e2\u00fa\3\2\2\2\u00e3\u00e4\f\7\2\2\u00e4\u00e5\7.\2\2\u00e5"+
    "\u00e6\5\34\17\b\u00e6\u00e7\b\17\1\2\u00e7\u00fa\3\2\2\2\u00e8\u00e9"+
    "\f\6\2\2\u00e9\u00ea\7/\2\2\u00ea\u00eb\5\34\17\7\u00eb\u00ec\b\17\1\2"+
    "\u00ec\u00fa\3\2\2\2\u00ed\u00ee\f\5\2\2\u00ee\u00ef\7\60\2\2\u00ef\u00f0"+
    "\5\34\17\6\u00f0\u00f1\b\17\1\2\u00f1\u00fa\3\2\2\2\u00f2\u00f3\f\4\2"+
    "\2\u00f3\u00f4\7\61\2\2\u00f4\u00f5\5\34\17\2\u00f5\u00f6\7\62\2\2\u00f6"+
    "\u00f7\5\34\17\4\u00f7\u00f8\b\17\1\2\u00f8\u00fa\3\2\2\2\u00f9\u00c0"+
    "\3\2\2\2\u00f9\u00c5\3\2\2\2\u00f9\u00ca\3\2\2\2\u00f9\u00cf\3\2\2\2\u00f9"+
    "\u00d4\3\2\2\2\u00f9\u00d9\3\2\2\2\u00f9\u00de\3\2\2\2\u00f9\u00e3\3\2"+
    "\2\2\u00f9\u00e8\3\2\2\2\u00f9\u00ed\3\2\2\2\u00f9\u00f2\3\2\2\2\u00fa"+
    "\u00fd\3\2\2\2\u00fb\u00f9\3\2\2\2\u00fb\u00fc\3\2\2\2\u00fc\35\3\2\2"+
    "\2\u00fd\u00fb\3\2\2\2\u00fe\u00ff\6\20\16\3\u00ff\u0100\t\n\2\2\u0100"+
    "\u011c\5 \21\2\u0101\u0102\6\20\17\3\u0102\u0103\5 \21\2\u0103\u0104\t"+
    "\n\2\2\u0104\u011c\3\2\2\2\u0105\u0106\6\20\20\3\u0106\u011c\5 \21\2\u0107"+
    "\u0108\6\20\21\3\u0108\u0109\t\13\2\2\u0109\u011c\b\20\1\2\u010a\u010b"+
    "\6\20\22\3\u010b\u010c\7G\2\2\u010c\u011c\b\20\1\2\u010d\u010e\6\20\23"+
    "\3\u010e\u010f\7H\2\2\u010f\u011c\b\20\1\2\u0110\u0111\6\20\24\3\u0111"+
    "\u0112\7I\2\2\u0112\u011c\b\20\1\2\u0113\u0114\6\20\25\3\u0114\u0115\t"+
    "\f\2\2\u0115\u011c\5\36\20\2\u0116\u0117\7\t\2\2\u0117\u0118\5\22\n\2"+
    "\u0118\u0119\7\n\2\2\u0119\u011a\5\36\20\2\u011a\u011c\3\2\2\2\u011b\u00fe"+
    "\3\2\2\2\u011b\u0101\3\2\2\2\u011b\u0105\3\2\2\2\u011b\u0107\3\2\2\2\u011b"+
    "\u010a\3\2\2\2\u011b\u010d\3\2\2\2\u011b\u0110\3\2\2\2\u011b\u0113\3\2"+
    "\2\2\u011b\u0116\3\2\2\2\u011c\37\3\2\2\2\u011d\u0121\5\"\22\2\u011e\u0120"+
    "\5$\23\2\u011f\u011e\3\2\2\2\u0120\u0123\3\2\2\2\u0121\u011f\3\2\2\2\u0121"+
    "\u0122\3\2\2\2\u0122\u0140\3\2\2\2\u0123\u0121\3\2\2\2\u0124\u0125\5\22"+
    "\n\2\u0125\u0129\5&\24\2\u0126\u0128\5$\23\2\u0127\u0126\3\2\2\2\u0128"+
    "\u012b\3\2\2\2\u0129\u0127\3\2\2\2\u0129\u012a\3\2\2\2\u012a\u0140\3\2"+
    "\2\2\u012b\u0129\3\2\2\2\u012c\u012d\7\26\2\2\u012d\u0132\7J\2\2\u012e"+
    "\u012f\7\7\2\2\u012f\u0130\5\34\17\2\u0130\u0131\7\b\2\2\u0131\u0133\3"+
    "\2\2\2\u0132\u012e\3\2\2\2\u0133\u0134\3\2\2\2\u0134\u0132\3\2\2\2\u0134"+
    "\u0135\3\2\2\2\u0135\u013d\3\2\2\2\u0136\u013a\5&\24\2\u0137\u0139\5$"+
    "\23\2\u0138\u0137\3\2\2\2\u0139\u013c\3\2\2\2\u013a\u0138\3\2\2\2\u013a"+
    "\u013b\3\2\2\2\u013b\u013e\3\2\2\2\u013c\u013a\3\2\2\2\u013d\u0136\3\2"+
    "\2\2\u013d\u013e\3\2\2\2\u013e\u0140\3\2\2\2\u013f\u011d\3\2\2\2\u013f"+
    "\u0124\3\2\2\2\u013f\u012c\3\2\2\2\u0140!\3\2\2\2\u0141\u0142\6\22\26"+
    "\3\u0142\u0143\7\t\2\2\u0143\u0144\5\34\17\2\u0144\u0145\7\n\2\2\u0145"+
    "\u0146\b\22\1\2\u0146\u0152\3\2\2\2\u0147\u0148\6\22\27\3\u0148\u0149"+
    "\7\t\2\2\u0149\u014a\5\36\20\2\u014a\u014b\7\n\2\2\u014b\u0152\3\2\2\2"+
    "\u014c\u0152\7F\2\2\u014d\u0152\7K\2\2\u014e\u014f\7\26\2\2\u014f\u0150"+
    "\7J\2\2\u0150\u0152\5*\26\2\u0151\u0141\3\2\2\2\u0151\u0147\3\2\2\2\u0151"+
    "\u014c\3\2\2\2\u0151\u014d\3\2\2\2\u0151\u014e\3\2\2\2\u0152#\3\2\2\2"+
    "\u0153\u0154\6\23\30\3\u0154\u0158\5&\24\2\u0155\u0156\6\23\31\3\u0156"+
    "\u0158\5(\25\2\u0157\u0153\3\2\2\2\u0157\u0155\3\2\2\2\u0158%\3\2\2\2"+
    "\u0159\u015a\7\13\2\2\u015a\u015b\7M\2\2\u015b\u015f\5*\26\2\u015c\u015d"+
    "\7\13\2\2\u015d\u015f\t\r\2\2\u015e\u0159\3\2\2\2\u015e\u015c\3\2\2\2"+
    "\u015f\'\3\2\2\2\u0160\u0161\7\7\2\2\u0161\u0162\5\34\17\2\u0162\u0163"+
    "\7\b\2\2\u0163)\3\2\2\2\u0164\u016d\7\t\2\2\u0165\u016a\5,\27\2\u0166"+
    "\u0167\7\f\2\2\u0167\u0169\5,\27\2\u0168\u0166\3\2\2\2\u0169\u016c\3\2"+
    "\2\2\u016a\u0168\3\2\2\2\u016a\u016b\3\2\2\2\u016b\u016e\3\2\2\2\u016c"+
    "\u016a\3\2\2\2\u016d\u0165\3\2\2\2\u016d\u016e\3\2\2\2\u016e\u016f\3\2"+
    "\2\2\u016f\u0170\7\n\2\2\u0170+\3\2\2\2\u0171\u0174\5\34\17\2\u0172\u0174"+
    "\5\24\13\2\u0173\u0171\3\2\2\2\u0173\u0172\3\2\2\2\u0174-\3\2\2\2!\61"+
    ">FSW[`r{\177\u0085\u008e\u0098\u00a0\u00aa\u00be\u00f9\u00fb\u011b\u0121"+
    "\u0129\u0134\u013a\u013d\u013f\u0151\u0157\u015e\u016a\u016d\u0173";
=======
    "\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u0125"+
    "\n\20\3\21\3\21\7\21\u0129\n\21\f\21\16\21\u012c\13\21\3\21\3\21\3\21"+
    "\7\21\u0131\n\21\f\21\16\21\u0134\13\21\3\21\3\21\3\21\3\21\3\21\3\21"+
    "\6\21\u013c\n\21\r\21\16\21\u013d\3\21\3\21\7\21\u0142\n\21\f\21\16\21"+
    "\u0145\13\21\5\21\u0147\n\21\5\21\u0149\n\21\3\22\3\22\3\22\3\22\3\22"+
    "\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u015b\n\22"+
    "\3\23\3\23\3\23\3\23\5\23\u0161\n\23\3\24\3\24\3\24\3\24\3\24\5\24\u0168"+
    "\n\24\3\25\3\25\3\25\3\25\3\26\3\26\3\26\3\26\7\26\u0172\n\26\f\26\16"+
    "\26\u0175\13\26\5\26\u0177\n\26\3\26\3\26\3\27\3\27\5\27\u017d\n\27\3"+
    "\27\2\3\34\30\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,\2\r\3\3\r"+
    "\r\3\2\66A\3\2\34\36\3\2\37 \3\2!#\3\2$\'\3\2(+\3\2\64\65\3\2BE\4\2\32"+
    "\33\37 \3\2LM\u01a5\2\61\3\2\2\2\4\u0084\3\2\2\2\6\u0088\3\2\2\2\b\u008a"+
    "\3\2\2\2\n\u0093\3\2\2\2\f\u0097\3\2\2\2\16\u0099\3\2\2\2\20\u009b\3\2"+
    "\2\2\22\u00a4\3\2\2\2\24\u00ac\3\2\2\2\26\u00b0\3\2\2\2\30\u00b5\3\2\2"+
    "\2\32\u00bc\3\2\2\2\34\u00c7\3\2\2\2\36\u0124\3\2\2\2 \u0148\3\2\2\2\""+
    "\u015a\3\2\2\2$\u0160\3\2\2\2&\u0167\3\2\2\2(\u0169\3\2\2\2*\u016d\3\2"+
    "\2\2,\u017c\3\2\2\2.\60\5\4\3\2/.\3\2\2\2\60\63\3\2\2\2\61/\3\2\2\2\61"+
    "\62\3\2\2\2\62\64\3\2\2\2\63\61\3\2\2\2\64\65\7\2\2\3\65\3\3\2\2\2\66"+
    "\67\7\16\2\2\678\7\t\2\289\5\34\17\29:\7\n\2\2:>\5\6\4\2;<\7\17\2\2<?"+
    "\5\6\4\2=?\6\3\2\2>;\3\2\2\2>=\3\2\2\2?\u0085\3\2\2\2@A\7\20\2\2AB\7\t"+
    "\2\2BC\5\34\17\2CF\7\n\2\2DG\5\6\4\2EG\5\n\6\2FD\3\2\2\2FE\3\2\2\2G\u0085"+
    "\3\2\2\2HI\7\21\2\2IJ\5\b\5\2JK\7\20\2\2KL\7\t\2\2LM\5\34\17\2MN\7\n\2"+
    "\2NO\5\32\16\2O\u0085\3\2\2\2PQ\7\22\2\2QS\7\t\2\2RT\5\f\7\2SR\3\2\2\2"+
    "ST\3\2\2\2TU\3\2\2\2UW\7\r\2\2VX\5\34\17\2WV\3\2\2\2WX\3\2\2\2XY\3\2\2"+
    "\2Y[\7\r\2\2Z\\\5\16\b\2[Z\3\2\2\2[\\\3\2\2\2\\]\3\2\2\2]`\7\n\2\2^a\5"+
    "\6\4\2_a\5\n\6\2`^\3\2\2\2`_\3\2\2\2a\u0085\3\2\2\2bc\7\22\2\2cd\7\t\2"+
    "\2de\5\22\n\2ef\7K\2\2fg\7\62\2\2gh\5\34\17\2hi\7\n\2\2ij\5\6\4\2j\u0085"+
    "\3\2\2\2kl\5\20\t\2lm\5\32\16\2m\u0085\3\2\2\2no\7\23\2\2o\u0085\5\32"+
    "\16\2pq\7\24\2\2q\u0085\5\32\16\2rs\7\25\2\2st\5\34\17\2tu\5\32\16\2u"+
    "\u0085\3\2\2\2vw\7\27\2\2wy\5\b\5\2xz\5\30\r\2yx\3\2\2\2z{\3\2\2\2{y\3"+
    "\2\2\2{|\3\2\2\2|\u0085\3\2\2\2}~\7\31\2\2~\177\5\34\17\2\177\u0080\5"+
    "\32\16\2\u0080\u0085\3\2\2\2\u0081\u0082\5\34\17\2\u0082\u0083\5\32\16"+
    "\2\u0083\u0085\3\2\2\2\u0084\66\3\2\2\2\u0084@\3\2\2\2\u0084H\3\2\2\2"+
    "\u0084P\3\2\2\2\u0084b\3\2\2\2\u0084k\3\2\2\2\u0084n\3\2\2\2\u0084p\3"+
    "\2\2\2\u0084r\3\2\2\2\u0084v\3\2\2\2\u0084}\3\2\2\2\u0084\u0081\3\2\2"+
    "\2\u0085\5\3\2\2\2\u0086\u0089\5\b\5\2\u0087\u0089\5\4\3\2\u0088\u0086"+
    "\3\2\2\2\u0088\u0087\3\2\2\2\u0089\7\3\2\2\2\u008a\u008e\7\5\2\2\u008b"+
    "\u008d\5\4\3\2\u008c\u008b\3\2\2\2\u008d\u0090\3\2\2\2\u008e\u008c\3\2"+
    "\2\2\u008e\u008f\3\2\2\2\u008f\u0091\3\2\2\2\u0090\u008e\3\2\2\2\u0091"+
    "\u0092\7\6\2\2\u0092\t\3\2\2\2\u0093\u0094\7\r\2\2\u0094\13\3\2\2\2\u0095"+
    "\u0098\5\20\t\2\u0096\u0098\5\34\17\2\u0097\u0095\3\2\2\2\u0097\u0096"+
    "\3\2\2\2\u0098\r\3\2\2\2\u0099\u009a\5\34\17\2\u009a\17\3\2\2\2\u009b"+
    "\u009c\5\22\n\2\u009c\u00a1\5\26\f\2\u009d\u009e\7\f\2\2\u009e\u00a0\5"+
    "\26\f\2\u009f\u009d\3\2\2\2\u00a0\u00a3\3\2\2\2\u00a1\u009f\3\2\2\2\u00a1"+
    "\u00a2\3\2\2\2\u00a2\21\3\2\2\2\u00a3\u00a1\3\2\2\2\u00a4\u00a9\7J\2\2"+
    "\u00a5\u00a6\7\7\2\2\u00a6\u00a8\7\b\2\2\u00a7\u00a5\3\2\2\2\u00a8\u00ab"+
    "\3\2\2\2\u00a9\u00a7\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa\23\3\2\2\2\u00ab"+
    "\u00a9\3\2\2\2\u00ac\u00ad\7J\2\2\u00ad\u00ae\7\63\2\2\u00ae\u00af\7K"+
    "\2\2\u00af\25\3\2\2\2\u00b0\u00b3\7K\2\2\u00b1\u00b2\7\66\2\2\u00b2\u00b4"+
    "\5\34\17\2\u00b3\u00b1\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4\27\3\2\2\2\u00b5"+
    "\u00b6\7\30\2\2\u00b6\u00b7\7\t\2\2\u00b7\u00b8\7J\2\2\u00b8\u00b9\7K"+
    "\2\2\u00b9\u00ba\7\n\2\2\u00ba\u00bb\5\b\5\2\u00bb\31\3\2\2\2\u00bc\u00bd"+
    "\t\2\2\2\u00bd\33\3\2\2\2\u00be\u00bf\b\17\1\2\u00bf\u00c0\5 \21\2\u00c0"+
    "\u00c1\t\3\2\2\u00c1\u00c2\5\34\17\3\u00c2\u00c3\b\17\1\2\u00c3\u00c8"+
    "\3\2\2\2\u00c4\u00c5\5\36\20\2\u00c5\u00c6\b\17\1\2\u00c6\u00c8\3\2\2"+
    "\2\u00c7\u00be\3\2\2\2\u00c7\u00c4\3\2\2\2\u00c8\u0104\3\2\2\2\u00c9\u00ca"+
    "\f\16\2\2\u00ca\u00cb\t\4\2\2\u00cb\u00cc\5\34\17\17\u00cc\u00cd\b\17"+
    "\1\2\u00cd\u0103\3\2\2\2\u00ce\u00cf\f\r\2\2\u00cf\u00d0\t\5\2\2\u00d0"+
    "\u00d1\5\34\17\16\u00d1\u00d2\b\17\1\2\u00d2\u0103\3\2\2\2\u00d3\u00d4"+
    "\f\f\2\2\u00d4\u00d5\t\6\2\2\u00d5\u00d6\5\34\17\r\u00d6\u00d7\b\17\1"+
    "\2\u00d7\u0103\3\2\2\2\u00d8\u00d9\f\13\2\2\u00d9\u00da\t\7\2\2\u00da"+
    "\u00db\5\34\17\f\u00db\u00dc\b\17\1\2\u00dc\u0103\3\2\2\2\u00dd\u00de"+
    "\f\n\2\2\u00de\u00df\t\b\2\2\u00df\u00e0\5\34\17\13\u00e0\u00e1\b\17\1"+
    "\2\u00e1\u0103\3\2\2\2\u00e2\u00e3\f\t\2\2\u00e3\u00e4\7,\2\2\u00e4\u00e5"+
    "\5\34\17\n\u00e5\u00e6\b\17\1\2\u00e6\u0103\3\2\2\2\u00e7\u00e8\f\b\2"+
    "\2\u00e8\u00e9\7-\2\2\u00e9\u00ea\5\34\17\t\u00ea\u00eb\b\17\1\2\u00eb"+
    "\u0103\3\2\2\2\u00ec\u00ed\f\7\2\2\u00ed\u00ee\7.\2\2\u00ee\u00ef\5\34"+
    "\17\b\u00ef\u00f0\b\17\1\2\u00f0\u0103\3\2\2\2\u00f1\u00f2\f\6\2\2\u00f2"+
    "\u00f3\7/\2\2\u00f3\u00f4\5\34\17\7\u00f4\u00f5\b\17\1\2\u00f5\u0103\3"+
    "\2\2\2\u00f6\u00f7\f\5\2\2\u00f7\u00f8\7\60\2\2\u00f8\u00f9\5\34\17\6"+
    "\u00f9\u00fa\b\17\1\2\u00fa\u0103\3\2\2\2\u00fb\u00fc\f\4\2\2\u00fc\u00fd"+
    "\7\61\2\2\u00fd\u00fe\5\34\17\2\u00fe\u00ff\7\62\2\2\u00ff\u0100\5\34"+
    "\17\4\u0100\u0101\b\17\1\2\u0101\u0103\3\2\2\2\u0102\u00c9\3\2\2\2\u0102"+
    "\u00ce\3\2\2\2\u0102\u00d3\3\2\2\2\u0102\u00d8\3\2\2\2\u0102\u00dd\3\2"+
    "\2\2\u0102\u00e2\3\2\2\2\u0102\u00e7\3\2\2\2\u0102\u00ec\3\2\2\2\u0102"+
    "\u00f1\3\2\2\2\u0102\u00f6\3\2\2\2\u0102\u00fb\3\2\2\2\u0103\u0106\3\2"+
    "\2\2\u0104\u0102\3\2\2\2\u0104\u0105\3\2\2\2\u0105\35\3\2\2\2\u0106\u0104"+
    "\3\2\2\2\u0107\u0108\6\20\16\3\u0108\u0109\t\t\2\2\u0109\u0125\5 \21\2"+
    "\u010a\u010b\6\20\17\3\u010b\u010c\5 \21\2\u010c\u010d\t\t\2\2\u010d\u0125"+
    "\3\2\2\2\u010e\u010f\6\20\20\3\u010f\u0125\5 \21\2\u0110\u0111\6\20\21"+
    "\3\u0111\u0112\t\n\2\2\u0112\u0125\b\20\1\2\u0113\u0114\6\20\22\3\u0114"+
    "\u0115\7G\2\2\u0115\u0125\b\20\1\2\u0116\u0117\6\20\23\3\u0117\u0118\7"+
    "H\2\2\u0118\u0125\b\20\1\2\u0119\u011a\6\20\24\3\u011a\u011b\7I\2\2\u011b"+
    "\u0125\b\20\1\2\u011c\u011d\6\20\25\3\u011d\u011e\t\13\2\2\u011e\u0125"+
    "\5\36\20\2\u011f\u0120\7\t\2\2\u0120\u0121\5\22\n\2\u0121\u0122\7\n\2"+
    "\2\u0122\u0123\5\36\20\2\u0123\u0125\3\2\2\2\u0124\u0107\3\2\2\2\u0124"+
    "\u010a\3\2\2\2\u0124\u010e\3\2\2\2\u0124\u0110\3\2\2\2\u0124\u0113\3\2"+
    "\2\2\u0124\u0116\3\2\2\2\u0124\u0119\3\2\2\2\u0124\u011c\3\2\2\2\u0124"+
    "\u011f\3\2\2\2\u0125\37\3\2\2\2\u0126\u012a\5\"\22\2\u0127\u0129\5$\23"+
    "\2\u0128\u0127\3\2\2\2\u0129\u012c\3\2\2\2\u012a\u0128\3\2\2\2\u012a\u012b"+
    "\3\2\2\2\u012b\u0149\3\2\2\2\u012c\u012a\3\2\2\2\u012d\u012e\5\22\n\2"+
    "\u012e\u0132\5&\24\2\u012f\u0131\5$\23\2\u0130\u012f\3\2\2\2\u0131\u0134"+
    "\3\2\2\2\u0132\u0130\3\2\2\2\u0132\u0133\3\2\2\2\u0133\u0149\3\2\2\2\u0134"+
    "\u0132\3\2\2\2\u0135\u0136\7\26\2\2\u0136\u013b\7J\2\2\u0137\u0138\7\7"+
    "\2\2\u0138\u0139\5\34\17\2\u0139\u013a\7\b\2\2\u013a\u013c\3\2\2\2\u013b"+
    "\u0137\3\2\2\2\u013c\u013d\3\2\2\2\u013d\u013b\3\2\2\2\u013d\u013e\3\2"+
    "\2\2\u013e\u0146\3\2\2\2\u013f\u0143\5&\24\2\u0140\u0142\5$\23\2\u0141"+
    "\u0140\3\2\2\2\u0142\u0145\3\2\2\2\u0143\u0141\3\2\2\2\u0143\u0144\3\2"+
    "\2\2\u0144\u0147\3\2\2\2\u0145\u0143\3\2\2\2\u0146\u013f\3\2\2\2\u0146"+
    "\u0147\3\2\2\2\u0147\u0149\3\2\2\2\u0148\u0126\3\2\2\2\u0148\u012d\3\2"+
    "\2\2\u0148\u0135\3\2\2\2\u0149!\3\2\2\2\u014a\u014b\6\22\26\3\u014b\u014c"+
    "\7\t\2\2\u014c\u014d\5\34\17\2\u014d\u014e\7\n\2\2\u014e\u014f\b\22\1"+
    "\2\u014f\u015b\3\2\2\2\u0150\u0151\6\22\27\3\u0151\u0152\7\t\2\2\u0152"+
    "\u0153\5\36\20\2\u0153\u0154\7\n\2\2\u0154\u015b\3\2\2\2\u0155\u015b\7"+
    "F\2\2\u0156\u015b\7K\2\2\u0157\u0158\7\26\2\2\u0158\u0159\7J\2\2\u0159"+
    "\u015b\5*\26\2\u015a\u014a\3\2\2\2\u015a\u0150\3\2\2\2\u015a\u0155\3\2"+
    "\2\2\u015a\u0156\3\2\2\2\u015a\u0157\3\2\2\2\u015b#\3\2\2\2\u015c\u015d"+
    "\6\23\30\3\u015d\u0161\5&\24\2\u015e\u015f\6\23\31\3\u015f\u0161\5(\25"+
    "\2\u0160\u015c\3\2\2\2\u0160\u015e\3\2\2\2\u0161%\3\2\2\2\u0162\u0163"+
    "\7\13\2\2\u0163\u0164\7M\2\2\u0164\u0168\5*\26\2\u0165\u0166\7\13\2\2"+
    "\u0166\u0168\t\f\2\2\u0167\u0162\3\2\2\2\u0167\u0165\3\2\2\2\u0168\'\3"+
    "\2\2\2\u0169\u016a\7\7\2\2\u016a\u016b\5\34\17\2\u016b\u016c\7\b\2\2\u016c"+
    ")\3\2\2\2\u016d\u0176\7\t\2\2\u016e\u0173\5,\27\2\u016f\u0170\7\f\2\2"+
    "\u0170\u0172\5,\27\2\u0171\u016f\3\2\2\2\u0172\u0175\3\2\2\2\u0173\u0171"+
    "\3\2\2\2\u0173\u0174\3\2\2\2\u0174\u0177\3\2\2\2\u0175\u0173\3\2\2\2\u0176"+
    "\u016e\3\2\2\2\u0176\u0177\3\2\2\2\u0177\u0178\3\2\2\2\u0178\u0179\7\n"+
    "\2\2\u0179+\3\2\2\2\u017a\u017d\5\34\17\2\u017b\u017d\5\24\13\2\u017c"+
    "\u017a\3\2\2\2\u017c\u017b\3\2\2\2\u017d-\3\2\2\2!\61>FSW[`{\u0084\u0088"+
    "\u008e\u0097\u00a1\u00a9\u00b3\u00c7\u0102\u0104\u0124\u012a\u0132\u013d"+
    "\u0143\u0146\u0148\u015a\u0160\u0167\u0173\u0176\u017c";
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_edb0fd3_f98be6f/rev_edb0fd3-f98be6f/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java;<<<<<<< MINE
    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3M\u0183\4\2\t\2\4"+
=======
    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3M\u01a0\4\2\t\2\4"+
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_edb0fd3_f98be6f/rev_edb0fd3-f98be6f/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java;<<<<<<< MINE
    "\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\3\2\7\2\60\n\2\f\2"+
    "\16\2\63\13\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3?\n\3\3\3\3\3"+
    "\3\3\3\3\3\3\3\3\5\3G\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3"+
    "\5\3T\n\3\3\3\3\3\5\3X\n\3\3\3\3\3\5\3\\\n\3\3\3\3\3\3\3\5\3a\n\3\3\3"+
    "\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3"+
    "\3\3\3\3\3\3\3\3\3\6\3z\n\3\r\3\16\3{\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3"+
    "\u0085\n\3\3\4\3\4\5\4\u0089\n\4\3\5\3\5\7\5\u008d\n\5\f\5\16\5\u0090"+
    "\13\5\3\5\3\5\3\6\3\6\3\7\3\7\5\7\u0098\n\7\3\b\3\b\3\t\3\t\3\t\3\t\7"+
    "\t\u00a0\n\t\f\t\16\t\u00a3\13\t\3\n\3\n\3\n\7\n\u00a8\n\n\f\n\16\n\u00ab"+
    "\13\n\3\13\3\13\3\13\3\13\3\13\3\13\5\13\u00b3\n\13\3\f\3\f\3\f\5\f\u00b8"+
    "\n\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3"+
    "\17\3\17\3\17\3\17\5\17\u00cc\n\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17"+
    "\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17"+
    "\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17"+
    "\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17"+
    "\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\7\17\u0107\n\17\f\17\16\17\u010a"+
    "\13\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20"+
    "\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20"+
    "\3\20\3\20\5\20\u0129\n\20\3\21\3\21\7\21\u012d\n\21\f\21\16\21\u0130"+
    "\13\21\3\21\3\21\3\21\7\21\u0135\n\21\f\21\16\21\u0138\13\21\3\21\3\21"+
    "\3\21\3\21\3\21\3\21\6\21\u0140\n\21\r\21\16\21\u0141\3\21\3\21\7\21\u0146"+
    "\n\21\f\21\16\21\u0149\13\21\5\21\u014b\n\21\5\21\u014d\n\21\3\22\3\22"+
    "\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22"+
    "\5\22\u015f\n\22\3\23\3\23\3\23\3\23\5\23\u0165\n\23\3\24\3\24\3\24\3"+
    "\24\3\24\5\24\u016c\n\24\3\25\3\25\3\25\3\25\3\26\3\26\3\26\3\26\7\26"+
    "\u0176\n\26\f\26\16\26\u0179\13\26\5\26\u017b\n\26\3\26\3\26\3\27\3\27"+
    "\5\27\u0181\n\27\3\27\2\3\34\30\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36"+
    " \"$&(*,\2\16\4\2\26\26KK\3\3\r\r\3\2\66A\3\2\34\36\3\2\37 \3\2!#\3\2"+
    "$\'\3\2(+\3\2\64\65\3\2BE\4\2\32\33\37 \3\2LM\u01aa\2\61\3\2\2\2\4\u0084"+
    "\3\2\2\2\6\u0088\3\2\2\2\b\u008a\3\2\2\2\n\u0093\3\2\2\2\f\u0097\3\2\2"+
    "\2\16\u0099\3\2\2\2\20\u009b\3\2\2\2\22\u00a4\3\2\2\2\24\u00b2\3\2\2\2"+
    "\26\u00b4\3\2\2\2\30\u00b9\3\2\2\2\32\u00c0\3\2\2\2\34\u00cb\3\2\2\2\36"+
    "\u0128\3\2\2\2 \u014c\3\2\2\2\"\u015e\3\2\2\2$\u0164\3\2\2\2&\u016b\3"+
    "\2\2\2(\u016d\3\2\2\2*\u0171\3\2\2\2,\u0180\3\2\2\2.\60\5\4\3\2/.\3\2"+
    "\2\2\60\63\3\2\2\2\61/\3\2\2\2\61\62\3\2\2\2\62\64\3\2\2\2\63\61\3\2\2"+
    "\2\64\65\7\2\2\3\65\3\3\2\2\2\66\67\7\16\2\2\678\7\t\2\289\5\34\17\29"+
    ":\7\n\2\2:>\5\6\4\2;<\7\17\2\2<?\5\6\4\2=?\6\3\2\2>;\3\2\2\2>=\3\2\2\2"+
    "?\u0085\3\2\2\2@A\7\20\2\2AB\7\t\2\2BC\5\34\17\2CF\7\n\2\2DG\5\6\4\2E"+
    "G\5\n\6\2FD\3\2\2\2FE\3\2\2\2G\u0085\3\2\2\2HI\7\21\2\2IJ\5\b\5\2JK\7"+
    "\20\2\2KL\7\t\2\2LM\5\34\17\2MN\7\n\2\2NO\5\32\16\2O\u0085\3\2\2\2PQ\7"+
    "\22\2\2QS\7\t\2\2RT\5\f\7\2SR\3\2\2\2ST\3\2\2\2TU\3\2\2\2UW\7\r\2\2VX"+
    "\5\34\17\2WV\3\2\2\2WX\3\2\2\2XY\3\2\2\2Y[\7\r\2\2Z\\\5\16\b\2[Z\3\2\2"+
    "\2[\\\3\2\2\2\\]\3\2\2\2]`\7\n\2\2^a\5\6\4\2_a\5\n\6\2`^\3\2\2\2`_\3\2"+
    "\2\2a\u0085\3\2\2\2bc\7\22\2\2cd\7\t\2\2de\5\22\n\2ef\7K\2\2fg\7\62\2"+
    "\2gh\5\34\17\2hi\7\n\2\2ij\5\6\4\2j\u0085\3\2\2\2kl\5\20\t\2lm\5\32\16"+
    "\2m\u0085\3\2\2\2no\7\23\2\2o\u0085\5\32\16\2pq\7\24\2\2q\u0085\5\32\16"+
    "\2rs\7\25\2\2st\5\34\17\2tu\5\32\16\2u\u0085\3\2\2\2vw\7\27\2\2wy\5\b"+
    "\5\2xz\5\30\r\2yx\3\2\2\2z{\3\2\2\2{y\3\2\2\2{|\3\2\2\2|\u0085\3\2\2\2"+
    "}~\7\31\2\2~\177\5\34\17\2\177\u0080\5\32\16\2\u0080\u0085\3\2\2\2\u0081"+
    "\u0082\5\34\17\2\u0082\u0083\5\32\16\2\u0083\u0085\3\2\2\2\u0084\66\3"+
    "\2\2\2\u0084@\3\2\2\2\u0084H\3\2\2\2\u0084P\3\2\2\2\u0084b\3\2\2\2\u0084"+
    "k\3\2\2\2\u0084n\3\2\2\2\u0084p\3\2\2\2\u0084r\3\2\2\2\u0084v\3\2\2\2"+
    "\u0084}\3\2\2\2\u0084\u0081\3\2\2\2\u0085\5\3\2\2\2\u0086\u0089\5\b\5"+
    "\2\u0087\u0089\5\4\3\2\u0088\u0086\3\2\2\2\u0088\u0087\3\2\2\2\u0089\7"+
    "\3\2\2\2\u008a\u008e\7\5\2\2\u008b\u008d\5\4\3\2\u008c\u008b\3\2\2\2\u008d"+
    "\u0090\3\2\2\2\u008e\u008c\3\2\2\2\u008e\u008f\3\2\2\2\u008f\u0091\3\2"+
    "\2\2\u0090\u008e\3\2\2\2\u0091\u0092\7\6\2\2\u0092\t\3\2\2\2\u0093\u0094"+
    "\7\r\2\2\u0094\13\3\2\2\2\u0095\u0098\5\20\t\2\u0096\u0098\5\34\17\2\u0097"+
    "\u0095\3\2\2\2\u0097\u0096\3\2\2\2\u0098\r\3\2\2\2\u0099\u009a\5\34\17"+
    "\2\u009a\17\3\2\2\2\u009b\u009c\5\22\n\2\u009c\u00a1\5\26\f\2\u009d\u009e"+
    "\7\f\2\2\u009e\u00a0\5\26\f\2\u009f\u009d\3\2\2\2\u00a0\u00a3\3\2\2\2"+
    "\u00a1\u009f\3\2\2\2\u00a1\u00a2\3\2\2\2\u00a2\21\3\2\2\2\u00a3\u00a1"+
    "\3\2\2\2\u00a4\u00a9\7J\2\2\u00a5\u00a6\7\7\2\2\u00a6\u00a8\7\b\2\2\u00a7"+
    "\u00a5\3\2\2\2\u00a8\u00ab\3\2\2\2\u00a9\u00a7\3\2\2\2\u00a9\u00aa\3\2"+
    "\2\2\u00aa\23\3\2\2\2\u00ab\u00a9\3\2\2\2\u00ac\u00ad\7J\2\2\u00ad\u00ae"+
    "\7\63\2\2\u00ae\u00b3\t\2\2\2\u00af\u00b0\7K\2\2\u00b0\u00b1\7\63\2\2"+
    "\u00b1\u00b3\7K\2\2\u00b2\u00ac\3\2\2\2\u00b2\u00af\3\2\2\2\u00b3\25\3"+
    "\2\2\2\u00b4\u00b7\7K\2\2\u00b5\u00b6\7\66\2\2\u00b6\u00b8\5\34\17\2\u00b7"+
    "\u00b5\3\2\2\2\u00b7\u00b8\3\2\2\2\u00b8\27\3\2\2\2\u00b9\u00ba\7\30\2"+
    "\2\u00ba\u00bb\7\t\2\2\u00bb\u00bc\7J\2\2\u00bc\u00bd\7K\2\2\u00bd\u00be"+
    "\7\n\2\2\u00be\u00bf\5\b\5\2\u00bf\31\3\2\2\2\u00c0\u00c1\t\3\2\2\u00c1"+
    "\33\3\2\2\2\u00c2\u00c3\b\17\1\2\u00c3\u00c4\5 \21\2\u00c4\u00c5\t\4\2"+
    "\2\u00c5\u00c6\5\34\17\3\u00c6\u00c7\b\17\1\2\u00c7\u00cc\3\2\2\2\u00c8"+
    "\u00c9\5\36\20\2\u00c9\u00ca\b\17\1\2\u00ca\u00cc\3\2\2\2\u00cb\u00c2"+
    "\3\2\2\2\u00cb\u00c8\3\2\2\2\u00cc\u0108\3\2\2\2\u00cd\u00ce\f\16\2\2"+
    "\u00ce\u00cf\t\5\2\2\u00cf\u00d0\5\34\17\17\u00d0\u00d1\b\17\1\2\u00d1"+
    "\u0107\3\2\2\2\u00d2\u00d3\f\r\2\2\u00d3\u00d4\t\6\2\2\u00d4\u00d5\5\34"+
    "\17\16\u00d5\u00d6\b\17\1\2\u00d6\u0107\3\2\2\2\u00d7\u00d8\f\f\2\2\u00d8"+
    "\u00d9\t\7\2\2\u00d9\u00da\5\34\17\r\u00da\u00db\b\17\1\2\u00db\u0107"+
    "\3\2\2\2\u00dc\u00dd\f\13\2\2\u00dd\u00de\t\b\2\2\u00de\u00df\5\34\17"+
    "\f\u00df\u00e0\b\17\1\2\u00e0\u0107\3\2\2\2\u00e1\u00e2\f\n\2\2\u00e2"+
    "\u00e3\t\t\2\2\u00e3\u00e4\5\34\17\13\u00e4\u00e5\b\17\1\2\u00e5\u0107"+
    "\3\2\2\2\u00e6\u00e7\f\t\2\2\u00e7\u00e8\7,\2\2\u00e8\u00e9\5\34\17\n"+
    "\u00e9\u00ea\b\17\1\2\u00ea\u0107\3\2\2\2\u00eb\u00ec\f\b\2\2\u00ec\u00ed"+
    "\7-\2\2\u00ed\u00ee\5\34\17\t\u00ee\u00ef\b\17\1\2\u00ef\u0107\3\2\2\2"+
    "\u00f0\u00f1\f\7\2\2\u00f1\u00f2\7.\2\2\u00f2\u00f3\5\34\17\b\u00f3\u00f4"+
    "\b\17\1\2\u00f4\u0107\3\2\2\2\u00f5\u00f6\f\6\2\2\u00f6\u00f7\7/\2\2\u00f7"+
    "\u00f8\5\34\17\7\u00f8\u00f9\b\17\1\2\u00f9\u0107\3\2\2\2\u00fa\u00fb"+
    "\f\5\2\2\u00fb\u00fc\7\60\2\2\u00fc\u00fd\5\34\17\6\u00fd\u00fe\b\17\1"+
    "\2\u00fe\u0107\3\2\2\2\u00ff\u0100\f\4\2\2\u0100\u0101\7\61\2\2\u0101"+
    "\u0102\5\34\17\2\u0102\u0103\7\62\2\2\u0103\u0104\5\34\17\4\u0104\u0105"+
    "\b\17\1\2\u0105\u0107\3\2\2\2\u0106\u00cd\3\2\2\2\u0106\u00d2\3\2\2\2"+
    "\u0106\u00d7\3\2\2\2\u0106\u00dc\3\2\2\2\u0106\u00e1\3\2\2\2\u0106\u00e6"+
    "\3\2\2\2\u0106\u00eb\3\2\2\2\u0106\u00f0\3\2\2\2\u0106\u00f5\3\2\2\2\u0106"+
    "\u00fa\3\2\2\2\u0106\u00ff\3\2\2\2\u0107\u010a\3\2\2\2\u0108\u0106\3\2"+
    "\2\2\u0108\u0109\3\2\2\2\u0109\35\3\2\2\2\u010a\u0108\3\2\2\2\u010b\u010c"+
    "\6\20\16\3\u010c\u010d\t\n\2\2\u010d\u0129\5 \21\2\u010e\u010f\6\20\17"+
    "\3\u010f\u0110\5 \21\2\u0110\u0111\t\n\2\2\u0111\u0129\3\2\2\2\u0112\u0113"+
    "\6\20\20\3\u0113\u0129\5 \21\2\u0114\u0115\6\20\21\3\u0115\u0116\t\13"+
    "\2\2\u0116\u0129\b\20\1\2\u0117\u0118\6\20\22\3\u0118\u0119\7G\2\2\u0119"+
    "\u0129\b\20\1\2\u011a\u011b\6\20\23\3\u011b\u011c\7H\2\2\u011c\u0129\b"+
    "\20\1\2\u011d\u011e\6\20\24\3\u011e\u011f\7I\2\2\u011f\u0129\b\20\1\2"+
    "\u0120\u0121\6\20\25\3\u0121\u0122\t\f\2\2\u0122\u0129\5\36\20\2\u0123"+
    "\u0124\7\t\2\2\u0124\u0125\5\22\n\2\u0125\u0126\7\n\2\2\u0126\u0127\5"+
    "\36\20\2\u0127\u0129\3\2\2\2\u0128\u010b\3\2\2\2\u0128\u010e\3\2\2\2\u0128"+
    "\u0112\3\2\2\2\u0128\u0114\3\2\2\2\u0128\u0117\3\2\2\2\u0128\u011a\3\2"+
    "\2\2\u0128\u011d\3\2\2\2\u0128\u0120\3\2\2\2\u0128\u0123\3\2\2\2\u0129"+
    "\37\3\2\2\2\u012a\u012e\5\"\22\2\u012b\u012d\5$\23\2\u012c\u012b\3\2\2"+
    "\2\u012d\u0130\3\2\2\2\u012e\u012c\3\2\2\2\u012e\u012f\3\2\2\2\u012f\u014d"+
    "\3\2\2\2\u0130\u012e\3\2\2\2\u0131\u0132\5\22\n\2\u0132\u0136\5&\24\2"+
    "\u0133\u0135\5$\23\2\u0134\u0133\3\2\2\2\u0135\u0138\3\2\2\2\u0136\u0134"+
    "\3\2\2\2\u0136\u0137\3\2\2\2\u0137\u014d\3\2\2\2\u0138\u0136\3\2\2\2\u0139"+
    "\u013a\7\26\2\2\u013a\u013f\7J\2\2\u013b\u013c\7\7\2\2\u013c\u013d\5\34"+
    "\17\2\u013d\u013e\7\b\2\2\u013e\u0140\3\2\2\2\u013f\u013b\3\2\2\2\u0140"+
    "\u0141\3\2\2\2\u0141\u013f\3\2\2\2\u0141\u0142\3\2\2\2\u0142\u014a\3\2"+
    "\2\2\u0143\u0147\5&\24\2\u0144\u0146\5$\23\2\u0145\u0144\3\2\2\2\u0146"+
    "\u0149\3\2\2\2\u0147\u0145\3\2\2\2\u0147\u0148\3\2\2\2\u0148\u014b\3\2"+
    "\2\2\u0149\u0147\3\2\2\2\u014a\u0143\3\2\2\2\u014a\u014b\3\2\2\2\u014b"+
    "\u014d\3\2\2\2\u014c\u012a\3\2\2\2\u014c\u0131\3\2\2\2\u014c\u0139\3\2"+
    "\2\2\u014d!\3\2\2\2\u014e\u014f\6\22\26\3\u014f\u0150\7\t\2\2\u0150\u0151"+
    "\5\34\17\2\u0151\u0152\7\n\2\2\u0152\u0153\b\22\1\2\u0153\u015f\3\2\2"+
    "\2\u0154\u0155\6\22\27\3\u0155\u0156\7\t\2\2\u0156\u0157\5\36\20\2\u0157"+
    "\u0158\7\n\2\2\u0158\u015f\3\2\2\2\u0159\u015f\7F\2\2\u015a\u015f\7K\2"+
    "\2\u015b\u015c\7\26\2\2\u015c\u015d\7J\2\2\u015d\u015f\5*\26\2\u015e\u014e"+
    "\3\2\2\2\u015e\u0154\3\2\2\2\u015e\u0159\3\2\2\2\u015e\u015a\3\2\2\2\u015e"+
    "\u015b\3\2\2\2\u015f#\3\2\2\2\u0160\u0161\6\23\30\3\u0161\u0165\5&\24"+
    "\2\u0162\u0163\6\23\31\3\u0163\u0165\5(\25\2\u0164\u0160\3\2\2\2\u0164"+
    "\u0162\3\2\2\2\u0165%\3\2\2\2\u0166\u0167\7\13\2\2\u0167\u0168\7M\2\2"+
    "\u0168\u016c\5*\26\2\u0169\u016a\7\13\2\2\u016a\u016c\t\r\2\2\u016b\u0166"+
    "\3\2\2\2\u016b\u0169\3\2\2\2\u016c\'\3\2\2\2\u016d\u016e\7\7\2\2\u016e"+
    "\u016f\5\34\17\2\u016f\u0170\7\b\2\2\u0170)\3\2\2\2\u0171\u017a\7\t\2"+
    "\2\u0172\u0177\5,\27\2\u0173\u0174\7\f\2\2\u0174\u0176\5,\27\2\u0175\u0173"+
    "\3\2\2\2\u0176\u0179\3\2\2\2\u0177\u0175\3\2\2\2\u0177\u0178\3\2\2\2\u0178"+
    "\u017b\3\2\2\2\u0179\u0177\3\2\2\2\u017a\u0172\3\2\2\2\u017a\u017b\3\2"+
    "\2\2\u017b\u017c\3\2\2\2\u017c\u017d\7\n\2\2\u017d+\3\2\2\2\u017e\u0181"+
    "\5\34\17\2\u017f\u0181\5\24\13\2\u0180\u017e\3\2\2\2\u0180\u017f\3\2\2"+
    "\2\u0181-\3\2\2\2\"\61>FSW[`{\u0084\u0088\u008e\u0097\u00a1\u00a9\u00b2"+
    "\u00b7\u00cb\u0106\u0108\u0128\u012e\u0136\u0141\u0147\u014a\u014c\u015e"+
    "\u0164\u016b\u0177\u017a\u0180";
=======
    "\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31\t\31"+
    "\3\2\7\2\64\n\2\f\2\16\2\67\13\2\3\2\7\2:\n\2\f\2\16\2=\13\2\3\2\3\2\3"+
    "\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\7\4M\n\4\f\4\16\4P\13\4"+
    "\5\4R\n\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5^\n\5\3\5\3\5\3\5"+
    "\3\5\3\5\3\5\5\5f\n\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5"+
    "s\n\5\3\5\3\5\5\5w\n\5\3\5\3\5\5\5{\n\5\3\5\3\5\3\5\5\5\u0080\n\5\3\5"+
    "\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3"+
    "\5\3\5\3\5\3\5\3\5\6\5\u0099\n\5\r\5\16\5\u009a\3\5\3\5\3\5\3\5\3\5\3"+
    "\5\3\5\5\5\u00a4\n\5\3\6\3\6\5\6\u00a8\n\6\3\7\3\7\7\7\u00ac\n\7\f\7\16"+
    "\7\u00af\13\7\3\7\3\7\3\b\3\b\3\t\3\t\5\t\u00b7\n\t\3\n\3\n\3\13\3\13"+
    "\3\13\3\13\7\13\u00bf\n\13\f\13\16\13\u00c2\13\13\3\f\3\f\3\f\7\f\u00c7"+
    "\n\f\f\f\16\f\u00ca\13\f\3\r\3\r\3\r\3\r\3\16\3\16\3\16\5\16\u00d3\n\16"+
    "\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\20\3\20\3\21\3\21\3\21\3\21\3\21"+
    "\3\21\3\21\3\21\3\21\5\21\u00e7\n\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21"+
    "\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21"+
    "\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21"+
    "\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21"+
    "\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\7\21\u0122\n\21\f\21\16\21\u0125"+
    "\13\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22"+
    "\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22"+
    "\3\22\3\22\5\22\u0144\n\22\3\23\3\23\7\23\u0148\n\23\f\23\16\23\u014b"+
    "\13\23\3\23\3\23\3\23\7\23\u0150\n\23\f\23\16\23\u0153\13\23\3\23\3\23"+
    "\3\23\3\23\3\23\3\23\6\23\u015b\n\23\r\23\16\23\u015c\3\23\3\23\7\23\u0161"+
    "\n\23\f\23\16\23\u0164\13\23\5\23\u0166\n\23\5\23\u0168\n\23\3\24\3\24"+
    "\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24"+
    "\3\24\3\24\5\24\u017c\n\24\3\25\3\25\3\25\3\25\5\25\u0182\n\25\3\26\3"+
    "\26\3\26\3\26\3\26\5\26\u0189\n\26\3\27\3\27\3\27\3\27\3\30\3\30\3\30"+
    "\3\30\7\30\u0193\n\30\f\30\16\30\u0196\13\30\5\30\u0198\n\30\3\30\3\30"+
    "\3\31\3\31\5\31\u019e\n\31\3\31\2\3 \32\2\4\6\b\n\f\16\20\22\24\26\30"+
    "\32\34\36 \"$&(*,.\60\2\16\4\2\26\26KK\3\3\r\r\3\2\66A\3\2\34\36\3\2\37"+
    " \3\2!#\3\2$\'\3\2(+\3\2\64\65\3\2BE\4\2\32\33\37 \3\2LM\u01c8\2\65\3"+
    "\2\2\2\4@\3\2\2\2\6E\3\2\2\2\b\u00a3\3\2\2\2\n\u00a7\3\2\2\2\f\u00a9\3"+
    "\2\2\2\16\u00b2\3\2\2\2\20\u00b6\3\2\2\2\22\u00b8\3\2\2\2\24\u00ba\3\2"+
    "\2\2\26\u00c3\3\2\2\2\30\u00cb\3\2\2\2\32\u00cf\3\2\2\2\34\u00d4\3\2\2"+
    "\2\36\u00db\3\2\2\2 \u00e6\3\2\2\2\"\u0143\3\2\2\2$\u0167\3\2\2\2&\u017b"+
    "\3\2\2\2(\u0181\3\2\2\2*\u0188\3\2\2\2,\u018a\3\2\2\2.\u018e\3\2\2\2\60"+
    "\u019d\3\2\2\2\62\64\5\4\3\2\63\62\3\2\2\2\64\67\3\2\2\2\65\63\3\2\2\2"+
    "\65\66\3\2\2\2\66;\3\2\2\2\67\65\3\2\2\28:\5\b\5\298\3\2\2\2:=\3\2\2\2"+
    ";9\3\2\2\2;<\3\2\2\2<>\3\2\2\2=;\3\2\2\2>?\7\2\2\3?\3\3\2\2\2@A\5\26\f"+
    "\2AB\7K\2\2BC\5\6\4\2CD\5\f\7\2D\5\3\2\2\2EQ\7\t\2\2FG\5\26\f\2GN\7K\2"+
    "\2HI\7\f\2\2IJ\5\26\f\2JK\7K\2\2KM\3\2\2\2LH\3\2\2\2MP\3\2\2\2NL\3\2\2"+
    "\2NO\3\2\2\2OR\3\2\2\2PN\3\2\2\2QF\3\2\2\2QR\3\2\2\2RS\3\2\2\2ST\7\n\2"+
    "\2T\7\3\2\2\2UV\7\16\2\2VW\7\t\2\2WX\5 \21\2XY\7\n\2\2Y]\5\n\6\2Z[\7\17"+
    "\2\2[^\5\n\6\2\\^\6\5\2\2]Z\3\2\2\2]\\\3\2\2\2^\u00a4\3\2\2\2_`\7\20\2"+
    "\2`a\7\t\2\2ab\5 \21\2be\7\n\2\2cf\5\n\6\2df\5\16\b\2ec\3\2\2\2ed\3\2"+
    "\2\2f\u00a4\3\2\2\2gh\7\21\2\2hi\5\f\7\2ij\7\20\2\2jk\7\t\2\2kl\5 \21"+
    "\2lm\7\n\2\2mn\5\36\20\2n\u00a4\3\2\2\2op\7\22\2\2pr\7\t\2\2qs\5\20\t"+
    "\2rq\3\2\2\2rs\3\2\2\2st\3\2\2\2tv\7\r\2\2uw\5 \21\2vu\3\2\2\2vw\3\2\2"+
    "\2wx\3\2\2\2xz\7\r\2\2y{\5\22\n\2zy\3\2\2\2z{\3\2\2\2{|\3\2\2\2|\177\7"+
    "\n\2\2}\u0080\5\n\6\2~\u0080\5\16\b\2\177}\3\2\2\2\177~\3\2\2\2\u0080"+
    "\u00a4\3\2\2\2\u0081\u0082\7\22\2\2\u0082\u0083\7\t\2\2\u0083\u0084\5"+
    "\26\f\2\u0084\u0085\7K\2\2\u0085\u0086\7\62\2\2\u0086\u0087\5 \21\2\u0087"+
    "\u0088\7\n\2\2\u0088\u0089\5\n\6\2\u0089\u00a4\3\2\2\2\u008a\u008b\5\24"+
    "\13\2\u008b\u008c\5\36\20\2\u008c\u00a4\3\2\2\2\u008d\u008e\7\23\2\2\u008e"+
    "\u00a4\5\36\20\2\u008f\u0090\7\24\2\2\u0090\u00a4\5\36\20\2\u0091\u0092"+
    "\7\25\2\2\u0092\u0093\5 \21\2\u0093\u0094\5\36\20\2\u0094\u00a4\3\2\2"+
    "\2\u0095\u0096\7\27\2\2\u0096\u0098\5\f\7\2\u0097\u0099\5\34\17\2\u0098"+
    "\u0097\3\2\2\2\u0099\u009a\3\2\2\2\u009a\u0098\3\2\2\2\u009a\u009b\3\2"+
    "\2\2\u009b\u00a4\3\2\2\2\u009c\u009d\7\31\2\2\u009d\u009e\5 \21\2\u009e"+
    "\u009f\5\36\20\2\u009f\u00a4\3\2\2\2\u00a0\u00a1\5 \21\2\u00a1\u00a2\5"+
    "\36\20\2\u00a2\u00a4\3\2\2\2\u00a3U\3\2\2\2\u00a3_\3\2\2\2\u00a3g\3\2"+
    "\2\2\u00a3o\3\2\2\2\u00a3\u0081\3\2\2\2\u00a3\u008a\3\2\2\2\u00a3\u008d"+
    "\3\2\2\2\u00a3\u008f\3\2\2\2\u00a3\u0091\3\2\2\2\u00a3\u0095\3\2\2\2\u00a3"+
    "\u009c\3\2\2\2\u00a3\u00a0\3\2\2\2\u00a4\t\3\2\2\2\u00a5\u00a8\5\f\7\2"+
    "\u00a6\u00a8\5\b\5\2\u00a7\u00a5\3\2\2\2\u00a7\u00a6\3\2\2\2\u00a8\13"+
    "\3\2\2\2\u00a9\u00ad\7\5\2\2\u00aa\u00ac\5\b\5\2\u00ab\u00aa\3\2\2\2\u00ac"+
    "\u00af\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae\u00b0\3\2"+
    "\2\2\u00af\u00ad\3\2\2\2\u00b0\u00b1\7\6\2\2\u00b1\r\3\2\2\2\u00b2\u00b3"+
    "\7\r\2\2\u00b3\17\3\2\2\2\u00b4\u00b7\5\24\13\2\u00b5\u00b7\5 \21\2\u00b6"+
    "\u00b4\3\2\2\2\u00b6\u00b5\3\2\2\2\u00b7\21\3\2\2\2\u00b8\u00b9\5 \21"+
    "\2\u00b9\23\3\2\2\2\u00ba\u00bb\5\26\f\2\u00bb\u00c0\5\32\16\2\u00bc\u00bd"+
    "\7\f\2\2\u00bd\u00bf\5\32\16\2\u00be\u00bc\3\2\2\2\u00bf\u00c2\3\2\2\2"+
    "\u00c0\u00be\3\2\2\2\u00c0\u00c1\3\2\2\2\u00c1\25\3\2\2\2\u00c2\u00c0"+
    "\3\2\2\2\u00c3\u00c8\7J\2\2\u00c4\u00c5\7\7\2\2\u00c5\u00c7\7\b\2\2\u00c6"+
    "\u00c4\3\2\2\2\u00c7\u00ca\3\2\2\2\u00c8\u00c6\3\2\2\2\u00c8\u00c9\3\2"+
    "\2\2\u00c9\27\3\2\2\2\u00ca\u00c8\3\2\2\2\u00cb\u00cc\7J\2\2\u00cc\u00cd"+
    "\7\63\2\2\u00cd\u00ce\t\2\2\2\u00ce\31\3\2\2\2\u00cf\u00d2\7K\2\2\u00d0"+
    "\u00d1\7\66\2\2\u00d1\u00d3\5 \21\2\u00d2\u00d0\3\2\2\2\u00d2\u00d3\3"+
    "\2\2\2\u00d3\33\3\2\2\2\u00d4\u00d5\7\30\2\2\u00d5\u00d6\7\t\2\2\u00d6"+
    "\u00d7\7J\2\2\u00d7\u00d8\7K\2\2\u00d8\u00d9\7\n\2\2\u00d9\u00da\5\f\7"+
    "\2\u00da\35\3\2\2\2\u00db\u00dc\t\3\2\2\u00dc\37\3\2\2\2\u00dd\u00de\b"+
    "\21\1\2\u00de\u00df\5$\23\2\u00df\u00e0\t\4\2\2\u00e0\u00e1\5 \21\3\u00e1"+
    "\u00e2\b\21\1\2\u00e2\u00e7\3\2\2\2\u00e3\u00e4\5\"\22\2\u00e4\u00e5\b"+
    "\21\1\2\u00e5\u00e7\3\2\2\2\u00e6\u00dd\3\2\2\2\u00e6\u00e3\3\2\2\2\u00e7"+
    "\u0123\3\2\2\2\u00e8\u00e9\f\16\2\2\u00e9\u00ea\t\5\2\2\u00ea\u00eb\5"+
    " \21\17\u00eb\u00ec\b\21\1\2\u00ec\u0122\3\2\2\2\u00ed\u00ee\f\r\2\2\u00ee"+
    "\u00ef\t\6\2\2\u00ef\u00f0\5 \21\16\u00f0\u00f1\b\21\1\2\u00f1\u0122\3"+
    "\2\2\2\u00f2\u00f3\f\f\2\2\u00f3\u00f4\t\7\2\2\u00f4\u00f5\5 \21\r\u00f5"+
    "\u00f6\b\21\1\2\u00f6\u0122\3\2\2\2\u00f7\u00f8\f\13\2\2\u00f8\u00f9\t"+
    "\b\2\2\u00f9\u00fa\5 \21\f\u00fa\u00fb\b\21\1\2\u00fb\u0122\3\2\2\2\u00fc"+
    "\u00fd\f\n\2\2\u00fd\u00fe\t\t\2\2\u00fe\u00ff\5 \21\13\u00ff\u0100\b"+
    "\21\1\2\u0100\u0122\3\2\2\2\u0101\u0102\f\t\2\2\u0102\u0103\7,\2\2\u0103"+
    "\u0104\5 \21\n\u0104\u0105\b\21\1\2\u0105\u0122\3\2\2\2\u0106\u0107\f"+
    "\b\2\2\u0107\u0108\7-\2\2\u0108\u0109\5 \21\t\u0109\u010a\b\21\1\2\u010a"+
    "\u0122\3\2\2\2\u010b\u010c\f\7\2\2\u010c\u010d\7.\2\2\u010d\u010e\5 \21"+
    "\b\u010e\u010f\b\21\1\2\u010f\u0122\3\2\2\2\u0110\u0111\f\6\2\2\u0111"+
    "\u0112\7/\2\2\u0112\u0113\5 \21\7\u0113\u0114\b\21\1\2\u0114\u0122\3\2"+
    "\2\2\u0115\u0116\f\5\2\2\u0116\u0117\7\60\2\2\u0117\u0118\5 \21\6\u0118"+
    "\u0119\b\21\1\2\u0119\u0122\3\2\2\2\u011a\u011b\f\4\2\2\u011b\u011c\7"+
    "\61\2\2\u011c\u011d\5 \21\2\u011d\u011e\7\62\2\2\u011e\u011f\5 \21\4\u011f"+
    "\u0120\b\21\1\2\u0120\u0122\3\2\2\2\u0121\u00e8\3\2\2\2\u0121\u00ed\3"+
    "\2\2\2\u0121\u00f2\3\2\2\2\u0121\u00f7\3\2\2\2\u0121\u00fc\3\2\2\2\u0121"+
    "\u0101\3\2\2\2\u0121\u0106\3\2\2\2\u0121\u010b\3\2\2\2\u0121\u0110\3\2"+
    "\2\2\u0121\u0115\3\2\2\2\u0121\u011a\3\2\2\2\u0122\u0125\3\2\2\2\u0123"+
    "\u0121\3\2\2\2\u0123\u0124\3\2\2\2\u0124!\3\2\2\2\u0125\u0123\3\2\2\2"+
    "\u0126\u0127\6\22\16\3\u0127\u0128\t\n\2\2\u0128\u0144\5$\23\2\u0129\u012a"+
    "\6\22\17\3\u012a\u012b\5$\23\2\u012b\u012c\t\n\2\2\u012c\u0144\3\2\2\2"+
    "\u012d\u012e\6\22\20\3\u012e\u0144\5$\23\2\u012f\u0130\6\22\21\3\u0130"+
    "\u0131\t\13\2\2\u0131\u0144\b\22\1\2\u0132\u0133\6\22\22\3\u0133\u0134"+
    "\7G\2\2\u0134\u0144\b\22\1\2\u0135\u0136\6\22\23\3\u0136\u0137\7H\2\2"+
    "\u0137\u0144\b\22\1\2\u0138\u0139\6\22\24\3\u0139\u013a\7I\2\2\u013a\u0144"+
    "\b\22\1\2\u013b\u013c\6\22\25\3\u013c\u013d\t\f\2\2\u013d\u0144\5\"\22"+
    "\2\u013e\u013f\7\t\2\2\u013f\u0140\5\26\f\2\u0140\u0141\7\n\2\2\u0141"+
    "\u0142\5\"\22\2\u0142\u0144\3\2\2\2\u0143\u0126\3\2\2\2\u0143\u0129\3"+
    "\2\2\2\u0143\u012d\3\2\2\2\u0143\u012f\3\2\2\2\u0143\u0132\3\2\2\2\u0143"+
    "\u0135\3\2\2\2\u0143\u0138\3\2\2\2\u0143\u013b\3\2\2\2\u0143\u013e\3\2"+
    "\2\2\u0144#\3\2\2\2\u0145\u0149\5&\24\2\u0146\u0148\5(\25\2\u0147\u0146"+
    "\3\2\2\2\u0148\u014b\3\2\2\2\u0149\u0147\3\2\2\2\u0149\u014a\3\2\2\2\u014a"+
    "\u0168\3\2\2\2\u014b\u0149\3\2\2\2\u014c\u014d\5\26\f\2\u014d\u0151\5"+
    "*\26\2\u014e\u0150\5(\25\2\u014f\u014e\3\2\2\2\u0150\u0153\3\2\2\2\u0151"+
    "\u014f\3\2\2\2\u0151\u0152\3\2\2\2\u0152\u0168\3\2\2\2\u0153\u0151\3\2"+
    "\2\2\u0154\u0155\7\26\2\2\u0155\u015a\7J\2\2\u0156\u0157\7\7\2\2\u0157"+
    "\u0158\5 \21\2\u0158\u0159\7\b\2\2\u0159\u015b\3\2\2\2\u015a\u0156\3\2"+
    "\2\2\u015b\u015c\3\2\2\2\u015c\u015a\3\2\2\2\u015c\u015d\3\2\2\2\u015d"+
    "\u0165\3\2\2\2\u015e\u0162\5*\26\2\u015f\u0161\5(\25\2\u0160\u015f\3\2"+
    "\2\2\u0161\u0164\3\2\2\2\u0162\u0160\3\2\2\2\u0162\u0163\3\2\2\2\u0163"+
    "\u0166\3\2\2\2\u0164\u0162\3\2\2\2\u0165\u015e\3\2\2\2\u0165\u0166\3\2"+
    "\2\2\u0166\u0168\3\2\2\2\u0167\u0145\3\2\2\2\u0167\u014c\3\2\2\2\u0167"+
    "\u0154\3\2\2\2\u0168%\3\2\2\2\u0169\u016a\6\24\26\3\u016a\u016b\7\t\2"+
    "\2\u016b\u016c\5 \21\2\u016c\u016d\7\n\2\2\u016d\u016e\b\24\1\2\u016e"+
    "\u017c\3\2\2\2\u016f\u0170\6\24\27\3\u0170\u0171\7\t\2\2\u0171\u0172\5"+
    "\"\22\2\u0172\u0173\7\n\2\2\u0173\u017c\3\2\2\2\u0174\u017c\7F\2\2\u0175"+
    "\u017c\7K\2\2\u0176\u0177\7K\2\2\u0177\u017c\5.\30\2\u0178\u0179\7\26"+
    "\2\2\u0179\u017a\7J\2\2\u017a\u017c\5.\30\2\u017b\u0169\3\2\2\2\u017b"+
    "\u016f\3\2\2\2\u017b\u0174\3\2\2\2\u017b\u0175\3\2\2\2\u017b\u0176\3\2"+
    "\2\2\u017b\u0178\3\2\2\2\u017c\'\3\2\2\2\u017d\u017e\6\25\30\3\u017e\u0182"+
    "\5*\26\2\u017f\u0180\6\25\31\3\u0180\u0182\5,\27\2\u0181\u017d\3\2\2\2"+
    "\u0181\u017f\3\2\2\2\u0182)\3\2\2\2\u0183\u0184\7\13\2\2\u0184\u0185\7"+
    "M\2\2\u0185\u0189\5.\30\2\u0186\u0187\7\13\2\2\u0187\u0189\t\r\2\2\u0188"+
    "\u0183\3\2\2\2\u0188\u0186\3\2\2\2\u0189+\3\2\2\2\u018a\u018b\7\7\2\2"+
    "\u018b\u018c\5 \21\2\u018c\u018d\7\b\2\2\u018d-\3\2\2\2\u018e\u0197\7"+
    "\t\2\2\u018f\u0194\5\60\31\2\u0190\u0191\7\f\2\2\u0191\u0193\5\60\31\2"+
    "\u0192\u0190\3\2\2\2\u0193\u0196\3\2\2\2\u0194\u0192\3\2\2\2\u0194\u0195"+
    "\3\2\2\2\u0195\u0198\3\2\2\2\u0196\u0194\3\2\2\2\u0197\u018f\3\2\2\2\u0197"+
    "\u0198\3\2\2\2\u0198\u0199\3\2\2\2\u0199\u019a\7\n\2\2\u019a/\3\2\2\2"+
    "\u019b\u019e\5 \21\2\u019c\u019e\5\30\r\2\u019d\u019b\3\2\2\2\u019d\u019c"+
    "\3\2\2\2\u019e\61\3\2\2\2$\65;NQ]ervz\177\u009a\u00a3\u00a7\u00ad\u00b6"+
    "\u00c0\u00c8\u00d2\u00e6\u0121\u0123\u0143\u0149\u0151\u015c\u0162\u0165"+
    "\u0167\u017b\u0181\u0188\u0194\u0197\u019d";
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_bd94c62_3871555/rev_bd94c62-3871555/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java;<<<<<<< MINE
    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3N\u01bc\4\2\t\2\4"+
=======
    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3M\u01a4\4\2\t\2\4"+
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_bd94c62_3871555/rev_bd94c62-3871555/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java;<<<<<<< MINE
    "\4\32\t\32\4\33\t\33\3\2\7\28\n\2\f\2\16\2;\13\2\3\2\7\2>\n\2\f\2\16\2"+
    "A\13\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\7\4Q\n"+
    "\4\f\4\16\4T\13\4\5\4V\n\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5"+
    "b\n\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5j\n\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5"+
    "\3\5\3\5\3\5\5\5w\n\5\3\5\3\5\5\5{\n\5\3\5\3\5\5\5\177\n\5\3\5\3\5\3\5"+
    "\5\5\u0084\n\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5"+
    "\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\6\5\u009d\n\5\r\5\16\5\u009e\3\5"+
    "\3\5\3\5\3\5\3\5\3\5\3\5\5\5\u00a8\n\5\3\6\3\6\5\6\u00ac\n\6\3\7\3\7\7"+
    "\7\u00b0\n\7\f\7\16\7\u00b3\13\7\3\7\3\7\3\b\3\b\3\t\3\t\5\t\u00bb\n\t"+
    "\3\n\3\n\3\13\3\13\3\13\3\13\7\13\u00c3\n\13\f\13\16\13\u00c6\13\13\3"+
    "\f\3\f\3\f\7\f\u00cb\n\f\f\f\16\f\u00ce\13\f\3\r\3\r\3\r\5\r\u00d3\n\r"+
    "\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\17\3\17\3\20\3\20\3\20\3\20\3\20"+
    "\3\20\3\20\3\20\3\20\5\20\u00e7\n\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20"+
    "\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20"+
    "\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20"+
    "\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20"+
    "\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\7\20\u0122\n\20\f\20\16\20\u0125"+
    "\13\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21"+
=======
    "\3\2\7\2\64\n\2\f\2\16\2\67\13\2\3\2\7\2:\n\2\f\2\16\2=\13\2\3\2\3\2\3"+
    "\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\7\4M\n\4\f\4\16\4P\13\4"+
    "\5\4R\n\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5^\n\5\3\5\3\5\3\5"+
    "\3\5\3\5\3\5\5\5f\n\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5"+
    "s\n\5\3\5\3\5\5\5w\n\5\3\5\3\5\5\5{\n\5\3\5\3\5\3\5\5\5\u0080\n\5\3\5"+
    "\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3"+
    "\5\3\5\3\5\3\5\3\5\6\5\u0099\n\5\r\5\16\5\u009a\3\5\3\5\3\5\3\5\3\5\3"+
    "\5\3\5\5\5\u00a4\n\5\3\6\3\6\5\6\u00a8\n\6\3\7\3\7\7\7\u00ac\n\7\f\7\16"+
    "\7\u00af\13\7\3\7\3\7\3\b\3\b\3\t\3\t\5\t\u00b7\n\t\3\n\3\n\3\13\3\13"+
    "\3\13\3\13\7\13\u00bf\n\13\f\13\16\13\u00c2\13\13\3\f\3\f\3\f\7\f\u00c7"+
    "\n\f\f\f\16\f\u00ca\13\f\3\r\3\r\3\r\3\r\3\r\3\r\5\r\u00d2\n\r\3\16\3"+
    "\16\3\16\5\16\u00d7\n\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\20\3\20"+
    "\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u00eb\n\21\3\21\3\21"+
    "\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21"+
    "\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21"+
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_bd94c62_3871555/rev_bd94c62-3871555/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java;<<<<<<< MINE
    "\3\21\3\21\5\21\u0144\n\21\3\22\3\22\7\22\u0148\n\22\f\22\16\22\u014b"+
    "\13\22\3\22\3\22\3\22\7\22\u0150\n\22\f\22\16\22\u0153\13\22\3\22\3\22"+
    "\3\22\3\22\3\22\3\22\6\22\u015b\n\22\r\22\16\22\u015c\3\22\3\22\7\22\u0161"+
    "\n\22\f\22\16\22\u0164\13\22\5\22\u0166\n\22\5\22\u0168\n\22\3\23\3\23"+
    "\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23"+
    "\3\23\3\23\5\23\u017c\n\23\3\24\3\24\3\24\3\24\5\24\u0182\n\24\3\25\3"+
    "\25\3\25\3\25\3\25\5\25\u0189\n\25\3\26\3\26\3\26\3\26\3\27\3\27\3\27"+
    "\3\27\7\27\u0193\n\27\f\27\16\27\u0196\13\27\5\27\u0198\n\27\3\27\3\27"+
    "\3\30\3\30\3\30\5\30\u019f\n\30\3\31\3\31\3\31\3\31\3\31\7\31\u01a6\n"+
    "\31\f\31\16\31\u01a9\13\31\5\31\u01ab\n\31\3\31\5\31\u01ae\n\31\3\31\3"+
    "\31\3\31\3\32\5\32\u01b4\n\32\3\32\3\32\3\33\3\33\3\33\3\33\3\33\2\3\36"+
    "\34\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\2\16\3\3"+
    "\r\r\3\2\67B\3\2\34\36\3\2\37 \3\2!#\3\2$\'\3\2(+\3\2\65\66\3\2CF\4\2"+
    "\32\33\37 \3\2MN\4\2\26\26LL\u01e7\29\3\2\2\2\4D\3\2\2\2\6I\3\2\2\2\b"+
    "\u00a7\3\2\2\2\n\u00ab\3\2\2\2\f\u00ad\3\2\2\2\16\u00b6\3\2\2\2\20\u00ba"+
    "\3\2\2\2\22\u00bc\3\2\2\2\24\u00be\3\2\2\2\26\u00c7\3\2\2\2\30\u00cf\3"+
    "\2\2\2\32\u00d4\3\2\2\2\34\u00db\3\2\2\2\36\u00e6\3\2\2\2 \u0143\3\2\2"+
    "\2\"\u0167\3\2\2\2$\u017b\3\2\2\2&\u0181\3\2\2\2(\u0188\3\2\2\2*\u018a"+
    "\3\2\2\2,\u018e\3\2\2\2.\u019e\3\2\2\2\60\u01ad\3\2\2\2\62\u01b3\3\2\2"+
    "\2\64\u01b7\3\2\2\2\668\5\4\3\2\67\66\3\2\2\28;\3\2\2\29\67\3\2\2\29:"+
    "\3\2\2\2:?\3\2\2\2;9\3\2\2\2<>\5\b\5\2=<\3\2\2\2>A\3\2\2\2?=\3\2\2\2?"+
    "@\3\2\2\2@B\3\2\2\2A?\3\2\2\2BC\7\2\2\3C\3\3\2\2\2DE\5\26\f\2EF\7L\2\2"+
    "FG\5\6\4\2GH\5\f\7\2H\5\3\2\2\2IU\7\t\2\2JK\5\26\f\2KR\7L\2\2LM\7\f\2"+
    "\2MN\5\26\f\2NO\7L\2\2OQ\3\2\2\2PL\3\2\2\2QT\3\2\2\2RP\3\2\2\2RS\3\2\2"+
    "\2SV\3\2\2\2TR\3\2\2\2UJ\3\2\2\2UV\3\2\2\2VW\3\2\2\2WX\7\n\2\2X\7\3\2"+
    "\2\2YZ\7\16\2\2Z[\7\t\2\2[\\\5\36\20\2\\]\7\n\2\2]a\5\n\6\2^_\7\17\2\2"+
    "_b\5\n\6\2`b\6\5\2\2a^\3\2\2\2a`\3\2\2\2b\u00a8\3\2\2\2cd\7\20\2\2de\7"+
    "\t\2\2ef\5\36\20\2fi\7\n\2\2gj\5\n\6\2hj\5\16\b\2ig\3\2\2\2ih\3\2\2\2"+
    "j\u00a8\3\2\2\2kl\7\21\2\2lm\5\f\7\2mn\7\20\2\2no\7\t\2\2op\5\36\20\2"+
    "pq\7\n\2\2qr\5\34\17\2r\u00a8\3\2\2\2st\7\22\2\2tv\7\t\2\2uw\5\20\t\2"+
    "vu\3\2\2\2vw\3\2\2\2wx\3\2\2\2xz\7\r\2\2y{\5\36\20\2zy\3\2\2\2z{\3\2\2"+
    "\2{|\3\2\2\2|~\7\r\2\2}\177\5\22\n\2~}\3\2\2\2~\177\3\2\2\2\177\u0080"+
    "\3\2\2\2\u0080\u0083\7\n\2\2\u0081\u0084\5\n\6\2\u0082\u0084\5\16\b\2"+
    "\u0083\u0081\3\2\2\2\u0083\u0082\3\2\2\2\u0084\u00a8\3\2\2\2\u0085\u0086"+
    "\7\22\2\2\u0086\u0087\7\t\2\2\u0087\u0088\5\26\f\2\u0088\u0089\7L\2\2"+
    "\u0089\u008a\7\62\2\2\u008a\u008b\5\36\20\2\u008b\u008c\7\n\2\2\u008c"+
    "\u008d\5\n\6\2\u008d\u00a8\3\2\2\2\u008e\u008f\5\24\13\2\u008f\u0090\5"+
    "\34\17\2\u0090\u00a8\3\2\2\2\u0091\u0092\7\23\2\2\u0092\u00a8\5\34\17"+
    "\2\u0093\u0094\7\24\2\2\u0094\u00a8\5\34\17\2\u0095\u0096\7\25\2\2\u0096"+
    "\u0097\5\36\20\2\u0097\u0098\5\34\17\2\u0098\u00a8\3\2\2\2\u0099\u009a"+
    "\7\27\2\2\u009a\u009c\5\f\7\2\u009b\u009d\5\32\16\2\u009c\u009b\3\2\2"+
    "\2\u009d\u009e\3\2\2\2\u009e\u009c\3\2\2\2\u009e\u009f\3\2\2\2\u009f\u00a8"+
    "\3\2\2\2\u00a0\u00a1\7\31\2\2\u00a1\u00a2\5\36\20\2\u00a2\u00a3\5\34\17"+
    "\2\u00a3\u00a8\3\2\2\2\u00a4\u00a5\5\36\20\2\u00a5\u00a6\5\34\17\2\u00a6"+
    "\u00a8\3\2\2\2\u00a7Y\3\2\2\2\u00a7c\3\2\2\2\u00a7k\3\2\2\2\u00a7s\3\2"+
    "\2\2\u00a7\u0085\3\2\2\2\u00a7\u008e\3\2\2\2\u00a7\u0091\3\2\2\2\u00a7"+
    "\u0093\3\2\2\2\u00a7\u0095\3\2\2\2\u00a7\u0099\3\2\2\2\u00a7\u00a0\3\2"+
    "\2\2\u00a7\u00a4\3\2\2\2\u00a8\t\3\2\2\2\u00a9\u00ac\5\f\7\2\u00aa\u00ac"+
    "\5\b\5\2\u00ab\u00a9\3\2\2\2\u00ab\u00aa\3\2\2\2\u00ac\13\3\2\2\2\u00ad"+
    "\u00b1\7\5\2\2\u00ae\u00b0\5\b\5\2\u00af\u00ae\3\2\2\2\u00b0\u00b3\3\2"+
    "\2\2\u00b1\u00af\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b4\3\2\2\2\u00b3"+
    "\u00b1\3\2\2\2\u00b4\u00b5\7\6\2\2\u00b5\r\3\2\2\2\u00b6\u00b7\7\r\2\2"+
    "\u00b7\17\3\2\2\2\u00b8\u00bb\5\24\13\2\u00b9\u00bb\5\36\20\2\u00ba\u00b8"+
    "\3\2\2\2\u00ba\u00b9\3\2\2\2\u00bb\21\3\2\2\2\u00bc\u00bd\5\36\20\2\u00bd"+
    "\23\3\2\2\2\u00be\u00bf\5\26\f\2\u00bf\u00c4\5\30\r\2\u00c0\u00c1\7\f"+
    "\2\2\u00c1\u00c3\5\30\r\2\u00c2\u00c0\3\2\2\2\u00c3\u00c6\3\2\2\2\u00c4"+
    "\u00c2\3\2\2\2\u00c4\u00c5\3\2\2\2\u00c5\25\3\2\2\2\u00c6\u00c4\3\2\2"+
    "\2\u00c7\u00cc\7K\2\2\u00c8\u00c9\7\7\2\2\u00c9\u00cb\7\b\2\2\u00ca\u00c8"+
    "\3\2\2\2\u00cb\u00ce\3\2\2\2\u00cc\u00ca\3\2\2\2\u00cc\u00cd\3\2\2\2\u00cd"+
    "\27\3\2\2\2\u00ce\u00cc\3\2\2\2\u00cf\u00d2\7L\2\2\u00d0\u00d1\7\67\2"+
    "\2\u00d1\u00d3\5\36\20\2\u00d2\u00d0\3\2\2\2\u00d2\u00d3\3\2\2\2\u00d3"+
    "\31\3\2\2\2\u00d4\u00d5\7\30\2\2\u00d5\u00d6\7\t\2\2\u00d6\u00d7\7K\2"+
    "\2\u00d7\u00d8\7L\2\2\u00d8\u00d9\7\n\2\2\u00d9\u00da\5\f\7\2\u00da\33"+
    "\3\2\2\2\u00db\u00dc\t\2\2\2\u00dc\35\3\2\2\2\u00dd\u00de\b\20\1\2\u00de"+
    "\u00df\5\"\22\2\u00df\u00e0\t\3\2\2\u00e0\u00e1\5\36\20\3\u00e1\u00e2"+
    "\b\20\1\2\u00e2\u00e7\3\2\2\2\u00e3\u00e4\5 \21\2\u00e4\u00e5\b\20\1\2"+
    "\u00e5\u00e7\3\2\2\2\u00e6\u00dd\3\2\2\2\u00e6\u00e3\3\2\2\2\u00e7\u0123"+
    "\3\2\2\2\u00e8\u00e9\f\16\2\2\u00e9\u00ea\t\4\2\2\u00ea\u00eb\5\36\20"+
    "\17\u00eb\u00ec\b\20\1\2\u00ec\u0122\3\2\2\2\u00ed\u00ee\f\r\2\2\u00ee"+
    "\u00ef\t\5\2\2\u00ef\u00f0\5\36\20\16\u00f0\u00f1\b\20\1\2\u00f1\u0122"+
    "\3\2\2\2\u00f2\u00f3\f\f\2\2\u00f3\u00f4\t\6\2\2\u00f4\u00f5\5\36\20\r"+
    "\u00f5\u00f6\b\20\1\2\u00f6\u0122\3\2\2\2\u00f7\u00f8\f\13\2\2\u00f8\u00f9"+
    "\t\7\2\2\u00f9\u00fa\5\36\20\f\u00fa\u00fb\b\20\1\2\u00fb\u0122\3\2\2"+
    "\2\u00fc\u00fd\f\n\2\2\u00fd\u00fe\t\b\2\2\u00fe\u00ff\5\36\20\13\u00ff"+
    "\u0100\b\20\1\2\u0100\u0122\3\2\2\2\u0101\u0102\f\t\2\2\u0102\u0103\7"+
    ",\2\2\u0103\u0104\5\36\20\n\u0104\u0105\b\20\1\2\u0105\u0122\3\2\2\2\u0106"+
    "\u0107\f\b\2\2\u0107\u0108\7-\2\2\u0108\u0109\5\36\20\t\u0109\u010a\b"+
    "\20\1\2\u010a\u0122\3\2\2\2\u010b\u010c\f\7\2\2\u010c\u010d\7.\2\2\u010d"+
    "\u010e\5\36\20\b\u010e\u010f\b\20\1\2\u010f\u0122\3\2\2\2\u0110\u0111"+
    "\f\6\2\2\u0111\u0112\7/\2\2\u0112\u0113\5\36\20\7\u0113\u0114\b\20\1\2"+
    "\u0114\u0122\3\2\2\2\u0115\u0116\f\5\2\2\u0116\u0117\7\60\2\2\u0117\u0118"+
    "\5\36\20\6\u0118\u0119\b\20\1\2\u0119\u0122\3\2\2\2\u011a\u011b\f\4\2"+
    "\2\u011b\u011c\7\61\2\2\u011c\u011d\5\36\20\2\u011d\u011e\7\62\2\2\u011e"+
    "\u011f\5\36\20\4\u011f\u0120\b\20\1\2\u0120\u0122\3\2\2\2\u0121\u00e8"+
    "\3\2\2\2\u0121\u00ed\3\2\2\2\u0121\u00f2\3\2\2\2\u0121\u00f7\3\2\2\2\u0121"+
    "\u00fc\3\2\2\2\u0121\u0101\3\2\2\2\u0121\u0106\3\2\2\2\u0121\u010b\3\2"+
    "\2\2\u0121\u0110\3\2\2\2\u0121\u0115\3\2\2\2\u0121\u011a\3\2\2\2\u0122"+
    "\u0125\3\2\2\2\u0123\u0121\3\2\2\2\u0123\u0124\3\2\2\2\u0124\37\3\2\2"+
    "\2\u0125\u0123\3\2\2\2\u0126\u0127\6\21\16\3\u0127\u0128\t\t\2\2\u0128"+
    "\u0144\5\"\22\2\u0129\u012a\6\21\17\3\u012a\u012b\5\"\22\2\u012b\u012c"+
    "\t\t\2\2\u012c\u0144\3\2\2\2\u012d\u012e\6\21\20\3\u012e\u0144\5\"\22"+
    "\2\u012f\u0130\6\21\21\3\u0130\u0131\t\n\2\2\u0131\u0144\b\21\1\2\u0132"+
    "\u0133\6\21\22\3\u0133\u0134\7H\2\2\u0134\u0144\b\21\1\2\u0135\u0136\6"+
    "\21\23\3\u0136\u0137\7I\2\2\u0137\u0144\b\21\1\2\u0138\u0139\6\21\24\3"+
    "\u0139\u013a\7J\2\2\u013a\u0144\b\21\1\2\u013b\u013c\6\21\25\3\u013c\u013d"+
    "\t\13\2\2\u013d\u0144\5 \21\2\u013e\u013f\7\t\2\2\u013f\u0140\5\26\f\2"+
    "\u0140\u0141\7\n\2\2\u0141\u0142\5 \21\2\u0142\u0144\3\2\2\2\u0143\u0126"+
    "\3\2\2\2\u0143\u0129\3\2\2\2\u0143\u012d\3\2\2\2\u0143\u012f\3\2\2\2\u0143"+
    "\u0132\3\2\2\2\u0143\u0135\3\2\2\2\u0143\u0138\3\2\2\2\u0143\u013b\3\2"+
    "\2\2\u0143\u013e\3\2\2\2\u0144!\3\2\2\2\u0145\u0149\5$\23\2\u0146\u0148"+
    "\5&\24\2\u0147\u0146\3\2\2\2\u0148\u014b\3\2\2\2\u0149\u0147\3\2\2\2\u0149"+
    "\u014a\3\2\2\2\u014a\u0168\3\2\2\2\u014b\u0149\3\2\2\2\u014c\u014d\5\26"+
    "\f\2\u014d\u0151\5(\25\2\u014e\u0150\5&\24\2\u014f\u014e\3\2\2\2\u0150"+
    "\u0153\3\2\2\2\u0151\u014f\3\2\2\2\u0151\u0152\3\2\2\2\u0152\u0168\3\2"+
    "\2\2\u0153\u0151\3\2\2\2\u0154\u0155\7\26\2\2\u0155\u015a\7K\2\2\u0156"+
    "\u0157\7\7\2\2\u0157\u0158\5\36\20\2\u0158\u0159\7\b\2\2\u0159\u015b\3"+
    "\2\2\2\u015a\u0156\3\2\2\2\u015b\u015c\3\2\2\2\u015c\u015a\3\2\2\2\u015c"+
    "\u015d\3\2\2\2\u015d\u0165\3\2\2\2\u015e\u0162\5(\25\2\u015f\u0161\5&"+
    "\24\2\u0160\u015f\3\2\2\2\u0161\u0164\3\2\2\2\u0162\u0160\3\2\2\2\u0162"+
    "\u0163\3\2\2\2\u0163\u0166\3\2\2\2\u0164\u0162\3\2\2\2\u0165\u015e\3\2"+
    "\2\2\u0165\u0166\3\2\2\2\u0166\u0168\3\2\2\2\u0167\u0145\3\2\2\2\u0167"+
    "\u014c\3\2\2\2\u0167\u0154\3\2\2\2\u0168#\3\2\2\2\u0169\u016a\6\23\26"+
    "\3\u016a\u016b\7\t\2\2\u016b\u016c\5\36\20\2\u016c\u016d\7\n\2\2\u016d"+
    "\u016e\b\23\1\2\u016e\u017c\3\2\2\2\u016f\u0170\6\23\27\3\u0170\u0171"+
    "\7\t\2\2\u0171\u0172\5 \21\2\u0172\u0173\7\n\2\2\u0173\u017c\3\2\2\2\u0174"+
    "\u017c\7G\2\2\u0175\u017c\7L\2\2\u0176\u0177\7L\2\2\u0177\u017c\5,\27"+
    "\2\u0178\u0179\7\26\2\2\u0179\u017a\7K\2\2\u017a\u017c\5,\27\2\u017b\u0169"+
    "\3\2\2\2\u017b\u016f\3\2\2\2\u017b\u0174\3\2\2\2\u017b\u0175\3\2\2\2\u017b"+
    "\u0176\3\2\2\2\u017b\u0178\3\2\2\2\u017c%\3\2\2\2\u017d\u017e\6\24\30"+
    "\3\u017e\u0182\5(\25\2\u017f\u0180\6\24\31\3\u0180\u0182\5*\26\2\u0181"+
    "\u017d\3\2\2\2\u0181\u017f\3\2\2\2\u0182\'\3\2\2\2\u0183\u0184\7\13\2"+
    "\2\u0184\u0185\7N\2\2\u0185\u0189\5,\27\2\u0186\u0187\7\13\2\2\u0187\u0189"+
    "\t\f\2\2\u0188\u0183\3\2\2\2\u0188\u0186\3\2\2\2\u0189)\3\2\2\2\u018a"+
    "\u018b\7\7\2\2\u018b\u018c\5\36\20\2\u018c\u018d\7\b\2\2\u018d+\3\2\2"+
    "\2\u018e\u0197\7\t\2\2\u018f\u0194\5.\30\2\u0190\u0191\7\f\2\2\u0191\u0193"+
    "\5.\30\2\u0192\u0190\3\2\2\2\u0193\u0196\3\2\2\2\u0194\u0192\3\2\2\2\u0194"+
    "\u0195\3\2\2\2\u0195\u0198\3\2\2\2\u0196\u0194\3\2\2\2\u0197\u018f\3\2"+
    "\2\2\u0197\u0198\3\2\2\2\u0198\u0199\3\2\2\2\u0199\u019a\7\n\2\2\u019a"+
    "-\3\2\2\2\u019b\u019f\5\36\20\2\u019c\u019f\5\60\31\2\u019d\u019f\5\64"+
    "\33\2\u019e\u019b\3\2\2\2\u019e\u019c\3\2\2\2\u019e\u019d\3\2\2\2\u019f"+
    "/\3\2\2\2\u01a0\u01ae\5\62\32\2\u01a1\u01aa\7\t\2\2\u01a2\u01a7\5\62\32"+
    "\2\u01a3\u01a4\7\f\2\2\u01a4\u01a6\5\62\32\2\u01a5\u01a3\3\2\2\2\u01a6"+
    "\u01a9\3\2\2\2\u01a7\u01a5\3\2\2\2\u01a7\u01a8\3\2\2\2\u01a8\u01ab\3\2"+
    "\2\2\u01a9\u01a7\3\2\2\2\u01aa\u01a2\3\2\2\2\u01aa\u01ab\3\2\2\2\u01ab"+
    "\u01ac\3\2\2\2\u01ac\u01ae\7\n\2\2\u01ad\u01a0\3\2\2\2\u01ad\u01a1\3\2"+
    "\2\2\u01ae\u01af\3\2\2\2\u01af\u01b0\7\64\2\2\u01b0\u01b1\5\f\7\2\u01b1"+
    "\61\3\2\2\2\u01b2\u01b4\5\26\f\2\u01b3\u01b2\3\2\2\2\u01b3\u01b4\3\2\2"+
    "\2\u01b4\u01b5\3\2\2\2\u01b5\u01b6\7L\2\2\u01b6\63\3\2\2\2\u01b7\u01b8"+
    "\7K\2\2\u01b8\u01b9\7\63\2\2\u01b9\u01ba\t\r\2\2\u01ba\65\3\2\2\2(9?R"+
    "Uaivz~\u0083\u009e\u00a7\u00ab\u00b1\u00ba\u00c4\u00cc\u00d2\u00e6\u0121"+
    "\u0123\u0143\u0149\u0151\u015c\u0162\u0165\u0167\u017b\u0181\u0188\u0194"+
    "\u0197\u019e\u01a7\u01aa\u01ad\u01b3";
=======
    "\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\7\21"+
    "\u0126\n\21\f\21\16\21\u0129\13\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22"+
    "\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22"+
    "\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u0148\n\22\3\23\3\23\7\23"+
    "\u014c\n\23\f\23\16\23\u014f\13\23\3\23\3\23\3\23\7\23\u0154\n\23\f\23"+
    "\16\23\u0157\13\23\3\23\3\23\3\23\3\23\3\23\3\23\6\23\u015f\n\23\r\23"+
    "\16\23\u0160\3\23\3\23\7\23\u0165\n\23\f\23\16\23\u0168\13\23\5\23\u016a"+
    "\n\23\5\23\u016c\n\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24"+
    "\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\5\24\u0180\n\24\3\25\3\25\3\25"+
    "\3\25\5\25\u0186\n\25\3\26\3\26\3\26\3\26\3\26\5\26\u018d\n\26\3\27\3"+
    "\27\3\27\3\27\3\30\3\30\3\30\3\30\7\30\u0197\n\30\f\30\16\30\u019a\13"+
    "\30\5\30\u019c\n\30\3\30\3\30\3\31\3\31\5\31\u01a2\n\31\3\31\2\3 \32\2"+
    "\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\2\16\4\2\26\26KK\3\3"+
    "\r\r\3\2\66A\3\2\34\36\3\2\37 \3\2!#\3\2$\'\3\2(+\3\2\64\65\3\2BE\4\2"+
    "\32\33\37 \3\2LM\u01cd\2\65\3\2\2\2\4@\3\2\2\2\6E\3\2\2\2\b\u00a3\3\2"+
    "\2\2\n\u00a7\3\2\2\2\f\u00a9\3\2\2\2\16\u00b2\3\2\2\2\20\u00b6\3\2\2\2"+
    "\22\u00b8\3\2\2\2\24\u00ba\3\2\2\2\26\u00c3\3\2\2\2\30\u00d1\3\2\2\2\32"+
    "\u00d3\3\2\2\2\34\u00d8\3\2\2\2\36\u00df\3\2\2\2 \u00ea\3\2\2\2\"\u0147"+
    "\3\2\2\2$\u016b\3\2\2\2&\u017f\3\2\2\2(\u0185\3\2\2\2*\u018c\3\2\2\2,"+
    "\u018e\3\2\2\2.\u0192\3\2\2\2\60\u01a1\3\2\2\2\62\64\5\4\3\2\63\62\3\2"+
    "\2\2\64\67\3\2\2\2\65\63\3\2\2\2\65\66\3\2\2\2\66;\3\2\2\2\67\65\3\2\2"+
    "\28:\5\b\5\298\3\2\2\2:=\3\2\2\2;9\3\2\2\2;<\3\2\2\2<>\3\2\2\2=;\3\2\2"+
    "\2>?\7\2\2\3?\3\3\2\2\2@A\5\26\f\2AB\7K\2\2BC\5\6\4\2CD\5\f\7\2D\5\3\2"+
    "\2\2EQ\7\t\2\2FG\5\26\f\2GN\7K\2\2HI\7\f\2\2IJ\5\26\f\2JK\7K\2\2KM\3\2"+
    "\2\2LH\3\2\2\2MP\3\2\2\2NL\3\2\2\2NO\3\2\2\2OR\3\2\2\2PN\3\2\2\2QF\3\2"+
    "\2\2QR\3\2\2\2RS\3\2\2\2ST\7\n\2\2T\7\3\2\2\2UV\7\16\2\2VW\7\t\2\2WX\5"+
    " \21\2XY\7\n\2\2Y]\5\n\6\2Z[\7\17\2\2[^\5\n\6\2\\^\6\5\2\2]Z\3\2\2\2]"+
    "\\\3\2\2\2^\u00a4\3\2\2\2_`\7\20\2\2`a\7\t\2\2ab\5 \21\2be\7\n\2\2cf\5"+
    "\n\6\2df\5\16\b\2ec\3\2\2\2ed\3\2\2\2f\u00a4\3\2\2\2gh\7\21\2\2hi\5\f"+
    "\7\2ij\7\20\2\2jk\7\t\2\2kl\5 \21\2lm\7\n\2\2mn\5\36\20\2n\u00a4\3\2\2"+
    "\2op\7\22\2\2pr\7\t\2\2qs\5\20\t\2rq\3\2\2\2rs\3\2\2\2st\3\2\2\2tv\7\r"+
    "\2\2uw\5 \21\2vu\3\2\2\2vw\3\2\2\2wx\3\2\2\2xz\7\r\2\2y{\5\22\n\2zy\3"+
    "\2\2\2z{\3\2\2\2{|\3\2\2\2|\177\7\n\2\2}\u0080\5\n\6\2~\u0080\5\16\b\2"+
    "\177}\3\2\2\2\177~\3\2\2\2\u0080\u00a4\3\2\2\2\u0081\u0082\7\22\2\2\u0082"+
    "\u0083\7\t\2\2\u0083\u0084\5\26\f\2\u0084\u0085\7K\2\2\u0085\u0086\7\62"+
    "\2\2\u0086\u0087\5 \21\2\u0087\u0088\7\n\2\2\u0088\u0089\5\n\6\2\u0089"+
    "\u00a4\3\2\2\2\u008a\u008b\5\24\13\2\u008b\u008c\5\36\20\2\u008c\u00a4"+
    "\3\2\2\2\u008d\u008e\7\23\2\2\u008e\u00a4\5\36\20\2\u008f\u0090\7\24\2"+
    "\2\u0090\u00a4\5\36\20\2\u0091\u0092\7\25\2\2\u0092\u0093\5 \21\2\u0093"+
    "\u0094\5\36\20\2\u0094\u00a4\3\2\2\2\u0095\u0096\7\27\2\2\u0096\u0098"+
    "\5\f\7\2\u0097\u0099\5\34\17\2\u0098\u0097\3\2\2\2\u0099\u009a\3\2\2\2"+
    "\u009a\u0098\3\2\2\2\u009a\u009b\3\2\2\2\u009b\u00a4\3\2\2\2\u009c\u009d"+
    "\7\31\2\2\u009d\u009e\5 \21\2\u009e\u009f\5\36\20\2\u009f\u00a4\3\2\2"+
    "\2\u00a0\u00a1\5 \21\2\u00a1\u00a2\5\36\20\2\u00a2\u00a4\3\2\2\2\u00a3"+
    "U\3\2\2\2\u00a3_\3\2\2\2\u00a3g\3\2\2\2\u00a3o\3\2\2\2\u00a3\u0081\3\2"+
    "\2\2\u00a3\u008a\3\2\2\2\u00a3\u008d\3\2\2\2\u00a3\u008f\3\2\2\2\u00a3"+
    "\u0091\3\2\2\2\u00a3\u0095\3\2\2\2\u00a3\u009c\3\2\2\2\u00a3\u00a0\3\2"+
    "\2\2\u00a4\t\3\2\2\2\u00a5\u00a8\5\f\7\2\u00a6\u00a8\5\b\5\2\u00a7\u00a5"+
    "\3\2\2\2\u00a7\u00a6\3\2\2\2\u00a8\13\3\2\2\2\u00a9\u00ad\7\5\2\2\u00aa"+
    "\u00ac\5\b\5\2\u00ab\u00aa\3\2\2\2\u00ac\u00af\3\2\2\2\u00ad\u00ab\3\2"+
    "\2\2\u00ad\u00ae\3\2\2\2\u00ae\u00b0\3\2\2\2\u00af\u00ad\3\2\2\2\u00b0"+
    "\u00b1\7\6\2\2\u00b1\r\3\2\2\2\u00b2\u00b3\7\r\2\2\u00b3\17\3\2\2\2\u00b4"+
    "\u00b7\5\24\13\2\u00b5\u00b7\5 \21\2\u00b6\u00b4\3\2\2\2\u00b6\u00b5\3"+
    "\2\2\2\u00b7\21\3\2\2\2\u00b8\u00b9\5 \21\2\u00b9\23\3\2\2\2\u00ba\u00bb"+
    "\5\26\f\2\u00bb\u00c0\5\32\16\2\u00bc\u00bd\7\f\2\2\u00bd\u00bf\5\32\16"+
    "\2\u00be\u00bc\3\2\2\2\u00bf\u00c2\3\2\2\2\u00c0\u00be\3\2\2\2\u00c0\u00c1"+
    "\3\2\2\2\u00c1\25\3\2\2\2\u00c2\u00c0\3\2\2\2\u00c3\u00c8\7J\2\2\u00c4"+
    "\u00c5\7\7\2\2\u00c5\u00c7\7\b\2\2\u00c6\u00c4\3\2\2\2\u00c7\u00ca\3\2"+
    "\2\2\u00c8\u00c6\3\2\2\2\u00c8\u00c9\3\2\2\2\u00c9\27\3\2\2\2\u00ca\u00c8"+
    "\3\2\2\2\u00cb\u00cc\7J\2\2\u00cc\u00cd\7\63\2\2\u00cd\u00d2\t\2\2\2\u00ce"+
    "\u00cf\7K\2\2\u00cf\u00d0\7\63\2\2\u00d0\u00d2\7K\2\2\u00d1\u00cb\3\2"+
    "\2\2\u00d1\u00ce\3\2\2\2\u00d2\31\3\2\2\2\u00d3\u00d6\7K\2\2\u00d4\u00d5"+
    "\7\66\2\2\u00d5\u00d7\5 \21\2\u00d6\u00d4\3\2\2\2\u00d6\u00d7\3\2\2\2"+
    "\u00d7\33\3\2\2\2\u00d8\u00d9\7\30\2\2\u00d9\u00da\7\t\2\2\u00da\u00db"+
    "\7J\2\2\u00db\u00dc\7K\2\2\u00dc\u00dd\7\n\2\2\u00dd\u00de\5\f\7\2\u00de"+
    "\35\3\2\2\2\u00df\u00e0\t\3\2\2\u00e0\37\3\2\2\2\u00e1\u00e2\b\21\1\2"+
    "\u00e2\u00e3\5$\23\2\u00e3\u00e4\t\4\2\2\u00e4\u00e5\5 \21\3\u00e5\u00e6"+
    "\b\21\1\2\u00e6\u00eb\3\2\2\2\u00e7\u00e8\5\"\22\2\u00e8\u00e9\b\21\1"+
    "\2\u00e9\u00eb\3\2\2\2\u00ea\u00e1\3\2\2\2\u00ea\u00e7\3\2\2\2\u00eb\u0127"+
    "\3\2\2\2\u00ec\u00ed\f\16\2\2\u00ed\u00ee\t\5\2\2\u00ee\u00ef\5 \21\17"+
    "\u00ef\u00f0\b\21\1\2\u00f0\u0126\3\2\2\2\u00f1\u00f2\f\r\2\2\u00f2\u00f3"+
    "\t\6\2\2\u00f3\u00f4\5 \21\16\u00f4\u00f5\b\21\1\2\u00f5\u0126\3\2\2\2"+
    "\u00f6\u00f7\f\f\2\2\u00f7\u00f8\t\7\2\2\u00f8\u00f9\5 \21\r\u00f9\u00fa"+
    "\b\21\1\2\u00fa\u0126\3\2\2\2\u00fb\u00fc\f\13\2\2\u00fc\u00fd\t\b\2\2"+
    "\u00fd\u00fe\5 \21\f\u00fe\u00ff\b\21\1\2\u00ff\u0126\3\2\2\2\u0100\u0101"+
    "\f\n\2\2\u0101\u0102\t\t\2\2\u0102\u0103\5 \21\13\u0103\u0104\b\21\1\2"+
    "\u0104\u0126\3\2\2\2\u0105\u0106\f\t\2\2\u0106\u0107\7,\2\2\u0107\u0108"+
    "\5 \21\n\u0108\u0109\b\21\1\2\u0109\u0126\3\2\2\2\u010a\u010b\f\b\2\2"+
    "\u010b\u010c\7-\2\2\u010c\u010d\5 \21\t\u010d\u010e\b\21\1\2\u010e\u0126"+
    "\3\2\2\2\u010f\u0110\f\7\2\2\u0110\u0111\7.\2\2\u0111\u0112\5 \21\b\u0112"+
    "\u0113\b\21\1\2\u0113\u0126\3\2\2\2\u0114\u0115\f\6\2\2\u0115\u0116\7"+
    "/\2\2\u0116\u0117\5 \21\7\u0117\u0118\b\21\1\2\u0118\u0126\3\2\2\2\u0119"+
    "\u011a\f\5\2\2\u011a\u011b\7\60\2\2\u011b\u011c\5 \21\6\u011c\u011d\b"+
    "\21\1\2\u011d\u0126\3\2\2\2\u011e\u011f\f\4\2\2\u011f\u0120\7\61\2\2\u0120"+
    "\u0121\5 \21\2\u0121\u0122\7\62\2\2\u0122\u0123\5 \21\4\u0123\u0124\b"+
    "\21\1\2\u0124\u0126\3\2\2\2\u0125\u00ec\3\2\2\2\u0125\u00f1\3\2\2\2\u0125"+
    "\u00f6\3\2\2\2\u0125\u00fb\3\2\2\2\u0125\u0100\3\2\2\2\u0125\u0105\3\2"+
    "\2\2\u0125\u010a\3\2\2\2\u0125\u010f\3\2\2\2\u0125\u0114\3\2\2\2\u0125"+
    "\u0119\3\2\2\2\u0125\u011e\3\2\2\2\u0126\u0129\3\2\2\2\u0127\u0125\3\2"+
    "\2\2\u0127\u0128\3\2\2\2\u0128!\3\2\2\2\u0129\u0127\3\2\2\2\u012a\u012b"+
    "\6\22\16\3\u012b\u012c\t\n\2\2\u012c\u0148\5$\23\2\u012d\u012e\6\22\17"+
    "\3\u012e\u012f\5$\23\2\u012f\u0130\t\n\2\2\u0130\u0148\3\2\2\2\u0131\u0132"+
    "\6\22\20\3\u0132\u0148\5$\23\2\u0133\u0134\6\22\21\3\u0134\u0135\t\13"+
    "\2\2\u0135\u0148\b\22\1\2\u0136\u0137\6\22\22\3\u0137\u0138\7G\2\2\u0138"+
    "\u0148\b\22\1\2\u0139\u013a\6\22\23\3\u013a\u013b\7H\2\2\u013b\u0148\b"+
    "\22\1\2\u013c\u013d\6\22\24\3\u013d\u013e\7I\2\2\u013e\u0148\b\22\1\2"+
    "\u013f\u0140\6\22\25\3\u0140\u0141\t\f\2\2\u0141\u0148\5\"\22\2\u0142"+
    "\u0143\7\t\2\2\u0143\u0144\5\26\f\2\u0144\u0145\7\n\2\2\u0145\u0146\5"+
    "\"\22\2\u0146\u0148\3\2\2\2\u0147\u012a\3\2\2\2\u0147\u012d\3\2\2\2\u0147"+
    "\u0131\3\2\2\2\u0147\u0133\3\2\2\2\u0147\u0136\3\2\2\2\u0147\u0139\3\2"+
    "\2\2\u0147\u013c\3\2\2\2\u0147\u013f\3\2\2\2\u0147\u0142\3\2\2\2\u0148"+
    "#\3\2\2\2\u0149\u014d\5&\24\2\u014a\u014c\5(\25\2\u014b\u014a\3\2\2\2"+
    "\u014c\u014f\3\2\2\2\u014d\u014b\3\2\2\2\u014d\u014e\3\2\2\2\u014e\u016c"+
    "\3\2\2\2\u014f\u014d\3\2\2\2\u0150\u0151\5\26\f\2\u0151\u0155\5*\26\2"+
    "\u0152\u0154\5(\25\2\u0153\u0152\3\2\2\2\u0154\u0157\3\2\2\2\u0155\u0153"+
    "\3\2\2\2\u0155\u0156\3\2\2\2\u0156\u016c\3\2\2\2\u0157\u0155\3\2\2\2\u0158"+
    "\u0159\7\26\2\2\u0159\u015e\7J\2\2\u015a\u015b\7\7\2\2\u015b\u015c\5 "+
    "\21\2\u015c\u015d\7\b\2\2\u015d\u015f\3\2\2\2\u015e\u015a\3\2\2\2\u015f"+
    "\u0160\3\2\2\2\u0160\u015e\3\2\2\2\u0160\u0161\3\2\2\2\u0161\u0169\3\2"+
    "\2\2\u0162\u0166\5*\26\2\u0163\u0165\5(\25\2\u0164\u0163\3\2\2\2\u0165"+
    "\u0168\3\2\2\2\u0166\u0164\3\2\2\2\u0166\u0167\3\2\2\2\u0167\u016a\3\2"+
    "\2\2\u0168\u0166\3\2\2\2\u0169\u0162\3\2\2\2\u0169\u016a\3\2\2\2\u016a"+
    "\u016c\3\2\2\2\u016b\u0149\3\2\2\2\u016b\u0150\3\2\2\2\u016b\u0158\3\2"+
    "\2\2\u016c%\3\2\2\2\u016d\u016e\6\24\26\3\u016e\u016f\7\t\2\2\u016f\u0170"+
    "\5 \21\2\u0170\u0171\7\n\2\2\u0171\u0172\b\24\1\2\u0172\u0180\3\2\2\2"+
    "\u0173\u0174\6\24\27\3\u0174\u0175\7\t\2\2\u0175\u0176\5\"\22\2\u0176"+
    "\u0177\7\n\2\2\u0177\u0180\3\2\2\2\u0178\u0180\7F\2\2\u0179\u0180\7K\2"+
    "\2\u017a\u017b\7K\2\2\u017b\u0180\5.\30\2\u017c\u017d\7\26\2\2\u017d\u017e"+
    "\7J\2\2\u017e\u0180\5.\30\2\u017f\u016d\3\2\2\2\u017f\u0173\3\2\2\2\u017f"+
    "\u0178\3\2\2\2\u017f\u0179\3\2\2\2\u017f\u017a\3\2\2\2\u017f\u017c\3\2"+
    "\2\2\u0180\'\3\2\2\2\u0181\u0182\6\25\30\3\u0182\u0186\5*\26\2\u0183\u0184"+
    "\6\25\31\3\u0184\u0186\5,\27\2\u0185\u0181\3\2\2\2\u0185\u0183\3\2\2\2"+
    "\u0186)\3\2\2\2\u0187\u0188\7\13\2\2\u0188\u0189\7M\2\2\u0189\u018d\5"+
    ".\30\2\u018a\u018b\7\13\2\2\u018b\u018d\t\r\2\2\u018c\u0187\3\2\2\2\u018c"+
    "\u018a\3\2\2\2\u018d+\3\2\2\2\u018e\u018f\7\7\2\2\u018f\u0190\5 \21\2"+
    "\u0190\u0191\7\b\2\2\u0191-\3\2\2\2\u0192\u019b\7\t\2\2\u0193\u0198\5"+
    "\60\31\2\u0194\u0195\7\f\2\2\u0195\u0197\5\60\31\2\u0196\u0194\3\2\2\2"+
    "\u0197\u019a\3\2\2\2\u0198\u0196\3\2\2\2\u0198\u0199\3\2\2\2\u0199\u019c"+
    "\3\2\2\2\u019a\u0198\3\2\2\2\u019b\u0193\3\2\2\2\u019b\u019c\3\2\2\2\u019c"+
    "\u019d\3\2\2\2\u019d\u019e\7\n\2\2\u019e/\3\2\2\2\u019f\u01a2\5 \21\2"+
    "\u01a0\u01a2\5\30\r\2\u01a1\u019f\3\2\2\2\u01a1\u01a0\3\2\2\2\u01a2\61"+
    "\3\2\2\2%\65;NQ]ervz\177\u009a\u00a3\u00a7\u00ad\u00b6\u00c0\u00c8\u00d1"+
    "\u00d6\u00ea\u0125\u0127\u0147\u014d\u0155\u0160\u0166\u0169\u016b\u017f"+
    "\u0185\u018c\u0198\u019b\u01a1";
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/plugins/mapper-attachments/src/main/java/org/elasticsearch/mapper/attachments/MapperAttachmentsPlugin.java;<<<<<<< MINE
    public void onModule(SettingsModule settingsModule) {
=======
    @Override
    public String name() {
        return "mapper-attachments";
    }

    @Override
    public String description() {
        return "Adds the attachment type allowing to parse difference attachment formats";
    }

    @Override
    public List<Setting<?>> getSettings() {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/plugins/lang-javascript/src/main/java/org/elasticsearch/plugin/javascript/JavaScriptPlugin.java;<<<<<<< MINE
    public void onModule(ScriptModule module) {
        module.addScriptEngine(new ScriptEngineRegistry.ScriptEngineRegistration(JavaScriptScriptEngineService.class, JavaScriptScriptEngineService.NAME));
=======
    @Override
    public String name() {
        return "lang-javascript";
    }

    @Override
    public String description() {
        return "JavaScript plugin allowing to add javascript scripting support";
    }

    @Override
    public ScriptEngineService getScriptEngineService(Settings settings) {
        return new JavaScriptScriptEngineService(settings);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/plugins/lang-python/src/main/java/org/elasticsearch/plugin/python/PythonPlugin.java;<<<<<<< MINE
    public void onModule(ScriptModule module) {
        module.addScriptEngine(new ScriptEngineRegistry.ScriptEngineRegistration(PythonScriptEngineService.class, PythonScriptEngineService.NAME));
=======
    @Override
    public String name() {
        return "lang-python";
    }

    @Override
    public String description() {
        return "Adds support for writing scripts in Python";
    }

    @Override
    public ScriptEngineService getScriptEngineService(Settings settings) {
        return new PythonScriptEngineService(settings);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/core/src/test/java/org/elasticsearch/search/basic/SearchWithRandomExceptionsIT.java;<<<<<<< MINE
            public void onModule(SettingsModule module) {
                module.registerSetting(EXCEPTION_TOP_LEVEL_RATIO_SETTING);
                module.registerSetting(EXCEPTION_LOW_LEVEL_RATIO_SETTING);
=======
            @Override
            public String name() {
                return "random-exception-reader-wrapper";
            }
            @Override
            public List<Setting<?>> getSettings() {
                return Arrays.asList(EXCEPTION_TOP_LEVEL_RATIO_SETTING, EXCEPTION_LOW_LEVEL_RATIO_SETTING);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/core/src/test/java/org/elasticsearch/indices/memory/breaker/RandomExceptionCircuitBreakerIT.java;<<<<<<< MINE
            public void onModule(SettingsModule module) {
                module.registerSetting(EXCEPTION_TOP_LEVEL_RATIO_SETTING);
                module.registerSetting(EXCEPTION_LOW_LEVEL_RATIO_SETTING);
=======
            @Override
            public String name() {
                return "random-exception-reader-wrapper";
            }
            @Override
            public String description() {
                return "a mock reader wrapper that throws random exceptions for testing";
            }

            @Override
            public List<Setting<?>> getSettings() {
                return Arrays.asList(EXCEPTION_TOP_LEVEL_RATIO_SETTING, EXCEPTION_LOW_LEVEL_RATIO_SETTING);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/core/src/test/java/org/elasticsearch/script/ScriptFieldIT.java;<<<<<<< MINE
        public void onModule(ScriptModule scriptModule) {
            scriptModule.registerScript("int", IntArrayScriptFactory.class);
            scriptModule.registerScript("long", LongArrayScriptFactory.class);
            scriptModule.registerScript("float", FloatArrayScriptFactory.class);
            scriptModule.registerScript("double", DoubleArrayScriptFactory.class);
=======
        @Override
        public String name() {
            return "custom_script";
        }

        @Override
        public String description() {
            return "script ";
        }

        @Override
        public List<NativeScriptFactory> getNativeScripts() {
            return Arrays.asList(new IntArrayScriptFactory(), new LongArrayScriptFactory(), new FloatArrayScriptFactory(),
                new DoubleArrayScriptFactory());
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessPlugin.java;<<<<<<< MINE
    public void onModule(final ScriptModule module) {
        module.addScriptEngine(new ScriptEngineRegistry.ScriptEngineRegistration(
                        PainlessScriptEngineService.class, PainlessScriptEngineService.NAME, true));
=======
    @Override
    public String name() {
        return "lang-painless";
    }

    @Override
    public String description() {
        return "Painless scripting language for Elasticsearch";
    }

    @Override
    public ScriptEngineService getScriptEngineService(Settings settings) {
        return new PainlessScriptEngineService(settings);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/modules/lang-groovy/src/main/java/org/elasticsearch/script/groovy/GroovyPlugin.java;<<<<<<< MINE
    public void onModule(ScriptModule module) {
        module.addScriptEngine(new ScriptEngineRegistry.ScriptEngineRegistration(GroovyScriptEngineService.class, GroovyScriptEngineService.NAME));
=======
    @Override
    public String name() {
        return "lang-groovy";
    }

    @Override
    public String description() {
        return "Groovy scripting integration for Elasticsearch";
    }

    @Override
    public ScriptEngineService getScriptEngineService(Settings settings) {
        return new GroovyScriptEngineService(settings);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/modules/lang-mustache/src/main/java/org/elasticsearch/script/mustache/MustachePlugin.java;<<<<<<< MINE
    public void onModule(ScriptModule module) {
        module.addScriptEngine(new ScriptEngineRegistry.ScriptEngineRegistration(MustacheScriptEngineService.class,
                        MustacheScriptEngineService.NAME, true));
=======
    @Override
    public String name() {
        return "lang-mustache";
    }

    @Override
    public String description() {
        return "Mustache scripting integration for Elasticsearch";
    }

    @Override
    public ScriptEngineService getScriptEngineService(Settings settings) {
        return new MustacheScriptEngineService(settings);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/modules/lang-expression/src/main/java/org/elasticsearch/script/expression/ExpressionPlugin.java;<<<<<<< MINE
    public void onModule(ScriptModule module) {
        module.addScriptEngine(new ScriptEngineRegistry.ScriptEngineRegistration(ExpressionScriptEngineService.class,
                        ExpressionScriptEngineService.NAME, true));
=======
    @Override
    public String name() {
        return "lang-expression";
    }

    @Override
    public String description() {
        return "Lucene expressions integration for Elasticsearch";
    }

    @Override
    public ScriptEngineService getScriptEngineService(Settings settings) {
        return new ExpressionScriptEngineService(settings);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/test/framework/src/main/java/org/elasticsearch/script/MockScriptEngine.java;<<<<<<< MINE
 * A dummy script engine used for testing. Scripts must be a number. Many 
=======
 * A dummy script engine used for testing. Scripts must be a number. Many
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_96321d7_ccad99f/rev_96321d7-ccad99f/test/framework/src/main/java/org/elasticsearch/script/MockScriptEngine.java;<<<<<<< MINE
        assert compiledScript.compiled() instanceof MockCompiledScript 
=======
        assert compiledScript.compiled() instanceof MockCompiledScript
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ef6e43e_1ad3d22/rev_ef6e43e-1ad3d22/plugins/discovery-gce/src/test/java/org/elasticsearch/discovery/gce/GceDiscoveryTests.java;<<<<<<< MINE
    protected List<DiscoveryNode> buildDynamicNodes(GceInstancesService gceInstancesService, Settings nodeSettings) {
        GceUnicastHostsProvider provider = new GceUnicastHostsProvider(nodeSettings, gceInstancesService,
                transportService, new NetworkService(Settings.EMPTY), Version.CURRENT);
=======
    protected List<DiscoveryNode> buildDynamicNodes(GceComputeService gceComputeService, Settings nodeSettings) {
        GceUnicastHostsProvider provider = new GceUnicastHostsProvider(nodeSettings, gceComputeService, transportService,
            new NetworkService(Settings.EMPTY));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_865b951_0732004/rev_865b951-0732004/modules/percolator/src/main/java/org/elasticsearch/percolator/RestMultiPercolateAction.java;<<<<<<< MINE
    public RestMultiPercolateAction(Settings settings, RestController controller,
                                    TransportMultiPercolateAction action) {
        super(settings);
        this.action = action;
=======
    public RestMultiPercolateAction(Settings settings, RestController controller, Client client) {
        super(settings, client);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/core/src/main/java/org/elasticsearch/ingest/Processor.java;<<<<<<< MINE
         * @param processorFactories Other processors which may be created inside this processor
         * @param config The configuration for the processor
         *
         * <b>Note:</b> Implementations are responsible for removing the used configuration keys, so that after
         * creating a pipeline ingest can verify if all configurations settings have been used.
=======
         * @param tag The tag for the processor
         * @param config Configuration for the processor to create
         *
         * Implementations are responsible for removing the used keys, so that after creating a pipeline ingest can
         * verify if all configurations settings have been used.
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/FailProcessor.java;<<<<<<< MINE
        public FailProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag,
                                      Map<String, Object> config) throws Exception {
=======
        public FailProcessor create(String processorTag, Map<String, Object> config) throws Exception {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/AppendProcessor.java;<<<<<<< MINE
        public AppendProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag,
                                        Map<String, Object> config) throws Exception {
=======
        public AppendProcessor create(String processorTag, Map<String, Object> config) throws Exception {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/AbstractStringProcessor.java;<<<<<<< MINE
        public AbstractStringProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag, Map<String, Object> config) throws Exception {
=======
        public AbstractStringProcessor create(String processorTag, Map<String, Object> config) throws Exception {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/RenameProcessor.java;<<<<<<< MINE
        public RenameProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag,
                                        Map<String, Object> config) throws Exception {
=======
        public RenameProcessor create(String processorTag, Map<String, Object> config) throws Exception {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/SetProcessor.java;<<<<<<< MINE
        public SetProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag,
                                     Map<String, Object> config) throws Exception {
=======
        public SetProcessor create(String processorTag, Map<String, Object> config) throws Exception {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/SortProcessor.java;<<<<<<< MINE
        public SortProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag,
                                      Map<String, Object> config) throws Exception {
=======
        public SortProcessor create(String processorTag, Map<String, Object> config) throws Exception {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/RemoveProcessor.java;<<<<<<< MINE
        public RemoveProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag,
                                        Map<String, Object> config) throws Exception {
=======
        public RemoveProcessor create(String processorTag, Map<String, Object> config) throws Exception {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_08b3b62_d24cc65/rev_08b3b62-d24cc65/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/GsubProcessor.java;<<<<<<< MINE
        public GsubProcessor doCreate(Map<String, Processor.Factory> registry, String processorTag,
                                      Map<String, Object> config) throws Exception {
=======
        public GsubProcessor create(String processorTag, Map<String, Object> config) throws Exception {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_f649104_62397c0/rev_f649104-62397c0/core/src/main/java/org/elasticsearch/node/service/NodeService.java;<<<<<<< MINE
    public NodeService(Settings settings, ThreadPool threadPool, MonitorService monitorService, Discovery discovery,
                       TransportService transportService, IndicesService indicesService, PluginsService pluginService,
                       CircuitBreakerService circuitBreakerService, ScriptService scriptService, HttpServer httpServer,
                       IngestService ingestService, ClusterService clusterService, SettingsFilter settingsFilter) {
=======
    public NodeService(Settings settings, ThreadPool threadPool, MonitorService monitorService,
                       Discovery discovery, TransportService transportService, IndicesService indicesService,
                       PluginsService pluginService, CircuitBreakerService circuitBreakerService, @Nullable HttpServer httpServer,
                       ProcessorsRegistry.Builder processorsRegistryBuilder, ClusterService clusterService, SettingsFilter settingsFilter) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_5a66c08_a8020b1/rev_5a66c08-a8020b1/core/src/main/java/org/elasticsearch/node/service/NodeService.java;<<<<<<< MINE
    public NodeService(Settings settings, ThreadPool threadPool, MonitorService monitorService, Discovery discovery,
                       TransportService transportService, IndicesService indicesService, PluginsService pluginService,
                       CircuitBreakerService circuitBreakerService, ScriptService scriptService, @Nullable HttpServer httpServer,
                       IngestService ingestService, ClusterService clusterService, SettingsFilter settingsFilter) {
=======
    public NodeService(Settings settings, ThreadPool threadPool, MonitorService monitorService, Discovery discovery,
                       TransportService transportService, IndicesService indicesService, PluginsService pluginService,
                       CircuitBreakerService circuitBreakerService, @Nullable HttpServer httpServer,
                       ProcessorsRegistry.Builder processorsRegistryBuilder, ClusterService clusterService,
                       SettingsFilter settingsFilter) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_7cc8a14_1d03a14/rev_7cc8a14-1d03a14/plugins/repository-s3/src/test/java/org/elasticsearch/cloud/aws/TestAwsS3Service.java;<<<<<<< MINE
    public synchronized AmazonS3 client(String endpoint, Protocol protocol, String region, String account, String key, Integer maxRetries, Boolean pathStyleAccess) {
        return cachedWrapper(super.client(endpoint, protocol, region, account, key, maxRetries, pathStyleAccess));
=======
    public synchronized AmazonS3 client(String endpoint, Protocol protocol, String region, String account, String key, Integer maxRetries,
                                        boolean useThrottleRetries) {
        return cachedWrapper(super.client(endpoint, protocol, region, account, key, maxRetries, useThrottleRetries));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e79492d_72784f4/rev_e79492d-72784f4/plugins/discovery-ec2/src/main/java/org/elasticsearch/cloud/aws/AwsEc2ServiceImpl.java;<<<<<<< MINE
            credentials = new AWSCredentialsProviderChain(
                new EnvironmentVariableCredentialsProvider(),
                new SystemPropertiesCredentialsProvider(),
                new InstanceProfileCredentialsProvider()
            );
=======
            credentials = new DefaultAWSCredentialsProviderChain();
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e79492d_72784f4/rev_e79492d-72784f4/plugins/discovery-ec2/src/main/java/org/elasticsearch/cloud/aws/AwsEc2ServiceImpl.java;<<<<<<< MINE
            credentials = new AWSCredentialsProviderChain(
                new StaticCredentialsProvider(new BasicAWSCredentials(key, secret))
            );
=======
            credentials = new StaticCredentialsProvider(new BasicAWSCredentials(key, secret));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c809671_85402d5/rev_c809671-85402d5/core/src/main/java/org/elasticsearch/action/update/UpdateResponse.java;<<<<<<< MINE
    public UpdateResponse(ShardId shardId, String type, String id, long version, boolean created) {
        this(new ShardInfo(0, 0), shardId, type, id, SequenceNumbersService.UNASSIGNED_SEQ_NO, version, created);
=======
    public UpdateResponse(ShardId shardId, String type, String id, long version, Result result) {
        this(new ShardInfo(0, 0), shardId, type, id, version, result);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c809671_85402d5/rev_c809671-85402d5/core/src/main/java/org/elasticsearch/action/update/UpdateResponse.java;<<<<<<< MINE
    public UpdateResponse(ShardInfo shardInfo, ShardId shardId, String type, String id, long seqNo, long version, boolean created) {
        super(shardId, type, id, seqNo, version);
=======
    public UpdateResponse(ShardInfo shardInfo, ShardId shardId, String type, String id,
                          long version, Result result) {
        super(shardId, type, id, version, result);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c809671_85402d5/rev_c809671-85402d5/core/src/main/java/org/elasticsearch/action/delete/DeleteResponse.java;<<<<<<< MINE
    public DeleteResponse(ShardId shardId, String type, String id, long seqNo, long version, boolean found) {
        super(shardId, type, id, seqNo, version);
        this.found = found;
    }

    /**
     * Returns <tt>true</tt> if a doc was found to delete.
     */
    public boolean isFound() {
        return found;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        found = in.readBoolean();
    }

    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeBoolean(found);
=======
    public DeleteResponse(ShardId shardId, String type, String id, long version, boolean found) {
        super(shardId, type, id, version, found ? Result.DELETED : Result.NOT_FOUND);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c809671_85402d5/rev_c809671-85402d5/core/src/main/java/org/elasticsearch/action/index/IndexResponse.java;<<<<<<< MINE
    public IndexResponse(ShardId shardId, String type, String id, long seqNo, long version, boolean created) {
        super(shardId, type, id, seqNo, version);
        this.created = created;
    }

    /**
     * Returns true if the document was created, false if updated.
     */
    public boolean isCreated() {
        return this.created;
=======
    public IndexResponse(ShardId shardId, String type, String id, long version, boolean created) {
        super(shardId, type, id, version, created ? Result.CREATED : Result.UPDATED);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c809671_85402d5/rev_c809671-85402d5/core/src/main/java/org/elasticsearch/action/DocWriteResponse.java;<<<<<<< MINE
    public DocWriteResponse(ShardId shardId, String type, String id, long seqNo, long version) {
=======
    public DocWriteResponse(ShardId shardId, String type, String id, long version, Result result) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c809671_85402d5/rev_c809671-85402d5/core/src/main/java/org/elasticsearch/index/mapper/ParsedDocument.java;<<<<<<< MINE
    public ParsedDocument(Field version, Field seqNo, String id, String type, String routing, long timestamp, long ttl, List<Document> documents, BytesReference source, Mapping dynamicMappingsUpdate) {
=======
    public ParsedDocument(Field version, String id, String type, String routing, long timestamp, long ttl, List<Document> documents,
                          BytesReference source, Mapping dynamicMappingsUpdate) {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_c809671_85402d5/rev_c809671-85402d5/core/src/main/java/org/elasticsearch/action/DocWriteResponse.java;<<<<<<< MINE
    }

    static final class Fields {
        static final String _INDEX = "_index";
        static final String _TYPE = "_type";
        static final String _ID = "_id";
        static final String _VERSION = "_version";
        static final String _SHARD_ID = "_shard_id";
        static final String _SEQ_NO = "_seq_no";
=======
        result.writeTo(out);
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e556c28_e168b3b/rev_e556c28-e168b3b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/date/DateRangeAggregatorFactory.java;<<<<<<< MINE
    public DateRangeAggregatorFactory(String name, Type type, ValuesSourceConfig<Numeric> config, List<Range> ranges, boolean keyed,
=======
    public DateRangeAggregatorFactory(String name, Type type, ValuesSourceConfig<Numeric> config, Range[] ranges, boolean keyed,
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e556c28_e168b3b/rev_e556c28-e168b3b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregatorFactory.java;<<<<<<< MINE
    public RangeAggregatorFactory(String name, Type type, ValuesSourceConfig<Numeric> config, List<Range> ranges, boolean keyed,
=======
    public RangeAggregatorFactory(String name, Type type, ValuesSourceConfig<Numeric> config, Range[] ranges, boolean keyed,
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e556c28_e168b3b/rev_e556c28-e168b3b/core/src/test/java/org/elasticsearch/indices/IndicesRequestCacheIT.java;<<<<<<< MINE
        final SearchResponse r4 = client().prepareSearch("index").setSearchType(SearchType.QUERY_THEN_FETCH).setSize(1)
=======
        final SearchResponse r6 = client().prepareSearch("index").setSearchType(SearchType.QUERY_THEN_FETCH).setSize(1)
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e556c28_e168b3b/rev_e556c28-e168b3b/core/src/test/java/org/elasticsearch/indices/IndicesRequestCacheIT.java;<<<<<<< MINE
        assertSearchResponse(r4);
        assertThat(r4.getHits().getTotalHits(), equalTo(7L));
=======
        assertSearchResponse(r6);
        assertThat(r6.getHits().getTotalHits(), equalTo(7L));
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_ce6f6d3_6174e21/rev_ce6f6d3-6174e21/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorFactory.java;<<<<<<< MINE
            List<String> docValueFields, List<ScriptFieldsContext.ScriptField> scriptFields, FetchSourceContext fetchSourceContext,
            AggregationContext context, AggregatorFactory<?> parent, AggregatorFactories.Builder subFactories, Map<String, Object> metaData)
            throws IOException {
=======
            List<String> docValueFields, List<ScriptFieldsContext.ScriptField> scriptFields, FetchSourceContext fetchSourceContext,
            AggregationContext context, AggregatorFactory<?> parent, AggregatorFactories.Builder subFactories,
            Map<String, Object> metaData) throws IOException {
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_d0df1ed_7a934bd/rev_d0df1ed-7a934bd/core/src/test/java/org/elasticsearch/search/aggregations/metrics/percentiles/InternalPercentilesTestCase.java;<<<<<<< MINE
        Class<? extends ParsedPercentiles> parsedClass = implementationClass();
        assertTrue(parsedClass != null && parsedClass.isInstance(parsedAggregation));
=======
    protected static double[] randomPercents() {
        List<Double> randomCdfValues = randomSubsetOf(randomIntBetween(1, 7), 0.01d, 0.05d, 0.25d, 0.50d, 0.75d, 0.95d, 0.99d);
        double[] percents = new double[randomCdfValues.size()];
        for (int i = 0; i < randomCdfValues.size(); i++) {
            percents[i] = randomCdfValues.get(i);
        }
        return percents;
>>>>>>> YOURS
/home/ramdisk/experiment5/projects/elasticsearch/revisions/rev_e2b95f9_0e74f5d/rev_e2b95f9-0e74f5d/core/src/test/java/org/elasticsearch/search/aggregations/metrics/percentiles/InternalPercentilesTestCase.java;<<<<<<< MINE
        Class<? extends ParsedPercentiles> parsedClass = implementationClass();
        assertTrue(parsedClass != null && parsedClass.isInstance(parsedAggregation));
=======
    public static double[] randomPercents() {
        List<Double> randomCdfValues = randomSubsetOf(randomIntBetween(1, 7), 0.01d, 0.05d, 0.25d, 0.50d, 0.75d, 0.95d, 0.99d);
        double[] percents = new double[randomCdfValues.size()];
        for (int i = 0; i < randomCdfValues.size(); i++) {
            percents[i] = randomCdfValues.get(i);
        }
        return percents;
>>>>>>> YOURS
