file;linedbasedConf
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_413c3a2_6244128/rev_413c3a2-6244128/src/main/test/cucumber/internal/StepMotherTest.java;<<<<<<< MINE
||||||| BASE
package cucumber.internal;

import org.junit.Test;

public class StepMotherTest {
    @Test
    public void shouldInvokeSuccessfully() throws Throwable {
        StepMother mother = new StepMother();
        mother.add(FooSteps.class);
        mother.newWorld();

        StepDefinition given = mother.getStepDefinitions().get(0);
        StepDefinition then = mother.getStepDefinitions().get(1);

        given.invokeOnTarget(new Object[]{56, "green"});
        then.invokeOnTarget(new Object[]{56, "green"});
    }

    @Test(expected=RuntimeException.class) 
    public void shouldInvokeWithFailure() throws Throwable {
        StepMother mother = new StepMother();
        mother.add(FooSteps.class);
        mother.newWorld();

        StepDefinition given = mother.getStepDefinitions().get(0);
        StepDefinition then = mother.getStepDefinitions().get(1);

        given.invokeOnTarget(new Object[]{56, "green"});
        then.invokeOnTarget(new Object[]{99, "green"});
    }
}=======
package cucumber.internal;

import org.junit.Test;

public class StepMotherTest {
    @Test
    public void shouldInvokeSuccessfully() throws Throwable {
        StepMother mother = new StepMother();
        mother.add(FooSteps.class);
        mother.newWorld();

        StepDefinition given = mother.getStepDefinitions().get(0);
        StepDefinition then = mother.getStepDefinitions().get(1);

        given.invokeOnTarget(new Object[]{"56", "green"});
        then.invokeOnTarget(new Object[]{"56", "green"});
    }

    @Test(expected=RuntimeException.class) 
    public void shouldInvokeWithFailure() throws Throwable {
        StepMother mother = new StepMother();
        mother.add(FooSteps.class);
        mother.newWorld();

        StepDefinition given = mother.getStepDefinitions().get(0);
        StepDefinition then = mother.getStepDefinitions().get(1);

        given.invokeOnTarget(new Object[]{"56", "green"});
        then.invokeOnTarget(new Object[]{"99", "green"});
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_56c5899_75037c8/rev_56c5899-75037c8/cucumber-maven-plugin/src/main/java/cucumber/mojo/CucumberMojo.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_db70ab6_e189683/rev_db70ab6-e189683/cucumber-maven-plugin/src/main/java/cucumber/mojo/AbstractJRubyMojo.java;<<<<<<< MINE
package cucumber.mojo;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.DependencyResolutionRequiredException;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildListener;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.Path;
import org.codehaus.plexus.util.StringUtils;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Base for all JRuby mojos.
 *
 * @requiresDependencyResolution compile
 */
public abstract class AbstractJRubyMojo extends AbstractMojo {

    protected boolean shouldFork = true;

    /**
     * @parameter expression="${project}"
     */
    protected MavenProject mavenProject;

    /**
     * @parameter expression="${project.basedir}"
     * @required
     */
    protected File launchDirectory;

    /**
     * @parameter expression="${jruby.home}"
     */
    protected String jrubyHome;

    /**
     * The amount of memory to use when forking JRuby. Default is "384m".
     *
     * @parameter expression="${jruby.launch.memory}"
     */
    protected String jrubyLaunchMemory = "384m";

    /**
     * The project compile classpath.
     *
     * @parameter default-value="${project.compileClasspathElements}"
     * @required
     * @readonly
     */
    private List compileClasspathElements;

    /**
     * The plugin dependencies.
     *
     * @parameter expression="${plugin.artifacts}"
     * @required
     * @readonly
     */
    private List pluginArtifacts;

    /**
     * The project test classpath
     *
     * @parameter expression="${project.testClasspathElements}"
     * @required
     * @readonly
     */
    private List testClasspathElements;

    protected Java jruby(List<String> args) throws MojoExecutionException {
        launchDirectory.mkdirs();
        Project project = null;
        try {
            project = getProject();
        } catch (DependencyResolutionRequiredException e) {
            throw new MojoExecutionException("error resolving dependencies", e);
        }

        Java java = new Java();
        java.setProject(project);
        java.setClassname("org.jruby.Main");
        java.setFailonerror(true);

        Commandline.Argument arg;

        if (shouldFork) {
            java.setFork(true);
            java.setDir(launchDirectory);

            arg = java.createJvmarg();
            arg.setValue("-Xmx" + jrubyLaunchMemory);
            Environment.Variable classpath = new Environment.Variable();

            Path p = new Path(java.getProject());
            p.add((Path) project.getReference("maven.plugin.classpath"));
            p.add((Path) project.getReference("maven.compile.classpath"));
            p.add((Path) project.getReference("maven.test.classpath"));
            classpath.setKey("JRUBY_PARENT_CLASSPATH");
            classpath.setValue(p.toString());

            java.addEnv(classpath);
        }

        if (jrubyHome != null) {
            Environment.Variable v = new Environment.Variable();
            v.setKey("jruby.home");
            v.setValue(jrubyHome);
            java.addSysproperty(v);
        }

        Path p = java.createClasspath();
        p.add((Path) project.getReference("maven.plugin.classpath"));
        p.add((Path) project.getReference("maven.compile.classpath"));
        p.add((Path) project.getReference("maven.test.classpath"));
        getLog().debug("java classpath: " + p.toString());

        for (String s : args) {
            arg = java.createArg();
            arg.setValue(s);
        }

        return java;
    }

    @SuppressWarnings({"unchecked"})
    protected void installGem(List<String> gem) throws MojoExecutionException {
        List args = new ArrayList();
        args.add("-S");
        // maybe_install_gems only takes a list of gems, no versions or sources
        if (gem.size() > 1) {
            args.add("gem");
            args.add("install");
        } else {
            args.add("maybe_install_gems");
        }
        args.addAll(gem);

        Java jruby = jruby(args);
        jruby.execute();
    }

    protected Project getProject() throws DependencyResolutionRequiredException {
        Project project = new Project();
        project.setBaseDir(mavenProject.getBasedir());
        project.addBuildListener(new LogAdapter());
        addReference(project, "maven.compile.classpath", compileClasspathElements);
        addReference(project, "maven.plugin.classpath", pluginArtifacts);
        addReference(project, "maven.test.classpath", testClasspathElements);
        return project;
    }

    @SuppressWarnings({"unchecked"})
    protected void addReference(Project project, String reference, List artifacts)
            throws DependencyResolutionRequiredException {
        List list = new ArrayList(artifacts.size());

        for (Object elem : artifacts) {
            String path;
            if (elem instanceof Artifact) {
                Artifact a = (Artifact) elem;
                File file = a.getFile();
                if (file == null) {
                    throw new DependencyResolutionRequiredException(a);
                }
                path = file.getPath();
            } else {
                path = elem.toString();
            }
            list.add(path);
        }

        Path p = new Path(project);
        p.setPath(StringUtils.join(list.iterator(), File.pathSeparator));
        project.addReference(reference, p);
    }

    public static <T> List<T> listify(T... objects) {
        List<T> res = new ArrayList<T>();
        res.addAll(Arrays.asList(objects));
        return res;
    }

    public class LogAdapter implements BuildListener {
        public void buildStarted(BuildEvent event) {
            log(event);
        }

        public void buildFinished(BuildEvent event) {
            log(event);
        }

        public void targetStarted(BuildEvent event) {
            log(event);
        }

        public void targetFinished(BuildEvent event) {
            log(event);
        }

        public void taskStarted(BuildEvent event) {
            log(event);
        }

        public void taskFinished(BuildEvent event) {
            log(event);
        }

        public void messageLogged(BuildEvent event) {
            log(event);
        }

        private void log(BuildEvent event) {
            int priority = event.getPriority();
            Log log = getLog();
            String message = event.getMessage();
            if (message.contains("nbb")) return;
			switch (priority) {
                case Project.MSG_ERR:
                    log.error(message);
                    break;

                case Project.MSG_WARN:
                    log.warn(message);
                    break;

                case Project.MSG_INFO:
                    log.info(message);
                    break;

                case Project.MSG_VERBOSE:
                    log.debug(message);
                    break;

                case Project.MSG_DEBUG:
                    log.debug(message);
                    break;

                default:
                    log.info(message);
                    break;
            }
        }
    }
}||||||| BASE
package cucumber.mojo;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.DependencyResolutionRequiredException;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;
import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildListener;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Java;
import org.apache.tools.ant.types.Commandline;
import org.apache.tools.ant.types.Environment;
import org.apache.tools.ant.types.Path;
import org.codehaus.plexus.util.StringUtils;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Base for all JRuby mojos.
 *
 * @requiresDependencyResolution compile
 */
public abstract class AbstractJRubyMojo extends AbstractMojo {

    protected boolean shouldFork = true;

    /**
     * @parameter expression="${project}"
     */
    protected MavenProject mavenProject;

    /**
     * @parameter expression="${project.basedir}"
     * @required
     */
    protected File launchDirectory;

    /**
     * @parameter expression="${jruby.home}"
     */
    protected String jrubyHome;

    /**
     * The amount of memory to use when forking JRuby. Default is "384m".
     *
     * @parameter expression="${jruby.launch.memory}"
     */
    protected String jrubyLaunchMemory = "384m";

    /**
     * The project compile classpath.
     *
     * @parameter default-value="${project.compileClasspathElements}"
     * @required
     * @readonly
     */
    private List compileClasspathElements;

    /**
     * The plugin dependencies.
     *
     * @parameter expression="${plugin.artifacts}"
     * @required
     * @readonly
     */
    private List pluginArtifacts;

    /**
     * The project test classpath
     *
     * @parameter expression="${project.testClasspathElements}"
     * @required
     * @readonly
     */
    private List testClasspathElements;

    protected Java jruby(List<String> args) throws MojoExecutionException {
        launchDirectory.mkdirs();
        Project project = null;
        try {
            project = getProject();
        } catch (DependencyResolutionRequiredException e) {
            throw new MojoExecutionException("error resolving dependencies", e);
        }

        Java java = new Java();
        java.setProject(project);
        java.setClassname("org.jruby.Main");
        java.setFailonerror(true);

        Commandline.Argument arg;

        if (shouldFork) {
            java.setFork(true);
            java.setDir(launchDirectory);

            arg = java.createJvmarg();
            arg.setValue("-Xmx" + jrubyLaunchMemory);
            Environment.Variable classpath = new Environment.Variable();

            Path p = new Path(java.getProject());
            p.add((Path) project.getReference("maven.plugin.classpath"));
            p.add((Path) project.getReference("maven.compile.classpath"));
            p.add((Path) project.getReference("maven.test.classpath"));
            classpath.setKey("JRUBY_PARENT_CLASSPATH");
            classpath.setValue(p.toString());

            java.addEnv(classpath);
        }

        if (jrubyHome != null) {
            Environment.Variable v = new Environment.Variable();
            v.setKey("jruby.home");
            v.setValue(jrubyHome);
            java.addSysproperty(v);
        }

        Path p = java.createClasspath();
        p.add((Path) project.getReference("maven.plugin.classpath"));
        p.add((Path) project.getReference("maven.compile.classpath"));
        p.add((Path) project.getReference("maven.test.classpath"));
        getLog().debug("java classpath: " + p.toString());

        for (String s : args) {
            arg = java.createArg();
            arg.setValue(s);
        }

        return java;
    }

    @SuppressWarnings({"unchecked"})
    protected void installGem(List<String> gem) throws MojoExecutionException {
        List args = new ArrayList();
        args.add("-S");
        // maybe_install_gems only takes a list of gems, no versions or sources
        if (gem.size() > 1) {
            args.add("gem");
            args.add("install");
        } else {
            args.add("maybe_install_gems");
        }
        args.addAll(gem);

        Java jruby = jruby(args);
        jruby.execute();
    }

    protected Project getProject() throws DependencyResolutionRequiredException {
        Project project = new Project();
        project.setBaseDir(mavenProject.getBasedir());
        project.addBuildListener(new LogAdapter());
        addReference(project, "maven.compile.classpath", compileClasspathElements);
        addReference(project, "maven.plugin.classpath", pluginArtifacts);
        addReference(project, "maven.test.classpath", testClasspathElements);
        return project;
    }

    @SuppressWarnings({"unchecked"})
    protected void addReference(Project project, String reference, List artifacts)
            throws DependencyResolutionRequiredException {
        List list = new ArrayList(artifacts.size());

        for (Object elem : artifacts) {
            String path;
            if (elem instanceof Artifact) {
                Artifact a = (Artifact) elem;
                File file = a.getFile();
                if (file == null) {
                    throw new DependencyResolutionRequiredException(a);
                }
                path = file.getPath();
            } else {
                path = elem.toString();
            }
            list.add(path);
        }

        Path p = new Path(project);
        p.setPath(StringUtils.join(list.iterator(), File.pathSeparator));
        project.addReference(reference, p);
    }

    public static <T> List<T> listify(T... objects) {
        List<T> res = new ArrayList<T>();
        res.addAll(Arrays.asList(objects));
        return res;
    }

    public class LogAdapter implements BuildListener {
        public void buildStarted(BuildEvent event) {
            log(event);
        }

        public void buildFinished(BuildEvent event) {
            log(event);
        }

        public void targetStarted(BuildEvent event) {
            log(event);
        }

        public void targetFinished(BuildEvent event) {
            log(event);
        }

        public void taskStarted(BuildEvent event) {
            log(event);
        }

        public void taskFinished(BuildEvent event) {
            log(event);
        }

        public void messageLogged(BuildEvent event) {
            log(event);
        }

        private void log(BuildEvent event) {
            int priority = event.getPriority();
            Log log = getLog();
            switch (priority) {
                case Project.MSG_ERR:
                    log.error(event.getMessage());
                    break;

                case Project.MSG_WARN:
                    log.warn(event.getMessage());
                    break;

                case Project.MSG_INFO:
                    log.info(event.getMessage());
                    break;

                case Project.MSG_VERBOSE:
                    log.debug(event.getMessage());
                    break;

                case Project.MSG_DEBUG:
                    log.debug(event.getMessage());
                    break;

                default:
                    log.info(event.getMessage());
                    break;
            }
        }
    }
}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b339f00_326f52b/rev_b339f00-326f52b/cuke4duke-maven-plugin/src/main/java/cuke4duke/mojo/CucumberMojo.java;<<<<<<< MINE
    /**
     * @parameter expression="${cucumber.bin}"
     */
    private File cucumberBin;

    @SuppressWarnings({"unchecked"})
||||||| BASE
    @SuppressWarnings({"unchecked"})
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b339f00_326f52b/rev_b339f00-326f52b/cuke4duke-maven-plugin/src/main/java/cuke4duke/mojo/AbstractJRubyMojo.java;<<<<<<< MINE
    /**
     * Installs gems. Each string must follow one of the following patterns:
     *
     * <ul>
     *   <li>name</li>
     *   <li>name:version</li>
     *   <li>name:version:github</li>
     * </ul>
     */
    @SuppressWarnings({"unchecked"})
||||||| BASE
    @SuppressWarnings({"unchecked"})
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_4f458e7_62ed918/rev_4f458e7-62ed918/cuke4duke/src/main/java/cuke4duke/internal/java/JavaLanguage.java;<<<<<<< MINE
import cuke4duke.*;
import cuke4duke.internal.language.ProgrammingLanguage;
import cuke4duke.internal.language.StepDefinition;
import cuke4duke.internal.language.LanguageMixin;

||||||| BASE
import cuke4duke.*;
import cuke4duke.internal.language.ProgrammingLanguage;
import cuke4duke.internal.language.StepDefinition;
import cuke4duke.internal.language.StepMother;
import cuke4duke.internal.language.LanguageMixin;

=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9c52824_64123b2/rev_9c52824-64123b2/examples/java/src/test/java/simple/SuperSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9c52824_64123b2/rev_9c52824-64123b2/examples/java/src/test/java/simple/HookSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9c52824_64123b2/rev_9c52824-64123b2/examples/java/src/test/java/simple/StuffSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1316538_92fb52a/rev_1316538-92fb52a/cuke4duke/src/main/java/cuke4duke/internal/clj/CljStepDefinition.java;<<<<<<< MINE
    private Method lookupInvokeMethod(int argCount) throws NoSuchMethodException {
        Class<?>[] parameterTypes = new Class[argCount];
        for(int i = 0; i < argCount; i++) {
            parameterTypes[i] = Object.class;
        }
        return AFunction.class.getMethod("invoke", parameterTypes);
||||||| BASE
    private Method lookupInvokeMethod(int argCount) throws NoSuchMethodException {
        Class[] parameterTypes = new Class[argCount];
        for(int i = 0; i < argCount; i++) {
            parameterTypes[i] = Object.class;
        }
        return AFunction.class.getMethod("invoke", parameterTypes);
=======
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        return AFunction.class.getMethod("invoke", getParameterTypes(args));
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1316538_92fb52a/rev_1316538-92fb52a/cuke4duke/src/main/java/cuke4duke/internal/jvmclass/ClassAnalyzer.java;<<<<<<< MINE

||||||| BASE
import cuke4duke.internal.language.Hook;
import cuke4duke.internal.language.StepDefinition;

import java.util.List;

=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1316538_92fb52a/rev_1316538-92fb52a/cuke4duke/src/main/java/cuke4duke/internal/js/JsLanguage.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1316538_92fb52a/rev_1316538-92fb52a/cuke4duke/src/main/java/cuke4duke/internal/js/JsLanguage.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e03d7f4_6c5c084/rev_e03d7f4-6c5c084/cuke4duke/src/main/java/cuke4duke/internal/js/JsLanguage.java;<<<<<<< MINE
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

||||||| BASE
import cuke4duke.internal.language.LanguageMixin;
import cuke4duke.internal.language.ProgrammingLanguage;
=======
import cuke4duke.internal.language.LanguageMixin;
import cuke4duke.internal.language.AbstractProgrammingLanguage;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_857f0c4_5bdbeb1/rev_857f0c4-5bdbeb1/cuke4duke/src/main/java/cuke4duke/internal/language/ProgrammingLanguage.java;<<<<<<< MINE
||||||| BASE
package cuke4duke.internal.language;

import cuke4duke.internal.JRuby;
import org.jruby.RubyArray;
import org.jruby.runtime.builtin.IRubyObject;

import java.util.*;

public abstract class ProgrammingLanguage {
    protected final LanguageMixin languageMixin;
    private List<StepDefinition> stepDefinitions;
    private List<Hook> befores;
    private List<Hook> afters;

    public ProgrammingLanguage(LanguageMixin languageMixin) {
        this.languageMixin = languageMixin;
    }

    final public RubyArray step_matches(String step_name, String formatted_step_name) {
        return JRuby.newArray(step_match_list(step_name, formatted_step_name));
    }

    public abstract void load_code_file(String file) throws Throwable;

    public final List<IRubyObject> step_match_list(String step_name, String formatted_step_name) {
        List<IRubyObject> matches = new ArrayList<IRubyObject>();
        for(StepDefinition stepDefinition : stepDefinitions){
            List<StepArgument> arguments = stepDefinition.arguments_from(step_name);
            if(arguments != null){
                matches.add(languageMixin.create_step_match(stepDefinition, step_name, formatted_step_name, arguments));
            }
        }
        return matches;
    }

    public final void begin_scenario() throws Throwable {
        prepareScenario();
        for(Hook before : befores){
            before.invoke("before", null);
        }
    }

    protected void clearHooksAndStepDefinitions() {
        befores = new ArrayList<Hook>();
        stepDefinitions = new ArrayList<StepDefinition>();
        afters = new ArrayList<Hook>();
    }

    public final void end_scenario() throws Throwable {
        for(Hook after : afters){
            after.invoke("after", null);
        }
        cleanupScenario();
    }

    public void addBeforeHook(Hook before) {
        befores.add(before);
    }

    public void addStepDefinition(StepDefinition stepDefinition) {
        stepDefinitions.add(stepDefinition);
    }

    public void addAfterHook(Hook after) {
        afters.add(after);
    }

    protected abstract void prepareScenario() throws Throwable;

    public abstract void cleanupScenario() throws Throwable;

    public void availableStepDefinition(String regexp_source, String file_colon_line) {
        languageMixin.available_step_definition(regexp_source, file_colon_line);
    }

    public void invokedStepDefinition(String regexp_source, String file_colon_line) {
        languageMixin.invoked_step_definition(regexp_source, file_colon_line);
    }
}=======
package cuke4duke.internal.language;

import cuke4duke.internal.JRuby;
import org.jruby.RubyArray;
import org.jruby.runtime.builtin.IRubyObject;

import java.util.*;

public abstract class ProgrammingLanguage {
    protected final LanguageMixin languageMixin;
    private List<StepDefinition> stepDefinitions;
    private List<Hook> befores;
    private List<Hook> afters;

    public ProgrammingLanguage(LanguageMixin languageMixin) {
        this.languageMixin = languageMixin;
    }

    final public RubyArray step_matches(String step_name, String formatted_step_name) throws Throwable {
        return JRuby.newArray(step_match_list(step_name, formatted_step_name));
    }

    public abstract void load_code_file(String file) throws Throwable;

    public final List<IRubyObject> step_match_list(String step_name, String formatted_step_name) throws Throwable {
        List<IRubyObject> matches = new ArrayList<IRubyObject>();
        for(StepDefinition stepDefinition : stepDefinitions){
            List<StepArgument> arguments = stepDefinition.arguments_from(step_name);
            if(arguments != null){
                matches.add(languageMixin.create_step_match(stepDefinition, step_name, formatted_step_name, arguments));
            }
        }
        return matches;
    }

    public final void begin_scenario() throws Throwable {
        prepareScenario();
        for(Hook before : befores){
            before.invoke("before", null);
        }
    }

    protected void clearHooksAndStepDefinitions() {
        befores = new ArrayList<Hook>();
        stepDefinitions = new ArrayList<StepDefinition>();
        afters = new ArrayList<Hook>();
    }

    public final void end_scenario() throws Throwable {
        for(Hook after : afters){
            after.invoke("after", null);
        }
        cleanupScenario();
    }

    public void addBeforeHook(Hook before) {
        befores.add(before);
    }

    public void addStepDefinition(StepDefinition stepDefinition) {
        stepDefinitions.add(stepDefinition);
    }

    public void addAfterHook(Hook after) {
        afters.add(after);
    }

    protected abstract void prepareScenario() throws Throwable;

    public abstract void cleanupScenario() throws Throwable;

    public void availableStepDefinition(String regexp_source, String file_colon_line) {
        languageMixin.available_step_definition(regexp_source, file_colon_line);
    }

    public void invokedStepDefinition(String regexp_source, String file_colon_line) {
        languageMixin.invoked_step_definition(regexp_source, file_colon_line);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/language/ProgrammignLanguage.java;<<<<<<< MINE
package cuke4duke.internal.language;

import org.jruby.RubyArray;

public interface ProgrammignLanguage {
    RubyArray step_matches(String step_name, String formatted_step_name);

    void load_code_file(String file) throws Throwable;

    void begin_scenario() throws Throwable;

    void end_scenario() throws Throwable;
}||||||| BASE
=======
package cuke4duke.internal.language;

import org.jruby.RubyArray;

public interface ProgrammignLanguage {
    RubyArray step_matches(String step_name, String formatted_step_name) throws Throwable;

    void load_code_file(String file) throws Throwable;

    void begin_scenario() throws Throwable;

    void end_scenario() throws Throwable;
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/language/AbstractProgrammingLanguage.java;<<<<<<< MINE
package cuke4duke.internal.language;

import cuke4duke.internal.JRuby;
import org.jruby.RubyArray;
import org.jruby.runtime.builtin.IRubyObject;

import java.util.*;

public abstract class AbstractProgrammingLanguage implements ProgrammignLanguage {
    protected final LanguageMixin languageMixin;
    private List<StepDefinition> stepDefinitions;
    private List<Hook> befores;
    private List<Hook> afters;

    public AbstractProgrammingLanguage(LanguageMixin languageMixin) {
        this.languageMixin = languageMixin;
    }

    final public RubyArray step_matches(String step_name, String formatted_step_name) {
        return JRuby.newArray(step_match_list(step_name, formatted_step_name));
    }

    public final List<IRubyObject> step_match_list(String step_name, String formatted_step_name) {
        List<IRubyObject> matches = new ArrayList<IRubyObject>();
        for(StepDefinition stepDefinition : stepDefinitions){
            List<StepArgument> arguments = stepDefinition.arguments_from(step_name);
            if(arguments != null){
                matches.add(languageMixin.create_step_match(stepDefinition, step_name, formatted_step_name, arguments));
            }
        }
        return matches;
    }

    public final void begin_scenario() throws Throwable {
        prepareScenario();
        for(Hook before : befores){
            before.invoke("before", null);
        }
    }

    protected void clearHooksAndStepDefinitions() {
        befores = new ArrayList<Hook>();
        stepDefinitions = new ArrayList<StepDefinition>();
        afters = new ArrayList<Hook>();
    }

    public final void end_scenario() throws Throwable {
        for(Hook after : afters){
            after.invoke("after", null);
        }
        cleanupScenario();
    }

    public void addBeforeHook(Hook before) {
        befores.add(before);
    }

    public void addStepDefinition(StepDefinition stepDefinition) {
        stepDefinitions.add(stepDefinition);
    }

    public void addAfterHook(Hook after) {
        afters.add(after);
    }

    protected abstract void prepareScenario() throws Throwable;

    public abstract void cleanupScenario() throws Throwable;

    public void availableStepDefinition(String regexp_source, String file_colon_line) {
        languageMixin.available_step_definition(regexp_source, file_colon_line);
    }

    public void invokedStepDefinition(String regexp_source, String file_colon_line) {
        languageMixin.invoked_step_definition(regexp_source, file_colon_line);
    }
}||||||| BASE
=======
package cuke4duke.internal.language;

import cuke4duke.internal.JRuby;
import org.jruby.RubyArray;
import org.jruby.runtime.builtin.IRubyObject;

import java.util.ArrayList;
import java.util.List;

public abstract class AbstractProgrammingLanguage implements ProgrammignLanguage {
    protected final LanguageMixin languageMixin;
    private List<StepDefinition> stepDefinitions;
    private List<Hook> befores;
    private List<Hook> afters;

    public AbstractProgrammingLanguage(LanguageMixin languageMixin) {
        this.languageMixin = languageMixin;
    }

    final public RubyArray step_matches(String step_name, String formatted_step_name) throws Throwable {
        return JRuby.newArray(step_match_list(step_name, formatted_step_name));
    }

    public abstract void load_code_file(String file) throws Throwable;

    public final List<IRubyObject> step_match_list(String step_name, String formatted_step_name) throws Throwable {
        List<IRubyObject> matches = new ArrayList<IRubyObject>();
        for(StepDefinition stepDefinition : stepDefinitions){
            List<StepArgument> arguments = stepDefinition.arguments_from(step_name);
            if(arguments != null){
                matches.add(languageMixin.create_step_match(stepDefinition, step_name, formatted_step_name, arguments));
            }
        }
        return matches;
    }

    public final void begin_scenario() throws Throwable {
        prepareScenario();
        for(Hook before : befores){
            before.invoke("before", null);
        }
    }

    protected void clearHooksAndStepDefinitions() {
        befores = new ArrayList<Hook>();
        stepDefinitions = new ArrayList<StepDefinition>();
        afters = new ArrayList<Hook>();
    }

    public final void end_scenario() throws Throwable {
        for(Hook after : afters){
            after.invoke("after", null);
        }
        cleanupScenario();
    }

    public void addBeforeHook(Hook before) {
        befores.add(before);
    }

    public void addStepDefinition(StepDefinition stepDefinition) {
        stepDefinitions.add(stepDefinition);
    }

    public void addAfterHook(Hook after) {
        afters.add(after);
    }

    protected abstract void prepareScenario() throws Throwable;

    public abstract void cleanupScenario() throws Throwable;

    public void availableStepDefinition(String regexp_source, String file_colon_line) {
        languageMixin.available_step_definition(regexp_source, file_colon_line);
    }

    public void invokedStepDefinition(String regexp_source, String file_colon_line) {
        languageMixin.invoked_step_definition(regexp_source, file_colon_line);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/language/AbstractStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/language/AbstractStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/clj/CljLanguage.java;<<<<<<< MINE
import cuke4duke.internal.language.AbstractProgrammingLanguage;
||||||| BASE
import cuke4duke.internal.language.ProgrammingLanguage;
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/clj/CljLanguage.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/jvmclass/ClassLanguage.java;<<<<<<< MINE
import cuke4duke.internal.language.AbstractProgrammingLanguage;
||||||| BASE
import cuke4duke.internal.language.ProgrammingLanguage;
=======
import cuke4duke.internal.language.AbstractProgrammingLanguage;
import cuke4duke.StepMother;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/jvmclass/ClassLanguage.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/groovy/GroovyLanguage.java;<<<<<<< MINE
import cuke4duke.internal.language.AbstractProgrammingLanguage;
||||||| BASE
import cuke4duke.internal.language.ProgrammingLanguage;
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/groovy/GroovyLanguage.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/js/JsLanguage.java;<<<<<<< MINE
import cuke4duke.internal.language.LanguageMixin;
import cuke4duke.internal.language.AbstractProgrammingLanguage;
||||||| BASE
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

=======
import cuke4duke.internal.language.AbstractProgrammingLanguage;
import cuke4duke.internal.language.LanguageMixin;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/main/java/cuke4duke/internal/js/JsLanguage.java;<<<<<<< MINE
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class JsLanguage extends AbstractProgrammingLanguage {
||||||| BASE
import cuke4duke.internal.language.LanguageMixin;
import cuke4duke.internal.language.ProgrammingLanguage;

public class JsLanguage extends ProgrammingLanguage {
=======
public class JsLanguage extends AbstractProgrammingLanguage {
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/test/java/cuke4duke/internal/language/MethodInvokerTest.java;<<<<<<< MINE
import java.lang.reflect.Method;

import org.junit.Before;
||||||| BASE
=======
import cuke4duke.Pending;
import cuke4duke.internal.JRuby;
import org.junit.Before;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/test/java/cuke4duke/internal/language/MethodInvokerTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/test/java/cuke4duke/internal/language/MethodInvokerTest.java;<<<<<<< MINE
import cuke4duke.Pending;
import cuke4duke.internal.JRuby;
||||||| BASE
import java.lang.reflect.Method;
import cuke4duke.Pending;
import cuke4duke.internal.JRuby;
=======
import java.lang.reflect.Method;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/test/java/cuke4duke/internal/jvmclass/ClassLanguageTest.java;<<<<<<< MINE
import org.junit.Before;
import org.junit.Test;

import cuke4duke.internal.language.ProgrammignLanguage;

||||||| BASE
import org.junit.Before;
import org.junit.Test;

import cuke4duke.internal.language.ProgrammingLanguage;

=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b05c252_3e66e50/rev_b05c252-3e66e50/cuke4duke/src/test/java/cuke4duke/internal/jvmclass/ClassLanguageTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8e1d25d_886564f/rev_8e1d25d-886564f/cuke4duke/src/main/java/cuke4duke/internal/JRuby.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1203598_ebda170/rev_1203598-ebda170/cuke4duke/src/main/java/cuke4duke/internal/ik/IkStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1203598_ebda170/rev_1203598-ebda170/cuke4duke/src/main/java/cuke4duke/internal/ik/IkStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1203598_ebda170/rev_1203598-ebda170/cuke4duke/src/main/java/cuke4duke/internal/ik/IkStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1203598_ebda170/rev_1203598-ebda170/cuke4duke/src/main/java/cuke4duke/internal/ik/IkStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1203598_ebda170/rev_1203598-ebda170/cuke4duke/src/main/java/cuke4duke/internal/JRuby.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1203598_ebda170/rev_1203598-ebda170/examples/spring/src/test/java/simple/CallingSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1203598_ebda170/rev_1203598-ebda170/examples/spring/src/test/java/simple/CallingSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_fb029a2_9fd0062/rev_fb029a2-9fd0062/cuke4duke/src/main/java/cuke4duke/internal/jvmclass/ClassAnalyzer.java;<<<<<<< MINE
    void addDefaultTransforms(ClassLanguage classLanguage, ObjectFactory objectFactory);
||||||| BASE
=======

    Class<?>[] alwaysLoad();
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_fb029a2_9fd0062/rev_fb029a2-9fd0062/cuke4duke/src/main/java/cuke4duke/internal/jvmclass/ClassLanguage.java;<<<<<<< MINE

||||||| BASE
=======

    private ObjectFactory createObjectFactory() throws Throwable {
        String className = System.getProperty("cuke4duke.objectFactory", "cuke4duke.internal.jvmclass.PicoFactory");
        if(className == null) {
            throw new RuntimeException("Missing system property: cuke4duke.objectFactory");
        }
        Class<?> ofc = Thread.currentThread().getContextClassLoader().loadClass(className);
        Constructor<?> ctor = ofc.getConstructor();
        try {
            return(ObjectFactory) ctor.newInstance();
        } catch(InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_aa47ccb_e344d6b/rev_aa47ccb-e344d6b/cuke4duke/src/main/java/cuke4duke/internal/clj/CljHook.java;<<<<<<< MINE
import java.util.List;

public class CljHook extends AbstractHook {
||||||| BASE
public class CljHook extends AFunction implements Hook {
    private final CljLanguage instance;
=======
@SuppressWarnings("serial")
public class CljHook extends AFunction implements Hook {
    @SuppressWarnings("unused")
    private final CljLanguage instance;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_09f3133_0ec7421/rev_09f3133-0ec7421/core/src/main/java/cucumber/runtime/Runtime.java;<<<<<<< MINE
import cucumber.classpath.Classpath;
||||||| BASE
import cucumber.classpath.Classpath;
import gherkin.GherkinParser;
=======
import static java.util.Arrays.asList;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_09f3133_0ec7421/rev_09f3133-0ec7421/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_09f3133_0ec7421/rev_09f3133-0ec7421/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;<<<<<<< MINE
import cucumber.classpath.Classpath;
import cucumber.classpath.Consumer;
import cucumber.io.Resource;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.StepDefinition;
||||||| BASE
import cucumber.classpath.Classpath;
import cucumber.classpath.Consumer;
import cucumber.classpath.Input;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.StepDefinition;
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_09f3133_0ec7421/rev_09f3133-0ec7421/ioke/src/main/java/cucumber/runtime/ioke/IokeBackend.java;<<<<<<< MINE
import cucumber.Table;
import cucumber.classpath.Classpath;
import cucumber.classpath.Consumer;
import cucumber.io.Resource;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.StepDefinition;
||||||| BASE
import cucumber.Table;
import cucumber.classpath.Classpath;
import cucumber.classpath.Consumer;
import cucumber.classpath.Input;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.StepDefinition;
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_09f3133_0ec7421/rev_09f3133-0ec7421/clojure/src/main/java/cucumber/runtime/clojure/ClojureBackend.java;<<<<<<< MINE
import cucumber.io.Resource;
import cucumber.runtime.*;
import gherkin.formatter.model.Step;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
||||||| BASE
import cucumber.classpath.Input;
import cucumber.runtime.*;
import gherkin.formatter.model.Step;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
=======
import cucumber.classpath.Input;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.StepDefinition;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_09f3133_0ec7421/rev_09f3133-0ec7421/rhino/src/main/java/cucumber/runtime/rhino/RhinoBackend.java;<<<<<<< MINE
import cucumber.classpath.Classpath;
import cucumber.classpath.Consumer;
import cucumber.io.Resource;
import cucumber.runtime.*;
import cucumber.runtime.javascript.JavascriptSnippetGenerator;
||||||| BASE
import cucumber.classpath.Classpath;
import cucumber.classpath.Consumer;
import cucumber.classpath.Input;
import cucumber.runtime.*;
import cucumber.runtime.javascript.JavascriptSnippetGenerator;
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e21aea9_5e11a0c/rev_e21aea9-5e11a0c/java/src/main/java/cucumber/annotation/Transform.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e21aea9_5e11a0c/rev_e21aea9-5e11a0c/java/src/main/java/cucumber/annotation/Transform.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b93afaa_ed729ee/rev_b93afaa-ed729ee/java/src/main/java/cucumber/annotation/Transform.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_77ec863_34f31fb/rev_77ec863-34f31fb/core/src/main/java/cucumber/Table.java;<<<<<<< MINE
||||||| BASE
package cucumber;

import gherkin.formatter.model.Row;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import cucumber.runtime.transformers.Transformer;

public class Table {

    private final List<List<String>> raw;
    private Map<String, Transformer<?>> columnTransformers = new HashMap<String, Transformer<?>>();

    public Table(List<Row> gherkinRows) {
        this.raw = new ArrayList<List<String>>();
        for (Row row : gherkinRows) {
            List<String> list = new ArrayList<String>();
            list.addAll(row.getCells());
            this.raw.add(list);
        }
    }

    /**
     * 
     * @return the headers of the table (first <i>raw</i> row with labels)
     */
    public List<String> getHeaders() {
        return this.raw.get(0);
    }

    public List<List<String>> raw() {
        return this.raw;
    }

    public List<List<String>> rows() {
        return this.raw.subList(1, this.raw.size());
    }
    
    public List<Map<String, Object>> hashes() {
        List<Map<String, Object>> hashes = new ArrayList<Map<String, Object>>();
        List<String> headers = getHeaders();
        List<List<String>> rows = rows();
        for (List<String> row : rows) {
            Map<String, Object> map = new HashMap<String, Object>();
            for(int i=0;i<row.size();i++) {
                String header = headers.get(i);
                Object hashValue = transformCellValue(header, row.get(i));
                map.put(header, hashValue);
            }
            hashes.add(map);
        }
        return hashes;
    }

    private Object transformCellValue(String header, String cellValue) {
        Object hashValue;
        Transformer<?> transformer = this.columnTransformers.get(header);
        if(transformer!=null) {
            //TODO: How to get Locale from here?
            hashValue = transformer.transform(Locale.getDefault(), cellValue);
        } else {
            hashValue = cellValue;
        }
        return hashValue;
    }
    
    public void mapColumn(String column, Transformer<?> transformer) {
        this.columnTransformers.put(column, transformer);
    }
}=======
package cucumber;

public class Table {
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_77ec863_34f31fb/rev_77ec863-34f31fb/ioke/src/main/java/cucumber/runtime/ioke/IokeBackend.java;<<<<<<< MINE
import cucumber.table.Table;
import cucumber.classpath.Classpath;
import cucumber.classpath.Consumer;
import cucumber.io.Resource;
||||||| BASE
import cucumber.Table;
import cucumber.classpath.Classpath;
import cucumber.classpath.Consumer;
import cucumber.io.Resource;
=======
import cucumber.Table;
import cucumber.resources.Resource;
import cucumber.resources.Resources;
import cucumber.resources.Consumer;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_87936d1_e768006/rev_87936d1-e768006/core/src/main/java/cucumber/resources/Resources.java;<<<<<<< MINE
import static cucumber.resources.FilePathExtractor.filePath;
import static java.util.Collections.emptyList;

||||||| BASE
import static java.util.Collections.emptyList;

=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/core/src/main/java/cucumber/runtime/TableArgumentProcessor.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/core/src/main/java/cucumber/runtime/StepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/core/src/main/java/cucumber/runtime/StepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/java/src/main/java/cucumber/annotation/TableProcessorInfo.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/java/src/main/java/cucumber/annotation/JavaBeanClass.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/java/src/main/java/cucumber/runtime/java/JavaStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/java/src/main/java/cucumber/runtime/java/JavaStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/java/src/main/java/cucumber/runtime/java/JavaStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/java/src/main/java/cucumber/runtime/java/JavaStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/java/src/main/java/cucumber/runtime/java/JavaBeanTableProcessor.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/java/src/test/java/cucumber/runtime/java/JavaBeanTableProcessorTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/groovy/src/main/java/cucumber/runtime/groovy/GroovyStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/groovy/src/main/java/cucumber/runtime/groovy/GroovyStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/jruby/src/main/java/cucumber/runtime/jruby/JRubyStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/jruby/src/main/java/cucumber/runtime/jruby/JRubyStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/ioke/src/main/java/cucumber/runtime/ioke/IokeStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/ioke/src/main/java/cucumber/runtime/ioke/IokeStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/clojure/src/main/java/cucumber/runtime/clojure/ClojureStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/clojure/src/main/java/cucumber/runtime/clojure/ClojureStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/rhino/src/main/java/cucumber/runtime/rhino/RhinoStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_e314593_125bc72/rev_e314593-125bc72/rhino/src/main/java/cucumber/runtime/rhino/RhinoStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_321575e_a5ac1a4/rev_321575e-a5ac1a4/java/src/main/java/cucumber/runtime/java/JavaBackend.java;<<<<<<< MINE
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
||||||| BASE
import java.lang.reflect.InvocationTargetException;
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_321575e_a5ac1a4/rev_321575e-a5ac1a4/java/src/main/java/cucumber/runtime/java/JavaBackend.java;<<<<<<< MINE
    private void addConstructorDependencies(Class<?> clazz) {
        for (Constructor constructor : clazz.getConstructors())
        {
            for(Class paramClazz : constructor.getParameterTypes())
            {
                // TODO: Check if class was already registered to prevent endless recursion
                objectFactory.addClass(paramClazz);
                addConstructorDependencies(paramClazz);
            }
        }
    }

    public Object invoke(Method method, Object[] javaArgs) {
        try {
            if (method.isAnnotationPresent(Pending.class)) {
                throw new PendingException(method.getAnnotation(Pending.class).value());
            } else {
                return method.invoke(this.objectFactory.getInstance(method.getDeclaringClass()), javaArgs);
            }
        } catch (IllegalArgumentException e) {
            throw new CucumberException(errorMessage(method, javaArgs), e);
        } catch (InvocationTargetException e) {
            throw new CucumberException(errorMessage(method, javaArgs), e.getTargetException());
        } catch (IllegalAccessException e) {
            throw new CucumberException(errorMessage(method, javaArgs), e);
        }
    }

    private String errorMessage(Method method, Object[] javaArgs) {
        StringBuilder m = new StringBuilder("Couldn't invoke ").append(method.toGenericString()).append(" with ").append(Utils.join(javaArgs, ",")).append(" (");
        boolean comma = false;
        for (Object javaArg : javaArgs) {
            if (comma) m.append(",");
            m.append(javaArg.getClass());
            comma = true;
        }
        m.append(")");
        return m.toString();
    }

||||||| BASE
    public Object invoke(Method method, Object[] javaArgs) {
        try {
            if (method.isAnnotationPresent(Pending.class)) {
                throw new PendingException(method.getAnnotation(Pending.class).value());
            } else {
                return method.invoke(this.objectFactory.getInstance(method.getDeclaringClass()), javaArgs);
            }
        } catch (IllegalArgumentException e) {
            throw new CucumberException(errorMessage(method, javaArgs), e);
        } catch (InvocationTargetException e) {
            throw new CucumberException(errorMessage(method, javaArgs), e.getTargetException());
        } catch (IllegalAccessException e) {
            throw new CucumberException(errorMessage(method, javaArgs), e);
        }
    }

    private String errorMessage(Method method, Object[] javaArgs) {
        StringBuilder m = new StringBuilder("Couldn't invoke ").append(method.toGenericString()).append(" with ").append(Utils.join(javaArgs, ",")).append(" (");
        boolean comma = false;
        for (Object javaArg : javaArgs) {
            if (comma) m.append(",");
            m.append(javaArg.getClass());
            comma = true;
        }
        m.append(")");
        return m.toString();
    }

=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_6b11cde_59b5d96/rev_6b11cde-59b5d96/core/src/main/java/cucumber/formatter/NullReporter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_6b11cde_59b5d96/rev_6b11cde-59b5d96/junit/src/main/java/cucumber/junit/JUnitReporterFactory.java;<<<<<<< MINE
import cucumber.formatter.FormatterFactory;
import cucumber.formatter.NullReporter;

||||||| BASE
import cucumber.runtime.NullReporter;
=======
import cucumber.formatter.NullReporter;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_ed96fe1_0fac5b8/rev_ed96fe1-0fac5b8/spring/src/test/java/cucumber/runtime/java/spring/hooks/SpringTransactionHooksTest.java;<<<<<<< MINE
    private SpringTransactionHooks target;

    @Mock
    private PlatformTransactionManager mockedPlatformTransactionManager;

    @Before
    public void setUp() {
        target = new SpringTransactionHooks();
        target.setTxMgr(mockedPlatformTransactionManager);
    }

    @Test
    public void shouldObtainOrStartTransactionInBeforeHook() {
        final SimpleTransactionStatus dummyTxStatus = new SimpleTransactionStatus();
        when(mockedPlatformTransactionManager.getTransaction(isA(TransactionDefinition.class))).thenReturn(dummyTxStatus);

        target.rollBackBeforeHook();

        assertSame(target.txStatus, dummyTxStatus);
    }

    @Test
    public void shouldTriggerTransactionRollbackInAfterHook() {
        final SimpleTransactionStatus dummyTxStatus = new SimpleTransactionStatus();
        target.txStatus = dummyTxStatus;

        mockedPlatformTransactionManager.rollback(dummyTxStatus);

        verify(mockedPlatformTransactionManager).rollback(dummyTxStatus);
    }
||||||| BASE
	private SpringTransactionHooks target;
	
	@Mock
	private PlatformTransactionManager mockedPlatformTransactionManager;
	
	@Before
	public void setUp() {
		target = new SpringTransactionHooks();
		target.setTxMgr(mockedPlatformTransactionManager);
	}
	
	@Test
	public void shouldObtainOrStartTransactionInBeforeHook() {
		final SimpleTransactionStatus dummyTxStatus = new SimpleTransactionStatus();
		when(mockedPlatformTransactionManager.getTransaction(isA(TransactionDefinition.class))).thenReturn(dummyTxStatus);
		
		target.rollBackBeforeHook();
		
		assertSame(target.txStatus, dummyTxStatus);
	}
	
	@Test
	public void shouldTriggerTransactionRollbackInAfterHook() {
		final SimpleTransactionStatus dummyTxStatus = new SimpleTransactionStatus();
		target.txStatus = dummyTxStatus;
		
		mockedPlatformTransactionManager.rollback(dummyTxStatus);
		
		verify(mockedPlatformTransactionManager).rollback(dummyTxStatus);
	}
=======
    private SpringTransactionHooks target;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_ed96fe1_0fac5b8/rev_ed96fe1-0fac5b8/spring/src/main/java/cucumber/runtime/java/spring/hooks/SpringTransactionHooks.java;<<<<<<< MINE
import cucumber.annotation.After;
import cucumber.annotation.Before;
||||||| BASE
=======
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_ed96fe1_0fac5b8/rev_ed96fe1-0fac5b8/spring/src/main/java/cucumber/runtime/java/spring/hooks/SpringTransactionHooks.java;<<<<<<< MINE
public class SpringTransactionHooks {
||||||| BASE
import cucumber.annotation.After;
import cucumber.annotation.Before;

public class SpringTransactionHooks {
=======
import cucumber.annotation.After;
import cucumber.annotation.Before;

/**
 * This class defines before and afrer hooks which provide automatic spring rollback capabilities.
 * These hooks will apply to any element(s) within a <code>.feature</code> file tagged with <code>@txn</code>.
 * 
 * Clients wishing to leverage these hooks should include this class' package in the <code>packages</code> property of the 
 * Test class' <code>Feature</code> annotation.
 * 
 * The BEFORE and AFTER hooks both rely on being able to obtain a <code>PlatformTransactionManager</code> by type, or
 * by an optionally specified bean name, from the runtime <code>BeanFactory</code>.
 * 
 *  NOTE: This class is NOT threadsafe!  It relies on the fact that cucumber-jvm will instantiate an instance of any 
 *        applicable hookdef class per scenario run.
 * 
 * @author patrickmcmichael
 */
public class SpringTransactionHooks implements BeanFactoryAware {
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_ed96fe1_0fac5b8/rev_ed96fe1-0fac5b8/spring/src/main/java/cucumber/runtime/java/spring/hooks/SpringTransactionHooks.java;<<<<<<< MINE
    TransactionStatus txStatus;

    private PlatformTransactionManager txMgr;

    /**
     * Setter for Dependency Injection - autowiring would rely on too many client-specific details
     */
    public void setTxMgr(PlatformTransactionManager txMgr) {
        this.txMgr = txMgr;
||||||| BASE
    TransactionStatus txStatus;
    
    private PlatformTransactionManager txMgr;
    /** Setter for Dependency Injection - autowiring would rely on too many client-specific details */
    public void setTxMgr(PlatformTransactionManager txMgr) {
       this.txMgr = txMgr;
=======
    private BeanFactory beanFactory;
    private String txnManagerBeanName;

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }
    
    /**
     * @return the (optional) bean name for the transaction manager to be obtained - if null, attempt will be made to find a transaction manager by bean type
     */
    public String getTxnManagerBeanName() {
        return txnManagerBeanName;
    }
    /**
     * Setter to allow (optional) bean name to be specified for transaction manager bean - if null, attempt will be made to find a transaction manager by bean type
     * @param txManagerBeanName bean name of transaction manager bean
     */
    public void setTxnManagerBeanName(String txnManagerBeanName) {
        this.txnManagerBeanName = txnManagerBeanName;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_ed96fe1_0fac5b8/rev_ed96fe1-0fac5b8/spring/src/main/java/cucumber/runtime/java/spring/hooks/SpringTransactionHooks.java;<<<<<<< MINE

||||||| BASE
    
=======
    
    
    TransactionStatus txStatus;
    
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/FormatterFactory.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_044a692_e28a394/rev_044a692-e28a394/core/src/main/java/cucumber/formatter/FormatterFactory.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/runtime/World.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/cli/Main.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/cli/Main.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/main/java/cucumber/cli/Main.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/test/java/cucumber/runtime/HookTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/core/src/test/java/cucumber/runtime/BackgroundTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/loadguicemodule/FirstSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/loadguicemodule/SharedBetweenSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/loadguicemodule/YourModuleClass.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/loadguicemodule/SecondSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/loadguicemodule/loadguicemodule.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/PrivateConstructor.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/GuiceFactoryTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/GuiceFactoryTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/GuiceFactoryTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/GuiceFactoryTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/GuiceFactoryTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/test/java/cucumber/runtime/java/guice/ModuleInstantiator_Test.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/main/java/cucumber/runtime/java/guice/GuiceFactory.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/main/java/cucumber/runtime/java/guice/GuiceFactory.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/main/java/cucumber/runtime/java/guice/GuiceFactory.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/main/java/cucumber/runtime/java/guice/GuiceFactory.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/main/java/cucumber/runtime/java/guice/ModuleInstantiator.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/main/java/cucumber/runtime/java/guice/GuiceModuleInstantiationFailed.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a90a684_618a766/rev_a90a684-618a766/guice/src/main/java/cucumber/runtime/java/guice/LoadingPropertiesFileFailed.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7d3b639_f6064ca/rev_7d3b639-f6064ca/examples/java-calculator/src/test/java/cucumber/examples/java/calculator/RpnCalculatorStepdefs.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7d3b639_f6064ca/rev_7d3b639-f6064ca/examples/java-calculator/src/test/java/cucumber/examples/java/calculator/RpnCalculatorStepdefs.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7d3b639_f6064ca/rev_7d3b639-f6064ca/examples/java-calculator/src/test/java/cucumber/examples/java/calculator/RpnCalculatorStepdefs.java;<<<<<<< MINE
	private RpnCalculator calc;
||||||| BASE
    private RpnCalculator calc;

    @Given("^a calculator I just turned on$")
    public void a_calculator_I_just_turned_on() {
        calc = new RpnCalculator();
    }

    @When("^I add (\\d+) and (\\d+)$")
    public void adding(int arg1, int arg2) {
        calc.push(arg1);
        calc.push(arg2);
        calc.push("+");
    }

    @Then("^the result is (\\d+)$")
    public void the_result_is(double expected) {
        assertEquals(expected, calc.value());
    }

    @Before({"~@foo"})
    public void before() {
        System.out.println("Runs before scenarios *not* tagged with @foo");
    }

    @After
    public void after() {
=======
    private RpnCalculator calc;
    private List<ScenarioMovement> stepDefmovements;

    @Given("^a calculator I just turned on$")
    public void a_calculator_I_just_turned_on() {
        calc = new RpnCalculator();
    }

    @When("^I add (\\d+) and (\\d+)$")
    public void adding(int arg1, int arg2) {
        calc.push(arg1);
        calc.push(arg2);
        calc.push("+");
    }

    @Then("^the result is (\\d+)$")
    public void the_result_is(double expected) {
        assertEquals(expected, calc.value());
    }

    @Before({"~@foo"})
    public void before() {
        System.out.println("Runs before scenarios *not* tagged with @foo");
    }

    @After
    public void after() {
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7d3b639_f6064ca/rev_7d3b639-f6064ca/examples/java-calculator/src/test/java/cucumber/examples/java/calculator/RpnCalculatorStepdefs.java;<<<<<<< MINE
	@Given("^a calculator I just turned on$")
	public void a_calculator_I_just_turned_on() {
		calc = new RpnCalculator();
	}

	@When("^I add (\\d+) and (\\d+)$")
	public void adding(int arg1, int arg2) {
		calc.push(arg1);
		calc.push(arg2);
		calc.push("+");
	}

	@Then("^the result is (\\d+)$")
	public void the_result_is(double expected) {
		assertEquals(expected, calc.value());
	}

	@Before({ "~@foo" })
	public void before() {
		System.out.println("Runs before scenarios *not* tagged with @foo");
	}

	@After
	public void after() {

	}

	/**
	 * Shows you can use the @Given annotation even inside a scenario outline,
	 * having a List<SomeObject> as the argument
	 * @param additions
	 */
	@Given("^the previous additions:$")
	public void thePreviousAdditions(List<PreviousAddition> additions) {
		calc = new RpnCalculator();		
		for (Iterator<PreviousAddition> iterator = additions.iterator(); iterator
				.hasNext();) {
			PreviousAddition operation = iterator.next();
			calc.push(operation.getFirst());
			calc.push(operation.getSecond());
			calc.push("+");
		}
	}

	public class PreviousAddition {
		Integer first;
		Integer second;
		String operation;
		
		public PreviousAddition(Integer first, Integer second, String operation) {
			super();
			this.first = first;
			this.second = second;
			this.operation = operation;
		}

		public Integer getFirst() {
			return first;
		}

		public void setFirst(Integer first) {
			this.first = first;
		}

		public Integer getSecond() {
			return second;
		}

		public void setSecond(Integer second) {
			this.second = second;
		}

		public String getOperation() {
			return operation;
		}

		public void setOperation(String operation) {
			this.operation = operation;
		}
	}
||||||| BASE
    }
=======
    }
    
	@Given("^the following movements:$")
	public void theFollowingMovements(List<ScenarioMovement> movements) {
		calc = new RpnCalculator();
		stepDefmovements = new ArrayList<RpnCalculatorStepdefs.ScenarioMovement>();
	    for (Iterator<ScenarioMovement> iterator = movements.iterator(); iterator.hasNext();) {
	    	
	    	stepDefmovements.add(iterator.next());	
		}
	}
	
	public class ScenarioMovement {
		String code;
		String from;
		String to;
		
		public ScenarioMovement(String code, String from, String to) {
			super();
			this.code = code;
			this.from = from;
			this.to = to;
		}
		public String getCode() {
			return code;
		}
		public void setCode(String code) {
			this.code = code;
		}
		public String getFrom() {
			return from;
		}
		public void setFrom(String from) {
			this.from = from;
		}
		public String getTo() {
			return to;
		}
		public void setTo(String to) {
			this.to = to;
		}
		
	}
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_697c16f_df04a2b/rev_697c16f-df04a2b/jruby/src/main/java/cucumber/runtime/jruby/JRubyHookDefinition.java;<<<<<<< MINE
package cucumber.runtime.jruby;

import static java.util.Arrays.asList;
import gherkin.TagExpression;

import java.util.Collection;

import org.jruby.RubyObject;
import org.jruby.runtime.builtin.IRubyObject;

import cucumber.runtime.HookDefinition;
import cucumber.runtime.ScenarioResult;

public class JRubyHookDefinition implements HookDefinition {

    private RubyObject hook;
    private int order;
    private final TagExpression tagExpression;

    public JRubyHookDefinition(String[] tagExpressions, RubyObject hook) {
        tagExpression = new TagExpression(asList(tagExpressions));
        this.order = 0;
        this.hook = hook;
    }

    @Override
    public void execute(ScenarioResult scenarioResult) throws Throwable {
        IRubyObject[] jrybyArgs = new IRubyObject[0];
        hook.callMethod("execute", jrybyArgs);
    }

    @Override
    public boolean matches(Collection<String> tags) {
        return tagExpression.eval(tags);
    }

    @Override
    public int getOrder() {
        return order;
    }

}||||||| BASE
=======
package cucumber.runtime.jruby;

import cucumber.runtime.HookDefinition;
import cucumber.runtime.ScenarioResult;
import gherkin.TagExpression;
import org.jruby.RubyObject;
import org.jruby.runtime.builtin.IRubyObject;

import java.util.Collection;

import static java.util.Arrays.asList;

public class JRubyHookDefinition implements HookDefinition {

    private RubyObject hook;
    private int order;
    private final TagExpression tagExpression;

    public JRubyHookDefinition(String[] tagExpressions, RubyObject hook) {
        tagExpression = new TagExpression(asList(tagExpressions));
        this.order = 0;
        this.hook = hook;
    }

    @Override
    public void execute(ScenarioResult scenarioResult) throws Throwable {
        IRubyObject[] jrybyArgs = new IRubyObject[0];
        hook.callMethod("execute", jrybyArgs);
    }

    @Override
    public boolean matches(Collection<String> tags) {
        return tagExpression.eval(tags);
    }

    @Override
    public int getOrder() {
        return order;
    }

}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_df04a2b_697c16f/rev_df04a2b-697c16f/jruby/src/main/java/cucumber/runtime/jruby/JRubyHookDefinition.java;<<<<<<< MINE
package cucumber.runtime.jruby;

import cucumber.runtime.HookDefinition;
import cucumber.runtime.ScenarioResult;
import gherkin.TagExpression;
import org.jruby.RubyObject;
import org.jruby.runtime.builtin.IRubyObject;

import java.util.Collection;

import static java.util.Arrays.asList;

public class JRubyHookDefinition implements HookDefinition {

    private RubyObject hook;
    private int order;
    private final TagExpression tagExpression;

    public JRubyHookDefinition(String[] tagExpressions, RubyObject hook) {
        tagExpression = new TagExpression(asList(tagExpressions));
        this.order = 0;
        this.hook = hook;
    }

    @Override
    public void execute(ScenarioResult scenarioResult) throws Throwable {
        IRubyObject[] jrybyArgs = new IRubyObject[0];
        hook.callMethod("execute", jrybyArgs);
    }

    @Override
    public boolean matches(Collection<String> tags) {
        return tagExpression.eval(tags);
    }

    @Override
    public int getOrder() {
        return order;
    }

}||||||| BASE
=======
package cucumber.runtime.jruby;

import static java.util.Arrays.asList;
import gherkin.TagExpression;

import java.util.Collection;

import org.jruby.RubyObject;
import org.jruby.runtime.builtin.IRubyObject;

import cucumber.runtime.HookDefinition;
import cucumber.runtime.ScenarioResult;

public class JRubyHookDefinition implements HookDefinition {

    private RubyObject hook;
    private int order;
    private final TagExpression tagExpression;

    public JRubyHookDefinition(String[] tagExpressions, RubyObject hook) {
        tagExpression = new TagExpression(asList(tagExpressions));
        this.order = 0;
        this.hook = hook;
    }

    @Override
    public void execute(ScenarioResult scenarioResult) throws Throwable {
        IRubyObject[] jrybyArgs = new IRubyObject[0];
        hook.callMethod("execute", jrybyArgs);
    }

    @Override
    public boolean matches(Collection<String> tags) {
        return tagExpression.eval(tags);
    }

    @Override
    public int getOrder() {
        return order;
    }

}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_addf7a9_199dc05/rev_addf7a9-199dc05/examples/java-calculator/src/test/java/cucumber/examples/java/calculator/ShoppingStepdefs.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_addf7a9_199dc05/rev_addf7a9-199dc05/examples/java-calculator/src/test/java/cucumber/examples/java/calculator/date_calculator_Test.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_addf7a9_199dc05/rev_addf7a9-199dc05/examples/java-calculator/src/test/java/cucumber/examples/java/calculator/DateStepdefs.java;<<<<<<< MINE
package cucumber.examples.java.calculator;

import java.util.Date;

import cucumber.annotation.DateFormat;
import cucumber.annotation.en.Given;
import cucumber.annotation.en.Then;
import cucumber.annotation.en.When;
import static org.junit.Assert.*;

public class DateStepdefs {

    String result;
    private DateCalculator calculator;

    @Given("^today is (.+)$")
    public void today_is_(@DateFormat("yyyy-MM-dd") Date date) {
        calculator = new DateCalculator(date);
    }

    @Then("^the result should be (.+)$")
    public void the_result_should_be_(String expectedResult) {
        assertEquals(expectedResult, result);
    }

    @When("^I ask if (.+) in in the past$")
    public void I_ask_how_many_days_ago_was(Date date) {
        result = calculator.isDateInThePast(date);
    }
}||||||| BASE
=======
package cucumber.examples.java.calculator;

import java.util.Date;

import cucumber.annotation.DateFormat;
import cucumber.annotation.en.Given;
import cucumber.annotation.en.Then;
import cucumber.annotation.en.When;
import static org.junit.Assert.*;

public class DateStepdefs {

    private String result;
    private DateCalculator calculator;

    @Given("^today is (.+)$")
    public void today_is(@DateFormat("yyyy-MM-dd") Date date) {
        calculator = new DateCalculator(date);
    }

    @When("^I ask if (.+) is in the past$")
    public void I_ask_if_date_is_in_the_past(Date date) {
        result = calculator.isDateInThePast(date);
    }

    @Then("^the result should be (.+)$")
    public void the_result_should_be(String expectedResult) {
        assertEquals(expectedResult, result);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_addf7a9_199dc05/rev_addf7a9-199dc05/examples/java-calculator/src/main/java/cucumber/examples/java/calculator/DateCalculator.java;<<<<<<< MINE
package cucumber.examples.java.calculator;

import java.util.Date;

public class DateCalculator {
	
	private Date now;

	public DateCalculator(Date now) {
		super();
		this.now = now;
	}

	public String isDateInThePast(Date date) {
		if(date.before(now))
			return "yes";
		else
			return "no";
	}
	
	

}||||||| BASE
=======
package cucumber.examples.java.calculator;

import java.util.Date;

public class DateCalculator {
    private Date now;

    public DateCalculator(Date now) {
        this.now = now;
    }

    public String isDateInThePast(Date date) {
        return (date.before(now)) ? "yes" : "no";
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_65cbace_f7ed8de/rev_65cbace-f7ed8de/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;<<<<<<< MINE
import cucumber.runtime.CucumberException;
||||||| BASE
=======
import cucumber.runtime.PendingException;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_4514f91_c196d7a/rev_4514f91-c196d7a/core/src/main/java/cucumber/runtime/World.java;<<<<<<< MINE
import java.util.*;
||||||| BASE
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
=======
import java.util.List;
import java.util.Locale;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_4514f91_c196d7a/rev_4514f91-c196d7a/core/src/main/java/cucumber/runtime/World.java;<<<<<<< MINE
    // TODO - it's expensive to create a new LocalizedXStreams for each scenario - reuse a global one.
    private final LocalizedXStreams localizedXStreams = new LocalizedXStreams();
    private final List<StepDefinition> stepDefinitions = new ArrayList<StepDefinition>();
    private final List<HookDefinition> beforeHooks = new ArrayList<HookDefinition>();
    private final List<HookDefinition> afterHooks = new ArrayList<HookDefinition>();
    private final ScenarioResultImpl scenarioResult = new ScenarioResultImpl();

    private final Runtime runtime;

    private final Collection<String> tags;

    private boolean skipNextStep = false;

    public World(Runtime runtime, Collection<String> tags) {
        this.runtime = runtime;
        this.tags = tags;
    }

    public void buildBackendWorldsAndRunBeforeHooks(List<String> gluePaths, Reporter reporter) {
        runtime.buildBackendWorlds(gluePaths, this);
        Collections.sort(beforeHooks, new HookComparator(true));
        runHooks(beforeHooks, reporter);
    }

    public void runAfterHooksAndDisposeBackendWorlds(Reporter reporter) {
        Collections.sort(afterHooks, new HookComparator(false));
        runHooks(afterHooks, reporter);
        runtime.disposeBackendWorlds();
    }

    private void runHooks(List<HookDefinition> hooks, Reporter reporter) {
        for (HookDefinition hook : hooks) {
            runHookIfTagsMatch(hook, reporter);
        }
    }

    private void runHookIfTagsMatch(HookDefinition hook, Reporter reporter) {
        if (hook.matches(tags)) {
            long start = System.nanoTime();
            try {
                hook.execute(scenarioResult);
            } catch (Throwable t) {
                skipNextStep = true;

                long duration = System.nanoTime() - start;
                Result result = new Result(Result.FAILED, duration, t, DUMMY_ARG);
                scenarioResult.add(result);
                reporter.result(result);
            }
        }
    }

    public void runStep(String uri, Step step, Reporter reporter, Locale locale) {
        StepDefinitionMatch match = stepDefinitionMatch(uri, step, locale);
        if (match != null) {
            reporter.match(match);
        } else {
            reporter.match(Match.UNDEFINED);
            reporter.result(Result.UNDEFINED);
            skipNextStep = true;
            return;
        }

        if (runtime.isDryRun()) {
            skipNextStep = true;
        }

        if (skipNextStep) {
            scenarioResult.add(Result.SKIPPED);
            reporter.result(Result.SKIPPED);
        } else {
            String status = Result.PASSED;
            Throwable error = null;
            long start = System.nanoTime();
            try {
                match.runStep(locale);
            } catch (Throwable t) {
                error = t;
                status = Result.FAILED;
                runtime.addError(t);
                skipNextStep = true;
            } finally {
                long duration = System.nanoTime() - start;
                Result result = new Result(status, duration, error, DUMMY_ARG);
                scenarioResult.add(result);
                reporter.result(result);
            }
        }
    }

    public void runUnreportedStep(String uri, Step step, Locale locale) throws Throwable {
        StepDefinitionMatch match = stepDefinitionMatch(uri, step, locale);
        if (match == null) {
            throw new CucumberException("Calling an undefined step from " + uri);
        }

        match.runStep(locale);
    }

    private StepDefinitionMatch stepDefinitionMatch(String uri, Step step, Locale locale) {
        List<StepDefinitionMatch> matches = stepDefinitionMatches(uri, step);
        try {
            if (matches.size() == 0) {
                runtime.addUndefinedStep(step, locale);
                return null;
            }
            if (matches.size() == 1) {
                return matches.get(0);
            } else {
                throw new AmbiguousStepDefinitionsException(matches);
            }
        } finally {
            runtime.storeStepKeyword(step, locale);
        }
    }

    public void addStepDefinition(StepDefinition stepDefinition) {
        stepDefinitions.add(stepDefinition);
    }

    private List<StepDefinitionMatch> stepDefinitionMatches(String uri, Step step) {
        List<StepDefinitionMatch> result = new ArrayList<StepDefinitionMatch>();
        for (StepDefinition stepDefinition : stepDefinitions) {
            List<Argument> arguments = stepDefinition.matchedArguments(step);
            if (arguments != null) {
                result.add(new StepDefinitionMatch(arguments, stepDefinition, uri, step, localizedXStreams));
            }
        }
        return result;
    }

    public void addBeforeHook(HookDefinition hookDefinition) {
        beforeHooks.add(hookDefinition);
    }

    public void addAfterHook(HookDefinition hookDefinition) {
        afterHooks.add(hookDefinition);
    }

    public List<HookDefinition> getBeforeHooks() {
        return beforeHooks;
    }

    public List<HookDefinition> getAfterHooks() {
        return afterHooks;
    }

    public List<StepDefinition> getStepDefinitions() {
        return stepDefinitions;
    }

    private final class HookComparator implements Comparator<HookDefinition> {
        final boolean ascending;

        public HookComparator(boolean ascending) {
            this.ascending = ascending;
        }

        @Override
        public int compare(HookDefinition hook1, HookDefinition hook2) {
            int comparison = hook1.getOrder() - hook2.getOrder();
            return ascending ? comparison : -comparison;
        }
    }
||||||| BASE
    // TODO - it's expensive to create a new LocalizedXStreams for each scenario - reuse a global one.
    private final LocalizedXStreams localizedXStreams = new LocalizedXStreams();
    private final List<StepDefinition> stepDefinitions = new ArrayList<StepDefinition>();
    private final List<HookDefinition> beforeHooks = new ArrayList<HookDefinition>();
    private final List<HookDefinition> afterHooks = new ArrayList<HookDefinition>();
    private final ScenarioResultImpl scenarioResult = new ScenarioResultImpl();

    private final Runtime runtime;

    private final Collection<String> tags;

    private boolean skipNextStep = false;

    public World(Runtime runtime, Collection<String> tags) {
        this.runtime = runtime;
        this.tags = tags;
    }

    public void buildBackendWorldsAndRunBeforeHooks(List<String> gluePaths, Reporter reporter) {
        runtime.buildBackendWorlds(gluePaths, this);
        Collections.sort(beforeHooks, new HookComparator(true));
        runHooks(beforeHooks, reporter);
    }

    public void runAfterHooksAndDisposeBackendWorlds(Reporter reporter) {
        Collections.sort(afterHooks, new HookComparator(false));
        runHooks(afterHooks, reporter);
        runtime.disposeBackendWorlds();
    }

    private void runHooks(List<HookDefinition> hooks, Reporter reporter) {
        for (HookDefinition hook : hooks) {
            runHookIfTagsMatch(hook, reporter);
        }
    }

    private void runHookIfTagsMatch(HookDefinition hook, Reporter reporter) {
        if (hook.matches(tags)) {
            long start = System.nanoTime();
            try {
                hook.execute(scenarioResult);
            } catch (Throwable t) {
                skipNextStep = true;

                long duration = System.nanoTime() - start;
                Result result = new Result(Result.FAILED, duration, t, DUMMY_ARG);
                scenarioResult.add(result);
                reporter.result(result);
            }
        }
    }

    public void runStep(String uri, Step step, Reporter reporter, Locale locale) {
        StepDefinitionMatch match = stepDefinitionMatch(uri, step, locale);
        if (match != null) {
            reporter.match(match);
        } else {
            reporter.match(Match.UNDEFINED);
            reporter.result(Result.UNDEFINED);
            skipNextStep = true;
            return;
        }

        if (runtime.isDryRun()) {
            skipNextStep = true;
        }

        if (skipNextStep) {
            scenarioResult.add(Result.SKIPPED);
            reporter.result(Result.SKIPPED);
        } else {
            String status = Result.PASSED;
            Throwable error = null;
            long start = System.nanoTime();
            try {
                match.runStep(locale);
            } catch (Throwable t) {
                error = t;
                status = Result.FAILED;
                runtime.addError(t);
                skipNextStep = true;
            } finally {
                long duration = System.nanoTime() - start;
                Result result = new Result(status, duration, error, DUMMY_ARG);
                scenarioResult.add(result);
                reporter.result(result);
            }
        }
    }

    private StepDefinitionMatch stepDefinitionMatch(String uri, Step step, Locale locale) {
        List<StepDefinitionMatch> matches = stepDefinitionMatches(uri, step);
        try {
            if (matches.size() == 0) {
                runtime.addUndefinedStep(step, locale);
                return null;
            }
            if (matches.size() == 1) {
                return matches.get(0);
            } else {
                throw new AmbiguousStepDefinitionsException(matches);
            }
        } finally {
            runtime.storeStepKeyword(step, locale);
        }
    }

    public void addStepDefinition(StepDefinition stepDefinition) {
        stepDefinitions.add(stepDefinition);
    }

    private List<StepDefinitionMatch> stepDefinitionMatches(String uri, Step step) {
        List<StepDefinitionMatch> result = new ArrayList<StepDefinitionMatch>();
        for (StepDefinition stepDefinition : stepDefinitions) {
            List<Argument> arguments = stepDefinition.matchedArguments(step);
            if (arguments != null) {
                result.add(new StepDefinitionMatch(arguments, stepDefinition, uri, step, localizedXStreams));
            }
        }
        return result;
    }

    public void addBeforeHook(HookDefinition hookDefinition) {
        beforeHooks.add(hookDefinition);
    }

    public void addAfterHook(HookDefinition hookDefinition) {
        afterHooks.add(hookDefinition);
    }

    public List<HookDefinition> getBeforeHooks() {
        return beforeHooks;
    }

    public List<HookDefinition> getAfterHooks() {
        return afterHooks;
    }

    public List<StepDefinition> getStepDefinitions() {
        return stepDefinitions;
    }

    private final class HookComparator implements Comparator<HookDefinition> {
        final boolean ascending;

        public HookComparator(boolean ascending) {
            this.ascending = ascending;
        }

        @Override
        public int compare(HookDefinition hook1, HookDefinition hook2) {
            int comparison = hook1.getOrder() - hook2.getOrder();
            return ascending ? comparison : -comparison;
        }
    }
=======
    void runAfterHooksAndDisposeBackendWorlds(Reporter reporter);

    void runStep(String uri, Step step, Reporter reporter, Locale locale);

    void addStepDefinition(StepDefinition stepDefinition);

    void addBeforeHook(HookDefinition hookDefinition);

    void addAfterHook(HookDefinition hookDefinition);

    List<HookDefinition> getBeforeHooks();

    List<HookDefinition> getAfterHooks();

    List<StepDefinition> getStepDefinitions();
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_4514f91_c196d7a/rev_4514f91-c196d7a/ioke/src/main/java/cucumber/runtime/ioke/IokeStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_4514f91_c196d7a/rev_4514f91-c196d7a/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;<<<<<<< MINE
    public void runStep(String uri, Locale locale, String stepString) throws Throwable {
        Step s = new Step(Collections.<Comment>emptyList(), "Given ", stepString, 0, null, null);
        world.runUnreportedStep(uri, s, locale);
    }

||||||| BASE
=======
    public void pending(String reason) throws PendingException {
        throw new PendingException(reason);
    }

>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_df198fe_2b74d1b/rev_df198fe-2b74d1b/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;<<<<<<< MINE
import java.io.IOException;
import java.io.InputStream;
||||||| BASE
=======
import java.io.IOException;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_df198fe_2b74d1b/rev_df198fe-2b74d1b/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;<<<<<<< MINE
        //Look for a cucumber-jruby.properties file and load in the things I might care about
        Properties props = new Properties();
        InputStream propsStream = this.getClass().getResourceAsStream("/cucumber-jruby.properties");
        try {
            if (propsStream != null) {
                props.load(propsStream);
            }
        } catch (IOException e) {
            //Oh well?
        }

        String gemPath = props.getProperty("GEM_PATH");
        if (gemPath != null && !gemPath.isEmpty()) {
            jruby.runScriptlet("ENV['GEM_PATH']='" + gemPath + "'");
        }

        String rubyVersion = props.getProperty("RUBY_VERSION");
        if ("1.9".equals(rubyVersion)) {
            jruby.setCompatVersion(CompatVersion.RUBY1_9);
        }
||||||| BASE
=======
        jruby.setClassLoader(getClass().getClassLoader());
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d7255fb_4a9f204/rev_d7255fb-4a9f204/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d7255fb_4a9f204/rev_d7255fb-4a9f204/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d7255fb_4a9f204/rev_d7255fb-4a9f204/clojure/src/main/java/cucumber/runtime/clojure/ClojureStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d7255fb_4a9f204/rev_d7255fb-4a9f204/clojure/src/main/java/cucumber/runtime/clojure/ClojureStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8a45465_f711375/rev_8a45465-f711375/clojure/src/main/java/cucumber/runtime/clojure/ClojureHookDefinition.java;<<<<<<< MINE
||||||| BASE
package cucumber.runtime.clojure;

import clojure.lang.AFunction;
import cucumber.runtime.HookDefinition;
import cucumber.runtime.ScenarioResult;
import cucumber.runtime.Utils;
import gherkin.TagExpression;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;

import static java.util.Arrays.asList;

public class ClojureHookDefinition implements HookDefinition {

    private final TagExpression tagExpression;
    private final AFunction closure;

    public ClojureHookDefinition(String[] tagExpressions, AFunction closure) {
        tagExpression = new TagExpression(asList(tagExpressions));
        this.closure = closure;
    }

    // Clojure's AFunction.invokeWithArgs doesn't take varargs :-/
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        return AFunction.class.getMethod("invoke", (Class<?>[]) Utils.listOf(args.length, String.class).toArray()  );
    }

    @Override
    public void execute(ScenarioResult scenarioResult) throws Throwable {
        Object[] args = new Object[0];
        Method functionInvoke = lookupInvokeMethod(args);
        try {
            functionInvoke.invoke(closure, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    @Override
    public boolean matches(Collection<String> tags) {
        return tagExpression.eval(tags);
    }

    @Override
    public int getOrder() {
        return 0;
    }

}=======
package cucumber.runtime.clojure;

import clojure.lang.IFn;
import cucumber.runtime.HookDefinition;
import cucumber.runtime.ScenarioResult;
import cucumber.runtime.Utils;
import gherkin.TagExpression;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;

import static java.util.Arrays.asList;

public class ClojureHookDefinition implements HookDefinition {

    private final TagExpression tagExpression;
    private final IFn closure;

    public ClojureHookDefinition(String[] tagExpressions, IFn closure) {
        tagExpression = new TagExpression(asList(tagExpressions));
        this.closure = closure;
    }

    // Clojure's AFunction.invokeWithArgs doesn't take varargs :-/
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        return IFn.class.getMethod("invoke", (Class<?>[]) Utils.listOf(args.length, String.class).toArray());
    }

    @Override
    public void execute(ScenarioResult scenarioResult) throws Throwable {
        Object[] args = new Object[0];
        Method functionInvoke = lookupInvokeMethod(args);
        try {
            functionInvoke.invoke(closure, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    @Override
    public boolean matches(Collection<String> tags) {
        return tagExpression.eval(tags);
    }

    @Override
    public int getOrder() {
        return 0;
    }

}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8a45465_f711375/rev_8a45465-f711375/clojure/src/main/java/cucumber/runtime/clojure/ClojureStepDefinition.java;<<<<<<< MINE
||||||| BASE
package cucumber.runtime.clojure;

import clojure.lang.AFunction;
import cucumber.runtime.JdkPatternArgumentMatcher;
import cucumber.runtime.ParameterType;
import cucumber.runtime.StepDefinition;
import cucumber.runtime.Utils;
import gherkin.formatter.Argument;
import gherkin.formatter.model.Step;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.List;
import java.util.regex.Pattern;

public class ClojureStepDefinition implements StepDefinition {
    private final Pattern pattern;
    private final AFunction closure;
    private StackTraceElement location;

    public ClojureStepDefinition(Pattern pattern, AFunction closure, StackTraceElement location) {
        this.pattern = pattern;
        this.closure = closure;
        this.location = location;
    }

    // Clojure's AFunction.invokeWithArgs doesn't take varargs :-/
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        return AFunction.class.getMethod("invoke", (Class<?>[]) Utils.listOf(args.length, Object.class).toArray());
    }

    public List<Argument> matchedArguments(Step step) {
        return new JdkPatternArgumentMatcher(pattern).argumentsFrom(step.getName());
    }

    public String getLocation() {
        return location.getFileName() + ":" + location.getLineNumber();
    }

    public List<ParameterType> getParameterTypes() {
        return null;
    }

    public void execute(Object[] args) throws Throwable {
        Method functionInvoke = lookupInvokeMethod(args);
        try {
            functionInvoke.invoke(closure, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    public boolean isDefinedAt(StackTraceElement stackTraceElement) {
        return location.getFileName().equals(stackTraceElement.getFileName());
    }

    @Override
    public String getPattern() {
        return pattern.pattern();
    }
}=======
package cucumber.runtime.clojure;

import clojure.lang.IFn;
import cucumber.runtime.JdkPatternArgumentMatcher;
import cucumber.runtime.ParameterType;
import cucumber.runtime.StepDefinition;
import cucumber.runtime.Utils;
import gherkin.formatter.Argument;
import gherkin.formatter.model.Step;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;

public class ClojureStepDefinition implements StepDefinition {
    private final Pattern pattern;
    private final IFn closure;
    private StackTraceElement location;

    public ClojureStepDefinition(Pattern pattern, IFn closure, StackTraceElement location) {
        this.pattern = pattern;
        this.closure = closure;
        this.location = location;
    }

    // Clojure's IFn.invoke doesn't take varargs :-/
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        List<Class<Object>> classes = Utils.listOf(args.length, Object.class);
        Class<?>[] params = classes.toArray(new Class<?>[classes.size()]);
        return IFn.class.getMethod("invoke", params);
    }

    public List<Argument> matchedArguments(Step step) {
        return new JdkPatternArgumentMatcher(pattern).argumentsFrom(step.getName());
    }

    public String getLocation() {
        return location.getFileName() + ":" + location.getLineNumber();
    }

    public List<ParameterType> getParameterTypes() {
        return null;
    }

    public void execute(Locale locale, Object[] args) throws Throwable {
        Method functionInvoke = lookupInvokeMethod(args);
        try {
            functionInvoke.invoke(closure, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    public boolean isDefinedAt(StackTraceElement stackTraceElement) {
        return location.getFileName().equals(stackTraceElement.getFileName());
    }

    @Override
    public String getPattern() {
        return pattern.pattern();
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8a45465_f711375/rev_8a45465-f711375/clojure/src/main/java/cucumber/runtime/clojure/ClojureBackend.java;<<<<<<< MINE
||||||| BASE
package cucumber.runtime.clojure;

import clojure.lang.AFunction;
import clojure.lang.RT;
import cucumber.io.Resource;
import cucumber.io.ResourceLoader;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.World;
import gherkin.formatter.model.Step;

import java.io.IOException;
import java.util.List;
import java.util.regex.Pattern;

public class ClojureBackend implements Backend {
    private static ClojureBackend instance;
    private final ResourceLoader resourceLoader;
    private World world;

    public ClojureBackend(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
        instance = this;
        loadScript("cucumber/runtime/clojure/dsl");
    }

    @Override
    public void buildWorld(List<String> gluePaths, World world) {
        this.world = world;
        for (String gluePath : gluePaths) {
            for (Resource resource : resourceLoader.resources(gluePath, ".clj")) {
                loadScript(resource.getPath());
            }
        }
    }

    private void loadScript(String path) {
        try {
            RT.load(path.replaceAll(".clj$", ""), true);
        } catch (IOException e) {
            throw new CucumberException(e);
        } catch (ClassNotFoundException e) {
            throw new CucumberException(e);
        }
    }

    @Override
    public void disposeWorld() {
    }

    @Override
    public String getSnippet(Step step) {
        return new ClojureSnippetGenerator(step).getSnippet();
    }

    private StackTraceElement stepDefLocation(String interpreterClassName, String interpreterMethodName) {
        Throwable t = new Throwable();
        StackTraceElement[] stackTraceElements = t.getStackTrace();
        for (int i = 0; i < stackTraceElements.length; i++) {
            StackTraceElement element = stackTraceElements[i];
            if (element.getClassName().equals(interpreterClassName) && element.getMethodName().equals(interpreterMethodName)) {
                return stackTraceElements[i - 1];
            }
        }
        throw new CucumberException("Couldn't find location for step definition");
    }

    public static void addStepDefinition(Pattern regexp, AFunction body) {
        StackTraceElement location = instance.stepDefLocation("clojure.lang.Compiler", "eval");
        instance.world.addStepDefinition(new ClojureStepDefinition(regexp, body, location));
    }

    public static void addBeforeHook(AFunction body) {
        instance.world.addBeforeHook(new ClojureHookDefinition(new String[0], body));
    }

    public static void addAfterHook(AFunction body) {
        instance.world.addAfterHook(new ClojureHookDefinition(new String[0], body));
    }
}=======
package cucumber.runtime.clojure;

import clojure.lang.IFn;
import clojure.lang.RT;
import clojure.lang.Compiler;
import cucumber.io.Resource;
import cucumber.io.ResourceLoader;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.World;
import gherkin.formatter.model.Step;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;
import java.util.regex.Pattern;

public class ClojureBackend implements Backend {
    private static ClojureBackend instance;
    private final ResourceLoader resourceLoader;
    private World world;

    public ClojureBackend(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
        instance = this;
        loadScript("cucumber/runtime/clojure/dsl");
    }

    @Override
    public void buildWorld(List<String> gluePaths, World world) {
        this.world = world;
        for (String gluePath : gluePaths) {
            for (Resource resource : resourceLoader.resources(gluePath, ".clj")) {
                loadScript(resource);
            }
        }
    }

    private void loadScript(String path) {
        try {
            RT.load(path.replaceAll(".clj$", ""), true);
        } catch (IOException e) {
            throw new CucumberException(e);
        } catch (ClassNotFoundException e) {
            throw new CucumberException(e);
        }
    }

    private void loadScript(Resource resource) {
        try {
            Compiler.load(new InputStreamReader(resource.getInputStream(), "UTF-8"), resource.getPath(), resource.getPath());
        } catch (IOException e) {
            throw new CucumberException(e);
        }
    }

    @Override
    public void disposeWorld() {
    }

    @Override
    public String getSnippet(Step step) {
        return new ClojureSnippetGenerator(step).getSnippet();
    }

    private StackTraceElement stepDefLocation(String interpreterClassName, String interpreterMethodName) {
        Throwable t = new Throwable();
        StackTraceElement[] stackTraceElements = t.getStackTrace();
        for (int i = 0; i < stackTraceElements.length; i++) {
            StackTraceElement element = stackTraceElements[i];
            if (element.getClassName().equals(interpreterClassName) && element.getMethodName().equals(interpreterMethodName)) {
                return stackTraceElements[i - 1];
            }
        }
        throw new CucumberException("Couldn't find location for step definition");
    }

    public static void addStepDefinition(Pattern regexp, IFn body) {
        StackTraceElement location = instance.stepDefLocation("clojure.lang.Compiler", "eval");
        instance.world.addStepDefinition(new ClojureStepDefinition(regexp, body, location));
    }

    public static void addBeforeHook(IFn body) {
        instance.world.addBeforeHook(new ClojureHookDefinition(new String[0], body));
    }

    public static void addAfterHook(IFn body) {
        instance.world.addAfterHook(new ClojureHookDefinition(new String[0], body));
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8a45465_f711375/rev_8a45465-f711375/clojure/src/main/java/cucumber/runtime/clojure/ClojureHook.java;<<<<<<< MINE
||||||| BASE
package cucumber.runtime.clojure;

import clojure.lang.AFunction;

import java.util.List;

public class ClojureHook {
    private final AFunction closure;

    public ClojureHook(List<String> tagExpressions, AFunction closure) {
        //super(tagExpressions);
        this.closure = closure;
    }

    public void invoke(String location, Object scenario) throws Throwable {
        closure.call();
    }
}=======
package cucumber.runtime.clojure;

import clojure.lang.IFn;

import java.util.List;

public class ClojureHook {
    private final IFn closure;

    public ClojureHook(List<String> tagExpressions, IFn closure) {
        //super(tagExpressions);
        this.closure = closure;
    }

    public void invoke(String location, Object scenario) throws Throwable {
        closure.call();
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b0f48d2_321c656/rev_b0f48d2-321c656/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b0f48d2_321c656/rev_b0f48d2-321c656/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b0f48d2_321c656/rev_b0f48d2-321c656/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b0f48d2_321c656/rev_b0f48d2-321c656/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b57da8b_8c8dc21/rev_b57da8b-8c8dc21/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b57da8b_8c8dc21/rev_b57da8b-8c8dc21/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b57da8b_8c8dc21/rev_b57da8b-8c8dc21/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b57da8b_8c8dc21/rev_b57da8b-8c8dc21/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b57da8b_8c8dc21/rev_b57da8b-8c8dc21/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b57da8b_8c8dc21/rev_b57da8b-8c8dc21/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b57da8b_8c8dc21/rev_b57da8b-8c8dc21/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b57da8b_8c8dc21/rev_b57da8b-8c8dc21/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_ad7c641_d8c6b73/rev_ad7c641-d8c6b73/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;<<<<<<< MINE
import cucumber.table.DataTable;
import gherkin.formatter.model.DataTableRow;
import gherkin.formatter.model.DocString;
||||||| BASE
import gherkin.formatter.model.Comment;
=======
import cucumber.runtime.snippets.SnippetGenerator;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_ad7c641_d8c6b73/rev_ad7c641-d8c6b73/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;<<<<<<< MINE
import java.util.*;
||||||| BASE
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
=======
import java.util.List;
import java.util.Locale;
import java.util.Properties;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberFeature.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberTagStatement.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberTagStatement.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberScenario.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberScenario.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberScenario.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberScenario.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberScenario.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberScenarioOutline.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberScenarioOutline.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/model/CucumberScenarioOutline.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/World.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/World.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/World.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/World.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/RuntimeWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/cli/Main.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/cli/Main.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/main/java/cucumber/io/OneTimeResourceLoader.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookOrderTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookOrderTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookOrderTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookOrderTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/core/src/test/java/cucumber/runtime/HookOrderTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaHookTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionDependencyInjectionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionDependencyInjectionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/java/src/test/java/cucumber/runtime/java/JavaBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/FeatureRunner.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/ExamplesRunner.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/ExecutionUnitRunner.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/ExecutionUnitRunner.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/ExecutionUnitRunner.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/ExecutionUnitRunner.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/ExecutionUnitRunner.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/Cucumber.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/Cucumber.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7eaa16a_547331e/rev_7eaa16a-547331e/junit/src/main/java/cucumber/junit/ScenarioOutlineRunner.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_dc738bc_e15f6ea/rev_dc738bc-e15f6ea/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_beb39a9_6c0dccd/rev_beb39a9-6c0dccd/core/src/main/java/cucumber/runtime/World.java;<<<<<<< MINE
package cucumber.runtime;

import gherkin.formatter.Reporter;
import gherkin.formatter.model.DataTableRow;
import gherkin.formatter.model.DocString;
import gherkin.formatter.model.Step;
import java.util.Locale;
import java.util.List;


public interface World {
    void buildBackendWorldsAndRunBeforeHooks(Reporter reporter);

    void runAfterHooksAndDisposeBackendWorlds(Reporter reporter);

    void runStep(String uri, Step step, Reporter reporter, Locale locale);

    void runUnreportedStep(String file, Locale locale, String stepKeyword, String stepName, int line, List<DataTableRow> dataTableRows, DocString docString) throws Throwable;

    void addStepDefinition(StepDefinition stepDefinition);

    void addBeforeHook(HookDefinition hookDefinition);

    void addAfterHook(HookDefinition hookDefinition);

    List<HookDefinition> getBeforeHooks();

    List<HookDefinition> getAfterHooks();

    List<StepDefinition> getStepDefinitions();

}||||||| BASE
package cucumber.runtime;

import gherkin.formatter.Reporter;
import gherkin.formatter.model.Step;
import java.util.Locale;
import java.util.List;


public interface World {
    void buildBackendWorldsAndRunBeforeHooks(Reporter reporter);

    void runAfterHooksAndDisposeBackendWorlds(Reporter reporter);

    void runStep(String uri, Step step, Reporter reporter, Locale locale);

    void runUnreportedStep(String file, Locale locale, String stepKeyword, String stepName, int line) throws Throwable;

    void addStepDefinition(StepDefinition stepDefinition);

    void addBeforeHook(HookDefinition hookDefinition);

    void addAfterHook(HookDefinition hookDefinition);

    List<HookDefinition> getBeforeHooks();

    List<HookDefinition> getAfterHooks();

    List<StepDefinition> getStepDefinitions();

}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_beb39a9_6c0dccd/rev_beb39a9-6c0dccd/core/src/main/java/cucumber/runtime/RuntimeWorld.java;<<<<<<< MINE
package cucumber.runtime;

import cucumber.runtime.converters.LocalizedXStreams;
import gherkin.formatter.Argument;
import gherkin.formatter.Reporter;
import gherkin.formatter.model.*;

import java.util.*;

public class RuntimeWorld implements World {
    private static final Object DUMMY_ARG = new Object();

    // TODO - it's expensive to create a new LocalizedXStreams for each scenario - reuse a global one.
    private final LocalizedXStreams localizedXStreams = new LocalizedXStreams();
    private final List<StepDefinition> stepDefinitions = new ArrayList<StepDefinition>();
    private final List<HookDefinition> beforeHooks = new ArrayList<HookDefinition>();
    private final List<HookDefinition> afterHooks = new ArrayList<HookDefinition>();
    private final ScenarioResultImpl scenarioResult = new ScenarioResultImpl();

    private final Runtime runtime;

    private final Collection<String> tags;

    private boolean skipNextStep = false;

    public RuntimeWorld(Runtime runtime, Collection<String> tags) {
        this.runtime = runtime;
        this.tags = tags;
    }

    @Override
    public void buildBackendWorldsAndRunBeforeHooks(Reporter reporter) {
        runtime.buildBackendWorlds(this);
        Collections.sort(beforeHooks, new HookComparator(true));
        runHooks(beforeHooks, reporter);
    }

    @Override
    public void runAfterHooksAndDisposeBackendWorlds(Reporter reporter) {
        Collections.sort(afterHooks, new HookComparator(false));
        runHooks(afterHooks, reporter);
        runtime.disposeBackendWorlds();
    }

    @Override
    public void runUnreportedStep(String uri, Locale locale, String stepKeyword, String stepName, int line, List<DataTableRow> dataTableRows, DocString docString) throws Throwable {
        Step step = new Step(Collections.<Comment>emptyList(), stepKeyword, stepName, line, dataTableRows, docString);

        StepDefinitionMatch match = stepDefinitionMatch(uri, step, locale);
        if (match == null) {
            UndefinedStepException error = new UndefinedStepException(step);

            StackTraceElement[] originalTrace = error.getStackTrace();
            StackTraceElement[] newTrace = new StackTraceElement[originalTrace.length + 1];
            newTrace[0] = new StackTraceElement("â½", "StepDefinition", uri, line);
            System.arraycopy(originalTrace, 0, newTrace, 1, originalTrace.length);
            error.setStackTrace(newTrace);

            throw error;
        }
        match.runStep(locale);
    }

    private void runHooks(List<HookDefinition> hooks, Reporter reporter) {
        for (HookDefinition hook : hooks) {
            runHookIfTagsMatch(hook, reporter);
        }
    }

    private void runHookIfTagsMatch(HookDefinition hook, Reporter reporter) {
        if (hook.matches(tags)) {
            long start = System.nanoTime();
            try {
                hook.execute(scenarioResult);
            } catch (Throwable t) {
                skipNextStep = true;

                long duration = System.nanoTime() - start;
                Result result = new Result(Result.FAILED, duration, t, DUMMY_ARG);
                scenarioResult.add(result);
                reporter.result(result);
            }
        }
    }

    @Override
    public void runStep(String uri, Step step, Reporter reporter, Locale locale) {
        StepDefinitionMatch match = stepDefinitionMatch(uri, step, locale);
        if (match != null) {
            reporter.match(match);
        } else {
            reporter.match(Match.UNDEFINED);
            reporter.result(Result.UNDEFINED);
            skipNextStep = true;
            return;
        }

        if (runtime.isDryRun()) {
            skipNextStep = true;
        }

        if (skipNextStep) {
            scenarioResult.add(Result.SKIPPED);
            reporter.result(Result.SKIPPED);
        } else {
            String status = Result.PASSED;
            Throwable error = null;
            long start = System.nanoTime();
            try {
                match.runStep(locale);
            } catch (Throwable t) {
                error = t;
                status = Result.FAILED;
                runtime.addError(t);
                skipNextStep = true;
            } finally {
                long duration = System.nanoTime() - start;
                Result result = new Result(status, duration, error, DUMMY_ARG);
                scenarioResult.add(result);
                reporter.result(result);
            }
        }
    }

    private StepDefinitionMatch stepDefinitionMatch(String uri, Step step, Locale locale) {
        List<StepDefinitionMatch> matches = stepDefinitionMatches(uri, step);
        try {
            if (matches.size() == 0) {
                runtime.addUndefinedStep(step, locale);
                return null;
            }
            if (matches.size() == 1) {
                return matches.get(0);
            } else {
                throw new AmbiguousStepDefinitionsException(matches);
            }
        } finally {
            runtime.storeStepKeyword(step, locale);
        }
    }

    @Override
    public void addStepDefinition(StepDefinition stepDefinition) {
        stepDefinitions.add(stepDefinition);
    }

    private List<StepDefinitionMatch> stepDefinitionMatches(String uri, Step step) {
        List<StepDefinitionMatch> result = new ArrayList<StepDefinitionMatch>();
        for (StepDefinition stepDefinition : stepDefinitions) {
            List<Argument> arguments = stepDefinition.matchedArguments(step);
            if (arguments != null) {
                result.add(new StepDefinitionMatch(arguments, stepDefinition, uri, step, localizedXStreams));
            }
        }
        return result;
    }

    @Override
    public void addBeforeHook(HookDefinition hookDefinition) {
        beforeHooks.add(hookDefinition);
    }

    @Override
    public void addAfterHook(HookDefinition hookDefinition) {
        afterHooks.add(hookDefinition);
    }

    @Override
    public List<HookDefinition> getBeforeHooks() {
        return beforeHooks;
    }

    @Override
    public List<HookDefinition> getAfterHooks() {
        return afterHooks;
    }

    @Override
    public List<StepDefinition> getStepDefinitions() {
        return stepDefinitions;
    }

    private final class HookComparator implements Comparator<HookDefinition> {
        final boolean ascending;

        public HookComparator(boolean ascending) {
            this.ascending = ascending;
        }

        @Override
        public int compare(HookDefinition hook1, HookDefinition hook2) {
            int comparison = hook1.getOrder() - hook2.getOrder();
            return ascending ? comparison : -comparison;
        }
    }
}||||||| BASE
package cucumber.runtime;

import cucumber.runtime.converters.LocalizedXStreams;
import gherkin.formatter.Argument;
import gherkin.formatter.Reporter;
import gherkin.formatter.model.Comment;
import gherkin.formatter.model.Match;
import gherkin.formatter.model.Result;
import gherkin.formatter.model.Step;

import java.util.*;

public class RuntimeWorld implements World {
    private static final Object DUMMY_ARG = new Object();

    // TODO - it's expensive to create a new LocalizedXStreams for each scenario - reuse a global one.
    private final LocalizedXStreams localizedXStreams = new LocalizedXStreams();
    private final List<StepDefinition> stepDefinitions = new ArrayList<StepDefinition>();
    private final List<HookDefinition> beforeHooks = new ArrayList<HookDefinition>();
    private final List<HookDefinition> afterHooks = new ArrayList<HookDefinition>();
    private final ScenarioResultImpl scenarioResult = new ScenarioResultImpl();

    private final Runtime runtime;

    private final Collection<String> tags;

    private boolean skipNextStep = false;

    public RuntimeWorld(Runtime runtime, Collection<String> tags) {
        this.runtime = runtime;
        this.tags = tags;
    }

    @Override
    public void buildBackendWorldsAndRunBeforeHooks(Reporter reporter) {
        runtime.buildBackendWorlds(this);
        Collections.sort(beforeHooks, new HookComparator(true));
        runHooks(beforeHooks, reporter);
    }

    @Override
    public void runAfterHooksAndDisposeBackendWorlds(Reporter reporter) {
        Collections.sort(afterHooks, new HookComparator(false));
        runHooks(afterHooks, reporter);
        runtime.disposeBackendWorlds();
    }

    @Override
    public void runUnreportedStep(String uri, Locale locale, String stepKeyword, String stepName, int line) throws Throwable {
        Step step = new Step(Collections.<Comment>emptyList(), stepKeyword, stepName, line, null, null);

        StepDefinitionMatch match = stepDefinitionMatch(uri, step, locale);
        if (match == null) {
            UndefinedStepException error = new UndefinedStepException(step);

            StackTraceElement[] originalTrace = error.getStackTrace();
            StackTraceElement[] newTrace = new StackTraceElement[originalTrace.length + 1];
            newTrace[0] = new StackTraceElement("â½", "StepDefinition", uri, line);
            System.arraycopy(originalTrace, 0, newTrace, 1, originalTrace.length);
            error.setStackTrace(newTrace);

            throw error;
        }
        match.runStep(locale);
    }

    private void runHooks(List<HookDefinition> hooks, Reporter reporter) {
        for (HookDefinition hook : hooks) {
            runHookIfTagsMatch(hook, reporter);
        }
    }

    private void runHookIfTagsMatch(HookDefinition hook, Reporter reporter) {
        if (hook.matches(tags)) {
            long start = System.nanoTime();
            try {
                hook.execute(scenarioResult);
            } catch (Throwable t) {
                skipNextStep = true;

                long duration = System.nanoTime() - start;
                Result result = new Result(Result.FAILED, duration, t, DUMMY_ARG);
                scenarioResult.add(result);
                reporter.result(result);
            }
        }
    }

    @Override
    public void runStep(String uri, Step step, Reporter reporter, Locale locale) {
        StepDefinitionMatch match = stepDefinitionMatch(uri, step, locale);
        if (match != null) {
            reporter.match(match);
        } else {
            reporter.match(Match.UNDEFINED);
            reporter.result(Result.UNDEFINED);
            skipNextStep = true;
            return;
        }

        if (runtime.isDryRun()) {
            skipNextStep = true;
        }

        if (skipNextStep) {
            scenarioResult.add(Result.SKIPPED);
            reporter.result(Result.SKIPPED);
        } else {
            String status = Result.PASSED;
            Throwable error = null;
            long start = System.nanoTime();
            try {
                match.runStep(locale);
            } catch (Throwable t) {
                error = t;
                status = Result.FAILED;
                runtime.addError(t);
                skipNextStep = true;
            } finally {
                long duration = System.nanoTime() - start;
                Result result = new Result(status, duration, error, DUMMY_ARG);
                scenarioResult.add(result);
                reporter.result(result);
            }
        }
    }

    private StepDefinitionMatch stepDefinitionMatch(String uri, Step step, Locale locale) {
        List<StepDefinitionMatch> matches = stepDefinitionMatches(uri, step);
        try {
            if (matches.size() == 0) {
                runtime.addUndefinedStep(step, locale);
                return null;
            }
            if (matches.size() == 1) {
                return matches.get(0);
            } else {
                throw new AmbiguousStepDefinitionsException(matches);
            }
        } finally {
            runtime.storeStepKeyword(step, locale);
        }
    }

    @Override
    public void addStepDefinition(StepDefinition stepDefinition) {
        stepDefinitions.add(stepDefinition);
    }

    private List<StepDefinitionMatch> stepDefinitionMatches(String uri, Step step) {
        List<StepDefinitionMatch> result = new ArrayList<StepDefinitionMatch>();
        for (StepDefinition stepDefinition : stepDefinitions) {
            List<Argument> arguments = stepDefinition.matchedArguments(step);
            if (arguments != null) {
                result.add(new StepDefinitionMatch(arguments, stepDefinition, uri, step, localizedXStreams));
            }
        }
        return result;
    }

    @Override
    public void addBeforeHook(HookDefinition hookDefinition) {
        beforeHooks.add(hookDefinition);
    }

    @Override
    public void addAfterHook(HookDefinition hookDefinition) {
        afterHooks.add(hookDefinition);
    }

    @Override
    public List<HookDefinition> getBeforeHooks() {
        return beforeHooks;
    }

    @Override
    public List<HookDefinition> getAfterHooks() {
        return afterHooks;
    }

    @Override
    public List<StepDefinition> getStepDefinitions() {
        return stepDefinitions;
    }

    private final class HookComparator implements Comparator<HookDefinition> {
        final boolean ascending;

        public HookComparator(boolean ascending) {
            this.ascending = ascending;
        }

        @Override
        public int compare(HookDefinition hook1, HookDefinition hook2) {
            int comparison = hook1.getOrder() - hook2.getOrder();
            return ascending ? comparison : -comparison;
        }
    }
}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_beb39a9_6c0dccd/rev_beb39a9-6c0dccd/jruby/src/main/java/cucumber/runtime/jruby/JRubyBackend.java;<<<<<<< MINE
    public void runStep(String uri, Locale locale, String stepKeyword, String stepName, int line, DataTable dataTable, DocString docString) throws Throwable {
        List<DataTableRow> dataTableRows = null;
        if (dataTable != null) {
            dataTableRows = dataTable.getGherkinRows();
        }

        world.runUnreportedStep(uri, locale, stepKeyword, stepName, line, dataTableRows, docString);
||||||| BASE
    public void runStep(String uri, Locale locale, String stepKeyword, String stepName, int line) throws Throwable {
        world.runUnreportedStep(uri, locale, stepKeyword, stepName, line);
=======
    public void runStep(String uri, Locale locale, String stepKeyword, String stepName, int line) throws Throwable {
        //TODO: need a way to request running of an additional step!
        unreportedStepExecutor.runUnreportedStep(uri, locale, stepKeyword, stepName, line);
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_beb39a9_6c0dccd/rev_beb39a9-6c0dccd/java/src/test/java/cucumber/runtime/java/JavaBackendTest.java;<<<<<<< MINE
import gherkin.formatter.Reporter;
import gherkin.formatter.model.DataTableRow;
import gherkin.formatter.model.DocString;
import gherkin.formatter.model.Step;
||||||| BASE
import gherkin.formatter.Reporter;
import gherkin.formatter.model.Step;
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_beb39a9_6c0dccd/rev_beb39a9-6c0dccd/java/src/test/java/cucumber/runtime/java/JavaBackendTest.java;<<<<<<< MINE
        public void buildBackendWorldsAndRunBeforeHooks(Reporter reporter) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void runAfterHooksAndDisposeBackendWorlds(Reporter reporter) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void runStep(String uri, Step step, Reporter reporter, Locale locale) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void runUnreportedStep(String file, Locale locale, String stepKeyword, String stepName, int line, List<DataTableRow> dataTableRows, DocString docString) throws Throwable {
            throw new UnsupportedOperationException();
        }

        @Override
||||||| BASE
        public void buildBackendWorldsAndRunBeforeHooks(Reporter reporter) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void runAfterHooksAndDisposeBackendWorlds(Reporter reporter) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void runStep(String uri, Step step, Reporter reporter, Locale locale) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void runUnreportedStep(String file, Locale locale, String stepKeyword, String stepName, int line) throws Throwable {
            throw new UnsupportedOperationException();
        }

        @Override
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_af2ad8b_9ed4fb0/rev_af2ad8b-9ed4fb0/java/src/test/java/cucumber/runtime/java/JavaBackendTest.java;<<<<<<< MINE
import gherkin.formatter.model.DataTableRow;
import gherkin.formatter.model.DocString;
||||||| BASE
=======
import gherkin.formatter.model.Step;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_34484c4_b25faf5/rev_34484c4-b25faf5/core/src/main/java/cucumber/runtime/UndefinedStepsTracker.java;<<<<<<< MINE
    private boolean isGivenWhenThenKeyword(String keyword, I18n i18n) {
||||||| BASE
    private boolean isGivenWhenThenKeyword(String keyword, Locale locale) {
        I18n i18n = new I18n("en");
=======
    private boolean isGivenWhenThenKeyword(String keyword, Locale locale) {
        I18n i18n = new I18n(toIsoCode(locale));
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_393837b_d4ffedd/rev_393837b-d4ffedd/clojure/src/main/java/cucumber/runtime/clojure/ClojureHookDefinition.java;<<<<<<< MINE
package cucumber.runtime.clojure;

import clojure.lang.IFn;
import cucumber.runtime.HookDefinition;
import cucumber.runtime.ScenarioResult;
import cucumber.runtime.Utils;
import gherkin.TagExpression;
import gherkin.formatter.model.Tag;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.List;

import static java.util.Arrays.asList;

public class ClojureHookDefinition implements HookDefinition {

    private final TagExpression tagExpression;
    private final IFn closure;

    public ClojureHookDefinition(String[] tagExpressions, IFn closure) {
        tagExpression = new TagExpression(asList(tagExpressions));
        this.closure = closure;
    }

    // Clojure's AFunction.invokeWithArgs doesn't take varargs :-/
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        List<Class<Object>> classes = Utils.listOf(args.length, Object.class);
        Class<?>[] params = classes.toArray(new Class<?>[classes.size()]);
        return IFn.class.getMethod("invoke", params);
    }

    @Override
    public void execute(ScenarioResult scenarioResult) throws Throwable {
        Object[] args = new Object[0];
        Method functionInvoke = lookupInvokeMethod(args);
        try {
            functionInvoke.invoke(closure, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    @Override
    public boolean matches(Collection<Tag> tags) {
        return tagExpression.eval(tags);
    }

    @Override
    public int getOrder() {
        return 0;
    }

}||||||| BASE
package cucumber.runtime.clojure;

import clojure.lang.IFn;
import cucumber.runtime.HookDefinition;
import cucumber.runtime.ScenarioResult;
import cucumber.runtime.Utils;
import gherkin.TagExpression;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;

import static java.util.Arrays.asList;

public class ClojureHookDefinition implements HookDefinition {

    private final TagExpression tagExpression;
    private final IFn closure;

    public ClojureHookDefinition(String[] tagExpressions, IFn closure) {
        tagExpression = new TagExpression(asList(tagExpressions));
        this.closure = closure;
    }

    // Clojure's AFunction.invokeWithArgs doesn't take varargs :-/
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        return IFn.class.getMethod("invoke", (Class<?>[]) Utils.listOf(args.length, String.class).toArray());
    }

    @Override
    public void execute(ScenarioResult scenarioResult) throws Throwable {
        Object[] args = new Object[0];
        Method functionInvoke = lookupInvokeMethod(args);
        try {
            functionInvoke.invoke(closure, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    @Override
    public boolean matches(Collection<String> tags) {
        return tagExpression.eval(tags);
    }

    @Override
    public int getOrder() {
        return 0;
    }

}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_393837b_d4ffedd/rev_393837b-d4ffedd/clojure/src/main/java/cucumber/runtime/clojure/ClojureStepDefinition.java;<<<<<<< MINE
package cucumber.runtime.clojure;

import clojure.lang.IFn;
import cucumber.runtime.JdkPatternArgumentMatcher;
import cucumber.runtime.ParameterType;
import cucumber.runtime.StepDefinition;
import cucumber.runtime.Utils;
import gherkin.I18n;
import gherkin.formatter.Argument;
import gherkin.formatter.model.Step;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import java.util.regex.Pattern;

public class ClojureStepDefinition implements StepDefinition {
    private final Pattern pattern;
    private final IFn closure;
    private StackTraceElement location;

    public ClojureStepDefinition(Pattern pattern, IFn closure, StackTraceElement location) {
        this.pattern = pattern;
        this.closure = closure;
        this.location = location;
    }

    // Clojure's IFn.invoke doesn't take varargs :-/
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        List<Class<Object>> classes = Utils.listOf(args.length, Object.class);
        Class<?>[] params = classes.toArray(new Class<?>[classes.size()]);
        return IFn.class.getMethod("invoke", params);
    }

    public List<Argument> matchedArguments(Step step) {
        return new JdkPatternArgumentMatcher(pattern).argumentsFrom(step.getName());
    }

    public String getLocation() {
        return location.getFileName() + ":" + location.getLineNumber();
    }

    public List<ParameterType> getParameterTypes() {
        return null;
    }

    public void execute(I18n i18n, Object[] args) throws Throwable {
        Method functionInvoke = lookupInvokeMethod(args);
        try {
            functionInvoke.invoke(closure, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    public boolean isDefinedAt(StackTraceElement stackTraceElement) {
        return location.getFileName().equals(stackTraceElement.getFileName());
    }

    @Override
    public String getPattern() {
        return pattern.pattern();
    }
}||||||| BASE
package cucumber.runtime.clojure;

import clojure.lang.IFn;
import cucumber.runtime.JdkPatternArgumentMatcher;
import cucumber.runtime.ParameterType;
import cucumber.runtime.StepDefinition;
import cucumber.runtime.Utils;
import gherkin.formatter.Argument;
import gherkin.formatter.model.Step;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;

public class ClojureStepDefinition implements StepDefinition {
    private final Pattern pattern;
    private final IFn closure;
    private StackTraceElement location;

    public ClojureStepDefinition(Pattern pattern, IFn closure, StackTraceElement location) {
        this.pattern = pattern;
        this.closure = closure;
        this.location = location;
    }

    // Clojure's IFn.invoke doesn't take varargs :-/
    private Method lookupInvokeMethod(Object[] args) throws NoSuchMethodException {
        List<Class<Object>> classes = Utils.listOf(args.length, Object.class);
        Class<?>[] params = classes.toArray(new Class<?>[classes.size()]);
        return IFn.class.getMethod("invoke", params);
    }

    public List<Argument> matchedArguments(Step step) {
        return new JdkPatternArgumentMatcher(pattern).argumentsFrom(step.getName());
    }

    public String getLocation() {
        return location.getFileName() + ":" + location.getLineNumber();
    }

    public List<ParameterType> getParameterTypes() {
        return null;
    }

    public void execute(Locale locale, Object[] args) throws Throwable {
        Method functionInvoke = lookupInvokeMethod(args);
        try {
            functionInvoke.invoke(closure, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    public boolean isDefinedAt(StackTraceElement stackTraceElement) {
        return location.getFileName().equals(stackTraceElement.getFileName());
    }

    @Override
    public String getPattern() {
        return pattern.pattern();
    }
}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_393837b_d4ffedd/rev_393837b-d4ffedd/clojure/src/main/java/cucumber/runtime/clojure/ClojureBackend.java;<<<<<<< MINE
package cucumber.runtime.clojure;

import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.RT;
import cucumber.io.Resource;
import cucumber.io.ResourceLoader;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.Glue;
import cucumber.runtime.UnreportedStepExecutor;
import cucumber.runtime.snippets.SnippetGenerator;
import gherkin.formatter.model.Step;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;
import java.util.regex.Pattern;

public class ClojureBackend implements Backend {
    private static ClojureBackend instance;
    private final SnippetGenerator snippetGenerator = new SnippetGenerator(new ClojureSnippet());
    private final ResourceLoader resourceLoader;
    private Glue glue;

    public ClojureBackend(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
        instance = this;
        loadScript("cucumber/runtime/clojure/dsl");
    }

    @Override
    public void loadGlue(Glue glue, List<String> gluePaths) {
        this.glue = glue;
        for (String gluePath : gluePaths) {
            for (Resource resource : resourceLoader.resources(gluePath, ".clj")) {
                loadScript(resource);
            }
        }

    }

    @Override
    public void setUnreportedStepExecutor(UnreportedStepExecutor executor) {
        //Not used yet
    }

    @Override
    public void buildWorld() {
    }

    private void loadScript(String path) {
        try {
            RT.load(path.replaceAll(".clj$", ""), true);
        } catch (IOException e) {
            throw new CucumberException(e);
        } catch (ClassNotFoundException e) {
            throw new CucumberException(e);
        }
    }

    private void loadScript(Resource resource) {
        try {
            Compiler.load(new InputStreamReader(resource.getInputStream(), "UTF-8"), resource.getPath(), resource.getPath());
        } catch (IOException e) {
            throw new CucumberException(e);
        }
    }

    @Override
    public void disposeWorld() {
    }

    @Override
    public String getSnippet(Step step) {
        return snippetGenerator.getSnippet(step);
    }

    private StackTraceElement stepDefLocation(String interpreterClassName, String interpreterMethodName) {
        Throwable t = new Throwable();
        StackTraceElement[] stackTraceElements = t.getStackTrace();
        for (int i = 0; i < stackTraceElements.length; i++) {
            StackTraceElement element = stackTraceElements[i];
            if (element.getClassName().equals(interpreterClassName) && element.getMethodName().equals(interpreterMethodName)) {
                return stackTraceElements[i - 1];
            }
        }
        throw new CucumberException("Couldn't find location for step definition");
    }

    public static void addStepDefinition(Pattern regexp, IFn body) {
        StackTraceElement location = instance.stepDefLocation("clojure.lang.Compiler", "eval");
        instance.glue.addStepDefinition(new ClojureStepDefinition(regexp, body, location));
    }

    public static void addBeforeHook(IFn body) {
        instance.glue.addBeforeHook(new ClojureHookDefinition(new String[0], body));
    }

    public static void addAfterHook(IFn body) {
        instance.glue.addAfterHook(new ClojureHookDefinition(new String[0], body));
    }
}||||||| BASE
package cucumber.runtime.clojure;

import clojure.lang.IFn;
import clojure.lang.RT;
import clojure.lang.Compiler;
import cucumber.io.Resource;
import cucumber.io.ResourceLoader;
import cucumber.runtime.Backend;
import cucumber.runtime.CucumberException;
import cucumber.runtime.World;
import gherkin.formatter.model.Step;

import java.io.IOException;
import java.io.InputStreamReader;
import java.util.List;
import java.util.regex.Pattern;

public class ClojureBackend implements Backend {
    private static ClojureBackend instance;
    private final ResourceLoader resourceLoader;
    private World world;

    public ClojureBackend(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
        instance = this;
        loadScript("cucumber/runtime/clojure/dsl");
    }

    @Override
    public void buildWorld(List<String> gluePaths, World world) {
        this.world = world;
        for (String gluePath : gluePaths) {
            for (Resource resource : resourceLoader.resources(gluePath, ".clj")) {
                loadScript(resource);
            }
        }
    }

    private void loadScript(String path) {
        try {
            RT.load(path.replaceAll(".clj$", ""), true);
        } catch (IOException e) {
            throw new CucumberException(e);
        } catch (ClassNotFoundException e) {
            throw new CucumberException(e);
        }
    }

    private void loadScript(Resource resource) {
        try {
            Compiler.load(new InputStreamReader(resource.getInputStream(), "UTF-8"), resource.getPath(), resource.getPath());
        } catch (IOException e) {
            throw new CucumberException(e);
        }
    }

    @Override
    public void disposeWorld() {
    }

    @Override
    public String getSnippet(Step step) {
        return new ClojureSnippetGenerator(step).getSnippet();
    }

    private StackTraceElement stepDefLocation(String interpreterClassName, String interpreterMethodName) {
        Throwable t = new Throwable();
        StackTraceElement[] stackTraceElements = t.getStackTrace();
        for (int i = 0; i < stackTraceElements.length; i++) {
            StackTraceElement element = stackTraceElements[i];
            if (element.getClassName().equals(interpreterClassName) && element.getMethodName().equals(interpreterMethodName)) {
                return stackTraceElements[i - 1];
            }
        }
        throw new CucumberException("Couldn't find location for step definition");
    }

    public static void addStepDefinition(Pattern regexp, IFn body) {
        StackTraceElement location = instance.stepDefLocation("clojure.lang.Compiler", "eval");
        instance.world.addStepDefinition(new ClojureStepDefinition(regexp, body, location));
    }

    public static void addBeforeHook(IFn body) {
        instance.world.addBeforeHook(new ClojureHookDefinition(new String[0], body));
    }

    public static void addAfterHook(IFn body) {
        instance.world.addAfterHook(new ClojureHookDefinition(new String[0], body));
    }
}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_393837b_d4ffedd/rev_393837b-d4ffedd/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;<<<<<<< MINE
            TimeConverter timeConverter = null;
||||||| BASE
=======

>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_393837b_d4ffedd/rev_393837b-d4ffedd/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;<<<<<<< MINE
            try {
                result[n] = converter.fromString(a.getVal());
            } finally {
                if (timeConverter != null) {
                    timeConverter.removeOnlyFormat();
                }
            }
||||||| BASE
            result[n] = converter.fromString(a.getVal());
=======
            result[n] = converter.fromString(a.getVal());
            } else {
                result[n] = a.getVal();
            }
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d623c28_2a400fe/rev_d623c28-2a400fe/examples/java-helloworld/src/test/java/cucumber/examples/java/helloworld/RunCukesTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a865428_dcec2a1/rev_a865428-dcec2a1/core/src/main/java/cucumber/formatter/FormatterFactory.java;<<<<<<< MINE
package cucumber.formatter;

import cucumber.formatter.usage.AverageUsageStatisticStrategy;
import cucumber.formatter.usage.MedianUsageStatisticStrategy;
import cucumber.runtime.CucumberException;
import gherkin.formatter.Formatter;
import gherkin.formatter.JSONFormatter;
import gherkin.formatter.JSONPrettyFormatter;
import gherkin.formatter.PrettyFormatter;

import java.io.File;
import java.io.FileWriter;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;

public class FormatterFactory {

    private final ClassLoader classLoader;

    private static final Map<String, String> BUILTIN_FORMATTERS = new HashMap<String, String>() {{
        put("progress", ProgressFormatter.class.getName());
        put("html", HTMLFormatter.class.getName());
        put("json", JSONFormatter.class.getName());
        put("json-pretty", JSONPrettyFormatter.class.getName());
        put("pretty", PrettyFormatter.class.getName());
        put("usage", UsageFormatter.class.getName());
    }};

    public FormatterFactory(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }

    public Formatter createFormatter(String formatterName, Object out) {
        String className = BUILTIN_FORMATTERS.containsKey(formatterName) ? BUILTIN_FORMATTERS.get(formatterName) : formatterName;
        return createFormatterFromClassName(className, out);
    }

    private Formatter createFormatterFromClassName(String className, Object out) {
        try {
            Class ctorArgClass = Appendable.class;
            if (out instanceof File) {
                File file = (File) out;
                if (file.isDirectory()) {
                    out = file;
                    ctorArgClass = File.class;
                } else {
                    out = new FileWriter(file);
                }
            }
            Class<Formatter> formatterClass = getFormatterClass(className);
            // TODO: Remove these if statements. We should fix PrettyFormatter and ProgressFormatter to only take a single Appendable arg.
            // Whether or not to use Monochrome is tricky. Maybe always enforce another 2nd argument for that
            if (PrettyFormatter.class.isAssignableFrom(formatterClass)) {
                return formatterClass.getConstructor(ctorArgClass, Boolean.TYPE, Boolean.TYPE).newInstance(out, false, true);
            } else if (ProgressFormatter.class.isAssignableFrom(formatterClass)) {
                return formatterClass.getConstructor(ctorArgClass, Boolean.TYPE).newInstance(out, false);
            } else if (UsageFormatter.class.isAssignableFrom(formatterClass)) {
                return createUsageFormatter(out, ctorArgClass, formatterClass);
            } else {
                return formatterClass.getConstructor(ctorArgClass).newInstance(out);
            }
        } catch (Exception e) {
            throw new CucumberException(String.format("Error creating instance of: %s outputting to %s", className, out), e);
        }
    }

    private Class<Formatter> getFormatterClass(String className) {
        try {
            return (Class<Formatter>) classLoader.loadClass(className);
        } catch (ClassNotFoundException e) {
            throw new CucumberException("Formatter class not found: " + className, e);
        }
    }

    private UsageFormatter createUsageFormatter(Object out, Class ctorArgClass, Class<Formatter> formatterClass) throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException
    {
        UsageFormatter formatter = (UsageFormatter)formatterClass.getConstructor(ctorArgClass).newInstance(out);
        formatter.addUsageStatisticStrategy("average", new AverageUsageStatisticStrategy());
        formatter.addUsageStatisticStrategy("median", new MedianUsageStatisticStrategy());
        return formatter;
    }
}||||||| BASE
package cucumber.formatter;

import cucumber.runtime.CucumberException;
import gherkin.formatter.Formatter;
import gherkin.formatter.JSONFormatter;
import gherkin.formatter.JSONPrettyFormatter;
import gherkin.formatter.PrettyFormatter;

import java.io.File;
import java.io.FileWriter;
import java.util.HashMap;
import java.util.Map;

public class FormatterFactory {

    private final ClassLoader classLoader;

    private static final Map<String, String> BUILTIN_FORMATTERS = new HashMap<String, String>() {{
        put("progress", ProgressFormatter.class.getName());
        put("html", HTMLFormatter.class.getName());
        put("json", JSONFormatter.class.getName());
        put("json-pretty", JSONPrettyFormatter.class.getName());
        put("pretty", PrettyFormatter.class.getName());
    }};

    public FormatterFactory(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }

    public Formatter createFormatter(String formatterName, Object out) {
        String className = BUILTIN_FORMATTERS.containsKey(formatterName) ? BUILTIN_FORMATTERS.get(formatterName) : formatterName;
        return createFormatterFromClassName(className, out);
    }

    private Formatter createFormatterFromClassName(String className, Object out) {
        try {
            Class ctorArgClass = Appendable.class;
            if (out instanceof File) {
                File file = (File) out;
                if (file.isDirectory()) {
                    out = file;
                    ctorArgClass = File.class;
                } else {
                    out = new FileWriter(file);
                }
            }
            Class<Formatter> formatterClass = getFormatterClass(className);
            // TODO: Remove these if statements. We should fix PrettyFormatter and ProgressFormatter to only take a single Appendable arg.
            // Whether or not to use Monochrome is tricky. Maybe always enforce another 2nd argument for that
            if (PrettyFormatter.class.isAssignableFrom(formatterClass)) {
                return formatterClass.getConstructor(ctorArgClass, Boolean.TYPE, Boolean.TYPE).newInstance(out, false, true);
            } else if (ProgressFormatter.class.isAssignableFrom(formatterClass)) {
                return formatterClass.getConstructor(ctorArgClass, Boolean.TYPE).newInstance(out, false);
            } else {
                return formatterClass.getConstructor(ctorArgClass).newInstance(out);
            }
        } catch (Exception e) {
            throw new CucumberException(String.format("Error creating instance of: %s outputting to %s", className, out), e);
        }
    }

    private Class<Formatter> getFormatterClass(String className) {
        try {
            return (Class<Formatter>) classLoader.loadClass(className);
        } catch (ClassNotFoundException e) {
            throw new CucumberException("Formatter class not found: " + className, e);
        }
    }
}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_a865428_dcec2a1/rev_a865428-dcec2a1/core/src/test/java/cucumber/formatter/FormatterFactoryTest.java;<<<<<<< MINE
package cucumber.formatter;

import cucumber.formatter.usage.AverageUsageStatisticStrategy;
import cucumber.formatter.usage.MedianUsageStatisticStrategy;
import cucumber.formatter.usage.UsageStatisticStrategy;
import gherkin.formatter.Formatter;
import gherkin.formatter.JSONFormatter;
import gherkin.formatter.JSONPrettyFormatter;
import gherkin.formatter.PrettyFormatter;
import org.junit.Test;

import java.io.File;
import java.io.StringWriter;
import java.util.Map;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.mock;

public class FormatterFactoryTest {

    private final FormatterFactory formatterFactory = new FormatterFactory(Thread.currentThread().getContextClassLoader());

    @Test
    public void shouldInstantiateJsonFormatter() {
        assertThat(formatterFactory.createFormatter("json", System.out), is(JSONFormatter.class));
    }

    @Test
    public void shouldInstantiateJsonPrettyFormatter() {
        assertThat(formatterFactory.createFormatter("json-pretty", System.out), is(JSONPrettyFormatter.class));
    }

    @Test
    public void shouldInstantiatePrettyFormatter() {
        assertThat(formatterFactory.createFormatter("pretty", System.out), is(PrettyFormatter.class));
    }

    @Test
    public void shouldInstantiateProgressFormatter() {
        assertThat(formatterFactory.createFormatter("progress", System.out), is(ProgressFormatter.class));
    }

    @Test
    public void shouldInstantiateHtmlFormatter() {
        assertThat(formatterFactory.createFormatter("html", new File(System.getProperty("user.dir"))), is(HTMLFormatter.class));
    }


    @Test
    public void shouldInstantiateUsageFormatter() {
        Formatter formatter = formatterFactory.createFormatter("usage", mock(Appendable.class));
        
        assertThat(formatter, is(UsageFormatter.class));
        Map<String,UsageStatisticStrategy> statisticStrategies = ((UsageFormatter) formatter).statisticStrategies;
        assertEquals(statisticStrategies.size(), 2);
        assertThat(statisticStrategies.get("average"), is(AverageUsageStatisticStrategy.class));
        assertThat(statisticStrategies.get("median"), is(MedianUsageStatisticStrategy.class));
    }

    @Test
    public void shouldInstantiateCustomFormatterFromClassNameWithAppender() {
        StringWriter writer = new StringWriter();
        Formatter formatter = formatterFactory.createFormatter(TestFormatter.class.getName(), writer);
        assertThat(formatter, is(TestFormatter.class));
        assertSame(writer, ((TestFormatter) formatter).appendable);
    }

    @Test
    public void shouldInstantiateCustomFormatterFromClassNameWithDirFile() {
        File dir = new File(System.getProperty("user.dir"));
        Formatter formatter = formatterFactory.createFormatter(TestFormatter.class.getName(), dir);
        assertThat(formatter, is(TestFormatter.class));
        assertSame(dir, ((TestFormatter) formatter).dir);
    }
}||||||| BASE
package cucumber.formatter;

import gherkin.formatter.Formatter;
import gherkin.formatter.JSONFormatter;
import gherkin.formatter.JSONPrettyFormatter;
import gherkin.formatter.PrettyFormatter;
import org.junit.Test;

import java.io.File;
import java.io.StringWriter;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertThat;

public class FormatterFactoryTest {

    private final FormatterFactory formatterFactory = new FormatterFactory(Thread.currentThread().getContextClassLoader());

    @Test
    public void shouldInstantiateJsonFormatter() {
        assertThat(formatterFactory.createFormatter("json", System.out), is(JSONFormatter.class));
    }

    @Test
    public void shouldInstantiateJsonPrettyFormatter() {
        assertThat(formatterFactory.createFormatter("json-pretty", System.out), is(JSONPrettyFormatter.class));
    }

    @Test
    public void shouldInstantiatePrettyFormatter() {
        assertThat(formatterFactory.createFormatter("pretty", System.out), is(PrettyFormatter.class));
    }

    @Test
    public void shouldInstantiateProgressFormatter() {
        assertThat(formatterFactory.createFormatter("progress", System.out), is(ProgressFormatter.class));
    }

    @Test
    public void shouldInstantiateHtmlFormatter() {
        assertThat(formatterFactory.createFormatter("html", new File(System.getProperty("user.dir"))), is(HTMLFormatter.class));
    }

    @Test
    public void shouldInstantiateCustomFormatterFromClassNameWithAppender() {
        StringWriter writer = new StringWriter();
        Formatter formatter = formatterFactory.createFormatter(TestFormatter.class.getName(), writer);
        assertThat(formatter, is(TestFormatter.class));
        assertSame(writer, ((TestFormatter) formatter).appendable);
    }

    @Test
    public void shouldInstantiateCustomFormatterFromClassNameWithDirFile() {
        File dir = new File(System.getProperty("user.dir"));
        Formatter formatter = formatterFactory.createFormatter(TestFormatter.class.getName(), dir);
        assertThat(formatter, is(TestFormatter.class));
        assertSame(dir, ((TestFormatter) formatter).dir);
    }

}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_132254f_0d63c1f/rev_132254f-0d63c1f/core/src/test/java/cucumber/table/FromDataTableTest.java;<<<<<<< MINE
    private class DirectStepDef implements StepDefinition {
        private final Object target;
        private final Method method;

        public DirectStepDef(Object target, Method method) {
            this.target = target;
            this.method = method;
        }

        @Override
        public List<Argument> matchedArguments(Step step) {
            throw new UnsupportedOperationException();
        }

        @Override
        public String getLocation(boolean detail) {
            return getClass().getName();
        }

        @Override
        public List<ParameterType> getParameterTypes() {
            return ParameterType.fromMethod(method);
        }

        @Override
        public void execute(I18n i18n, Object[] args) throws Throwable {
            method.invoke(target, args);
        }

        @Override
        public boolean isDefinedAt(StackTraceElement stackTraceElement) {
            return false;
        }

        @Override
        public String getPattern() {
            throw new UnsupportedOperationException();
        }
    }
||||||| BASE
    private class DirectStepDef implements StepDefinition {
        private final Object target;
        private final Method method;

        public DirectStepDef(Object target, Method method) {
            this.target = target;
            this.method = method;
        }

        @Override
        public List<Argument> matchedArguments(Step step) {
            throw new UnsupportedOperationException();
        }

        @Override
        public String getLocation() {
            return getClass().getName();
        }

        @Override
        public List<ParameterType> getParameterTypes() {
            return ParameterType.fromMethod(method);
        }

        @Override
        public void execute(I18n i18n, Object[] args) throws Throwable {
            method.invoke(target, args);
        }

        @Override
        public boolean isDefinedAt(StackTraceElement stackTraceElement) {
            return false;
        }

        @Override
        public String getPattern() {
            throw new UnsupportedOperationException();
        }
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_f388f5e_5654134/rev_f388f5e-5654134/core/src/main/java/cucumber/runtime/RuntimeOptions.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_f388f5e_5654134/rev_f388f5e-5654134/core/src/main/java/cucumber/runtime/Utils.java;<<<<<<< MINE

    public static String packagePath(Class clazz) {
        return packagePath(packageName(clazz.getName()));
    }

    public static String packagePath(String packageName) {
        return packageName.replace('.', '/');
    }

    public static String packageName(Class clazz) {
        return packageName(clazz.getName());
    }

    public static String toPackage(String path) {
        return path.replace('/', '.').replace('\\', '.');
    }

    static String packageName(String className) {
        return className.substring(0, Math.max(0, className.lastIndexOf(".")));
    }

    public static <T> Iterator<T> emptyIterator() {
        return new Iterator<T>() {

            @Override
            public boolean hasNext() {
                return false;
            }

            @Override
            public T next() {
                throw new UnsupportedOperationException();
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    public static Object invoke(Object target, Method method, Object... args) {
        try {
            return method.invoke(target, args);
        } catch (IllegalArgumentException e) {
            throw new CucumberException("Can't invoke " + MethodFormat.FULL.format(method), e);
        } catch (InvocationTargetException e) {
            throw new CucumberException("Can't invoke " + MethodFormat.FULL.format(method), e.getTargetException());
        } catch (IllegalAccessException e) {
            throw new CucumberException("Can't invoke " + MethodFormat.FULL.format(method), e);
        }
    }
||||||| BASE

    public static String packagePath(Class clazz) {
        return packagePath(packageName(clazz.getName()));
    }

    public static String packagePath(String packageName) {
        return packageName.replace('.', '/');
    }

    public static String packageName(Class clazz) {
        return packageName(clazz.getName());
    }

    public static String toPackage(String path) {
        return path.replace('/', '.').replace('\\', '.');
    }

    static String packageName(String className) {
        return className.substring(0, Math.max(0, className.lastIndexOf(".")));
    }

    public static <T> Iterator<T> emptyIterator() {
        return new Iterator<T>() {

            @Override
            public boolean hasNext() {
                return false;
            }

            @Override
            public T next() {
                throw new UnsupportedOperationException();
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_f388f5e_5654134/rev_f388f5e-5654134/java/src/main/java/cucumber/runtime/java/JavaBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_f388f5e_5654134/rev_f388f5e-5654134/junit/src/main/java/cucumber/junit/DescriptionFactory.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_f388f5e_5654134/rev_f388f5e-5654134/openejb/src/main/java/cucumber/runtime/java/openejb/OpenEJBObjectFactory.java;<<<<<<< MINE
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
||||||| BASE
import java.util.*;
=======
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_f388f5e_5654134/rev_f388f5e-5654134/openejb/src/main/java/cucumber/runtime/java/openejb/OpenEJBObjectFactory.java;<<<<<<< MINE
    public void createInstances() {
||||||| BASE
    public void createInstances() {
        configureLog4J();

=======
    public void start() {
        configureLog4J();

>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/runtime/FeatureBuilder.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/UsageFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/UsageFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/UsageFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/ProgressFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/ProgressFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/JUnitFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/JUnitFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/JUnitFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/main/java/cucumber/formatter/NullFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/formatter/TestFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/runtime/JdkPatternArgumentMatcherTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/runtime/JdkPatternArgumentMatcherTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/junit/src/main/java/cucumber/junit/JUnitReporter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9531933_3f8f171/rev_9531933-3f8f171/junit/src/main/java/cucumber/junit/JUnitReporter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/main/java/cucumber/runtime/FeatureBuilder.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/main/java/cucumber/formatter/UsageFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/main/java/cucumber/formatter/ProgressFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/main/java/cucumber/formatter/HTMLFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/main/java/cucumber/formatter/JUnitFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/main/java/cucumber/formatter/NullFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/table/TableParser.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/core/src/test/java/cucumber/formatter/TestFormatter.java;<<<<<<< MINE
package cucumber.formatter;

import gherkin.formatter.Formatter;
import gherkin.formatter.model.Background;
import gherkin.formatter.model.Examples;
import gherkin.formatter.model.Feature;
import gherkin.formatter.model.Scenario;
import gherkin.formatter.model.ScenarioOutline;
import gherkin.formatter.model.Step;
import org.junit.Ignore;

import java.io.File;
import java.util.List;

@Ignore
public class TestFormatter implements Formatter {
    public Appendable appendable;
    public File dir;

    public TestFormatter(Appendable appendable) {
        this.appendable = appendable;
    }

    public TestFormatter(File dir) {
        this.dir = dir;
    }

    @Override
    public void uri(String uri) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void feature(Feature feature) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void background(Background background) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void scenario(Scenario scenario) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void scenarioOutline(ScenarioOutline scenarioOutline) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void examples(Examples examples) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void step(Step step) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void eof() {
        throw new UnsupportedOperationException();
    }

    @Override
    public void syntaxError(String state, String event, List<String> legalEvents, String uri, Integer line) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void done() {
        throw new UnsupportedOperationException();
    }

    @Override
    public void close() {
        throw new UnsupportedOperationException();
    }
}||||||| BASE
package cucumber.formatter;

import gherkin.formatter.Formatter;
import gherkin.formatter.model.Background;
import gherkin.formatter.model.Examples;
import gherkin.formatter.model.Feature;
import gherkin.formatter.model.Scenario;
import gherkin.formatter.model.ScenarioOutline;
import gherkin.formatter.model.Step;
import org.junit.Ignore;

import java.io.File;
import java.util.List;

@Ignore
public class TestFormatter implements Formatter {
    public Appendable appendable;
    public File dir;

    public TestFormatter(Appendable appendable) {
        this.appendable = appendable;
    }

    public TestFormatter(File dir) {
        this.dir = dir;
    }

    @Override
    public void uri(String uri) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void feature(Feature feature) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void background(Background background) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void scenario(Scenario scenario) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void scenarioOutline(ScenarioOutline scenarioOutline) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void examples(Examples examples) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void step(Step step) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void eof() {
        throw new UnsupportedOperationException();
    }

    @Override
    public void syntaxError(String state, String event, List<String> legalEvents, String uri, int line) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void done() {
        throw new UnsupportedOperationException();
    }

    @Override
    public void close() {
        throw new UnsupportedOperationException();
    }
}=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2c84c2b_73efd68/rev_2c84c2b-73efd68/junit/src/main/java/cucumber/junit/JUnitReporter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/table/xstream/ComplexTypeWriter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/table/xstream/ListOfComplexTypeReader.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/table/xstream/CellWriter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/table/TableConverter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/table/TableConverter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/table/TableDiffer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/converters/ClassWithStringConstructorConverter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/converters/ConverterWithFormat.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/converters/ConverterWithFormat.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/converters/ConverterWithEnumFormat.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/converters/LocalizedXStreams.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/converters/LocalizedXStreams.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/converters/SingleValueConverterWrapperExt.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/ParameterType.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/runtime/StepDefinitionMatch.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/api/Transform.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/main/java/cucumber/api/Transformer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/converters/StandardConvertersTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/converters/ConvertersTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/converters/ConvertersTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/autocomplete/StepdefGeneratorTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/UtilsTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/UtilsTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/UtilsTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/ParameterTypeTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/runtime/StepDefinitionMatchTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/FromDataTableTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/FromDataTableTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/FromDataTableTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/FromDataTableTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/FromDataTableTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/FromDataTableTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/FromDataTableTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/DataTableTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/table/TableConverterTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/formatter/StubFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/formatter/StubFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/io/FileResourceTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/core/src/test/java/cucumber/io/FileResourceTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/jython/src/main/java/cucumber/runtime/jython/JythonStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/jython/src/main/java/cucumber/runtime/jython/JythonStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/picocontainer/src/test/java/cucumber/runtime/java/picocontainer/DatesSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/picocontainer/src/test/java/cucumber/runtime/java/picocontainer/DatesSteps.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/examples/java-helloworld/src/test/java/cucumber/examples/java/helloworld/TimeStepdefs.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/jruby/src/main/java/cucumber/runtime/jruby/JRubyStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/groovy/src/main/java/cucumber/runtime/groovy/GroovyStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/java/src/test/java/cucumber/runtime/java/JavaStepDefinitionTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/ioke/src/main/java/cucumber/runtime/ioke/IokeStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/rhino/src/main/java/cucumber/runtime/rhino/RhinoStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d55b7c6_20cdb63/rev_d55b7c6-20cdb63/rhino/src/main/java/cucumber/runtime/rhino/RhinoStepDefinition.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9612724_e572769/rev_9612724-e572769/jython/src/main/java/cucumber/runtime/jython/JythonBackend.java;<<<<<<< MINE
    public void addBeforeHook(PyInstance hookDefinition) {
        glue.addBeforeHook(new JythonHookDefinition(this, hookDefinition));
    }

    public void addAfterHook(PyInstance hookDefinition) {
        glue.addAfterHook(new JythonHookDefinition(this, hookDefinition));
    }

    public void executeHook(PyInstance hookDefinition, Object[] scenarioResults) {
        PyObject[] pyArgs = new PyObject[1];
        pyArgs[0] = pyWorld;
        hookDefinition.invoke("execute", pyArgs);
    }

    public void execute(PyInstance stepdef, Object[] args) {
||||||| BASE
    public void execute(PyInstance stepdef, Object[] args) {
=======
    public void execute(PyInstance stepdef, Object[] args) throws Throwable {
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_842ecca_16cb45d/rev_842ecca-16cb45d/junit/src/main/java/cucumber/runtime/junit/DescriptionFactory.java;<<<<<<< MINE
||||||| BASE
package cucumber.runtime.junit;

import cucumber.runtime.CucumberException;
import cucumber.runtime.Utils;
import org.junit.runner.Description;

import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Method;

/**
 * This class attempts to create descriptions with unique ids, if the method is available.
 * Falls back to not using uniqueId if not.
 * <p/>
 * See <a href="https://github.com/cucumber/cucumber-jvm/issues/225">#225</a> for details.
 */
public class DescriptionFactory {
    private static Method CREATE_SUITE_DESCRIPTION;
    private static boolean USE_UNIQUE_ID = false;
    private static String UNIQUE_HACK = "";

    static {
        try {
            CREATE_SUITE_DESCRIPTION = Description.class.getMethod("createSuiteDescription", String.class, Object.class, Array.newInstance(Annotation.class, 0).getClass());
            USE_UNIQUE_ID = true;
        } catch (NoSuchMethodException e) {
            try {
                CREATE_SUITE_DESCRIPTION = Description.class.getMethod("createSuiteDescription", String.class, Array.newInstance(Annotation.class, 0).getClass());
                USE_UNIQUE_ID = false;
            } catch (NoSuchMethodException e1) {
                throw new CucumberException("You need JUnit 4.10 or newer");
            }
        }
    }

    public static Description createDescription(String name, Object uniqueId) {
        if (USE_UNIQUE_ID) {
            try {
                return (Description) Utils.invoke(null, CREATE_SUITE_DESCRIPTION, 0, name, uniqueId, Array.newInstance(Annotation.class, 0));
            } catch (Throwable t) {
                throw new CucumberException(t);
            }
        } else {
            UNIQUE_HACK += " ";
            try {
                return (Description) Utils.invoke(null, CREATE_SUITE_DESCRIPTION, 0, name + UNIQUE_HACK, Array.newInstance(Annotation.class, 0));
            } catch (Throwable t) {
                throw new CucumberException(t);
            }
        }
    }
}=======
package cucumber.runtime.junit;

import cucumber.runtime.CucumberException;
import cucumber.runtime.Utils;
import org.junit.runner.Description;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Method;

/**
 * This class attempts to create descriptions with unique ids, if the method is available.
 * Falls back to not using uniqueId if not.
 * <p/>
 * See <a href="https://github.com/cucumber/cucumber-jvm/issues/225">#225</a> for details.
 */
public class DescriptionFactory {
    private static Method CREATE_SUITE_DESCRIPTION;
    private static boolean USE_UNIQUE_ID = false;
    private static String UNIQUE_HACK = "";

    static {
        try {
            CREATE_SUITE_DESCRIPTION = Description.class.getMethod("createSuiteDescription", String.class, Serializable.class, Array.newInstance(Annotation.class, 0).getClass());
            USE_UNIQUE_ID = true;
        } catch (NoSuchMethodException e) {
            try {
                CREATE_SUITE_DESCRIPTION = Description.class.getMethod("createSuiteDescription", String.class, Array.newInstance(Annotation.class, 0).getClass());
                USE_UNIQUE_ID = false;
            } catch (NoSuchMethodException e1) {
                throw new CucumberException("You need JUnit 4.10 or newer");
            }
        }
    }

    public static Description createDescription(String name, Serializable uniqueId) {
        if (USE_UNIQUE_ID) {
            try {
                return (Description) Utils.invoke(null, CREATE_SUITE_DESCRIPTION, 0, name, uniqueId, Array.newInstance(Annotation.class, 0));
            } catch (Throwable t) {
                throw new CucumberException(t);
            }
        } else {
            UNIQUE_HACK += " ";
            try {
                return (Description) Utils.invoke(null, CREATE_SUITE_DESCRIPTION, 0, name + UNIQUE_HACK, Array.newInstance(Annotation.class, 0));
            } catch (Throwable t) {
                throw new CucumberException(t);
            }
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_d89f488_1499ae8/rev_d89f488-1499ae8/core/src/main/java/cucumber/api/DataTable.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_829c41d_2fe7fba/rev_829c41d-2fe7fba/examples/spring-txn/src/main/java/cucumber/examples/spring/txn/MessageRepository.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_829c41d_2fe7fba/rev_829c41d-2fe7fba/examples/spring-txn/src/main/java/cucumber/examples/spring/txn/UserRepository.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_829c41d_2fe7fba/rev_829c41d-2fe7fba/examples/spring-txn/src/main/java/cucumber/examples/spring/txn/UserRepository.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_829c41d_2fe7fba/rev_829c41d-2fe7fba/examples/spring-txn/src/main/java/cucumber/examples/spring/txn/UserRepository.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/test/java/cucumber/runtime/table/TableDifferTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/main/java/cucumber/runtime/table/TableDiffer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/main/java/cucumber/runtime/table/TableDiffer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/main/java/cucumber/runtime/table/TableDiffer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/main/java/cucumber/runtime/table/TableDiffer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/main/java/cucumber/runtime/table/TableDiffer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/core/src/main/java/cucumber/runtime/Env.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/junit/src/main/java/cucumber/runtime/junit/JUnitReporter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_8848117_fd0cd8b/rev_8848117-fd0cd8b/junit/src/main/java/cucumber/runtime/junit/JUnitReporter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_c87e2e2_3be4969/rev_c87e2e2-3be4969/examples/java-webbit-websockets-selenium/src/main/java/cucumber/examples/java/websockets/TemperatureServer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_c87e2e2_3be4969/rev_c87e2e2-3be4969/examples/java-webbit-websockets-selenium/src/main/java/cucumber/examples/java/websockets/TemperatureServer.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_39e2432_6045294/rev_39e2432-6045294/core/src/test/java/cucumber/runtime/formatter/StepMatcher.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_39e2432_6045294/rev_39e2432-6045294/core/src/test/java/cucumber/runtime/TestHelper.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/test/java/cucumber/runtime/RuntimeTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/test/java/cucumber/runtime/RuntimeTest.java;<<<<<<< MINE
import static org.junit.Assert.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.doThrow;
||||||| BASE
=======
import static org.junit.Assert.fail;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/test/java/cucumber/runtime/RuntimeTest.java;<<<<<<< MINE
    @Test
    public void should_throw_cucumer_exception_if_no_backends_are_found() throws Exception {
        try {
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            new Runtime(new ClasspathResourceLoader(classLoader), classLoader, Collections.<Backend>emptyList(),
                    new RuntimeOptions(new Properties()));
            fail("A CucumberException should have been thrown");
        } catch (CucumberException e) {
            assertEquals("No backends were found. Please make sure you have a backend module on your CLASSPATH.", e.getMessage());
        }
    }

    @Test
    public void should_add_passed_result_to_the_summary_counter() throws Exception {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Reporter reporter = mock(Reporter.class);
        StepDefinitionMatch match = mock(StepDefinitionMatch.class);

        Runtime runtime = createRuntimeWithMockedGlue(match, "--monochrome");
        runtime.buildBackendWorlds(reporter, Collections.<Tag>emptySet());
        runStep(reporter, runtime);
        runtime.disposeBackendWorlds();
        runtime.printSummary(new PrintStream(baos));

        assertThat(baos.toString(), startsWith(String.format(
                "1 Scenarios (1 passed)%n" +
                "1 Steps (1 passed)%n")));
    }

    @Test
    public void should_add_pending_result_to_the_summary_counter() throws Throwable {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Reporter reporter = mock(Reporter.class);
        StepDefinitionMatch match = createExceptionThrowingMatch(new PendingException());

        Runtime runtime = createRuntimeWithMockedGlue(match, "--monochrome");
        runtime.buildBackendWorlds(reporter, Collections.<Tag>emptySet());
        runStep(reporter, runtime);
        runtime.disposeBackendWorlds();
        runtime.printSummary(new PrintStream(baos));

        assertThat(baos.toString(), startsWith(String.format(
                "1 Scenarios (1 pending)%n" +
                "1 Steps (1 pending)%n")));
    }

    @Test
    public void should_add_failed_result_to_the_summary_counter() throws Throwable {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Reporter reporter = mock(Reporter.class);
        StepDefinitionMatch match = createExceptionThrowingMatch(new Exception());

        Runtime runtime = createRuntimeWithMockedGlue(match, "--monochrome");
        runtime.buildBackendWorlds(reporter, Collections.<Tag>emptySet());
        runStep(reporter, runtime);
        runtime.disposeBackendWorlds();
        runtime.printSummary(new PrintStream(baos));

        assertThat(baos.toString(), startsWith(String.format(
                "1 Scenarios (1 failed)%n" +
                "1 Steps (1 failed)%n")));
    }

    @Test
    public void should_add_ambiguous_match_as_failed_result_to_the_summary_counter() throws Throwable {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Reporter reporter = mock(Reporter.class);

        Runtime runtime = createRuntimeWithMockedGlueWithAmbiguousMatch("--monochrome");
        runtime.buildBackendWorlds(reporter, Collections.<Tag>emptySet());
        runStep(reporter, runtime);
        runtime.disposeBackendWorlds();
        runtime.printSummary(new PrintStream(baos));

        assertThat(baos.toString(), startsWith(String.format(
                "1 Scenarios (1 failed)%n" +
                "1 Steps (1 failed)%n")));
    }

    @Test
    public void should_add_skipped_result_to_the_summary_counter() throws Throwable {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Reporter reporter = mock(Reporter.class);
        StepDefinitionMatch match = createExceptionThrowingMatch(new Exception());

        Runtime runtime = createRuntimeWithMockedGlue(match, "--monochrome");
        runtime.buildBackendWorlds(reporter, Collections.<Tag>emptySet());
        runStep(reporter, runtime);
        runStep(reporter, runtime);
        runtime.disposeBackendWorlds();
        runtime.printSummary(new PrintStream(baos));

        assertThat(baos.toString(), startsWith(String.format(
                "1 Scenarios (1 failed)%n" +
                "2 Steps (1 failed, 1 skipped)%n")));
    }

    @Test
    public void should_add_undefined_result_to_the_summary_counter() throws Throwable {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Reporter reporter = mock(Reporter.class);

        Runtime runtime = createRuntimeWithMockedGlue(null, "--monochrome");
        runtime.buildBackendWorlds(reporter, Collections.<Tag>emptySet());
        runStep(reporter, runtime);
        runtime.disposeBackendWorlds();
        runtime.printSummary(new PrintStream(baos));

        assertThat(baos.toString(), startsWith(String.format(
                "1 Scenarios (1 undefined)%n" +
                "1 Steps (1 undefined)%n")));
    }

    @Test
    public void should_fail_the_scenario_if_before_fails() throws Throwable {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Reporter reporter = mock(Reporter.class);
        StepDefinitionMatch match = mock(StepDefinitionMatch.class);
        HookDefinition hook = createExceptionThrowingHook();

        Runtime runtime = createRuntimeWithMockedGlue(match, hook, true, "--monochrome");
        runtime.buildBackendWorlds(reporter, Collections.<Tag>emptySet());
        runtime.runBeforeHooks(reporter, Collections.<Tag>emptySet());
        runStep(reporter, runtime);
        runtime.disposeBackendWorlds();
        runtime.printSummary(new PrintStream(baos));

        assertThat(baos.toString(), startsWith(String.format(
                "1 Scenarios (1 failed)%n" +
                "1 Steps (1 skipped)%n")));
   }

    @Test
    public void should_fail_the_scenario_if_after_fails() throws Throwable {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Reporter reporter = mock(Reporter.class);
        StepDefinitionMatch match = mock(StepDefinitionMatch.class);
        HookDefinition hook = createExceptionThrowingHook();

        Runtime runtime = createRuntimeWithMockedGlue(match, hook, false, "--monochrome");
        runtime.buildBackendWorlds(reporter, Collections.<Tag>emptySet());
        runStep(reporter, runtime);
        runtime.runAfterHooks(reporter, Collections.<Tag>emptySet());
        runtime.disposeBackendWorlds();
        runtime.printSummary(new PrintStream(baos));

        assertThat(baos.toString(), startsWith(String.format(
                "1 Scenarios (1 failed)%n" +
                "1 Steps (1 passed)%n")));
   }

    private StepDefinitionMatch createExceptionThrowingMatch(Exception exception) throws Throwable {
        StepDefinitionMatch match = mock(StepDefinitionMatch.class);
        doThrow(exception).when(match).runStep((I18n)any());
        return match;
    }

    private HookDefinition createExceptionThrowingHook() throws Throwable {
        HookDefinition hook = mock(HookDefinition.class);
        when(hook.matches(anyCollectionOf(Tag.class))).thenReturn(true);
        doThrow(new Exception()).when(hook).execute((Scenario)any());
        return hook;
    }

    public void runStep(Reporter reporter, Runtime runtime) {
        Step step = mock(Step.class);
        I18n i18n = mock(I18n.class);
        runtime.runStep("<uri>", step, reporter, i18n);
    }

||||||| BASE
=======
    @Test
    public void should_throw_cucumer_exception_if_no_backends_are_found() throws Exception {
        try {
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            new Runtime(new ClasspathResourceLoader(classLoader), classLoader, Collections.<Backend>emptyList(),
                    new RuntimeOptions(new Properties()));
            fail("A CucumberException should have been thrown");
        } catch (CucumberException e) {
            assertEquals("No backends were found. Please make sure you have a backend module on your CLASSPATH.", e.getMessage());
        }
    }

>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/main/java/cucumber/runtime/Runtime.java;<<<<<<< MINE
import java.io.PrintStream;
import java.util.*;
||||||| BASE
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
=======
import java.util.*;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/main/java/cucumber/runtime/Runtime.java;<<<<<<< MINE
        this.runtimeOptions = runtimeOptions;
        this.glue = optionalGlue != null ? optionalGlue : new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader));
        this.summaryCounter = new SummaryCounter(runtimeOptions.isMonochrome());
||||||| BASE
        glue = new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader));
=======
        this.runtimeOptions = runtimeOptions;
        this.glue = optionalGlue != null ? optionalGlue : new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader));
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/main/java/cucumber/runtime/Runtime.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_442c4ed_4439178/rev_442c4ed-4439178/core/src/main/java/cucumber/runtime/RuntimeOptions.java;<<<<<<< MINE

    public boolean isMonochrome() {
        return monochrome;
    }
||||||| BASE
=======

    private void setFormatterOptions() {
        for (Formatter formatter : formatters) {
            setMonochromeOnColorAwareFormatters(formatter);
            setStrictOnStrictAwareFormatters(formatter);
        }
    }

    private void setMonochromeOnColorAwareFormatters(Formatter formatter) {
        if (formatter instanceof ColorAware) {
            ColorAware colorAware = (ColorAware) formatter;
            colorAware.setMonochrome(monochrome);
        }
    }

    private void setStrictOnStrictAwareFormatters(Formatter formatter) {
        if (formatter instanceof StrictAware) {
            StrictAware strictAware = (StrictAware) formatter;
            strictAware.setStrict(strict);
        }
    }

    public List<String> getGlue() {
        return glue;
    }

    public boolean isStrict() {
        return strict;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public List<String> getFeaturePaths() {
        return featurePaths;
    }

    public URL getDotCucumber() {
        return dotCucumber;
    }

    public List<Formatter> getFormatters() {
        return formatters;
    }

    public List<Object> getFilters() {
        return filters;
    }
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9258c4b_d82908e/rev_9258c4b-d82908e/core/src/test/java/cucumber/runtime/formatter/JSONPrettyFormatterTest.java;<<<<<<< MINE
import cucumber.runtime.Backend;
import cucumber.runtime.Runtime;
import cucumber.runtime.RuntimeOptions;
import cucumber.runtime.io.ClasspathResourceLoader;
import cucumber.runtime.snippets.FunctionNameSanitizer;
||||||| BASE
import static java.util.Arrays.asList;
import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
=======
import static java.util.Arrays.asList;
import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyListOf;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9258c4b_d82908e/rev_9258c4b-d82908e/core/src/test/java/cucumber/runtime/formatter/JSONPrettyFormatterTest.java;<<<<<<< MINE
import org.junit.Test;
||||||| BASE
=======
import gherkin.formatter.model.Tag;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_9258c4b_d82908e/rev_9258c4b-d82908e/core/src/test/java/cucumber/runtime/formatter/JSONPrettyFormatterTest.java;<<<<<<< MINE
import static java.util.Arrays.asList;
import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
||||||| BASE
import org.junit.Test;

import cucumber.runtime.Backend;
import cucumber.runtime.Runtime;
import cucumber.runtime.RuntimeOptions;
import cucumber.runtime.io.ClasspathResourceLoader;
=======
import org.junit.Test;

import cucumber.runtime.Backend;
import cucumber.runtime.HookDefinition;
import cucumber.runtime.Runtime;
import cucumber.runtime.RuntimeOptions;
import cucumber.runtime.io.ClasspathResourceLoader;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_517487c_10ba032/rev_517487c-10ba032/junit/src/test/java/cucumber/runtime/junit/CucumberTest.java;<<<<<<< MINE
    @Test
||||||| BASE
    @Test(expected = CucumberException.class)
=======
    @Test
    public void testThatParsingErrorsIsNicelyReported() throws Exception {
        try {
            new Cucumber(LexerErrorFeature.class);
            fail("Expecting error");
        } catch (CucumberException e) {
            assertEquals("Error parsing feature file cucumber/runtime/error/lexer_error.feature", e.getMessage());
        }
    }

    @Test(expected = CucumberException.class)
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_6e7e1b3_f9cad32/rev_6e7e1b3-f9cad32/core/src/main/java/cucumber/runtime/formatter/JUnitFormatter.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2ac08a8_c591426/rev_2ac08a8-c591426/core/src/test/java/cucumber/runtime/formatter/JUnitFormatterTest.java;<<<<<<< MINE
import cucumber.runtime.HookDefinition;
||||||| BASE
import cucumber.runtime.Env;
import cucumber.runtime.HookDefinition;
=======
import cucumber.runtime.Env;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_2ac08a8_c591426/rev_2ac08a8-c591426/core/src/test/java/cucumber/runtime/formatter/CucumberPrettyFormatterTest.java;<<<<<<< MINE
import cucumber.runtime.Backend;
import cucumber.runtime.Runtime;
import cucumber.runtime.RuntimeGlue;
import cucumber.runtime.RuntimeOptions;
import cucumber.runtime.StepDefinitionMatch;
import cucumber.runtime.io.ClasspathResourceLoader;
||||||| BASE
import cucumber.runtime.Backend;
import cucumber.runtime.Env;
import cucumber.runtime.Runtime;
import cucumber.runtime.RuntimeGlue;
import cucumber.runtime.RuntimeOptions;
import cucumber.runtime.StepDefinitionMatch;
import cucumber.runtime.io.ClasspathResourceLoader;
=======
import cucumber.runtime.TestHelper;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_fb86373_1500f10/rev_fb86373-1500f10/core/src/test/java/cucumber/runtime/table/ToDataTableTest.java;<<<<<<< MINE
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
||||||| BASE
import java.lang.reflect.Type;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
=======
import java.lang.reflect.Type;
import java.util.*;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_3745fd6_ae0b2e2/rev_3745fd6-ae0b2e2/core/src/main/java/cucumber/runtime/ParameterInfo.java;<<<<<<< MINE
    private final boolean transposed;
    private final Transformer transformer;
||||||| BASE
    private final Transformer transformer;
=======
    private final Transformer<?> transformer;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_c4f6c53_9cc482e/rev_c4f6c53-9cc482e/core/src/main/java/cucumber/runtime/xstream/LocalizedXStreams.java;<<<<<<< MINE
        private final ThreadLocal<List<TimeConverter>> timeConverters = new ThreadLocal<List<TimeConverter>>() {
            @Override
            protected List<TimeConverter> initialValue() {
                return new ArrayList<TimeConverter>();
            }
        };
        
||||||| BASE
        private static final List<TimeConverter> timeConverters = new ArrayList<TimeConverter>();

=======
        private final ThreadLocal<List<TimeConverter>> timeConverters = new ThreadLocal<List<TimeConverter>>() {
            @Override
            protected List<TimeConverter> initialValue() {
                return new ArrayList<TimeConverter>();
            }
        };

>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_c4f6c53_9cc482e/rev_c4f6c53-9cc482e/core/src/main/java/cucumber/runtime/xstream/LocalizedXStreams.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_c4f6c53_9cc482e/rev_c4f6c53-9cc482e/core/src/main/java/cucumber/runtime/xstream/LocalizedXStreams.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_c4f6c53_9cc482e/rev_c4f6c53-9cc482e/core/src/main/java/cucumber/runtime/xstream/LocalizedXStreams.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b7d2505_d90c7af/rev_b7d2505-d90c7af/core/src/main/java/cucumber/runtime/model/CucumberScenarioOutline.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_80fac3f_34332ef/rev_80fac3f-34332ef/core/src/main/java/cucumber/runtime/Glue.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_35438bf_e073420/rev_35438bf-e073420/core/src/test/java/cucumber/runtime/formatter/FormatterFactoryTest.java;<<<<<<< MINE
||||||| BASE
package cucumber.runtime.formatter;

import cucumber.runtime.CucumberException;
import cucumber.runtime.Utils;
import cucumber.runtime.io.UTF8OutputStreamWriter;
import gherkin.formatter.Formatter;
import gherkin.formatter.model.Result;

import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.net.URL;

import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.fail;

public class FormatterFactoryTest {
    private FormatterFactory fc = new FormatterFactory();

    @Test
    public void instantiates_null_formatter() {
        Formatter formatter = fc.create("null");
        assertEquals(NullFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_junit_formatter_with_file_arg() throws IOException {
        Formatter formatter = fc.create("junit:" + File.createTempFile("cucumber", "xml"));
        assertEquals(JUnitFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_html_formatter_with_dir_arg() throws IOException {
        Formatter formatter = fc.create("html:" + TempDir.createTempDirectory().getAbsolutePath());
        assertEquals(HTMLFormatter.class, formatter.getClass());
    }

    @Test
    public void fails_to_instantiate_html_formatter_without_dir_arg() throws IOException {
        try {
            fc.create("html");
            fail();
        } catch (CucumberException e) {
            assertEquals("You must supply an output argument to html. Like so: html:output", e.getMessage());
        }
    }

    @Test
    public void instantiates_pretty_formatter_with_file_arg() throws IOException {
        Formatter formatter = fc.create("pretty:" + Utils.toURL(TempDir.createTempFile().getAbsolutePath()));
        assertEquals(CucumberPrettyFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_pretty_formatter_without_file_arg() {
        Formatter formatter = fc.create("pretty");
        assertEquals(CucumberPrettyFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_usage_formatter_without_file_arg() {
        Formatter formatter = fc.create("usage");
        assertEquals(UsageFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_usage_formatter_with_file_arg() throws IOException {
        Formatter formatter = fc.create("usage:" + TempDir.createTempFile().getAbsolutePath());
        assertEquals(UsageFormatter.class, formatter.getClass());
    }
    
    @Test
    public void formatter_does_not_buffer_its_output() throws IOException {
        PrintStream previousSystemOut = System.out;
        OutputStream mockSystemOut = new ByteArrayOutputStream();
        
        try {
            System.setOut(new PrintStream(mockSystemOut));
            
            // Need to create a new formatter factory here since we need it to pick up the new value of System.out
            fc = new FormatterFactory();
            
            ProgressFormatter formatter = (ProgressFormatter) fc.create("progress");
            
            formatter.result(new Result("passed", null, null));
            
            assertThat(mockSystemOut.toString(), is(not("")));
        } finally {
            System.setOut(previousSystemOut);
        }
    }

    @Test
    public void instantiates_single_custom_appendable_formatter_with_stdout() {
        WantsAppendable formatter = (WantsAppendable) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable");
        assertThat(formatter.out, is(instanceOf(PrintStream.class)));
        try {
            fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable");
            fail();
        } catch (CucumberException expected) {
            assertEquals("Only one formatter can use STDOUT. If you use more than one formatter you must specify output path with FORMAT:PATH_OR_URL", expected.getMessage());
        }
    }

    @Test
    public void instantiates_custom_appendable_formatter_with_stdout_and_file() throws IOException {
        WantsAppendable formatter = (WantsAppendable) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable");
        assertThat(formatter.out, is(instanceOf(PrintStream.class)));

        WantsAppendable formatter2 = (WantsAppendable) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable:" + TempDir.createTempFile().getAbsolutePath());
        assertEquals(UTF8OutputStreamWriter.class, formatter2.out.getClass());
    }

    @Test
    public void instantiates_custom_url_formatter() throws IOException {
        WantsUrl formatter = (WantsUrl) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsUrl:halp");
        assertEquals(new URL("file:halp/"), formatter.out);
    }

    @Test
    public void instantiates_custom_url_formatter_with_http() throws IOException {
        WantsUrl formatter = (WantsUrl) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsUrl:http://halp/");
        assertEquals(new URL("http://halp/"), formatter.out);
    }

    @Test
    public void instantiates_custom_uri_formatter_with_ws() throws IOException, URISyntaxException {
        WantsUri formatter = (WantsUri) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsUri:ws://halp/");
        assertEquals(new URI("ws://halp/"), formatter.out);
    }

    @Test
    public void instantiates_custom_file_formatter() throws IOException {
        WantsFile formatter = (WantsFile) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsFile:halp.txt");
        assertEquals(new File("halp.txt"), formatter.out);
    }

    public static class WantsAppendable extends StubFormatter {
        public final Appendable out;

        public WantsAppendable(Appendable out) {
            this.out = out;
        }
    }

    public static class WantsUrl extends StubFormatter {
        public final URL out;

        public WantsUrl(URL out) {
            this.out = out;
        }
    }

    public static class WantsUri extends StubFormatter {
        public final URI out;

        public WantsUri(URI out) {
            this.out = out;
        }
    }

    public static class WantsFile extends StubFormatter {
        public final File out;

        public WantsFile(File out) {
            this.out = out;
        }
    }
}=======
package cucumber.runtime.formatter;

import cucumber.runtime.CucumberException;
import cucumber.runtime.Utils;
import cucumber.runtime.io.UTF8OutputStreamWriter;
import gherkin.formatter.Formatter;
import gherkin.formatter.model.Result;

import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.net.URL;

import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.fail;

public class FormatterFactoryTest {
    private FormatterFactory fc = new FormatterFactory();

    @Test
    public void instantiates_null_formatter() {
        Formatter formatter = fc.create("null");
        assertEquals(NullFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_junit_formatter_with_file_arg() throws IOException {
        Formatter formatter = fc.create("junit:" + File.createTempFile("cucumber", "xml"));
        assertEquals(JUnitFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_html_formatter_with_dir_arg() throws IOException {
        Formatter formatter = fc.create("html:" + TempDir.createTempDirectory().getAbsolutePath());
        assertEquals(HTMLFormatter.class, formatter.getClass());
    }

    @Test
    public void fails_to_instantiate_html_formatter_without_dir_arg() throws IOException {
        try {
            fc.create("html");
            fail();
        } catch (CucumberException e) {
            assertEquals("You must supply an output argument to html. Like so: html:output", e.getMessage());
        }
    }

    @Test
    public void instantiates_pretty_formatter_with_file_arg() throws IOException {
        Formatter formatter = fc.create("pretty:" + Utils.toURL(TempDir.createTempFile().getAbsolutePath()));
        assertEquals(CucumberPrettyFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_pretty_formatter_without_file_arg() {
        Formatter formatter = fc.create("pretty");
        assertEquals(CucumberPrettyFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_usage_formatter_without_file_arg() {
        Formatter formatter = fc.create("usage");
        assertEquals(UsageFormatter.class, formatter.getClass());
    }

    @Test
    public void instantiates_usage_formatter_with_file_arg() throws IOException {
        Formatter formatter = fc.create("usage:" + TempDir.createTempFile().getAbsolutePath());
        assertEquals(UsageFormatter.class, formatter.getClass());
    }
    
    @Test
    public void formatter_does_not_buffer_its_output() throws IOException {
        PrintStream previousSystemOut = System.out;
        OutputStream mockSystemOut = new ByteArrayOutputStream();
        
        try {
            System.setOut(new PrintStream(mockSystemOut));
            
            // Need to create a new formatter factory here since we need it to pick up the new value of System.out
            fc = new FormatterFactory();
            
            ProgressFormatter formatter = (ProgressFormatter) fc.create("progress");
            
            formatter.result(new Result("passed", null, null));
            
            assertThat(mockSystemOut.toString(), is(not("")));
        } finally {
            System.setOut(previousSystemOut);
        }
    }

    @Test
    public void instantiates_single_custom_appendable_formatter_with_stdout() {
        WantsAppendable formatter = (WantsAppendable) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable");
        assertThat(formatter.out, is(instanceOf(PrintStream.class)));
        try {
            fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable");
            fail();
        } catch (CucumberException expected) {
            assertEquals("Only one formatter can use STDOUT, now both cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable " +
                         "and cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable use it. " +
                         "If you use more than one formatter you must specify output path with FORMAT:PATH_OR_URL", expected.getMessage());
        }
    }

    @Test
    public void instantiates_custom_appendable_formatter_with_stdout_and_file() throws IOException {
        WantsAppendable formatter = (WantsAppendable) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable");
        assertThat(formatter.out, is(instanceOf(PrintStream.class)));

        WantsAppendable formatter2 = (WantsAppendable) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsAppendable:" + TempDir.createTempFile().getAbsolutePath());
        assertEquals(UTF8OutputStreamWriter.class, formatter2.out.getClass());
    }

    @Test
    public void instantiates_custom_url_formatter() throws IOException {
        WantsUrl formatter = (WantsUrl) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsUrl:halp");
        assertEquals(new URL("file:halp/"), formatter.out);
    }

    @Test
    public void instantiates_custom_url_formatter_with_http() throws IOException {
        WantsUrl formatter = (WantsUrl) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsUrl:http://halp/");
        assertEquals(new URL("http://halp/"), formatter.out);
    }

    @Test
    public void instantiates_custom_uri_formatter_with_ws() throws IOException, URISyntaxException {
        WantsUri formatter = (WantsUri) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsUri:ws://halp/");
        assertEquals(new URI("ws://halp/"), formatter.out);
    }

    @Test
    public void instantiates_custom_file_formatter() throws IOException {
        WantsFile formatter = (WantsFile) fc.create("cucumber.runtime.formatter.FormatterFactoryTest$WantsFile:halp.txt");
        assertEquals(new File("halp.txt"), formatter.out);
    }

    public static class WantsAppendable extends StubFormatter {
        public final Appendable out;

        public WantsAppendable(Appendable out) {
            this.out = out;
        }
    }

    public static class WantsUrl extends StubFormatter {
        public final URL out;

        public WantsUrl(URL out) {
            this.out = out;
        }
    }

    public static class WantsUri extends StubFormatter {
        public final URI out;

        public WantsUri(URI out) {
            this.out = out;
        }
    }

    public static class WantsFile extends StubFormatter {
        public final File out;

        public WantsFile(File out) {
            this.out = out;
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_35438bf_e073420/rev_35438bf-e073420/core/src/main/java/cucumber/runtime/formatter/FormatterFactory.java;<<<<<<< MINE
||||||| BASE
package cucumber.runtime.formatter;

import cucumber.runtime.CucumberException;
import cucumber.runtime.io.URLOutputStream;
import cucumber.runtime.io.UTF8OutputStreamWriter;
import gherkin.formatter.Formatter;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static cucumber.runtime.Utils.toURL;
import static java.util.Arrays.asList;

/**
 * This class creates {@link Formatter} instances (that may also implement {@link gherkin.formatter.Reporter} from
 * a String.
 * <p/>
 * The String is of the form name[:output] where name is either a fully qualified class name or one of the built-in short names.
 * output is optional for some formatters (and mandatory for some) and must refer to a path on the file system.
 * <p/>
 * The formatter class must have a constructor that is either empty or takes a single argument of one of the following types:
 * <ul>
 * <li>{@link Appendable}</li>
 * <li>{@link File}</li>
 * <li>{@link URL}</li>
 * <li>{@link URI}</li>
 * </ul>
 */
public class FormatterFactory {
    private final Class[] CTOR_ARGS = new Class[]{null, Appendable.class, URI.class, URL.class, File.class};

    private static final Map<String, Class<? extends Formatter>> FORMATTER_CLASSES = new HashMap<String, Class<? extends Formatter>>() {{
        put("null", NullFormatter.class);
        put("junit", JUnitFormatter.class);
        put("html", HTMLFormatter.class);
        put("pretty", CucumberPrettyFormatter.class);
        put("progress", ProgressFormatter.class);
        put("json", CucumberJSONFormatter.class);
        put("usage", UsageFormatter.class);
        put("rerun", RerunFormatter.class);
    }};
    private static final Pattern FORMATTER_WITH_FILE_PATTERN = Pattern.compile("([^:]+):(.*)");
    private Appendable defaultOut = new PrintStream(System.out) {
        @Override
        public void close() {
            // We have no intention to close System.out
        }
    };

    public Formatter create(String formatterString) {
        Matcher formatterWithFile = FORMATTER_WITH_FILE_PATTERN.matcher(formatterString);
        String formatterName;
        String path = null;
        if (formatterWithFile.matches()) {
            formatterName = formatterWithFile.group(1);
            path = formatterWithFile.group(2);
        } else {
            formatterName = formatterString;
        }
        Class<? extends Formatter> formatterClass = formatterClass(formatterName);
        try {
            return instantiate(formatterString, formatterClass, path);
        } catch (IOException e) {
            throw new CucumberException(e);
        } catch (URISyntaxException e) {
            throw new CucumberException(e);
        }
    }

    private Formatter instantiate(String formatterString, Class<? extends Formatter> formatterClass, String pathOrUrl) throws IOException, URISyntaxException {
        for (Class ctorArgClass : CTOR_ARGS) {
            Constructor<? extends Formatter> constructor = findConstructor(formatterClass, ctorArgClass);
            if (constructor != null) {
                Object ctorArg = convertOrNull(pathOrUrl, ctorArgClass);
                try {
                    if (ctorArgClass == null) {
                        return constructor.newInstance();
                    } else {
                        if (ctorArg == null) {
                            throw new CucumberException(String.format("You must supply an output argument to %s. Like so: %s:output", formatterString, formatterString));
                        }
                        return constructor.newInstance(ctorArg);
                    }
                } catch (InstantiationException e) {
                    throw new CucumberException(e);
                } catch (IllegalAccessException e) {
                    throw new CucumberException(e);
                } catch (InvocationTargetException e) {
                    throw new CucumberException(e.getTargetException());
                }
            }
        }
        throw new CucumberException(String.format("%s must have a constructor that is either empty or a single arg of one of: %s", formatterClass, asList(CTOR_ARGS)));
    }

    private Object convertOrNull(String pathOrUrl, Class ctorArgClass) throws IOException, URISyntaxException {
        if (ctorArgClass == null) {
            return null;
        }
        if (ctorArgClass.equals(URI.class)) {
            if (pathOrUrl != null) {
                return new URI(pathOrUrl);
            }
        }
        if (ctorArgClass.equals(URL.class)) {
            if (pathOrUrl != null) {
                return toURL(pathOrUrl);
            }
        }
        if (ctorArgClass.equals(File.class)) {
            if (pathOrUrl != null) {
                return new File(pathOrUrl);
            }
        }
        if (ctorArgClass.equals(Appendable.class)) {
            if (pathOrUrl != null) {
                return new UTF8OutputStreamWriter(new URLOutputStream(toURL(pathOrUrl)));
            } else {
                return defaultOutOrFailIfAlreadyUsed();
            }
        }
        return null;
    }

    private Constructor<? extends Formatter> findConstructor(Class<? extends Formatter> formatterClass, Class<?> ctorArgClass) {
        try {
            if (ctorArgClass == null) {
                return formatterClass.getConstructor();
            } else {
                return formatterClass.getConstructor(ctorArgClass);
            }
        } catch (NoSuchMethodException e) {
            return null;
        }
    }

    private Class<? extends Formatter> formatterClass(String formatterName) {
        Class<? extends Formatter> formatterClass = FORMATTER_CLASSES.get(formatterName);
        if (formatterClass == null) {
            formatterClass = loadClass(formatterName);
        }
        return formatterClass;
    }

    @SuppressWarnings("unchecked")
    private Class<? extends Formatter> loadClass(String className) {
        try {
            return (Class<? extends Formatter>) Thread.currentThread().getContextClassLoader().loadClass(className);
        } catch (ClassNotFoundException e) {
            throw new CucumberException("Couldn't load formatter class: " + className, e);
        }
    }

    private Appendable defaultOutOrFailIfAlreadyUsed() {
        try {
            if (defaultOut != null) {
                return defaultOut;
            } else {
                throw new CucumberException("Only one formatter can use STDOUT. If you use more than one formatter you must specify output path with FORMAT:PATH_OR_URL");
            }
        } finally {
            defaultOut = null;
        }
    }
}=======
package cucumber.runtime.formatter;

import cucumber.runtime.CucumberException;
import cucumber.runtime.io.URLOutputStream;
import cucumber.runtime.io.UTF8OutputStreamWriter;
import gherkin.formatter.Formatter;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static cucumber.runtime.Utils.toURL;
import static java.util.Arrays.asList;

/**
 * This class creates {@link Formatter} instances (that may also implement {@link gherkin.formatter.Reporter} from
 * a String.
 * <p/>
 * The String is of the form name[:output] where name is either a fully qualified class name or one of the built-in short names.
 * output is optional for some formatters (and mandatory for some) and must refer to a path on the file system.
 * <p/>
 * The formatter class must have a constructor that is either empty or takes a single argument of one of the following types:
 * <ul>
 * <li>{@link Appendable}</li>
 * <li>{@link File}</li>
 * <li>{@link URL}</li>
 * <li>{@link URI}</li>
 * </ul>
 */
public class FormatterFactory {
    private final Class[] CTOR_ARGS = new Class[]{null, Appendable.class, URI.class, URL.class, File.class};

    private static final Map<String, Class<? extends Formatter>> FORMATTER_CLASSES = new HashMap<String, Class<? extends Formatter>>() {{
        put("null", NullFormatter.class);
        put("junit", JUnitFormatter.class);
        put("html", HTMLFormatter.class);
        put("pretty", CucumberPrettyFormatter.class);
        put("progress", ProgressFormatter.class);
        put("json", CucumberJSONFormatter.class);
        put("usage", UsageFormatter.class);
        put("rerun", RerunFormatter.class);
    }};
    private static final Pattern FORMATTER_WITH_FILE_PATTERN = Pattern.compile("([^:]+):(.*)");
    private String defaultOutFormatter = null;
    private Appendable defaultOut = new PrintStream(System.out) {
        @Override
        public void close() {
            // We have no intention to close System.out
        }
    };

    public Formatter create(String formatterString) {
        Matcher formatterWithFile = FORMATTER_WITH_FILE_PATTERN.matcher(formatterString);
        String formatterName;
        String path = null;
        if (formatterWithFile.matches()) {
            formatterName = formatterWithFile.group(1);
            path = formatterWithFile.group(2);
        } else {
            formatterName = formatterString;
        }
        Class<? extends Formatter> formatterClass = formatterClass(formatterName);
        try {
            return instantiate(formatterString, formatterClass, path);
        } catch (IOException e) {
            throw new CucumberException(e);
        } catch (URISyntaxException e) {
            throw new CucumberException(e);
        }
    }

    private Formatter instantiate(String formatterString, Class<? extends Formatter> formatterClass, String pathOrUrl) throws IOException, URISyntaxException {
        for (Class ctorArgClass : CTOR_ARGS) {
            Constructor<? extends Formatter> constructor = findConstructor(formatterClass, ctorArgClass);
            if (constructor != null) {
                Object ctorArg = convertOrNull(pathOrUrl, ctorArgClass, formatterString);
                try {
                    if (ctorArgClass == null) {
                        return constructor.newInstance();
                    } else {
                        if (ctorArg == null) {
                            throw new CucumberException(String.format("You must supply an output argument to %s. Like so: %s:output", formatterString, formatterString));
                        }
                        return constructor.newInstance(ctorArg);
                    }
                } catch (InstantiationException e) {
                    throw new CucumberException(e);
                } catch (IllegalAccessException e) {
                    throw new CucumberException(e);
                } catch (InvocationTargetException e) {
                    throw new CucumberException(e.getTargetException());
                }
            }
        }
        throw new CucumberException(String.format("%s must have a constructor that is either empty or a single arg of one of: %s", formatterClass, asList(CTOR_ARGS)));
    }

    private Object convertOrNull(String pathOrUrl, Class ctorArgClass, String formatterString) throws IOException, URISyntaxException {
        if (ctorArgClass == null) {
            return null;
        }
        if (ctorArgClass.equals(URI.class)) {
            if (pathOrUrl != null) {
                return new URI(pathOrUrl);
            }
        }
        if (ctorArgClass.equals(URL.class)) {
            if (pathOrUrl != null) {
                return toURL(pathOrUrl);
            }
        }
        if (ctorArgClass.equals(File.class)) {
            if (pathOrUrl != null) {
                return new File(pathOrUrl);
            }
        }
        if (ctorArgClass.equals(Appendable.class)) {
            if (pathOrUrl != null) {
                return new UTF8OutputStreamWriter(new URLOutputStream(toURL(pathOrUrl)));
            } else {
                return defaultOutOrFailIfAlreadyUsed(formatterString);
            }
        }
        return null;
    }

    private Constructor<? extends Formatter> findConstructor(Class<? extends Formatter> formatterClass, Class<?> ctorArgClass) {
        try {
            if (ctorArgClass == null) {
                return formatterClass.getConstructor();
            } else {
                return formatterClass.getConstructor(ctorArgClass);
            }
        } catch (NoSuchMethodException e) {
            return null;
        }
    }

    private Class<? extends Formatter> formatterClass(String formatterName) {
        Class<? extends Formatter> formatterClass = FORMATTER_CLASSES.get(formatterName);
        if (formatterClass == null) {
            formatterClass = loadClass(formatterName);
        }
        return formatterClass;
    }

    @SuppressWarnings("unchecked")
    private Class<? extends Formatter> loadClass(String className) {
        try {
            return (Class<? extends Formatter>) Thread.currentThread().getContextClassLoader().loadClass(className);
        } catch (ClassNotFoundException e) {
            throw new CucumberException("Couldn't load formatter class: " + className, e);
        }
    }

    private Appendable defaultOutOrFailIfAlreadyUsed(String formatterString) {
        try {
            if (defaultOut != null) {
                defaultOutFormatter = formatterString;
                return defaultOut;
            } else {
                throw new CucumberException("Only one formatter can use STDOUT, now both " +
                        defaultOutFormatter + " and " + formatterString + " use it. " +
                        "If you use more than one formatter you must specify output path with FORMAT:PATH_OR_URL");
            }
        } finally {
            defaultOut = null;
        }
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyBackend.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/main/java/cucumber/runtime/groovy/GroovyWorld.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/ParallelTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyWorldTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_7f4f543_1cd5727/rev_7f4f543-1cd5727/groovy/src/test/java/cucumber/runtime/groovy/GroovyBackendTest.java;null
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_1ed7dab_a53cde8/rev_1ed7dab-a53cde8/spring/src/test/java/cucumber/runtime/java/spring/BellyStepdefs.java;<<<<<<< MINE
||||||| BASE
package cucumber.runtime.java.spring;

import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;

import static org.junit.Assert.assertEquals;

@ContextConfiguration("classpath:cucumber.xml")
public class BellyStepdefs {

    @Autowired
    private Belly belly;

    @Autowired
    private BellyBean bellyBean;

    @Then("^there are (\\d+) cukes in my belly")
    public void checkCukes(final int n) {
        assertEquals(n, belly.getCukes());
    }

    @Given("^I have (\\d+) cukes in my belly")
    public void haveCukes(final int n) {
        belly.setCukes(n);
    }

    @Given("^I have (\\d+) beans in my belly$")
    public void I_have_beans_in_my_belly(int n) {
        bellyBean.setCukes(n);
    }

    @Then("^there are (\\d+) beans in my belly$")
    public void there_are_beans_in_my_belly(int n) {
        assertEquals(n, bellyBean.getCukes());
    }

    public BellyBean getBellyBean() {
        return bellyBean;
    }

}=======
package cucumber.runtime.java.spring;

import cucumber.api.java.en.Then;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;

import static org.junit.Assert.assertNotNull;

@ContextConfiguration("classpath:cucumber.xml")
public class BellyStepdefs {

    @Autowired
    private Belly belly;

    @Autowired
    private BellyBean bellyBean;

    public BellyBean getBellyBean() {
        return bellyBean;
    }

    @Then("^I have belly$")
    public void I_have_belly() throws Throwable {
        assertNotNull(belly);
    }

    @Then("^I have belly bean$")
    public void I_have_belly_bean() throws Throwable {
        assertNotNull(bellyBean);
    }
}>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_97da422_df03361/rev_97da422-df03361/core/src/main/java/cucumber/runtime/RuntimeOptions.java;<<<<<<< MINE
import gherkin.I18n;
||||||| BASE
=======
import cucumber.runtime.model.PathWithLines;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_950172a_fd317c3/rev_950172a-fd317c3/core/src/test/java/cucumber/runtime/RuntimeOptionsTest.java;<<<<<<< MINE
}

class FormatterMissingLifecycleMethods implements Formatter, Reporter {
    @Override
    public void startOfScenarioLifeCycle(gherkin.formatter.model.Scenario arg0) {
        throw new NoSuchMethodError(); // simulate that this method is not implemented
    }

    @Override
    public void endOfScenarioLifeCycle(gherkin.formatter.model.Scenario arg0) {
        throw new NoSuchMethodError(); // simulate that this method is not implemented
    }

    @Override
    public void after(Match arg0, Result arg1) {
    }

    @Override
    public void before(Match arg0, Result arg1) {
    }

    @Override
    public void embedding(String arg0, byte[] arg1) {
    }

    @Override
    public void match(Match arg0) {
    }

    @Override
    public void result(Result arg0) {
    }

    @Override
    public void write(String arg0) {
    }

    @Override
    public void background(Background arg0) {
    }

    @Override
    public void close() {
    }

    @Override
    public void done() {
    }

    @Override
    public void eof() {
    }

    @Override
    public void examples(Examples arg0) {
    }

    @Override
    public void feature(Feature arg0) {

    }

    @Override
    public void scenario(gherkin.formatter.model.Scenario arg0) {

    }

    @Override
    public void scenarioOutline(ScenarioOutline arg0) {
    }

    @Override
    public void step(Step arg0) {
    }

    @Override
    public void syntaxError(String arg0, String arg1, List<String> arg2, String arg3, Integer arg4) {
    }

    @Override
    public void uri(String arg0) {
    }

||||||| BASE
=======

    private void assertPluginExists(List<Object> plugins, String pluginName) {
        assertTrue(pluginName + " not found among the plugins", pluginExists(plugins, pluginName));
    }

    private void assertPluginNotExists(List<Object> plugins, String pluginName) {
        assertFalse(pluginName + " found among the plugins", pluginExists(plugins, pluginName));
    }

    private boolean pluginExists(List<Object> plugins, String pluginName) {
        boolean found = false;
        for (Object plugin : plugins) {
            if (plugin.getClass().getName() == pluginName) {
                found = true;
            }
        }
        return found;
    }
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_950172a_fd317c3/rev_950172a-fd317c3/core/src/main/java/cucumber/runtime/model/CucumberScenario.java;<<<<<<< MINE
        formatter.endOfScenarioLifeCycle((Scenario) getGherkinModel());
        runtime.disposeBackendWorlds();
||||||| BASE
        try {
            formatter.endOfScenarioLifeCycle((Scenario) getGherkinModel());
        } catch (Throwable ignore) {
            // IntelliJ has its own formatter which doesn't yet implement this.
        }
        runtime.disposeBackendWorlds();
=======
        try {
            formatter.endOfScenarioLifeCycle((Scenario) getGherkinModel());
        } catch (Throwable ignore) {
            // IntelliJ has its own formatter which doesn't yet implement this.
        }
        runtime.disposeBackendWorlds(createScenarioDesignation());
    }

    private String createScenarioDesignation() {
        return cucumberFeature.getPath() + ":" + Integer.toString(scenario.getLine()) + " # " +
                scenario.getKeyword() + ": " + scenario.getName();
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b66c765_0ac2df0/rev_b66c765-0ac2df0/core/src/main/java/cucumber/runtime/RuntimeOptions.java;<<<<<<< MINE
        if (!parsedJunitOptions.isEmpty()) {
            junitOptions.clear();
            junitOptions.addAll(parsedJunitOptions);
        }
    }
||||||| BASE
    }
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_b66c765_0ac2df0/rev_b66c765-0ac2df0/core/src/main/java/cucumber/runtime/RuntimeOptions.java;<<<<<<< MINE

    public List<String> getJunitOptions() {
        return junitOptions;
    }
||||||| BASE
=======
}

class ParsedPluginData {
    ParsedOptionNames formatterNames = new ParsedOptionNames();
    ParsedOptionNames stepDefinitionReporterNames = new ParsedOptionNames();
    ParsedOptionNames summaryPrinterNames = new ParsedOptionNames();

    public void addPluginName(String name, boolean isAddPlugin) {
        if (PluginFactory.isFormatterName(name)) {
            formatterNames.addName(name, isAddPlugin);
        } else if (PluginFactory.isStepDefinitionResporterName(name)) {
            stepDefinitionReporterNames.addName(name, isAddPlugin);
        } else if (PluginFactory.isSummaryPrinterName(name)) {
            summaryPrinterNames.addName(name, isAddPlugin);
        } else {
            throw new CucumberException("Unrecognized plugin: " + name);
        }
    }

    public void updatePluginFormatterNames(List<String> pluginFormatterNames) {
        formatterNames.updateNameList(pluginFormatterNames);
    }

    public void updatePluginStepDefinitionReporterNames(List<String> pluginStepDefinitionReporterNames) {
        stepDefinitionReporterNames.updateNameList(pluginStepDefinitionReporterNames);
    }

    public void updatePluginSummaryPrinterNames(List<String> pluginSummaryPrinterNames) {
        summaryPrinterNames.updateNameList(pluginSummaryPrinterNames);
    }
}

class ParsedOptionNames {
    private List<String> names = new ArrayList<String>();
    private boolean clobber = false;

    public void addName(String name, boolean isAddOption) {
        names.add(name);
        if (!isAddOption) {
            clobber = true;
        }
    }

    public void updateNameList(List<String> nameList) {
        if (!names.isEmpty()) {
            if (clobber) {
                nameList.clear();
            }
            nameList.addAll(names);
        }
    }
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_280113e_9ec2d0f/rev_280113e-9ec2d0f/core/src/test/java/cucumber/runtime/RuntimeOptionsFactoryTest.java;<<<<<<< MINE
import cucumber.runtime.io.ResourceLoader;
||||||| BASE
import gherkin.formatter.JSONFormatter;
import gherkin.formatter.PrettyFormatter;
=======
import cucumber.deps.com.thoughtworks.xstream.annotations.XStreamConverter;
import cucumber.deps.com.thoughtworks.xstream.annotations.XStreamConverters;
import cucumber.deps.com.thoughtworks.xstream.converters.basic.LongConverter;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_280113e_9ec2d0f/rev_280113e-9ec2d0f/core/src/main/java/cucumber/runtime/Runtime.java;<<<<<<< MINE
        Glue glue = optionalGlue != null ? optionalGlue : new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader));
||||||| BASE
        this.stopWatch = stopWatch;
        this.glue = optionalGlue != null ? optionalGlue : new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader));
=======
        this.stopWatch = stopWatch;
        this.glue = optionalGlue != null ? optionalGlue : new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader, runtimeOptions.getConverters()));
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_280113e_9ec2d0f/rev_280113e-9ec2d0f/core/src/main/java/cucumber/runtime/RuntimeOptions.java;<<<<<<< MINE
import cucumber.api.formatter.ColorAware;
import cucumber.api.formatter.Formatter;
import cucumber.api.formatter.StrictAware;
import cucumber.runner.EventBus;
||||||| BASE
import cucumber.runtime.formatter.ColorAware;
=======
import cucumber.deps.com.thoughtworks.xstream.annotations.XStreamConverter;
import cucumber.runtime.formatter.ColorAware;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_280113e_9ec2d0f/rev_280113e-9ec2d0f/core/src/main/java/cucumber/runtime/RuntimeOptions.java;<<<<<<< MINE
import static cucumber.util.FixJava.join;
import static cucumber.util.FixJava.map;
import static java.util.Arrays.asList;
||||||| BASE
=======
import static java.util.Collections.unmodifiableList;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_280113e_9ec2d0f/rev_280113e-9ec2d0f/core/src/main/java/cucumber/runtime/RuntimeOptions.java;<<<<<<< MINE
    private void addLineFilters(Map<String, List<Long>> parsedLineFilters, String key, List<Long> lines) {
        if (parsedLineFilters.containsKey(key)) {
            parsedLineFilters.get(key).addAll(lines);
        } else {
            parsedLineFilters.put(key, lines);
        }
    }

||||||| BASE
=======
    RuntimeOptions withConverters(List<XStreamConverter> converters) {
        this.converters.addAll(converters);
        return this;
    }

>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_062758b_636471a/rev_062758b-636471a/core/src/test/java/cucumber/runtime/RuntimeTest.java;<<<<<<< MINE
import gherkin.events.PickleEvent;
import gherkin.pickles.Pickle;
import gherkin.pickles.PickleLocation;
import gherkin.pickles.PickleStep;
import gherkin.pickles.PickleTag;
||||||| BASE
import gherkin.I18n;
import gherkin.formatter.Formatter;
import gherkin.formatter.JSONFormatter;
import gherkin.formatter.Reporter;
import gherkin.formatter.model.Result;
import gherkin.formatter.model.Step;
import gherkin.formatter.model.Tag;
=======
import cucumber.runtime.xstream.LocalizedXStreams;
import gherkin.I18n;
import gherkin.formatter.Formatter;
import gherkin.formatter.JSONFormatter;
import gherkin.formatter.Reporter;
import gherkin.formatter.model.Result;
import gherkin.formatter.model.Step;
import gherkin.formatter.model.Tag;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_062758b_636471a/rev_062758b-636471a/core/src/main/java/cucumber/runtime/Runtime.java;<<<<<<< MINE
||||||| BASE
    static {
        Arrays.sort(PENDING_EXCEPTIONS);
    }

    private static final Object DUMMY_ARG = new Object();
    private static final byte ERRORS = 0x1;

    private final Stats stats;
    final UndefinedStepsTracker undefinedStepsTracker = new UndefinedStepsTracker();

    private final Glue glue;
=======
    static {
        Arrays.sort(PENDING_EXCEPTIONS);
    }

    private static final Object DUMMY_ARG = new Object();
    private static final byte ERRORS = 0x1;

    private final Stats stats;
    final UndefinedStepsTracker undefinedStepsTracker;

    private final Glue glue;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_062758b_636471a/rev_062758b-636471a/core/src/main/java/cucumber/runtime/Runtime.java;<<<<<<< MINE
        Glue glue = optionalGlue != null ? optionalGlue : new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader, runtimeOptions.getConverters()));
||||||| BASE
        this.stopWatch = stopWatch;
        this.glue = optionalGlue != null ? optionalGlue : new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader));
=======
        this.stopWatch = stopWatch;
        if (optionalGlue == null) {
            this.undefinedStepsTracker = new UndefinedStepsTracker();
            this.glue = new RuntimeGlue(undefinedStepsTracker, new LocalizedXStreams(classLoader));
        } else {
            this.undefinedStepsTracker = optionalGlue.getTracker();
            this.glue = optionalGlue;
        }
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_062758b_636471a/rev_062758b-636471a/junit/src/test/java/cucumber/runtime/junit/FeatureRunnerTest.java;<<<<<<< MINE
import cucumber.runner.TimeService;
import cucumber.runtime.Backend;
||||||| BASE
import cucumber.runtime.Backend;
=======
import cucumber.runtime.*;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_062758b_636471a/rev_062758b-636471a/junit/src/test/java/cucumber/runtime/junit/FeatureRunnerTest.java;<<<<<<< MINE
import cucumber.runtime.RuntimeGlue;
import cucumber.runtime.RuntimeOptions;
||||||| BASE
import cucumber.runtime.RuntimeGlue;
import cucumber.runtime.RuntimeOptions;
import cucumber.runtime.StopWatch;
=======
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_062758b_636471a/rev_062758b-636471a/junit/src/test/java/cucumber/runtime/junit/FeatureRunnerTest.java;<<<<<<< MINE
import static org.mockito.Mockito.times;
||||||| BASE
=======
import static org.mockito.Mockito.when;
>>>>>>> YOURS
/home/ramdisk/experiment4/projects/cucumber-jvm/revisions/rev_062758b_636471a/rev_062758b-636471a/junit/src/test/java/cucumber/runtime/junit/FeatureRunnerTest.java;<<<<<<< MINE
        final TimeService timeServiceStub = new TimeService() {
            @Override
            public long time() {
                return 0l;
            }
        };
        final Runtime runtime = new Runtime(resourceLoader, classLoader, asList(mock(Backend.class)), runtimeOptions, timeServiceStub, glue);
        return new FeatureRunner(cucumberFeature, runtime, new JUnitReporter(runtime.getEventBus(), false, junitOption));
    }


    @Test
    public void should_populate_descriptions_with_stable_unique_ids() throws Exception {
        CucumberFeature cucumberFeature = TestPickleBuilder.parseFeature("path/test.feature", "" +
            "Feature: feature name\n" +
            "  Background:\n" +
            "    Given background step\n" +
            "  Scenario: A\n" +
            "    Then scenario name\n" +
            "  Scenario: B\n" +
            "    Then scenario name\n" +
            "  Scenario Outline: C\n" +
            "    Then scenario <name>\n" +
            "  Examples:\n" +
            "    | name |\n" +
            "    | C    |\n" +
            "    | D    |\n" +
            "    | E    |\n"

        );

        FeatureRunner runner = createFeatureRunner(cucumberFeature);
        FeatureRunner rerunner = createFeatureRunner(cucumberFeature);

        Set<Description> descriptions = new HashSet<Description>();
        assertDescriptionIsUnique(runner.getDescription(), descriptions);
        assertDescriptionIsPredictable(runner.getDescription(), descriptions);
        assertDescriptionIsPredictable(rerunner.getDescription(), descriptions);

    }

    @Test
    public void should_not_create_step_descriptions_by_default() throws Exception {
        CucumberFeature cucumberFeature = TestPickleBuilder.parseFeature("path/test.feature", "" +
            "Feature: feature name\n" +
            "  Background:\n" +
            "    Given background step\n" +
            "  Scenario: A\n" +
            "    Then scenario name\n" +
            "  Scenario: B\n" +
            "    Then scenario name\n" +
            "  Scenario Outline: C\n" +
            "    Then scenario <name>\n" +
            "  Examples:\n" +
            "    | name |\n" +
            "    | C    |\n" +
            "    | D    |\n" +
            "    | E    |\n"

        );

        FeatureRunner runner = createFeatureRunner(cucumberFeature);

        Description feature = runner.getDescription();
        Description scenarioA = feature.getChildren().get(0);
        assertTrue(scenarioA.getChildren().isEmpty());
        Description scenarioB = feature.getChildren().get(1);
        assertTrue(scenarioB.getChildren().isEmpty());
        Description scenarioC0 = feature.getChildren().get(2);
        assertTrue(scenarioC0.getChildren().isEmpty());
        Description scenarioC1 = feature.getChildren().get(3);
        assertTrue(scenarioC1.getChildren().isEmpty());
        Description scenarioC2 = feature.getChildren().get(4);
        assertTrue(scenarioC2.getChildren().isEmpty());
    }

    @Test
    public void step_descriptions_can_be_turned_on() throws Exception {
        CucumberFeature cucumberFeature = TestPickleBuilder.parseFeature("path/test.feature", "" +
            "Feature: feature name\n" +
            "  Background:\n" +
            "    Given background step\n" +
            "  Scenario: A\n" +
            "    Then scenario name\n" +
            "  Scenario: B\n" +
            "    Then scenario name\n" +
            "  Scenario Outline: C\n" +
            "    Then scenario <name>\n" +
            "  Examples:\n" +
            "    | name |\n" +
            "    | C    |\n" +
            "    | D    |\n" +
            "    | E    |\n"

        );

        FeatureRunner runner = createFeatureRunner(cucumberFeature, "--step-notifications");

        Description feature = runner.getDescription();
        Description scenarioA = feature.getChildren().get(0);
        assertEquals(2, scenarioA.getChildren().size());
        Description scenarioB = feature.getChildren().get(1);
        assertEquals(2, scenarioB.getChildren().size());
        Description scenarioC0 = feature.getChildren().get(2);
        assertEquals(2, scenarioC0.getChildren().size());
        Description scenarioC1 = feature.getChildren().get(3);
        assertEquals(2, scenarioC1.getChildren().size());
        Description scenarioC2 = feature.getChildren().get(4);
        assertEquals(2, scenarioC2.getChildren().size());
    }

    private static void assertDescriptionIsUnique(Description description, Set<Description> descriptions) {
        // Note: JUnit uses the the serializable parameter as the unique id when comparing Descriptions
        assertTrue(descriptions.add(description));
        for (Description each : description.getChildren()) {
            assertDescriptionIsUnique(each, descriptions);
        }
    }

    private static void assertDescriptionIsPredictable(Description description, Set<Description> descriptions) {
        assertTrue(descriptions.contains(description));
        for (Description each : description.getChildren()) {
            assertDescriptionIsPredictable(each, descriptions);
        }
||||||| BASE
        final Runtime runtime = new Runtime(resourceLoader, classLoader, asList(mock(Backend.class)), runtimeOptions, new StopWatch.Stub(0l), glue);
        FormatterSpy formatterSpy = new FormatterSpy();
        FeatureRunner runner = new FeatureRunner(cucumberFeature, runtime, new JUnitReporter(formatterSpy, formatterSpy, false, new JUnitOptions(Collections.<String>emptyList())));
        runner.run(mock(RunNotifier.class));
        return formatterSpy.toString();
=======
        when(glue.getTracker()).thenReturn(new UndefinedStepsTracker());
        final Runtime runtime = new Runtime(resourceLoader, classLoader, asList(mock(Backend.class)), runtimeOptions, new StopWatch.Stub(0l), glue);
        FormatterSpy formatterSpy = new FormatterSpy();
        FeatureRunner runner = new FeatureRunner(cucumberFeature, runtime, new JUnitReporter(formatterSpy, formatterSpy, false, new JUnitOptions(Collections.<String>emptyList())));
        runner.run(mock(RunNotifier.class));
        return formatterSpy.toString();
>>>>>>> YOURS
