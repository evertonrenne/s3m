file;linedbasedConf
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/test/java/com/netflix/astyanax/serializers/SerializerPackageImplTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/test/java/com/netflix/astyanax/serializers/SerializersTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/test/java/com/netflix/astyanax/serializers/SerializersTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/SerializerPackageImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/SerializerPackageImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/SerializerPackageImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/CompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/CompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/CompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/SpecificCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/SpecificCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/SpecificCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/SpecificCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_37833de_497bc19/rev_37833de-497bc19/src/main/java/com/netflix/astyanax/serializers/SpecificCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_10859c3_8c71eab/rev_10859c3-8c71eab/src/main/java/com/netflix/astyanax/connectionpool/impl/ConnectionPoolConfigurationImpl.java;<<<<<<< MINE

||||||| BASE
=======
import com.google.common.util.concurrent.ThreadFactoryBuilder;
>>>>>>> YOURS
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_10859c3_8c71eab/rev_10859c3-8c71eab/src/main/java/com/netflix/astyanax/connectionpool/impl/ConnectionPoolConfigurationImpl.java;<<<<<<< MINE
    public static final String DEFAULT_SSL_PROTOCOL = "TLS";
    public static final List<String> DEFAULT_SSL_CIPHER_SUITES = Arrays.asList("TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA");
||||||| BASE
=======
    private static final int DEFAULT_RECONNECT_THREAD_COUNT = 5;
    private static final int DEFAULT_MAINTAINANCE_THREAD_COUNT = 1;
>>>>>>> YOURS
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_10859c3_8c71eab/rev_10859c3-8c71eab/src/main/java/com/netflix/astyanax/connectionpool/impl/ConnectionPoolConfigurationImpl.java;<<<<<<< MINE
    private String sslTruststore;
    private String sslTruststorePassword;

||||||| BASE

=======
    private ScheduledExecutorService maintainanceExecutor;
    private ScheduledExecutorService reconnectExecutor;
    
    private boolean bOwnMaintainanceExecutor              = false;
    private boolean bOwnReconnectExecutor                 = false;
            
>>>>>>> YOURS
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_10859c3_8c71eab/rev_10859c3-8c71eab/src/main/java/com/netflix/astyanax/connectionpool/impl/ConnectionPoolConfigurationImpl.java;<<<<<<< MINE
    public boolean isUsingSsl() {
        return useSsl;
    }

    public ConnectionPoolConfigurationImpl setUsingSsl(boolean useSsl) {
        this.useSsl = useSsl;
        return this;
    }

    public String getSslProtocol() {
        return sslProtocol;
    }

    public ConnectionPoolConfigurationImpl setSslProtocol(String sslProtocol) {
        this.sslProtocol = sslProtocol;
        return this;
    }

    public List<String> getSslCipherSuites() {
        return sslCipherSuites;
    }

    public ConnectionPoolConfigurationImpl setSslCipherSuites(List<String> sslCipherSuites) {
        this.sslCipherSuites = sslCipherSuites;
        return this;
    }

    public String getSslTruststore() {
        return sslTruststore;
    }

    public ConnectionPoolConfigurationImpl setSslTruststore(String truststore) {
        this.sslTruststore = truststore;
        return this;
    }

    public String getSslTruststorePassword() {
        return sslTruststorePassword;
    }

    public ConnectionPoolConfigurationImpl setSslTruststorePassword(String passwd) {
        this.sslTruststorePassword = passwd;
        return this;
    }
||||||| BASE
=======
    @Override
    public ScheduledExecutorService getMaintainanceScheduler() {
        return maintainanceExecutor;
    }

    public ConnectionPoolConfigurationImpl setMaintainanceScheduler(ScheduledExecutorService executor) {
        maintainanceExecutor = executor;
        bOwnMaintainanceExecutor = false;
        return this;
    }

    @Override
    public ScheduledExecutorService getHostReconnectExecutor() {
        return this.reconnectExecutor;
    }

    public ConnectionPoolConfigurationImpl setHostReconnectExecutor(ScheduledExecutorService executor) {
        reconnectExecutor = executor;
        bOwnReconnectExecutor = false;
        return this;
    }

>>>>>>> YOURS
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_10859c3_8c71eab/rev_10859c3-8c71eab/src/main/java/com/netflix/astyanax/connectionpool/ConnectionPoolConfiguration.java;<<<<<<< MINE

    // ssl values

    /**
     * Declares if connections should be made using SSL.
     */
    boolean isUsingSsl();

    /**
     * SSL protocol (typically, TLS)
     */
    String getSslProtocol();

    /**
     * The SSL ciphers to use. Common examples, often default, are
     * TLS_RSA_WITH_AES_128_CBC_SHA and TLS_RSA_WITH_AES_256_CBC_SHA
     */
    List<String> getSslCipherSuites();

    /**
     * path to SSL truststore
     */
    String getSslTruststore();

    /**
     * password to SSL truststore
     */
    String getSslTruststorePassword();
||||||| BASE
=======
    
    /**
     * Return executor service used for maintenance tasks.  This pool is used for internal
     * operations that update stats such as token aware scores.  Threads in this pool 
     * and not expected to block on I/O and the pool can therefore be very small
     * @return
     */
    ScheduledExecutorService getMaintainanceScheduler();

    /**
     * Return executor service used to reconnect hosts.  Keep in mind that the threads 
     * may be blocked for an extended duration while trying to reconnect to a downed host
     * @return
     */
    ScheduledExecutorService getHostReconnectExecutor();

    /**
     * Initialization prior to starting the connection pool 
     */
    void initialize();

    /**
     * Shutdown after stopping the connection pool
     */
    void shutdown();
>>>>>>> YOURS
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftSuperColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftSuperColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftSuperColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftCounterColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftCounterColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftCounterSuperColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftCounterSuperColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/thrift/model/ThriftColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/shallows/EmptyColumn.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/shallows/EmptyColumn.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/shallows/EmptyColumn.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/model/Column.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/model/Column.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/serializers/StringCoercibleSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Mapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Coercions.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Coercions.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Coercions.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/Coercions.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/StringCoercible.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/MappingCache.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/MappingCache.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/MappingCache.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/MappingCache.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_eac3380_e943beb/rev_eac3380-e943beb/src/main/java/com/netflix/astyanax/mapping/MappingCache.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_d37b242_448ab28/rev_d37b242-448ab28/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_7b2d506_3a9a24e/rev_7b2d506-3a9a24e/src/test/java/com/netflix/astyanax/thrift/ThrifeKeyspaceImplTest.java;<<<<<<< MINE
package com.netflix.astyanax.thrift;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringReader;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicLong;

import javax.annotation.Nullable;

import junit.framework.Assert;

import org.apache.cassandra.utils.Pair;
import org.apache.commons.lang.RandomStringUtils;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Function;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.netflix.astyanax.AstyanaxContext;
import com.netflix.astyanax.Cluster;
import com.netflix.astyanax.ColumnListMutation;
import com.netflix.astyanax.ExceptionCallback;
import com.netflix.astyanax.Keyspace;
import com.netflix.astyanax.MutationBatch;
import com.netflix.astyanax.RowCallback;
import com.netflix.astyanax.Serializer;
import com.netflix.astyanax.SerializerPackage;
import com.netflix.astyanax.connectionpool.Host;
import com.netflix.astyanax.connectionpool.NodeDiscoveryType;
import com.netflix.astyanax.connectionpool.OperationResult;
import com.netflix.astyanax.connectionpool.TokenRange;
import com.netflix.astyanax.connectionpool.exceptions.ConnectionException;
import com.netflix.astyanax.connectionpool.exceptions.NotFoundException;
import com.netflix.astyanax.connectionpool.impl.ConnectionPoolConfigurationImpl;
import com.netflix.astyanax.connectionpool.impl.ConnectionPoolType;
import com.netflix.astyanax.connectionpool.impl.CountingConnectionPoolMonitor;
import com.netflix.astyanax.cql.CqlStatementResult;
import com.netflix.astyanax.ddl.ColumnFamilyDefinition;
import com.netflix.astyanax.ddl.FieldMetadata;
import com.netflix.astyanax.ddl.KeyspaceDefinition;
import com.netflix.astyanax.impl.AstyanaxConfigurationImpl;
import com.netflix.astyanax.impl.FilteringHostSupplier;
import com.netflix.astyanax.impl.RingDescribeHostSupplier;
import com.netflix.astyanax.model.Column;
import com.netflix.astyanax.model.ColumnFamily;
import com.netflix.astyanax.model.ColumnList;
import com.netflix.astyanax.model.ColumnSlice;
import com.netflix.astyanax.model.ConsistencyLevel;
import com.netflix.astyanax.model.CqlResult;
import com.netflix.astyanax.model.Equality;
import com.netflix.astyanax.model.Row;
import com.netflix.astyanax.model.Rows;
import com.netflix.astyanax.query.IndexQuery;
import com.netflix.astyanax.query.PreparedIndexExpression;
import com.netflix.astyanax.query.RowQuery;
import com.netflix.astyanax.recipes.UUIDStringSupplier;
import com.netflix.astyanax.recipes.locks.BusyLockException;
import com.netflix.astyanax.recipes.locks.ColumnPrefixDistributedRowLock;
import com.netflix.astyanax.recipes.locks.StaleLockException;
import com.netflix.astyanax.recipes.queue.CountingQueueStats;
import com.netflix.astyanax.recipes.queue.Message;
import com.netflix.astyanax.recipes.queue.MessageConsumer;
import com.netflix.astyanax.recipes.queue.MessageContext;
import com.netflix.astyanax.recipes.queue.MessageHistory;
import com.netflix.astyanax.recipes.queue.MessageProducer;
import com.netflix.astyanax.recipes.queue.MessageQueue;
import com.netflix.astyanax.recipes.queue.MessageQueueDispatcher;
import com.netflix.astyanax.recipes.queue.MessageQueueException;
import com.netflix.astyanax.recipes.queue.SendMessageResponse;
import com.netflix.astyanax.recipes.queue.ShardedDistributedMessageQueue;
import com.netflix.astyanax.recipes.queue.triggers.RepeatingTrigger;
import com.netflix.astyanax.recipes.reader.AllRowsReader;
import com.netflix.astyanax.recipes.uniqueness.ColumnPrefixUniquenessConstraint;
import com.netflix.astyanax.recipes.uniqueness.DedicatedMultiRowUniquenessConstraint;
import com.netflix.astyanax.recipes.uniqueness.MultiRowUniquenessConstraint;
import com.netflix.astyanax.recipes.uniqueness.NotUniqueException;
import com.netflix.astyanax.recipes.uniqueness.RowUniquenessConstraint;
import com.netflix.astyanax.retry.ExponentialBackoff;
import com.netflix.astyanax.serializers.AnnotatedCompositeSerializer;
import com.netflix.astyanax.serializers.ByteBufferSerializer;
import com.netflix.astyanax.serializers.LongSerializer;
import com.netflix.astyanax.serializers.ObjectSerializer;
import com.netflix.astyanax.serializers.PrefixedSerializer;
import com.netflix.astyanax.serializers.SerializerPackageImpl;
import com.netflix.astyanax.serializers.StringSerializer;
import com.netflix.astyanax.serializers.TimeUUIDSerializer;
import com.netflix.astyanax.serializers.UnknownComparatorException;
import com.netflix.astyanax.test.EmbeddedCassandra;
import com.netflix.astyanax.test.SessionEvent;
import com.netflix.astyanax.util.ColumnarRecordWriter;
import com.netflix.astyanax.util.CsvColumnReader;
import com.netflix.astyanax.util.CsvRecordReader;
import com.netflix.astyanax.util.JsonRowsWriter;
import com.netflix.astyanax.util.RangeBuilder;
import com.netflix.astyanax.util.RecordReader;
import com.netflix.astyanax.util.RecordWriter;
import com.netflix.astyanax.util.SingletonEmbeddedCassandra;
import com.netflix.astyanax.util.TimeUUIDUtils;

public class ThrifeKeyspaceImplTest {

    private static Logger LOG = LoggerFactory.getLogger(ThrifeKeyspaceImplTest.class);

    private static Keyspace                  keyspace;
    private static AstyanaxContext<Keyspace> keyspaceContext;

    private static String TEST_CLUSTER_NAME  = "cass_sandbox";
    private static String TEST_KEYSPACE_NAME = "AstyanaxUnitTests";
    private static String SCHEDULER_NAME_CF_NAME = "SchedulerQueue";

    private static ColumnFamily<String, String> CF_USER_INFO = ColumnFamily.newColumnFamily(
            "Standard1", // Column Family Name
            StringSerializer.get(), // Key Serializer
            StringSerializer.get()); // Column Serializer

    private static ColumnFamily<Long, Long> CF_DELETE = ColumnFamily
            .newColumnFamily(
                    "delete", 
                    LongSerializer.get(),
                    LongSerializer.get());
    
    private static ColumnFamily<Long, String> CF_USERS = ColumnFamily
            .newColumnFamily(
                    "users", 
                    LongSerializer.get(),
                    StringSerializer.get());

    private static ColumnFamily<String, String> CF_TTL = ColumnFamily
            .newColumnFamily(
                    "ttl", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, String> CF_STANDARD1 = ColumnFamily
            .newColumnFamily(
                    "Standard1", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, Long> CF_LONGCOLUMN = ColumnFamily
            .newColumnFamily(
                    "LongColumn1", 
                    StringSerializer.get(),
                    LongSerializer.get());

    public static ColumnFamily<String, String> CF_STANDARD2 = ColumnFamily
            .newColumnFamily(
                    "Standard2", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, String> CF_COUNTER1 = ColumnFamily
            .newColumnFamily(
                    "Counter1", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, String> CF_NOT_DEFINED = ColumnFamily
            .newColumnFamily(
                    "NotDefined", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, String> CF_EMPTY = ColumnFamily
            .newColumnFamily(
                    "NotDefined", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static AnnotatedCompositeSerializer<MockCompositeType> M_SERIALIZER = new AnnotatedCompositeSerializer<MockCompositeType>(
            MockCompositeType.class);
    
    public static ColumnFamily<String, MockCompositeType> CF_COMPOSITE = ColumnFamily
            .newColumnFamily(
                    "CompositeColumn", 
                    StringSerializer.get(),
                    M_SERIALIZER);

    public static ColumnFamily<ByteBuffer, ByteBuffer> CF_COMPOSITE_CSV = ColumnFamily
            .newColumnFamily(
                    "CompositeCsv", 
                    ByteBufferSerializer.get(),
                    ByteBufferSerializer.get());

    public static ColumnFamily<MockCompositeType, String> CF_COMPOSITE_KEY = ColumnFamily
            .newColumnFamily(
                    "CompositeKey",
                    M_SERIALIZER, 
                    StringSerializer.get());

    public static ColumnFamily<String, UUID> CF_TIME_UUID = ColumnFamily
            .newColumnFamily(
                    "TimeUUID1", 
                    StringSerializer.get(),
                    TimeUUIDSerializer.get());

    public static ColumnFamily<String, UUID> CF_USER_UNIQUE_UUID = ColumnFamily
            .newColumnFamily(
                    "UserUniqueUUID", 
                    StringSerializer.get(),
                    TimeUUIDSerializer.get());
    
    public static ColumnFamily<String, UUID> CF_EMAIL_UNIQUE_UUID = ColumnFamily
            .newColumnFamily(
                    "EmailUniqueUUID", 
                    StringSerializer.get(),
                    TimeUUIDSerializer.get());
    
    private static ColumnFamily<String, String> UNIQUE_CF = ColumnFamily
            .newColumnFamily(
                    "UniqueCf", 
                    StringSerializer.get(), 
                    StringSerializer.get());

    public static AnnotatedCompositeSerializer<SessionEvent> SE_SERIALIZER = new AnnotatedCompositeSerializer<SessionEvent>(
            SessionEvent.class);

    public static ColumnFamily<String, SessionEvent> CF_CLICK_STREAM = ColumnFamily
            .newColumnFamily("ClickStream", StringSerializer.get(),
                    SE_SERIALIZER);

    private static ColumnFamily<String, String> LOCK_CF_LONG   = 
            ColumnFamily.newColumnFamily("LockCfLong", StringSerializer.get(), StringSerializer.get(), LongSerializer.get());
    
    private static ColumnFamily<String, String> LOCK_CF_STRING = 
            ColumnFamily.newColumnFamily("LockCfString", StringSerializer.get(), StringSerializer.get(), StringSerializer.get());
    
    private static final String SEEDS = "localhost:9160";

    private static final long   CASSANDRA_WAIT_TIME = 3000;
    private static final int    TTL                 = 20;
    private static final int    TIMEOUT             = 10;
    
    @BeforeClass
    public static void setup() throws Exception {
        System.out.println("TESTING THRIFT KEYSPACE");

        SingletonEmbeddedCassandra.getInstance();
        
        Thread.sleep(CASSANDRA_WAIT_TIME);
        
        createKeyspace();
    }

    @AfterClass
    public static void teardown() throws Exception {
        if (keyspaceContext != null)
            keyspaceContext.shutdown();
        
        Thread.sleep(CASSANDRA_WAIT_TIME);
    }

    public static void createKeyspace() throws Exception {
        keyspaceContext = new AstyanaxContext.Builder()
                .forCluster(TEST_CLUSTER_NAME)
                .forKeyspace(TEST_KEYSPACE_NAME)
                .withAstyanaxConfiguration(
                        new AstyanaxConfigurationImpl()
                                .setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE)
                                .setConnectionPoolType(ConnectionPoolType.TOKEN_AWARE)
                                .setDiscoveryDelayInSeconds(60000))
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl(TEST_CLUSTER_NAME
                                + "_" + TEST_KEYSPACE_NAME)
                                .setSocketTimeout(30000)
                                .setMaxTimeoutWhenExhausted(2000)
                                .setMaxConnsPerHost(20)
                                .setInitConnsPerHost(10)
                                .setSeeds(SEEDS))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
                .buildKeyspace(ThriftFamilyFactory.getInstance());

        keyspaceContext.start();
        
        keyspace = keyspaceContext.getEntity();
        
        try {
            keyspace.dropKeyspace();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        
        keyspace.createKeyspace(ImmutableMap.<String, Object>builder()
                .put("strategy_options", ImmutableMap.<String, Object>builder()
                        .put("replication_factor", "1")
                        .build())
                .put("strategy_class",     "SimpleStrategy")
                .build()
                );
        
        keyspace.createColumnFamily(CF_STANDARD1, ImmutableMap.<String, Object>builder()
                .put("column_metadata", ImmutableMap.<String, Object>builder()
                        .put("Index1", ImmutableMap.<String, Object>builder()
                                .put("validation_class", "UTF8Type")
                                .put("index_name",       "Index1")
                                .put("index_type",       "KEYS")
                                .build())
                        .put("Index2", ImmutableMap.<String, Object>builder()
                                .put("validation_class", "UTF8Type")
                                .put("index_name",       "Index2")
                                .put("index_type",       "KEYS")
                                .build())
                         .build())
                     .build());
        
        keyspace.createColumnFamily(CF_TTL,        null);
        keyspace.createColumnFamily(CF_STANDARD2,  null);
        keyspace.createColumnFamily(CF_LONGCOLUMN, null);
        keyspace.createColumnFamily(CF_DELETE,     null);
        keyspace.createColumnFamily(CF_COUNTER1, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "CounterColumnType")
                .build());
        keyspace.createColumnFamily(CF_CLICK_STREAM, ImmutableMap.<String, Object>builder()
                .put("comparator_type", "CompositeType(UTF8Type, TimeUUIDType)")
                .build());
        keyspace.createColumnFamily(CF_COMPOSITE_CSV, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "UTF8Type")
                .put("key_validation_class",     "UTF8Type")
                .put("comparator_type",          "CompositeType(UTF8Type, LongType)")
                .build());
        keyspace.createColumnFamily(CF_COMPOSITE, ImmutableMap.<String, Object>builder()
                .put("comparator_type", "CompositeType(AsciiType, IntegerType(reversed=true), IntegerType, BytesType, UTF8Type)")
                .build());
        keyspace.createColumnFamily(CF_COMPOSITE_KEY, ImmutableMap.<String, Object>builder()
                .put("key_validation_class", "BytesType")
                .build());
        keyspace.createColumnFamily(CF_TIME_UUID,         null);
        keyspace.createColumnFamily(CF_USER_UNIQUE_UUID,  null);
        keyspace.createColumnFamily(CF_EMAIL_UNIQUE_UUID, null);
        keyspace.createColumnFamily(CF_USERS, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "UTF8Type")
                .put("column_metadata", ImmutableMap.<String, Object>builder()
                        .put("firstname",  ImmutableMap.<String, Object>builder()
                                .put("validation_class", "UTF8Type")
                                .put("index_name",       "firstname")
                                .put("index_type",       "KEYS")
                                .build())
                        .put("lastname", ImmutableMap.<String, Object>builder()
                                .put("validation_class", "UTF8Type")
                                .put("index_name",       "lastname")
                                .put("index_type",       "KEYS")
                                .build())
                        .put("age", ImmutableMap.<String, Object>builder()
                                .put("validation_class", "LongType")
                                .put("index_name",       "age")
                                .put("index_type",       "KEYS")
                                .build())
                        .build())
                     .build());
        
        keyspace.createColumnFamily(LOCK_CF_LONG, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "LongType")
                .put("key_validation_class",     "UTF8Type")
                .put("comparator_type",          "UTF8Type")
                .build());
        
        keyspace.createColumnFamily(LOCK_CF_STRING, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "UTF8Type")
                .put("key_validation_class",     "UTF8Type")
                .put("comparator_type",          "UTF8Type")
                .build());
        
        keyspace.createColumnFamily(UNIQUE_CF, null);
        
        KeyspaceDefinition ki = keyspaceContext.getEntity().describeKeyspace();
        System.out.println("Describe Keyspace: " + ki.getName());

        try {
            //
            // CF_Super :
            // 'A' :
            // 'a' :
            // 1 : 'Aa1',
            // 2 : 'Aa2',
            // 'b' :
            // ...
            // 'z' :
            // ...
            // 'B' :
            // ...
            //
            // CF_Standard :
            // 'A' :
            // 'a' : 1,
            // 'b' : 2,
            // ...
            // 'z' : 26,
            // 'B' :
            // ...
            //

            MutationBatch m;
            OperationResult<Void> result;
            m = keyspace.prepareMutationBatch();

            for (char keyName = 'A'; keyName <= 'Z'; keyName++) {
                String rowKey = Character.toString(keyName);
                ColumnListMutation<String> cfmStandard = m.withRow(
                        CF_STANDARD1, rowKey);
                for (char cName = 'a'; cName <= 'z'; cName++) {
                    cfmStandard.putColumn(Character.toString(cName),
                            (int) (cName - 'a') + 1, null);
                }
                cfmStandard
                        .putColumn("Index1", (int) (keyName - 'A') + 1, null);
                cfmStandard.putColumn("Index2", 42, null);
                m.execute();
            }

            m.withRow(CF_STANDARD1, "Prefixes").putColumn("Prefix1_a", 1, null)
                    .putColumn("Prefix1_b", 2, null)
                    .putColumn("prefix2_a", 3, null);

            result = m.execute();

            String rowKey = "A";
            ColumnListMutation<Long> cfmLong = m.withRow(CF_LONGCOLUMN, rowKey);
            for (Long l = -10L; l < 10L; l++) {
                cfmLong.putEmptyColumn(l, null);
            }
            cfmLong.putEmptyColumn(Long.MAX_VALUE, null);
            result = m.execute();

            m.withRow(CF_USER_INFO, "acct1234")
                .putColumn("firstname", "john", null)
                .putColumn("lastname", "smith", null)
                .putColumn("address", "555 Elm St", null)
                .putColumn("age", 30, null)
                .putEmptyColumn("empty");

            m.execute();

        } catch (Exception e) {
            System.out.println(e.getMessage());
            Assert.fail();
        }
    }

    @Test
    public void testMultiColumnDelete() throws Exception {
        MutationBatch mb = keyspace.prepareMutationBatch();
        mb.withRow(CF_DELETE, 1L)
            .setTimestamp(1).putEmptyColumn(1L, null)
            .setTimestamp(10).putEmptyColumn(2L, null)
            ;
        mb.execute();
        
        ColumnList<Long> result1 = keyspace.prepareQuery(CF_DELETE).getRow(1L).execute().getResult();
        Assert.assertEquals(2, result1.size());
        Assert.assertNotNull(result1.getColumnByName(1L));
        Assert.assertNotNull(result1.getColumnByName(2L));
        
        logColumnList("Insert", result1);
        
        mb = keyspace.prepareMutationBatch();
        mb.withRow(CF_DELETE,  1L)
            .setTimestamp(result1.getColumnByName(1L).getTimestamp()-1)
            .deleteColumn(1L)
            .setTimestamp(result1.getColumnByName(2L).getTimestamp()-1)
            .deleteColumn(2L)
            .putEmptyColumn(3L, null);
        
        mb.execute();
        
        result1 = keyspace.prepareQuery(CF_DELETE).getRow(1L).execute().getResult();
        logColumnList("Delete with older timestamp", result1);
        Assert.assertEquals(3, result1.size());
        
        LOG.info("Delete L2 with TS: " + (result1.getColumnByName(2L).getTimestamp()+1));
        mb.withRow(CF_DELETE,  1L)
            .setTimestamp(result1.getColumnByName(1L).getTimestamp()+1)
            .deleteColumn(1L)
            .setTimestamp(result1.getColumnByName(2L).getTimestamp()+1)
            .deleteColumn(2L);
        mb.execute();
        
        result1 = keyspace.prepareQuery(CF_DELETE).getRow(1L).execute().getResult();
        logColumnList("Delete with newer timestamp", result1);
        Assert.assertEquals(1, result1.size());
    }
    
    <T> void logColumnList(String label, ColumnList<T> cl) {
        LOG.info(">>>>>> " + label);
        for (Column<T> c : cl) {
            LOG.info(c.getName() + " " + c.getTimestamp());
        }
        LOG.info("<<<<<<");
    }
    
    @Test
    public void testCqlComposite() throws Exception {
        CqlStatementResult result = keyspace.prepareCqlStatement()
            .withCql("SELECT * FROM " + CF_COMPOSITE_CSV.getName())
            .execute()
            .getResult();
        
        result.getSchema();
        result.getRows(CF_COMPOSITE_CSV);
    }
    
    @Test
    public void testHasValue() throws Exception {
        ColumnList<String> response = keyspace.prepareQuery(CF_USER_INFO).getRow("acct1234").execute().getResult();
        Assert.assertEquals("firstname", response.getColumnByName("firstname").getName());
        Assert.assertEquals("firstname", response.getColumnByName("firstname").getName());
        Assert.assertEquals("john", response.getColumnByName("firstname").getStringValue());
        Assert.assertEquals("john", response.getColumnByName("firstname").getStringValue());
        Assert.assertEquals(true,  response.getColumnByName("firstname").hasValue());
        Assert.assertEquals(false, response.getColumnByName("empty").hasValue());
        
    }
    
    @Test
    public void getKeyspaceDefinition() throws Exception {
        KeyspaceDefinition def = keyspaceContext.getEntity().describeKeyspace();
        Collection<String> fieldNames = def.getFieldNames();
        LOG.info("Getting field names");
        for (String field : fieldNames) {
            LOG.info(field);
        }
        LOG.info(fieldNames.toString());
        
        System.out.println(fieldNames.toString());
        
        for (FieldMetadata field : def.getFieldsMetadata()) {
            System.out.println(field.getName() + " = " + def.getFieldValue(field.getName()) + " (" + field.getType() + ")");
        }
        
        for (ColumnFamilyDefinition cfDef : def.getColumnFamilyList()) {
            LOG.info("----------" );
            for (FieldMetadata field : cfDef.getFieldsMetadata()) {
                LOG.info(field.getName() + " = " + cfDef.getFieldValue(field.getName()) + " (" + field.getType() + ")");
            }
        }
    }
    
    @Test
    public void testNonExistentKeyspace()  {
        AstyanaxContext<Keyspace> ctx = new AstyanaxContext.Builder()
            .forCluster(TEST_CLUSTER_NAME)
            .forKeyspace(TEST_KEYSPACE_NAME + "_NonExistent")
            .withAstyanaxConfiguration(
                    new AstyanaxConfigurationImpl()
                            .setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE)
                            .setConnectionPoolType(ConnectionPoolType.TOKEN_AWARE)
                            .setDiscoveryDelayInSeconds(60000))
            .withConnectionPoolConfiguration(
                    new ConnectionPoolConfigurationImpl(TEST_CLUSTER_NAME
                            + "_" + TEST_KEYSPACE_NAME)
                            .setSocketTimeout(30000)
                            .setMaxTimeoutWhenExhausted(2000)
                            .setMaxConnsPerHost(20)
                            .setInitConnsPerHost(10)
                            .setSeeds(SEEDS))
            .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
            .buildKeyspace(ThriftFamilyFactory.getInstance());        
        
        ctx.start();
        
        try {
            KeyspaceDefinition keyspaceDef = ctx.getEntity().describeKeyspace();
        } catch (ConnectionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        
    }
    
    @Test
    public void testDescribeRing() throws Exception {
        // [TokenRangeImpl [startToken=0, endToken=0, endpoints=[127.0.0.1]]]
        List<TokenRange> ring = keyspaceContext.getEntity().describeRing();
        LOG.info(ring.toString());
        
        // 127.0.0.1
        RingDescribeHostSupplier ringSupplier = new RingDescribeHostSupplier(keyspaceContext.getEntity(), 9160);
        List<Host> hosts = ringSupplier.get();
        Assert.assertEquals(1, hosts.get(0).getTokenRanges().size());
        LOG.info(hosts.toString());
        
        Supplier<List<Host>> sourceSupplier1 = Suppliers.ofInstance((List<Host>)Lists.newArrayList(new Host("127.0.0.1", 9160)));
        Supplier<List<Host>> sourceSupplier2 = Suppliers.ofInstance((List<Host>)Lists.newArrayList(new Host("127.0.0.2", 9160)));
        
        // 127.0.0.1
        LOG.info(sourceSupplier1.get().toString());
        
        // 127.0.0.2
        LOG.info(sourceSupplier2.get().toString());
        
        hosts = new FilteringHostSupplier(ringSupplier, sourceSupplier1).get();
        LOG.info(hosts.toString());
        
        Assert.assertEquals(1, hosts.size());
        Assert.assertEquals(1, hosts.get(0).getTokenRanges().size());
        hosts = new FilteringHostSupplier(ringSupplier, sourceSupplier2).get();
        LOG.info(hosts.toString());
        Assert.assertEquals(1, hosts.size());
    }
    
    @Test
    public void paginateColumns() {
        String column = "";
        ColumnList<String> columns;
        int pageize = 10;
        try {
            RowQuery<String, String> query = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .getKey("A")
                    .autoPaginate(true)
                    .withColumnRange(
                            new RangeBuilder().setStart(column)
                                    .setLimit(pageize).build());

            while (!(columns = query.execute().getResult()).isEmpty()) {
                for (Column<String> c : columns) {
                }
                // column = Iterables.getLast(columns).getName() + "\u0000";
            }
        } catch (ConnectionException e) {
            System.out.println(e.getMessage());
        }
    }

    @Test
    public void example() {
        AstyanaxContext<Keyspace> context = new AstyanaxContext.Builder()
                .forCluster(TEST_CLUSTER_NAME)
                .forKeyspace(TEST_KEYSPACE_NAME)
                .withAstyanaxConfiguration(
                        new AstyanaxConfigurationImpl()
                                .setDiscoveryType(NodeDiscoveryType.NONE))
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl("MyConnectionPool")
                                .setMaxConnsPerHost(1).setSeeds(
                                        "127.0.0.1:9160"))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
                .buildKeyspace(ThriftFamilyFactory.getInstance());

        context.start();
        Keyspace keyspace = context.getEntity();

        MutationBatch m = keyspace.prepareMutationBatch();

        // m.withRow(CF_USER_STATS, "acct1234")
        // .incrementCounterColumn("loginCount", 1);

        try {
            OperationResult<Void> result = m.execute();
        } catch (ConnectionException e) {
            System.out.println(e);
        }

        try {
            OperationResult<ColumnList<String>> result = keyspace
                    .prepareQuery(CF_USER_INFO).getKey("acct1234").execute();
            ColumnList<String> columns = result.getResult();

            // Lookup columns in response by name
            int age = columns.getColumnByName("age").getIntegerValue();
            String address = columns.getColumnByName("address")
                    .getStringValue();

            // Or, iterate through the columns
            for (Column<String> c : result.getResult()) {
                System.out.println(c.getName());
            }
        } catch (ConnectionException e) {
            System.out.println(e);
        }

    }
    
    @Test
    public void testMultiRowUniqueness() {
        DedicatedMultiRowUniquenessConstraint<UUID> constraint = new DedicatedMultiRowUniquenessConstraint<UUID>
                  (keyspace, TimeUUIDUtils.getUniqueTimeUUIDinMicros())
                  .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                  .withRow(CF_USER_UNIQUE_UUID, "user1")
                  .withRow(CF_EMAIL_UNIQUE_UUID, "user1@domain.com");
        
        DedicatedMultiRowUniquenessConstraint<UUID> constraint2 = new DedicatedMultiRowUniquenessConstraint<UUID>
                  (keyspace, TimeUUIDUtils.getUniqueTimeUUIDinMicros())
                  .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                  .withRow(CF_USER_UNIQUE_UUID, "user1")
                  .withRow(CF_EMAIL_UNIQUE_UUID, "user1@domain.com");
        
        try {
            Column<UUID> c = constraint.getUniqueColumn();
            Assert.fail();
        }
        catch (Exception e) {
            LOG.info(e.getMessage());
        }
        
        try {
            constraint.acquire();
            
            Column<UUID> c = constraint.getUniqueColumn();
            LOG.info("Unique column is " + c.getName());
            
            try {
                constraint2.acquire();
                Assert.fail("Should already be acquired");
            }
            catch (NotUniqueException e) {
                
            }
            catch (Exception e) {
                e.printStackTrace();
                Assert.fail();
            }
            finally {
                try {
                    constraint2.release();
                }
                catch (Exception e) {
                    e.printStackTrace();
                    Assert.fail();
                }
            }
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail();
        }
        finally {
            try {
                constraint.release();
            }
            catch (Exception e) {
                e.printStackTrace();
                Assert.fail();
            }
        }
        
        try {
            constraint2.acquire();
            Column<UUID> c = constraint.getUniqueColumn();
            LOG.info("Unique column is " + c.getName());
        }
        catch (NotUniqueException e) {
            Assert.fail("Should already be unique");
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail();
        }
        finally {
            try {
                constraint2.release();
            }
            catch (Exception e) {
                e.printStackTrace();
                Assert.fail();
            }
        }
        
    }

    @Test
    public void paginateLongColumns() {
        Long column = Long.MIN_VALUE;
        ColumnList<Long> columns;
        int pageize = 10;
        try {
            RowQuery<String, Long> query = keyspace
                    .prepareQuery(CF_LONGCOLUMN)
                    .getKey("A")
                    .autoPaginate(true)
                    .withColumnRange(
                            new RangeBuilder().setStart(column)
                                    .setLimit(pageize).build());

            while (!(columns = query.execute().getResult()).isEmpty()) {
                LOG.info("-----");
                for (Column<Long> c : columns) {
                    LOG.info(Long.toString(c.getName()));
                }
                // column = Iterables.getLast(columns).getName() + "\u0000";
            }
        } catch (ConnectionException e) {
        }
    }

    @Test
    public void getAll() {
        try {
            OperationResult<Rows<String, String>> rows = keyspace
                    .prepareQuery(CF_STANDARD1).getAllRows().setRowLimit(10)
                    .withColumnRange(new RangeBuilder().setLimit(0).build())
                    .setExceptionCallback(new ExceptionCallback() {
                        @Override
                        public boolean onException(ConnectionException e) {
                            Assert.fail(e.getMessage());
                            return true;
                        }
                    }).execute();
            for (Row<String, String> row : rows.getResult()) {
                LOG.info("ROW: " + row.getKey() + " " + row.getColumns().size());
            }
        } catch (ConnectionException e) {
            Assert.fail();
        }
    }
    
    @Test
    public void testAllRowsReader() throws Exception {
        final AtomicLong counter = new AtomicLong(0);
        
        boolean result = new AllRowsReader.Builder<String, String>(keyspace, CF_STANDARD1)
                .forEachRow(new Function<Row<String, String>, Boolean>() {
                    @Override
                    public Boolean apply(@Nullable Row<String, String> row) {
                        counter.incrementAndGet();
                        LOG.info("Got a row: " + row.getKey().toString());
                        return true;
                    }
                })
                .build()
                .call();
        
        Assert.assertTrue(result);
        Assert.assertEquals(28, counter.get());
    }
    
    @Test
    public void testAllRowsReaderWithCancel() throws Exception {
        final AtomicLong counter = new AtomicLong(0);
        
        AllRowsReader<String, String> reader = new AllRowsReader.Builder<String, String>(keyspace, CF_STANDARD1)
                .withPageSize(3)
                .forEachRow(new Function<Row<String, String>, Boolean>() {
                    @Override
                    public Boolean apply(@Nullable Row<String, String> row) {
                        try {
                            Thread.sleep(200);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            throw new RuntimeException(e);
                        }
                        counter.incrementAndGet();
                        LOG.info("Got a row: " + row.getKey().toString());
                        return true;
                    }
                })
                .build();
        
        
        Future<Boolean> future = Executors.newSingleThreadExecutor().submit(reader);        
        
        Thread.sleep(1000);
        
        reader.cancel();
        
        try {
            boolean result = future.get();
            Assert.assertEquals(false, result);
            Assert.fail();
        }
        catch (Exception e) {
            LOG.info("Failed to execute", e);
        }
        LOG.info("Before: " + counter.get());
        Assert.assertNotSame(28, counter.get());
        Thread.sleep(2000);
        LOG.info("After: " + counter.get());
        Assert.assertNotSame(28, counter.get());
    }

    @Test
    public void testAllRowsReaderConcurrency() throws Exception {
        final AtomicLong counter = new AtomicLong(0);
        
        boolean result = new AllRowsReader.Builder<String, String>(keyspace, CF_STANDARD1)
                .withConcurrencyLevel(4)
                .forEachRow(new Function<Row<String, String>, Boolean>() {
                    @Override
                    public Boolean apply(@Nullable Row<String, String> row) {
                        counter.incrementAndGet();
                        LOG.info("Got a row: " + row.getKey().toString());
                        return true;
                    }
                })
                .build()
                .call();
        
        Assert.assertTrue(result);
        Assert.assertEquals(28, counter.get());
    }

    @Test
    public void getAllWithCallback() {
        try {
            final AtomicLong counter = new AtomicLong();

            keyspace.prepareQuery(CF_STANDARD1).getAllRows().setRowLimit(3)
                    .setRepeatLastToken(false)
                    .withColumnRange(new RangeBuilder().setLimit(2).build())
                    .executeWithCallback(new RowCallback<String, String>() {
                        @Override
                        public void success(Rows<String, String> rows) {
                            for (Row<String, String> row : rows) {
                                LOG.info("ROW: " + row.getKey() + " "
                                        + row.getColumns().size());
                                counter.incrementAndGet();
                            }
                        }

                        @Override
                        public boolean failure(ConnectionException e) {
                            LOG.error(e.getMessage(), e);
                            return false;
                        }
                    });
            LOG.info("Read " + counter.get() + " keys");
        } catch (ConnectionException e) {
            Assert.fail();
        }
    }

    static class UserInfo implements Serializable {
        private static final long serialVersionUID = 6366200973810770033L;

        private String firstName;
        private String lastName;

        public UserInfo() {

        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        public String getFirstName() {
            return this.firstName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }

        public String getLastName() {
            return this.lastName;
        }

        public boolean equals(Object other) {
            UserInfo smo = (UserInfo) other;
            return firstName.equals(smo.firstName)
                    && lastName.equals(smo.lastName);
        }
    }

    @Test
    public void testSerializedClassValue() {
        UserInfo smo = new UserInfo();
        smo.setLastName("Landau");
        smo.setFirstName("Eran");

        try {
            ByteBuffer bb = ObjectSerializer.get().toByteBuffer(smo);
            keyspace.prepareColumnMutation(CF_STANDARD1, "Key_SerializeTest",
                    "Column1").putValue(bb, null).execute();

            UserInfo smo2 = (UserInfo) keyspace.prepareQuery(CF_STANDARD1)
                    .getKey("Key_SerializeTest").getColumn("Column1").execute()
                    .getResult().getValue(ObjectSerializer.get());

            Assert.assertEquals(smo, smo2);
        } catch (ConnectionException e) {
            Assert.fail();
        }
    }    
    
    @Test
    public void testSingleOps() throws Exception {
        String key = "SingleOpsTest";
        Random prng = new Random();

        // Set a string value
        {
            String column = "StringColumn";
            String value = RandomStringUtils.randomAlphanumeric(32);
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            String v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getStringValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult()
                        .getStringValue();
                Assert.fail();
            } catch (NotFoundException e) {
            } catch (ConnectionException e) {
                Assert.fail();
            }
        } 

        // Set a byte value
        {
            String column = "ByteColumn";
            byte value = (byte) prng.nextInt(Byte.MAX_VALUE);
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            byte v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getByteValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getByteValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        } 
        
        // Set a short value
        {
            String column = "ShortColumn";
            short value = (short) prng.nextInt(Short.MAX_VALUE);
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            short v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getShortValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getShortValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        } 
        
        // Set a int value
        {
            String column = "IntColumn";
            int value = prng.nextInt();
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            int v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getIntegerValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getIntegerValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        }
        
        // Set a long value
        {
            String column = "LongColumn";
            long value = prng.nextLong();
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            long v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getLongValue();
            Assert.assertEquals(value, v);
         // get as integer should fail
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult()
                        .getIntegerValue();
                Assert.fail();
            } catch (Exception e) {
            	// expected
            }
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getLongValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        }
        
        // Set a float value
        {
            String column = "FloatColumn";
            float value = prng.nextFloat();
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            float v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getFloatValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getFloatValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        }

        // Set a double value
        {
            String column = "IntColumn";
            double value = prng.nextDouble();
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            double v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getDoubleValue();
            Assert.assertEquals(value, v);
            // get as integer should fail
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult()
                        .getIntegerValue();
                Assert.fail();
            } catch (Exception e) {
            	// expected
            }
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult()
                        .getDoubleValue();
                Assert.fail();
            } catch (NotFoundException e) {
            } catch (ConnectionException e) {
                Assert.fail();
            }
        } 
        
        // Set long column with timestamp
        {
            String column = "TimestampColumn";
            long value = prng.nextLong();

            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .withTimestamp(100)
                    .putValue(value, null)
                    .execute();

            // Read
            Column<String> c = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult();
            Assert.assertEquals(100,  c.getTimestamp());
        } 
    }

    @Test
    public void testTimeUUIDUnique() {
        long now = System.currentTimeMillis();
        UUID uuid1 = TimeUUIDUtils.getTimeUUID(now);
        UUID uuid2 = TimeUUIDUtils.getTimeUUID(now);
        LOG.info(uuid1.toString());
        LOG.info(uuid2.toString());
        Assert.assertTrue(uuid1.equals(uuid2));
    }

    @Test
    public void testTimeUUID2() {
        MutationBatch m = keyspace.prepareMutationBatch();
        String rowKey = "Key2";
        m.withRow(CF_TIME_UUID, rowKey).delete();
        try {
            m.execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        long now = System.currentTimeMillis();
        long msecPerDay = 86400000;
        for (int i = 0; i < 100; i++) {
            m.withRow(CF_TIME_UUID, rowKey).putColumn(
                    TimeUUIDUtils.getTimeUUID(now - i * msecPerDay), i, null);
        }
        try {
            m.execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        try {
            OperationResult<ColumnList<UUID>> result = keyspace
                    .prepareQuery(CF_TIME_UUID)
                    .getKey(rowKey)
                    .withColumnRange(
                            new RangeBuilder()
                                    .setLimit(100)
                                    .setStart(
                                            TimeUUIDUtils.getTimeUUID(now - 20
                                                    * msecPerDay)).build())
                    .execute();
            for (Column<UUID> column : result.getResult()) {
                System.out.println((now - TimeUUIDUtils.getTimeFromUUID(column
                        .getName())) / msecPerDay);
            }
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }
    }

    @Test
    public void testTimeUUID() {
        MutationBatch m = keyspace.prepareMutationBatch();

        UUID columnName = TimeUUIDUtils.getUniqueTimeUUIDinMillis();
        long columnTime = TimeUUIDUtils.getTimeFromUUID(columnName);
        String rowKey = "Key1";

        m.withRow(CF_TIME_UUID, rowKey).delete();
        try {
            m.execute();
        } catch (ConnectionException e1) {
            Assert.fail();
        }

        int startTime = 100;
        int endTime = 200;

        m.withRow(CF_TIME_UUID, rowKey).putColumn(columnName, 42, null);
        for (int i = startTime; i < endTime; i++) {
            // UUID c = TimeUUIDUtils.getTimeUUID(i);
            LOG.info(TimeUUIDUtils.getTimeUUID(columnTime + i).toString());

            m.withRow(CF_TIME_UUID, rowKey).putColumn(
                    TimeUUIDUtils.getTimeUUID(columnTime + i), i, null);
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            OperationResult<Column<UUID>> result = keyspace
                    .prepareQuery(CF_TIME_UUID).getKey(rowKey)
                    .getColumn(columnName).execute();

            Assert.assertEquals(columnName, result.getResult().getName());
            Assert.assertTrue(result.getResult().getIntegerValue() == 42);

            OperationResult<ColumnList<UUID>> result2 = keyspace
                    .prepareQuery(CF_TIME_UUID).getKey(rowKey).execute();

            result2 = keyspace
                    .prepareQuery(CF_TIME_UUID)
                    .getKey(rowKey)
                    .withColumnRange(
                            new RangeBuilder()
                                    .setLimit(10)
                                    .setStart(TimeUUIDUtils.getTimeUUID(0))
                                    .setEnd(TimeUUIDUtils
                                            .getTimeUUID(Long.MAX_VALUE >> 8))
                                    .build()).execute();
            Assert.assertEquals(10, result2.getResult().size());

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        UUID currentUUID = TimeUUIDUtils.getUniqueTimeUUIDinMicros();

        SerializerPackage pkg = null;
        try {
            pkg = keyspace.getSerializerPackage(CF_TIME_UUID.getName(), false);
        } catch (ConnectionException e) {
            Assert.fail();
            e.printStackTrace();
        } catch (UnknownComparatorException e) {
            Assert.fail();
            e.printStackTrace();
        }
        Serializer<UUID> serializer = (Serializer<UUID>) pkg
                .getColumnNameSerializer();

        ByteBuffer buffer = serializer.toByteBuffer(currentUUID);
        String value = serializer.getString(buffer);
        LOG.info("UUID Time = " + value);

        // Test timeUUID pagination
        RowQuery<String, UUID> query = keyspace
                .prepareQuery(CF_TIME_UUID)
                .getKey(rowKey)
                .withColumnRange(
                        new RangeBuilder()
                                .setLimit(10)
                                .setStart(
                                        TimeUUIDUtils.getTimeUUID(columnTime
                                                + startTime))
                                .setEnd(TimeUUIDUtils.getTimeUUID(columnTime
                                        + endTime)).build()).autoPaginate(true);
        OperationResult<ColumnList<UUID>> result;
        int pageCount = 0;
        int rowCount = 0;
        try {
            LOG.info("starting pagination");
            while (!(result = query.execute()).getResult().isEmpty()) {
                pageCount++;
                rowCount += result.getResult().size();
                LOG.info("==== Block ====");
                for (Column<UUID> column : result.getResult()) {
                    LOG.info("Column is " + column.getName());
                }
            }
            LOG.info("pagination complete");
        } catch (ConnectionException e) {
            Assert.fail();
            LOG.info(e.getMessage());
            e.printStackTrace();
        }

    }

    @Test
    public void testCopy() {
        String keyName = "A";

        try {
            keyspace.prepareQuery(CF_STANDARD1).getKey(keyName)
                    .copyTo(CF_STANDARD2, keyName).execute();

            ColumnList<String> list1 = keyspace.prepareQuery(CF_STANDARD1)
                    .getKey(keyName).execute().getResult();

            ColumnList<String> list2 = keyspace.prepareQuery(CF_STANDARD2)
                    .getKey(keyName).execute().getResult();

            Iterator<Column<String>> iter1 = list1.iterator();
            Iterator<Column<String>> iter2 = list2.iterator();

            while (iter1.hasNext()) {
                Column<String> column1 = iter1.next();
                Column<String> column2 = iter2.next();
                Assert.assertEquals(column1.getName(), column2.getName());
                Assert.assertEquals(column1.getByteBufferValue(),
                        column2.getByteBufferValue());
            }
            Assert.assertFalse(iter2.hasNext());

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail(e.getMessage());
        }
    }

    @Test
    public void testMutationBatchMultipleWithRow() throws Exception {
        MutationBatch mb = keyspace.prepareMutationBatch();
        
        Long key = 9L;
        
        mb.withRow(CF_USERS, key).delete();
        mb.withRow(CF_USERS, key).putEmptyColumn("test", null);
        
        mb.execute();
        
        ColumnList<String> result = keyspace.prepareQuery(CF_USERS).getRow(key).execute().getResult();
        
        Assert.assertEquals(1, result.size());
    }
    
    @Test
    public void testClickStream() {
        MutationBatch m = keyspace.prepareMutationBatch();
        String userId = "UserId";

        long timeCounter = 0;
        for (int i = 0; i < 10; i++) {
            String sessionId = "Session" + i;

            for (int j = 0; j < 10; j++) {
                m.withRow(CF_CLICK_STREAM, userId).putColumn(
                        new SessionEvent(sessionId,
                                TimeUUIDUtils.getTimeUUID(j)),
                        Long.toString(timeCounter), null);
                timeCounter++;
            }
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            OperationResult<ColumnList<SessionEvent>> result;

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER.buildRange()
                                    .greaterThanEquals("Session3")
                                    .lessThanEquals("Session5").build())
                    .execute();
            // Assert.assertEquals(10, result.getResult().size());
            // LOG.info("*********************** INCLUSIVE - INCLUSIVE");
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER.buildRange()
                                    .greaterThanEquals("Session3")
                                    .lessThan("Session5").build()).execute();
            // Assert.assertEquals(10, result.getResult().size());
            // LOG.info("XXXXXXXXXXXXXXXXXXXXXXXX INCLUSIVE - NON_INCLUSIVE");
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER.buildRange().greaterThan("Session3")
                                    .lessThanEquals("Session5").build())
                    .execute();
            // LOG.info("XXXXXXXXXXXXXXXXXXXXXXXX NON_INCLUSIVE - INCLUSIVE");
            // Assert.assertEquals(10, result.getResult().size());
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER.buildRange().greaterThan("Session3")
                                    .lessThan("Session5").build()).execute();
            // LOG.info("XXXXXXXXXXXXXXXXXXXXXXXX NON_INCLUSIVE - NON_INCLUSIVE");
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER
                                    .buildRange()
                                    .withPrefix("Session3")
                                    .greaterThanEquals(
                                            TimeUUIDUtils.getTimeUUID(2))
                                    .lessThanEquals(
                                            TimeUUIDUtils.getTimeUUID(8))
                                    .build()).execute();

            // Assert.assertEquals(10, result.getResult().size());
            // LOG.info("XXXXXXXXXXXXXXXXXXXXXXXX EQUAL - EQUAL");
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testChangeConsistencyLevel() {
        try {
            keyspace.prepareQuery(CF_STANDARD1)
                    .setConsistencyLevel(ConsistencyLevel.CL_ONE).getKey("A")
                    .execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }
    }

    @Test
    public void testCompositeKey() {
        MockCompositeType key = new MockCompositeType("A", 1, 2, true, "B");
        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF_COMPOSITE_KEY, key).putColumn("Test", "Value", null);
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            ColumnList<String> row = keyspace.prepareQuery(CF_COMPOSITE_KEY)
                    .getKey(key).execute().getResult();
            Assert.assertFalse(row.isEmpty());
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

    }

    @Test
    public void testComposite() {
        String rowKey = "Composite1";

        boolean bool = false;
        MutationBatch m = keyspace.prepareMutationBatch();
        ColumnListMutation<MockCompositeType> mRow = m.withRow(CF_COMPOSITE,
                rowKey);
        int columnCount = 0;
        for (char part1 = 'a'; part1 <= 'b'; part1++) {
            for (int part2 = 0; part2 < 10; part2++) {
                for (int part3 = 10; part3 < 11; part3++) {
                    bool = !bool;
                    columnCount++;
                    mRow.putEmptyColumn(
                            new MockCompositeType(Character.toString(part1),
                                    part2, part3, bool, "UTF"), null);
                }
            }
        }
        LOG.info("Created " + columnCount + " columns");
        
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        OperationResult<ColumnList<MockCompositeType>> result;
        try {
            result = keyspace.prepareQuery(CF_COMPOSITE).getKey(rowKey)
                    .execute();
            Assert.assertEquals(columnCount,  result.getResult().size());
            for (Column<MockCompositeType> col : result.getResult()) {
                LOG.info("COLUMN: " + col.getName().toString());
            }
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            Column<MockCompositeType> column = keyspace
                    .prepareQuery(CF_COMPOSITE).getKey(rowKey)
                    .getColumn(new MockCompositeType("a", 0, 10, true, "UTF"))
                    .execute().getResult();
            LOG.info("Got single column: " + column.getName().toString());
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        LOG.info("Range builder");
        try {
            result = keyspace
                    .prepareQuery(CF_COMPOSITE)
                    .getKey(rowKey)
                    .withColumnRange(
                            M_SERIALIZER
                                    .buildRange()
                                    .withPrefix("a")
                                    .greaterThanEquals(1)
                                    .lessThanEquals(1)
                                    .build()).execute();
            for (Column<MockCompositeType> col : result.getResult()) {
                LOG.info("COLUMN: " + col.getName().toString());
            }
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        
        /*
         * Composite c = new Composite(); c.addComponent("String1",
         * StringSerializer.get()) .addComponent(123, IntegerSerializer.get());
         * 
         * MutationBatch m = keyspace.prepareMutationBatch();
         * m.withRow(CF_COMPOSITE, "Key1") .putColumn(c, 123, null);
         * 
         * try { m.execute(); } catch (ConnectionException e) { Assert.fail(); }
         * 
         * try { OperationResult<Column<Composite>> result =
         * keyspace.prepareQuery(CF_COMPOSITE) .getKey("Key1") .getColumn(c)
         * .execute();
         * 
         * Assert.assertEquals(123, result.getResult().getIntegerValue()); }
         * catch (ConnectionException e) { Assert.fail(); }
         */
    }

    @Test
    public void testCompositeSlice() throws ConnectionException {
        AnnotatedCompositeSerializer<MockCompositeType> ser = new AnnotatedCompositeSerializer<MockCompositeType>(
                MockCompositeType.class);

        keyspace.prepareQuery(CF_COMPOSITE)
                .getKey("Key1")
                .withColumnRange(
                        ser.makeEndpoint("sessionid1", Equality.LESS_THAN)
                                .toBytes(),
                        ser.makeEndpoint("sessionid1", Equality.GREATER_THAN)
                                .toBytes(), false, 100).execute();
    }

    @Test
    public void testIndexQueryWithPagination() {
        OperationResult<Rows<String, String>> result;
        try {
            LOG.info("************************************************** testIndexQueryWithPagination: ");

            int rowCount = 0;
            int pageCount = 0;
            IndexQuery<String, String> query = keyspace
                    .prepareQuery(CF_STANDARD1).searchWithIndex()
                    .setRowLimit(10).autoPaginateRows(true).addExpression()
                    .whereColumn("Index2").equals().value(42);

            while (!(result = query.execute()).getResult().isEmpty()) {
                pageCount++;
                rowCount += result.getResult().size();
                LOG.info("==== Block ====");
                for (Row<String, String> row : result.getResult()) {
                    LOG.info("RowKey is " + row.getKey());
                }
            }

            Assert.assertEquals(pageCount, 3);
            Assert.assertEquals(rowCount, 26);
            LOG.info("************************************************** Index query: "
                    + result.getResult().size());

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        }
    }

    @Test
    public void testIndexQuery() {
        OperationResult<Rows<String, String>> result;
        try {
            LOG.info("************************************************** prepareGetMultiRowIndexQuery: ");

            result = keyspace.prepareQuery(CF_STANDARD1).searchWithIndex()
                    .setStartKey("").addExpression().whereColumn("Index1")
                    .equals().value(26).execute();
            Assert.assertEquals(1, result.getResult().size());
            Assert.assertEquals("Z", result.getResult().getRowByIndex(0)
                    .getKey());
            /*
             * for (Row<String, String> row : result.getResult()) {
             * LOG.info("RowKey is " + row.getKey()); for (Column<String> column
             * : row.getColumns()) { LOG.info("  Column: " + column.getName() +
             * "=" + column.getIntegerValue()); } }
             */

            LOG.info("************************************************** Index query: "
                    + result.getResult().size());

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        }
    }

    @Test
    public void testPreparedIndexQuery() {
        OperationResult<Rows<String, String>> result;
        try {
            LOG.info("************************************************** prepareGetMultiRowIndexQuery: ");

            PreparedIndexExpression<String, String> clause = CF_STANDARD1
                    .newIndexClause().whereColumn("Index1").equals().value(26);

            result = keyspace.prepareQuery(CF_STANDARD1).searchWithIndex()
                    .setStartKey("")
                    .addPreparedExpressions(Arrays.asList(clause)).execute();

            for (Row<String, String> row : result.getResult()) {
                LOG.info("RowKey is " + row.getKey() + " columnCount="
                        + row.getColumns().size());
                for (Column<String> column : row.getColumns()) {
                    LOG.info("  Column: " + column.getName() + "="
                            + column.getIntegerValue());
                }
            }
            Assert.assertEquals(1, result.getResult().size());
            Assert.assertEquals("Z", result.getResult().getRowByIndex(0)
                    .getKey());

            LOG.info("************************************************** Index query: "
                    + result.getResult().size());

        } catch (ConnectionException e) {
            e.printStackTrace();
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (Exception e) {
            e.printStackTrace();
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testIncrementCounter() {
        long baseAmount, incrAmount = 100;
        Column<String> column;

        try {
            column = getColumnValue(CF_COUNTER1, "CounterRow1", "MyCounter");
            baseAmount = column.getLongValue();
        } catch (Exception e) {
            baseAmount = 0;
        }

        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF_COUNTER1, "CounterRow1").incrementCounterColumn(
                "MyCounter", incrAmount);
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        column = getColumnValue(CF_COUNTER1, "CounterRow1", "MyCounter");
        Assert.assertNotNull(column);
        Assert.assertEquals(column.getLongValue(), baseAmount + incrAmount);

        m = keyspace.prepareMutationBatch();
        m.withRow(CF_COUNTER1, "CounterRow1").incrementCounterColumn(
                "MyCounter", incrAmount);
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        column = getColumnValue(CF_COUNTER1, "CounterRow1", "MyCounter");
        Assert.assertNotNull(column);
        Assert.assertEquals(column.getLongValue(), baseAmount + 2 * incrAmount);
    }

    @Test
    public void testDeleteCounter() {
        Column<String> column;
        String rowKey = "CounterRowDelete1";
        String counterName = "MyCounter";

        // Increment the column
        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF_COUNTER1, rowKey).incrementCounterColumn(counterName, 1);
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        // Read back the value
        column = getColumnValue(CF_COUNTER1, rowKey, counterName);
        Assert.assertNotNull(column);
        Assert.assertEquals(column.getLongValue(), 1);

        // Delete the column
        try {
            // keyspace.prepareColumnMutation(CF_COUNTER1, rowKey, counterName)
            // .deleteCounterColumn().execute();
            keyspace.prepareColumnMutation(CF_COUNTER1, rowKey, counterName)
                    .deleteCounterColumn().execute();
            /*
             * m = keyspace.prepareMutationBatch(); m.withRow(CF_COUNTER1,
             * rowKey) .deleteColumn(counterName); m.execute();
             */
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        // Try to read back
        // This should be non-existent
        column = getColumnValue(CF_COUNTER1, rowKey, counterName);
        if (column != null) {
            LOG.error("Counter has value: " + column.getLongValue());
            Assert.fail();
        }
    }

    @Test
    public void testCql() {
        try {
            System.out.println("testCQL");
            LOG.info("CQL Test");
            OperationResult<CqlResult<String, String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .withCql("SELECT * FROM Standard1;").execute();
            Assert.assertTrue(result.getResult().hasRows());
            Assert.assertEquals(30, result.getResult().getRows().size());
            Assert.assertFalse(result.getResult().hasNumber());
            
            Row<String, String> row;
            
            row = result.getResult().getRows().getRow("A");
            Assert.assertEquals("A", row.getKey());
            
            row = result.getResult().getRows().getRow("B");
            Assert.assertEquals("B", row.getKey());
            
            row = result.getResult().getRows().getRow("NonExistent");
            Assert.assertNull(row);
            
            row = result.getResult().getRows().getRowByIndex(10);
            Assert.assertEquals("I", row.getKey());
            
            for (Row<String, String> row1 : result.getResult().getRows()) {
              LOG.info("KEY***: " + row1.getKey()); 
            }
            
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testCqlCount() {
        try {
            LOG.info("CQL Test");
            OperationResult<CqlResult<String, String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .withCql("SELECT count(*) FROM Standard1 where KEY='A';")
                    .execute();

            long count = result.getResult().getRows().getRowByIndex(0).getColumns().getColumnByName("count").getLongValue();
            LOG.info("CQL Count: " + count);
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testGetSingleColumn() {
        Column<String> column = getColumnValue(CF_STANDARD1, "A", "a");
        Assert.assertNotNull(column);
        Assert.assertEquals(1, column.getIntegerValue());
    }

    @Test
    public void testColumnFamilyDoesntExist() {
        ColumnFamily<String, String> cf = new ColumnFamily<String, String>(
                "DoesntExist", StringSerializer.get(), StringSerializer.get());
        OperationResult<Void> result;
        try {
            MutationBatch m = keyspace.prepareMutationBatch();
            m.withRow(cf, "Key1").putColumn("Column2", "Value2", null);
            result = m.execute();
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.info(e.getMessage());
        }
    }

    @Test
    public void testKeyspaceDoesntExist() {
        AstyanaxContext<Keyspace> keyspaceContext = new AstyanaxContext.Builder()
                .forCluster(TEST_CLUSTER_NAME)
                .forKeyspace(TEST_KEYSPACE_NAME + "_DOESNT_EXIST")
                .withAstyanaxConfiguration(
                        new AstyanaxConfigurationImpl()
                                .setDiscoveryType(NodeDiscoveryType.NONE))
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl(TEST_CLUSTER_NAME
                                + "_" + TEST_KEYSPACE_NAME + "_DOESNT_EXIST")
                                .setMaxConnsPerHost(1).setSeeds(SEEDS))
                .buildKeyspace(ThriftFamilyFactory.getInstance());

        try {
            keyspaceContext.start();

            Keyspace ks = keyspaceContext.getEntity();

            OperationResult<Void> result = null;
            try {
                MutationBatch m = ks.prepareMutationBatch();
                m.withRow(CF_STANDARD1, "Key1").putColumn("Column2", "Value2",
                        null);
                result = m.execute();
                Assert.fail();
            } catch (ConnectionException e) {
                LOG.info(e.getMessage());
            }
        } finally {
            keyspaceContext.shutdown();
        }
    }

    @Test
    public void testGetSingleColumnNotExists() {
        Column<String> column = getColumnValue(CF_STANDARD1, "A",
                "DoesNotExist");
        Assert.assertNull(column);
    }

    @Test
    public void testGetSingleColumnNotExistsAsync() {
        Future<OperationResult<Column<String>>> future = null;
        try {
            future = keyspace.prepareQuery(CF_STANDARD1).getKey("A")
                    .getColumn("DoesNotExist").executeAsync();
            future.get(1000, TimeUnit.MILLISECONDS);
        } catch (ConnectionException e) {
            LOG.info("ConnectionException: " + e.getMessage());
            Assert.fail();
        } catch (InterruptedException e) {
            LOG.info(e.getMessage());
            Assert.fail();
        } catch (ExecutionException e) {
            if (e.getCause() instanceof NotFoundException)
                LOG.info(e.getCause().getMessage());
            else {
                Assert.fail(e.getMessage());
            }
        } catch (TimeoutException e) {
            future.cancel(true);
            LOG.info(e.getMessage());
            Assert.fail();
        }
    }

    @Test
    public void testGetSingleKeyNotExists() {
        Column<String> column = getColumnValue(CF_STANDARD1, "AA", "ab");
        Assert.assertNull(column);
    }

    @Test
    public void testFunctionalQuery() throws ConnectionException {
        OperationResult<ColumnList<String>> r1 = keyspace
                .prepareQuery(CF_STANDARD1).getKey("A").execute();
        Assert.assertEquals(28, r1.getResult().size());

        /*
         * OperationResult<Rows<String, String>> r2 = keyspace.prepareQuery()
         * .fromColumnFamily(CF_STANDARD1) .selectKeyRange("A", "Z", null, null,
         * 5) .execute();
         */
    }
    
    @Test
    public void testNullKeyInMutation() throws ConnectionException {
        try {
            keyspace.prepareMutationBatch()
                .withRow(CF_STANDARD1,  null)
                .putColumn("abc", "def");
            
            Assert.fail();
        }
        catch (NullPointerException e) {
            
        }
    }
    

    @Test
    public void testColumnSlice() throws ConnectionException {
        OperationResult<ColumnList<String>> r1 = keyspace
                .prepareQuery(CF_STANDARD1).getKey("A")
                .withColumnSlice("a", "b").execute();
        Assert.assertEquals(2, r1.getResult().size());
    }

    @Test
    public void testColumnRangeSlice() throws ConnectionException {
        OperationResult<ColumnList<String>> r1 = keyspace
                .prepareQuery(CF_STANDARD1)
                .getKey("A")
                .withColumnRange(
                        new RangeBuilder().setStart("a").setEnd("b")
                                .setLimit(5).build()).execute();
        Assert.assertEquals(2, r1.getResult().size());

        OperationResult<ColumnList<String>> r2 = keyspace
                .prepareQuery(CF_STANDARD1).getKey("A")
                .withColumnRange("a", null, false, 5).execute();
        Assert.assertEquals(5, r2.getResult().size());
        Assert.assertEquals("a", r2.getResult().getColumnByIndex(0).getName());

        ByteBuffer EMPTY_BUFFER = ByteBuffer.wrap(new byte[0]);
        OperationResult<ColumnList<String>> r3 = keyspace
                .prepareQuery(CF_STANDARD1).getKey("A")
                .withColumnRange(EMPTY_BUFFER, EMPTY_BUFFER, true, 5).execute();
        Assert.assertEquals(5, r3.getResult().size());
        Assert.assertEquals("z", r3.getResult().getColumnByIndex(0).getName());
    }

    @Test
    public void testGetColumnsWithPrefix() throws ConnectionException {
        OperationResult<ColumnList<String>> r = keyspace
                .prepareQuery(CF_STANDARD1)
                .getKey("Prefixes")
                .withColumnRange("Prefix1_\u00000", "Prefix1_\uffff", false,
                        Integer.MAX_VALUE).execute();
        Assert.assertEquals(2, r.getResult().size());
        Assert.assertEquals("Prefix1_a", r.getResult().getColumnByIndex(0)
                .getName());
        Assert.assertEquals("Prefix1_b", r.getResult().getColumnByIndex(1)
                .getName());
    }

    @Test
    public void testGetCounters() throws ConnectionException {
        LOG.info("Starting testGetCounters...");

        try {
            OperationResult<Column<String>> result = keyspace
                    .prepareQuery(CF_COUNTER1).getKey("CounterRow1")
                    .getColumn("TestCounter").execute();

            Long count = result.getResult().getLongValue();
            Assert.assertNotNull(count);
            Assert.assertTrue(count > 0);
        } catch (NotFoundException e) {

        }

        LOG.info("... testGetCounters done");
    }

    @Test
    public void testGetSingleKey() {
        try {
            for (char key = 'A'; key <= 'Z'; key++) {
                String keyName = Character.toString(key);
                OperationResult<ColumnList<String>> result = keyspace
                        .prepareQuery(CF_STANDARD1).getKey(keyName).execute();

                Assert.assertNotNull(result.getResult());

                System.out.printf("%s executed on %s in %d msec size=%d\n",
                        keyName, result.getHost(), result.getLatency(), result
                                .getResult().size());
            }
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testGetSingleKeyAsync() {
        try {
            Future<OperationResult<ColumnList<String>>> result = keyspace
                    .prepareQuery(CF_STANDARD1).getKey("A").executeAsync();

            result.get(1000, TimeUnit.MILLISECONDS);

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (InterruptedException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (ExecutionException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (TimeoutException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        }
    }

    @Test
    public void testGetAllKeysRoot() {
        LOG.info("Starting testGetAllKeysRoot...");

        try {
            List<String> keys = new ArrayList<String>();
            for (char key = 'A'; key <= 'Z'; key++) {
                String keyName = Character.toString(key);
                keys.add(keyName);
            }

            OperationResult<Rows<String, String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .getKeySlice(keys.toArray(new String[keys.size()]))
                    .execute();

            Assert.assertEquals(26,  result.getResult().size());
            
            Row<String, String> row;
            
            row = result.getResult().getRow("A");
            Assert.assertEquals("A", row.getKey());
            
            row = result.getResult().getRow("B");
            Assert.assertEquals("B", row.getKey());
            
            row = result.getResult().getRow("NonExistent");
            Assert.assertNull(row);
            
            row = result.getResult().getRowByIndex(10);
            Assert.assertEquals("M", row.getKey());
            /*
             * LOG.info("Get " + result.getResult().size() + " keys"); for
             * (Row<String, String> row : result.getResult()) {
             * LOG.info(String.format("%s executed on %s in %d msec size=%d\n",
             * row.getKey(), result.getHost(), result.getLatency(),
             * row.getColumns().size())); for (Column<String> sc :
             * row.getColumns()) { LOG.info("  " + sc.getName());
             * ColumnList<Integer> subColumns =
             * sc.getSubColumns(IntegerSerializer.get()); for (Column<Integer>
             * sub : subColumns) { LOG.info("    " + sub.getName() + "=" +
             * sub.getStringValue()); } } }
             */

        } catch (ConnectionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            Assert.fail();
        }

        LOG.info("... testGetAllKeysRoot");
    }

    @Test
    public void testGetColumnSlice() {
        LOG.info("Starting testGetColumnSlice...");
        try {
            OperationResult<ColumnList<String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .getKey("A")
                    .withColumnSlice(
                            new ColumnSlice<String>("c", "h").setLimit(5))
                    .execute();
            Assert.assertNotNull(result.getResult());
            Assert.assertEquals(5, result.getResult().size());
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

    }

    @Test
    public void testGetAllKeysPath() {
        LOG.info("Starting testGetAllKeysPath...");

        try {
            List<String> keys = new ArrayList<String>();
            for (char key = 'A'; key <= 'Z'; key++) {
                String keyName = Character.toString(key);
                keys.add(keyName);
            }

            OperationResult<Rows<String, String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .getKeySlice(keys.toArray(new String[keys.size()]))
                    .execute();
            /*
             * System.out.printf("%s executed on %s in %d msec size=%d\n",
             * row.getKey(), result.getHost(), result.getLatency(),
             * row.getColumns().size());
             */

            // for (Row<String, String> row : result.getResult()) {
            // for (Column<Integer> column : row.getColumns()) {
            // System.out.println("  Column: " + column.getName());
            // }
            // }
            
            OperationResult<Map<String, Integer>> counts = keyspace
                .prepareQuery(CF_STANDARD1)
                .getKeySlice(keys.toArray(new String[keys.size()]))
                .getColumnCounts()
                .execute();
                        
            Assert.assertEquals(26, counts.getResult().size());
            
            for (Entry<String, Integer> count : counts.getResult().entrySet()) {
                Assert.assertEquals(new Integer(28), count.getValue());
            }
            
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        LOG.info("Starting testGetAllKeysPath...");
    }
    
    @Test
    public void testDeleteMultipleKeys() {
        LOG.info("Starting testDeleteMultipleKeys...");
        LOG.info("... testGetAllKeysPath");

    }

    @Test
    public void testMutationMerge() {
        MutationBatch m1 = keyspace.prepareMutationBatch();
        MutationBatch m2 = keyspace.prepareMutationBatch();
        MutationBatch m3 = keyspace.prepareMutationBatch();
        MutationBatch m4 = keyspace.prepareMutationBatch();
        MutationBatch m5 = keyspace.prepareMutationBatch();

        m1.withRow(CF_STANDARD1, "1").putColumn("1", "X", null);
        m2.withRow(CF_STANDARD1, "2").putColumn("2", "X", null)
                .putColumn("3", "X", null);
        m3.withRow(CF_STANDARD1, "3").putColumn("4", "X", null)
                .putColumn("5", "X", null).putColumn("6", "X", null);
        m4.withRow(CF_STANDARD1, "1").putColumn("7", "X", null)
                .putColumn("8", "X", null).putColumn("9", "X", null)
                .putColumn("10", "X", null);

        MutationBatch merged = keyspace.prepareMutationBatch();
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 0);

        merged.mergeShallow(m1);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 1);

        merged.mergeShallow(m2);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 2);

        merged.mergeShallow(m3);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 3);

        merged.mergeShallow(m4);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 3);

        merged.mergeShallow(m5);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 3);
    }

    @Test
    public void testDelete() {
        LOG.info("Starting testDelete...");

        String rowKey = "DeleteMe_testDelete";

        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF_STANDARD1, rowKey).putColumn("Column1", "X", null)
                .putColumn("Column2", "X", null);

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        Assert.assertEquals(getColumnValue(CF_STANDARD1, rowKey, "Column1")
                .getStringValue(), "X");
        Assert.assertTrue(deleteColumn(CF_STANDARD1, rowKey, "Column1"));
        Assert.assertNull(getColumnValue(CF_STANDARD1, rowKey, "Column1"));

        LOG.info("... testDelete");
    }

    @Test
    public void testDeleteLotsOfColumns() {
        LOG.info("Starting testDelete...");

        String rowKey = "DeleteMe_testDeleteLotsOfColumns";

        int nColumns = 100;
        int pageSize = 25;

        // Insert a bunch of rows
        MutationBatch m = keyspace.prepareMutationBatch();
        ColumnListMutation<String> rm = m.withRow(CF_STANDARD1, rowKey);

        for (int i = 0; i < nColumns; i++) {
            rm.putEmptyColumn("" + i, null);
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        // Verify count
        try {
            int count = keyspace.prepareQuery(CF_STANDARD1)
                    .setConsistencyLevel(ConsistencyLevel.CL_QUORUM)
                    .getKey(rowKey).getCount().execute().getResult();
            Assert.assertEquals(nColumns, count);
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        // Delete half of the columns
        m = keyspace.prepareMutationBatch().setConsistencyLevel(
                ConsistencyLevel.CL_QUORUM);
        rm = m.withRow(CF_STANDARD1, rowKey);

        for (int i = 0; i < nColumns / 2; i++) {
            rm.deleteColumn("" + i);
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        // Verify count
        try {
            int count = getRowColumnCount(CF_STANDARD1, rowKey);
            Assert.assertEquals(nColumns / 2, count);

            count = getRowColumnCountWithPagination(CF_STANDARD1, rowKey,
                    pageSize);
            Assert.assertEquals(nColumns / 2, count);

        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        // Delete all of the columns
        m = keyspace.prepareMutationBatch().setConsistencyLevel(
                ConsistencyLevel.CL_QUORUM);
        rm = m.withRow(CF_STANDARD1, rowKey);

        for (int i = 0; i < nColumns; i++) {
            rm.deleteColumn("" + i);
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        // Verify count
        try {
            int count = getRowColumnCount(CF_STANDARD1, rowKey);
            Assert.assertEquals(0, count);

            count = getRowColumnCountWithPagination(CF_STANDARD1, rowKey,
                    pageSize);
            Assert.assertEquals(0, count);
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        LOG.info("... testDelete");
    }

    private <K, C> int getRowColumnCount(ColumnFamily<K, C> cf, K rowKey)
            throws ConnectionException {
        int count = keyspace.prepareQuery(cf)
                .setConsistencyLevel(ConsistencyLevel.CL_QUORUM).getKey(rowKey)
                .getCount().execute().getResult();

        return count;
    }

    private <K, C> int getRowColumnCountWithPagination(ColumnFamily<K, C> cf,
            K rowKey, int pageSize) throws ConnectionException {
        RowQuery<K, C> query = keyspace.prepareQuery(cf)
                .setConsistencyLevel(ConsistencyLevel.CL_QUORUM).getKey(rowKey)
                .withColumnRange(new RangeBuilder().setLimit(pageSize).build())
                .autoPaginate(true);

        ColumnList<C> result;
        int count = 0;
        while (!(result = query.execute().getResult()).isEmpty()) {
            count += result.size();
        }

        return count;
    }

    @Test
    public void testCsvLoader() {
        StringBuilder sb = new StringBuilder()
                .append("key, firstname, lastname, age, test\n")
                .append("1, eran, landau, 34, a\n")
                .append("2, netta, landau, 33, b\n")
                .append("3, arielle, landau, 6, c\n")
                .append("4, eyal, landau, 2, d\n");

        RecordReader reader = new CsvRecordReader(new StringReader(
                sb.toString()));
        RecordWriter writer = new ColumnarRecordWriter(keyspace,
                CF_USERS.getName());

        try {
            reader.start();
            writer.start();
            List<Pair<String, String>> record = null;
            while (null != (record = reader.next())) {
                writer.write(record);
            }
        } catch (IOException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } finally {
            reader.shutdown();
            writer.shutdown();
        }

        try {
            Rows<Long, String> rows = keyspace.prepareQuery(CF_USERS)
                    .getAllRows().execute().getResult();
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(false).write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true).setCountName("_count_")
                    .setRowsName("_rows_").setNamesName("_names_").write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true).setDynamicColumnNames(true)
                    .write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true).setIgnoreUndefinedColumns(true)
                    .write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true)
                    .setFixedColumnNames("firstname", "lastname")
                    .setIgnoreUndefinedColumns(true).write(rows);

            LOG.info("******* COLUMNS AS ROWS ********");
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true).setColumnsAsRows(true).write(rows);

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testCsvLoaderWithCustomSerializers() {
        StringBuilder sb = new StringBuilder()
                .append("key, firstname, lastname, age, test\n")
                .append("1, eran, landau, 34, a\n")
                .append("2, netta, landau, 33, b\n")
                .append("3, arielle, landau, 6, c\n")
                .append("4, eyal, landau, 2, d\n");

        SerializerPackageImpl pkg = null;
        try {
            pkg = new SerializerPackageImpl().setKeyType("LongType")
                    .setColumnNameType("UTF8Type")
                    .setDefaultValueType("UTF8Type")
                    .setValueType("firstname", "UTF8Type")
                    .setValueType("lastname", "UTF8Type")
                    .setValueType("age", "LongType");
        } catch (UnknownComparatorException e) {
            Assert.fail();
        }

        RecordReader reader = new CsvRecordReader(new StringReader(
                sb.toString()));
        RecordWriter writer = new ColumnarRecordWriter(keyspace,
                CF_USERS.getName(), pkg);

        try {
            reader.start();
            writer.start();
            List<Pair<String, String>> record = null;
            while (null != (record = reader.next())) {
                writer.write(record);
            }
        } catch (IOException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } finally {
            reader.shutdown();
            writer.shutdown();
        }

        try {
            Rows<Long, String> rows = keyspace.prepareQuery(CF_USERS)
                    .getAllRows().execute().getResult();
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(false).write(rows);
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testCsvLoaderComposite() {
        StringBuilder sb = new StringBuilder().append("key, column, value\n")
                .append("1, a:1, 1a1\n").append("1, b:1, 2b1\n")
                .append("2, a:1, 3a1\n").append("3, a:1, 4a1\n");

        CsvColumnReader reader = new CsvColumnReader(new StringReader(
                sb.toString()));
        RecordWriter writer = new ColumnarRecordWriter(keyspace,
                CF_COMPOSITE_CSV.getName());

        try {
            reader.start();
            writer.start();
            List<Pair<String, String>> record = null;
            while (null != (record = reader.next())) {
                writer.write(record);
            }
        } catch (IOException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } finally {
            reader.shutdown();
            writer.shutdown();
        }

        try {
            Rows<ByteBuffer, ByteBuffer> rows = keyspace
                    .prepareQuery(CF_COMPOSITE_CSV).getAllRows().execute()
                    .getResult();
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(false).write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(true)
                    .setCountName("_count_").setRowsName("_rows_")
                    .setNamesName("_names_").write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(true)
                    .setDynamicColumnNames(true).write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(true)
                    .setIgnoreUndefinedColumns(true).write(rows);

            LOG.info("******* COLUMNS AS ROWS ********");
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(true).setColumnsAsRows(true)
                    .write(rows);

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testTtlValues() throws Exception {
        MutationBatch mb = keyspace.prepareMutationBatch();
        mb.withRow(CF_TTL, "row")
          .putColumn("TTL0", "TTL0", 0)
          .putColumn("TTLNULL", "TTLNULL", null)
          .putColumn("TTL1", "TTL1", 1);
        
        mb.execute();
        
        Thread.sleep(2000);
        
        ColumnList<String> result = keyspace.prepareQuery(CF_TTL)
            .getRow("row")
            .execute().getResult();
       
        Assert.assertEquals(2,  result.size());
        Assert.assertNotNull(result.getColumnByName("TTL0"));
        Assert.assertNotNull(result.getColumnByName("TTLNULL"));
    }
    
    @Test
    public void testCluster() {
        AstyanaxContext<Cluster> clusterContext = new AstyanaxContext.Builder()
                .forCluster(TEST_CLUSTER_NAME)
                .withAstyanaxConfiguration(new AstyanaxConfigurationImpl())
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl(TEST_CLUSTER_NAME)
                                .setSeeds(SEEDS).setSocketTimeout(30000)
                                .setMaxTimeoutWhenExhausted(200)
                                .setMaxConnsPerHost(1))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
                .buildCluster(ThriftFamilyFactory.getInstance());

        clusterContext.start();
        Cluster cluster = clusterContext.getEntity();

        try {
            cluster.describeClusterName();
            List<KeyspaceDefinition> keyspaces = cluster.describeKeyspaces();
            LOG.info("Keyspace count:" + keyspaces.size());
            for (KeyspaceDefinition keyspace : keyspaces) {
                LOG.info("Keyspace: " + keyspace.getName());
            }
            Assert.assertNotNull(keyspaces);
            Assert.assertTrue(keyspaces.size() > 0);
        } catch (Exception e) {
            Assert.fail(e.getMessage());
        } finally {
            clusterContext.shutdown();
        }
    }

    @Test
    public void testPrefixedSerializer() {
        ColumnFamily<String, String> cf = new ColumnFamily<String, String>(
                "Standard1", StringSerializer.get(), StringSerializer.get());

        ColumnFamily<String, String> cf1 = new ColumnFamily<String, String>(
                "Standard1", new PrefixedSerializer<String, String>("Prefix1_",
                        StringSerializer.get(), StringSerializer.get()),
                StringSerializer.get());

        ColumnFamily<String, String> cf2 = new ColumnFamily<String, String>(
                "Standard1", new PrefixedSerializer<String, String>("Prefix2_",
                        StringSerializer.get(), StringSerializer.get()),
                StringSerializer.get());

        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(cf1, "A").putColumn("Column1", "Value1", null);
        m.withRow(cf2, "A").putColumn("Column1", "Value2", null);

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            OperationResult<ColumnList<String>> result = keyspace
                    .prepareQuery(cf).getKey("Prefix1_A").execute();
            Assert.assertEquals(1, result.getResult().size());
            Column<String> c = result.getResult().getColumnByName("Column1");
            Assert.assertEquals("Value1", c.getStringValue());
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            OperationResult<ColumnList<String>> result = keyspace
                    .prepareQuery(cf).getKey("Prefix2_A").execute();
            Assert.assertEquals(1, result.getResult().size());
            Column<String> c = result.getResult().getColumnByName("Column1");
            Assert.assertEquals("Value2", c.getStringValue());
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

    }

    @Test
    public void testWithRetry() {
        String clusterName = TEST_CLUSTER_NAME + "_DOESNT_EXIST";
        AstyanaxContext<Keyspace> keyspaceContext = new AstyanaxContext.Builder()
                .forCluster(clusterName)
                .forKeyspace(TEST_KEYSPACE_NAME)
                .withAstyanaxConfiguration(
                        new AstyanaxConfigurationImpl()
                                .setDiscoveryType(NodeDiscoveryType.NONE))
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl(clusterName + "_"
                                + TEST_KEYSPACE_NAME).setMaxConnsPerHost(1)
                                .setSeeds(SEEDS))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
                .buildKeyspace(ThriftFamilyFactory.getInstance());

        ColumnFamily<String, String> cf = new ColumnFamily<String, String>(
                "DoesntExist", StringSerializer.get(), StringSerializer.get());
        try {
            MutationBatch m = keyspaceContext.getEntity()
                    .prepareMutationBatch()
                    .withRetryPolicy(new ExponentialBackoff(10, 3));
            m.withRow(cf, "Key1").putColumn("Column2", "Value2", null);
            m.execute();
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.info(e.getMessage());
        }
    }
    
    @Test
    public void testTtl() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testTtl")
                .withTtl(2)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1,  TimeUnit.SECONDS);
        
        try {
            lock.acquire();
            Assert.assertEquals(1, lock.readLockColumns().size());
            Thread.sleep(3000);
            Assert.assertEquals(0, lock.readLockColumns().size());
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        finally {
            lock.release();
        }    
        Assert.assertEquals(0, lock.readLockColumns().size());
    }
    
    @Test
    public void testTtlWithPartialUpdate() throws Exception {
    	 MutationBatch mb = keyspace.prepareMutationBatch();
         mb.withRow(CF_TTL, "row")
           .putColumn("c1", "v1", 5)
           .putColumn("c2", "v2", 5);
         mb.execute();
         
         Thread.sleep(3000);
         
         // both columns should be alive
         ColumnList<String> result = keyspace.prepareQuery(CF_TTL)
             .getRow("row")
             .execute().getResult();
         Assert.assertEquals(2,  result.size());
         Assert.assertEquals("v1", result.getColumnByName("c1").getStringValue());
         Assert.assertEquals("v2", result.getColumnByName("c2").getStringValue());
         
    	 mb = keyspace.prepareMutationBatch();
         mb.withRow(CF_TTL, "row")
           .putColumn("c1", "v1", 5);
         mb.execute();
         
         Thread.sleep(3000);
         
         // only c1 should be alive since udpate extended its life
         result = keyspace.prepareQuery(CF_TTL)
             .getRow("row")
             .execute().getResult();
         Assert.assertEquals(1,  result.size());
         Assert.assertEquals("v1", result.getColumnByName("c1").getStringValue());
         Assert.assertNull(result.getColumnByName("c2"));
         
         Thread.sleep(3000);
         
         // both columns should be dead now
         result = keyspace.prepareQuery(CF_TTL)
                 .getRow("row")
                 .execute().getResult();
         Assert.assertEquals(0,  result.size());
    }
    
    @Test
    public void testTtlString() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testTtl")
                .withTtl(2)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1,  TimeUnit.SECONDS);
        
        try {
            lock.acquire();
            Assert.assertEquals(1, lock.readLockColumns().size());
            Thread.sleep(3000);
            Assert.assertEquals(0, lock.readLockColumns().size());
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        finally {
            lock.release();
        }    
        Assert.assertEquals(0, lock.readLockColumns().size());
    }
    
    @Test
    public void testStaleLockWithFail() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock1 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1, TimeUnit.SECONDS);
        
        ColumnPrefixDistributedRowLock<String> lock2 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(9,  TimeUnit.SECONDS);
        
        try {
            lock1.acquire();
            Thread.sleep(5000);
            try {
                lock2.acquire();
            }
            catch (Exception e) {
                Assert.fail(e.getMessage());
            }
            finally {
                lock2.release();
            }
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        finally {
            lock1.release();
        }
    }
    
    @Test
    public void testStaleLockWithFail_String() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock1 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1, TimeUnit.SECONDS);
        
        ColumnPrefixDistributedRowLock<String> lock2 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(9,  TimeUnit.SECONDS);
        
        try {
            lock1.acquire();
            Thread.sleep(5000);
            try {
                lock2.acquire();
            }
            catch (Exception e) {
                Assert.fail(e.getMessage());
            }
            finally {
                lock2.release();
            }
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        finally {
            lock1.release();
        }
    }
    
    @Test
    public void testStaleLock() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock1 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1, TimeUnit.SECONDS);
        
        ColumnPrefixDistributedRowLock<String> lock2 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testStaleLock")
                .failOnStaleLock(true)
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(9, TimeUnit.SECONDS);
        
        try {
            lock1.acquire();
            Thread.sleep(2000);
            try {
                lock2.acquire();
                Assert.fail();
            }
            catch (StaleLockException e) {
            }
            catch (Exception e) {
                Assert.fail(e.getMessage());
            }
            finally {
                lock2.release();
            }
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        finally {
            lock1.release();
        }
    }
    
    @Test
    public void testStaleLock_String() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock1 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1, TimeUnit.SECONDS);
        
        ColumnPrefixDistributedRowLock<String> lock2 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testStaleLock")
                .failOnStaleLock(true)
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(9, TimeUnit.SECONDS);
        
        try {
            lock1.acquire();
            Thread.sleep(2000);
            try {
                lock2.acquire();
                Assert.fail();
            }
            catch (StaleLockException e) {
            }
            catch (Exception e) {
                Assert.fail(e.getMessage());
            }
            finally {
                lock2.release();
            }
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        finally {
            lock1.release();
        }
    }
    
    @Test
    public void testMultiLock() {
        MultiRowUniquenessConstraint unique = new MultiRowUniquenessConstraint(keyspace)
            .withConsistencyLevel(ConsistencyLevel.CL_ONE)
            .withTtl(60)
            .withLockId("abc")
            .withColumnPrefix("prefix_")
            .withRow(UNIQUE_CF, "testMultiLock_A")
            .withRow(UNIQUE_CF, "testMultiLock_B");
        
        ColumnPrefixUniquenessConstraint<String> singleUnique 
            = new ColumnPrefixUniquenessConstraint<String>(keyspace, UNIQUE_CF, "testMultiLock_A")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .withPrefix("prefix_");
        try {
            unique.acquire();
            String uniqueColumn = singleUnique.readUniqueColumn();
            Assert.assertEquals("abc", uniqueColumn);
            LOG.info("UniqueColumn: " + uniqueColumn);
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        
        MultiRowUniquenessConstraint unique2 = new MultiRowUniquenessConstraint(keyspace)
            .withTtl(60)
            .withConsistencyLevel(ConsistencyLevel.CL_ONE)
            .withColumnPrefix("prefix_")
            .withRow(UNIQUE_CF, "testMultiLock_B");
        try {
            unique2.acquire();
            Assert.fail();
        }
        catch (Exception e) {
            LOG.info(e.getMessage());
        }
        
        try {
            Assert.assertEquals("abc", singleUnique.readUniqueColumn());
            unique.release();
        }
        catch (Exception e) {
            LOG.error(e.getMessage());
            Assert.fail();
        }
        
        try {
            unique2.acquire();
        }
        catch (Exception e) {
            LOG.error(e.getMessage());
            Assert.fail();
        }
        
        try {
            unique2.release();
        } catch (Exception e) {
            LOG.error(e.getMessage());
            Assert.fail();
        }
    }
    
    @Test
    public void testRowUniquenessConstraint() throws Exception {
        RowUniquenessConstraint<String, String> unique = new RowUniquenessConstraint<String, String>
                (keyspace, UNIQUE_CF, "testRowUniquenessConstraint", UUIDStringSupplier.getInstance())
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                ;
        RowUniquenessConstraint<String, String> unique2 = new RowUniquenessConstraint<String, String>
                (keyspace, UNIQUE_CF, "testRowUniquenessConstraint", UUIDStringSupplier.getInstance())
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                ;
        
        try {
            unique.withData("abc").acquire();
            try {
                unique2.acquire();
                Assert.fail();
            }
            catch (Exception e) {
                LOG.info(e.getMessage());
            }
            
            String data = unique.readDataAsString();
            Assert.assertNotNull(data);
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
            LOG.error(e.getMessage());
        }
        finally {
            unique.release();
        }
        
        try {
            String data = unique.readDataAsString();
            Assert.fail();
        }
        catch (Exception e) {
            LOG.info("", e);
        }
    }

    @Test
    public void testPrefixUniquenessConstraint() throws Exception {
        ColumnPrefixUniquenessConstraint<String> unique = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, "testPrefixUniquenessConstraint")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                ;
        ColumnPrefixUniquenessConstraint<String> unique2 = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, "testPrefixUniquenessConstraint")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                ;
        
        try {
            unique.acquire();
            String column = unique.readUniqueColumn();
            LOG.info("Unique Column: " + column);
            
            try {
                unique2.acquire();
                Assert.fail();
            }
            catch (Exception e) {
                
            }
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
            LOG.error(e.getMessage());
        }
        finally {
            unique.release();
        }

        try {
            String column = unique.readUniqueColumn();
            LOG.info(column);
            Assert.fail();
        }
        catch (Exception e) {
            
        }
    }

    @Test
    public void testPrefixUniquenessConstraintWithColumn() throws Exception {
        ColumnPrefixUniquenessConstraint<String> unique = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, "testPrefixUniquenessConstraintWithColumn")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .withUniqueId("abc");
        ColumnPrefixUniquenessConstraint<String> unique2 = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, "testPrefixUniquenessConstraintWithColumn")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .withUniqueId("def");
        
        try {
            unique.acquire();
            
            String column = unique.readUniqueColumn();
            LOG.info("Unique Column: " + column);
            Assert.assertEquals("abc", column);
            
            try {
                unique2.acquire();
                Assert.fail();
            }
            catch (Exception e) {
                
            }
            
            column = unique.readUniqueColumn();
            LOG.info("Unique Column: " + column);
            Assert.assertEquals("abc", column);
            
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
            LOG.error(e.getMessage());
        }
        finally {
            unique.release();
        }
    }
    
    @Test 
    public void testAcquireAndMutate() throws Exception {
        final String row        = "testAcquireAndMutate";
        final String dataColumn = "data";
        final String value      = "test";
        
        ColumnPrefixUniquenessConstraint<String> unique = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, row)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .withUniqueId("def");
        
        try {
            unique.acquireAndApplyMutation(new Function<MutationBatch, Boolean>() {
                @Override
                public Boolean apply(@Nullable MutationBatch m) {
                    m.withRow(UNIQUE_CF, row)
                        .putColumn(dataColumn, value, null);
                    return true;
                }
            });
            String column = unique.readUniqueColumn();
            Assert.assertNotNull(column);
        }
        catch (Exception e) {
            e.printStackTrace();
            LOG.error("", e);
            Assert.fail();
        }
        finally {
        }
        
        ColumnList<String> columns = keyspace.prepareQuery(UNIQUE_CF).getKey(row).execute().getResult();
        Assert.assertEquals(2, columns.size());
        Assert.assertEquals(value, columns.getStringValue(dataColumn, null));
        
        unique.release();
        
        columns = keyspace.prepareQuery(UNIQUE_CF).getKey(row).execute().getResult();
        Assert.assertEquals(1, columns.size());
        Assert.assertEquals(value, columns.getStringValue(dataColumn, null));
    }
    
    // This test confirms the fix for https://github.com/Netflix/astyanax/issues/170
    @Test
    public void columnAutoPaginateTest() throws Exception {
        final ColumnFamily<String, UUID> CF1 = ColumnFamily.newColumnFamily("CF1", StringSerializer.get(),
                TimeUUIDSerializer.get());
        final ColumnFamily<String, String> CF2 = ColumnFamily.newColumnFamily("CF2", StringSerializer.get(),
                StringSerializer.get());
        
        keyspace.createColumnFamily(CF1, null);
        Thread.sleep(3000);
        keyspace.createColumnFamily(CF2, null);
        Thread.sleep(3000);
    
        // query on another column family with different column key type
        // does not seem to work after the first query
        keyspace.prepareQuery(CF2).getKey("anything").execute();

        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF1, "test").putColumn(TimeUUIDUtils.getUniqueTimeUUIDinMillis(), "value1", null);
        m.execute();
    
        RowQuery<String, UUID> query = keyspace.prepareQuery(CF1).getKey("test").autoPaginate(true);
    
        // Adding a column range removes the problem
        // query.withColumnRange(new RangeBuilder().build());
    
        ColumnList<UUID> columns = query.execute().getResult();
        
        keyspace.prepareQuery(CF2).getKey("anything").execute();
    }
    
    private boolean deleteColumn(ColumnFamily<String, String> cf,
            String rowKey, String columnName) {
        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(cf, rowKey).deleteColumn(columnName);

        try {
            m.execute();
            return true;
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
            return false;
        }
    }

    private Column<String> getColumnValue(ColumnFamily<String, String> cf,
            String rowKey, String columnName) {
        OperationResult<Column<String>> result;
        try {
            result = keyspace.prepareQuery(cf).getKey(rowKey)
                    .getColumn(columnName).execute();
            return result.getResult();
        } catch (NotFoundException e) {
            LOG.info(e.getMessage());
            return null;
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
            return null;
        }
    }
}||||||| BASE
package com.netflix.astyanax.thrift;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringReader;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicLong;

import javax.annotation.Nullable;

import junit.framework.Assert;

import org.apache.cassandra.utils.Pair;
import org.apache.commons.lang.RandomStringUtils;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Function;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.netflix.astyanax.AstyanaxContext;
import com.netflix.astyanax.Cluster;
import com.netflix.astyanax.ColumnListMutation;
import com.netflix.astyanax.ExceptionCallback;
import com.netflix.astyanax.Keyspace;
import com.netflix.astyanax.MutationBatch;
import com.netflix.astyanax.RowCallback;
import com.netflix.astyanax.Serializer;
import com.netflix.astyanax.SerializerPackage;
import com.netflix.astyanax.connectionpool.Host;
import com.netflix.astyanax.connectionpool.NodeDiscoveryType;
import com.netflix.astyanax.connectionpool.OperationResult;
import com.netflix.astyanax.connectionpool.TokenRange;
import com.netflix.astyanax.connectionpool.exceptions.ConnectionException;
import com.netflix.astyanax.connectionpool.exceptions.NotFoundException;
import com.netflix.astyanax.connectionpool.impl.ConnectionPoolConfigurationImpl;
import com.netflix.astyanax.connectionpool.impl.ConnectionPoolType;
import com.netflix.astyanax.connectionpool.impl.CountingConnectionPoolMonitor;
import com.netflix.astyanax.cql.CqlStatementResult;
import com.netflix.astyanax.ddl.ColumnFamilyDefinition;
import com.netflix.astyanax.ddl.FieldMetadata;
import com.netflix.astyanax.ddl.KeyspaceDefinition;
import com.netflix.astyanax.impl.AstyanaxConfigurationImpl;
import com.netflix.astyanax.impl.FilteringHostSupplier;
import com.netflix.astyanax.impl.RingDescribeHostSupplier;
import com.netflix.astyanax.model.Column;
import com.netflix.astyanax.model.ColumnFamily;
import com.netflix.astyanax.model.ColumnList;
import com.netflix.astyanax.model.ColumnSlice;
import com.netflix.astyanax.model.ConsistencyLevel;
import com.netflix.astyanax.model.CqlResult;
import com.netflix.astyanax.model.Equality;
import com.netflix.astyanax.model.Row;
import com.netflix.astyanax.model.Rows;
import com.netflix.astyanax.query.IndexQuery;
import com.netflix.astyanax.query.PreparedIndexExpression;
import com.netflix.astyanax.query.RowQuery;
import com.netflix.astyanax.recipes.UUIDStringSupplier;
import com.netflix.astyanax.recipes.locks.BusyLockException;
import com.netflix.astyanax.recipes.locks.ColumnPrefixDistributedRowLock;
import com.netflix.astyanax.recipes.locks.StaleLockException;
import com.netflix.astyanax.recipes.queue.CountingQueueStats;
import com.netflix.astyanax.recipes.queue.Message;
import com.netflix.astyanax.recipes.queue.MessageConsumer;
import com.netflix.astyanax.recipes.queue.MessageContext;
import com.netflix.astyanax.recipes.queue.MessageHistory;
import com.netflix.astyanax.recipes.queue.MessageProducer;
import com.netflix.astyanax.recipes.queue.MessageQueue;
import com.netflix.astyanax.recipes.queue.MessageQueueDispatcher;
import com.netflix.astyanax.recipes.queue.MessageQueueException;
import com.netflix.astyanax.recipes.queue.SendMessageResponse;
import com.netflix.astyanax.recipes.queue.ShardedDistributedMessageQueue;
import com.netflix.astyanax.recipes.queue.triggers.RepeatingTrigger;
import com.netflix.astyanax.recipes.reader.AllRowsReader;
import com.netflix.astyanax.recipes.uniqueness.ColumnPrefixUniquenessConstraint;
import com.netflix.astyanax.recipes.uniqueness.DedicatedMultiRowUniquenessConstraint;
import com.netflix.astyanax.recipes.uniqueness.MultiRowUniquenessConstraint;
import com.netflix.astyanax.recipes.uniqueness.NotUniqueException;
import com.netflix.astyanax.recipes.uniqueness.RowUniquenessConstraint;
import com.netflix.astyanax.retry.ExponentialBackoff;
import com.netflix.astyanax.serializers.AnnotatedCompositeSerializer;
import com.netflix.astyanax.serializers.ByteBufferSerializer;
import com.netflix.astyanax.serializers.LongSerializer;
import com.netflix.astyanax.serializers.ObjectSerializer;
import com.netflix.astyanax.serializers.PrefixedSerializer;
import com.netflix.astyanax.serializers.SerializerPackageImpl;
import com.netflix.astyanax.serializers.StringSerializer;
import com.netflix.astyanax.serializers.TimeUUIDSerializer;
import com.netflix.astyanax.serializers.UnknownComparatorException;
import com.netflix.astyanax.test.EmbeddedCassandra;
import com.netflix.astyanax.test.SessionEvent;
import com.netflix.astyanax.util.ColumnarRecordWriter;
import com.netflix.astyanax.util.CsvColumnReader;
import com.netflix.astyanax.util.CsvRecordReader;
import com.netflix.astyanax.util.JsonRowsWriter;
import com.netflix.astyanax.util.RangeBuilder;
import com.netflix.astyanax.util.RecordReader;
import com.netflix.astyanax.util.RecordWriter;
import com.netflix.astyanax.util.SingletonEmbeddedCassandra;
import com.netflix.astyanax.util.TimeUUIDUtils;

public class ThrifeKeyspaceImplTest {

    private static Logger LOG = LoggerFactory.getLogger(ThrifeKeyspaceImplTest.class);

    private static Keyspace                  keyspace;
    private static AstyanaxContext<Keyspace> keyspaceContext;

    private static String TEST_CLUSTER_NAME  = "cass_sandbox";
    private static String TEST_KEYSPACE_NAME = "AstyanaxUnitTests";
    private static String SCHEDULER_NAME_CF_NAME = "SchedulerQueue";

    private static ColumnFamily<String, String> CF_USER_INFO = ColumnFamily.newColumnFamily(
            "Standard1", // Column Family Name
            StringSerializer.get(), // Key Serializer
            StringSerializer.get()); // Column Serializer

    private static ColumnFamily<Long, Long> CF_DELETE = ColumnFamily
            .newColumnFamily(
                    "delete", 
                    LongSerializer.get(),
                    LongSerializer.get());
    
    private static ColumnFamily<Long, String> CF_USERS = ColumnFamily
            .newColumnFamily(
                    "users", 
                    LongSerializer.get(),
                    StringSerializer.get());

    private static ColumnFamily<String, String> CF_TTL = ColumnFamily
            .newColumnFamily(
                    "ttl", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, String> CF_STANDARD1 = ColumnFamily
            .newColumnFamily(
                    "Standard1", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, Long> CF_LONGCOLUMN = ColumnFamily
            .newColumnFamily(
                    "LongColumn1", 
                    StringSerializer.get(),
                    LongSerializer.get());

    public static ColumnFamily<String, String> CF_STANDARD2 = ColumnFamily
            .newColumnFamily(
                    "Standard2", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, String> CF_COUNTER1 = ColumnFamily
            .newColumnFamily(
                    "Counter1", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, String> CF_NOT_DEFINED = ColumnFamily
            .newColumnFamily(
                    "NotDefined", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static ColumnFamily<String, String> CF_EMPTY = ColumnFamily
            .newColumnFamily(
                    "NotDefined", 
                    StringSerializer.get(),
                    StringSerializer.get());

    public static AnnotatedCompositeSerializer<MockCompositeType> M_SERIALIZER = new AnnotatedCompositeSerializer<MockCompositeType>(
            MockCompositeType.class);
    
    public static ColumnFamily<String, MockCompositeType> CF_COMPOSITE = ColumnFamily
            .newColumnFamily(
                    "CompositeColumn", 
                    StringSerializer.get(),
                    M_SERIALIZER);

    public static ColumnFamily<ByteBuffer, ByteBuffer> CF_COMPOSITE_CSV = ColumnFamily
            .newColumnFamily(
                    "CompositeCsv", 
                    ByteBufferSerializer.get(),
                    ByteBufferSerializer.get());

    public static ColumnFamily<MockCompositeType, String> CF_COMPOSITE_KEY = ColumnFamily
            .newColumnFamily(
                    "CompositeKey",
                    M_SERIALIZER, 
                    StringSerializer.get());

    public static ColumnFamily<String, UUID> CF_TIME_UUID = ColumnFamily
            .newColumnFamily(
                    "TimeUUID1", 
                    StringSerializer.get(),
                    TimeUUIDSerializer.get());

    public static ColumnFamily<String, UUID> CF_USER_UNIQUE_UUID = ColumnFamily
            .newColumnFamily(
                    "UserUniqueUUID", 
                    StringSerializer.get(),
                    TimeUUIDSerializer.get());
    
    public static ColumnFamily<String, UUID> CF_EMAIL_UNIQUE_UUID = ColumnFamily
            .newColumnFamily(
                    "EmailUniqueUUID", 
                    StringSerializer.get(),
                    TimeUUIDSerializer.get());
    
    private static ColumnFamily<String, String> UNIQUE_CF = ColumnFamily
            .newColumnFamily(
                    "UniqueCf", 
                    StringSerializer.get(), 
                    StringSerializer.get());

    public static AnnotatedCompositeSerializer<SessionEvent> SE_SERIALIZER = new AnnotatedCompositeSerializer<SessionEvent>(
            SessionEvent.class);

    public static ColumnFamily<String, SessionEvent> CF_CLICK_STREAM = ColumnFamily
            .newColumnFamily("ClickStream", StringSerializer.get(),
                    SE_SERIALIZER);

    private static ColumnFamily<String, String> LOCK_CF_LONG   = 
            ColumnFamily.newColumnFamily("LockCfLong", StringSerializer.get(), StringSerializer.get(), LongSerializer.get());
    
    private static ColumnFamily<String, String> LOCK_CF_STRING = 
            ColumnFamily.newColumnFamily("LockCfString", StringSerializer.get(), StringSerializer.get(), StringSerializer.get());
    
    private static final String SEEDS = "localhost:9160";

    private static final long   CASSANDRA_WAIT_TIME = 3000;
    private static final int    TTL                 = 20;
    private static final int    TIMEOUT             = 10;
    
    @BeforeClass
    public static void setup() throws Exception {
        System.out.println("TESTING THRIFT KEYSPACE");

        SingletonEmbeddedCassandra.getInstance();
        
        Thread.sleep(CASSANDRA_WAIT_TIME);
        
        createKeyspace();
    }

    @AfterClass
    public static void teardown() throws Exception {
        if (keyspaceContext != null)
            keyspaceContext.shutdown();
        
        Thread.sleep(CASSANDRA_WAIT_TIME);
    }

    public static void createKeyspace() throws Exception {
        keyspaceContext = new AstyanaxContext.Builder()
                .forCluster(TEST_CLUSTER_NAME)
                .forKeyspace(TEST_KEYSPACE_NAME)
                .withAstyanaxConfiguration(
                        new AstyanaxConfigurationImpl()
                                .setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE)
                                .setConnectionPoolType(ConnectionPoolType.TOKEN_AWARE)
                                .setDiscoveryDelayInSeconds(60000))
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl(TEST_CLUSTER_NAME
                                + "_" + TEST_KEYSPACE_NAME)
                                .setSocketTimeout(30000)
                                .setMaxTimeoutWhenExhausted(2000)
                                .setMaxConnsPerHost(20)
                                .setInitConnsPerHost(10)
                                .setSeeds(SEEDS))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
                .buildKeyspace(ThriftFamilyFactory.getInstance());

        keyspaceContext.start();
        
        keyspace = keyspaceContext.getEntity();
        
        try {
            keyspace.dropKeyspace();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        
        keyspace.createKeyspace(ImmutableMap.<String, Object>builder()
                .put("strategy_options", ImmutableMap.<String, Object>builder()
                        .put("replication_factor", "1")
                        .build())
                .put("strategy_class",     "SimpleStrategy")
                .build()
                );
        
        keyspace.createColumnFamily(CF_STANDARD1, ImmutableMap.<String, Object>builder()
                .put("column_metadata", ImmutableMap.<String, Object>builder()
                        .put("Index1", ImmutableMap.<String, Object>builder()
                                .put("validation_class", "UTF8Type")
                                .put("index_name",       "Index1")
                                .put("index_type",       "KEYS")
                                .build())
                        .put("Index2", ImmutableMap.<String, Object>builder()
                                .put("validation_class", "UTF8Type")
                                .put("index_name",       "Index2")
                                .put("index_type",       "KEYS")
                                .build())
                         .build())
                     .build());
        
        keyspace.createColumnFamily(CF_TTL,        null);
        keyspace.createColumnFamily(CF_STANDARD2,  null);
        keyspace.createColumnFamily(CF_LONGCOLUMN, null);
        keyspace.createColumnFamily(CF_DELETE,     null);
        keyspace.createColumnFamily(CF_COUNTER1, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "CounterColumnType")
                .build());
        keyspace.createColumnFamily(CF_CLICK_STREAM, ImmutableMap.<String, Object>builder()
                .put("comparator_type", "CompositeType(UTF8Type, TimeUUIDType)")
                .build());
        keyspace.createColumnFamily(CF_COMPOSITE_CSV, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "UTF8Type")
                .put("key_validation_class",     "UTF8Type")
                .put("comparator_type",          "CompositeType(UTF8Type, LongType)")
                .build());
        keyspace.createColumnFamily(CF_COMPOSITE, ImmutableMap.<String, Object>builder()
                .put("comparator_type", "CompositeType(AsciiType, IntegerType(reversed=true), IntegerType, BytesType, UTF8Type)")
                .build());
        keyspace.createColumnFamily(CF_COMPOSITE_KEY, ImmutableMap.<String, Object>builder()
                .put("key_validation_class", "BytesType")
                .build());
        keyspace.createColumnFamily(CF_TIME_UUID,         null);
        keyspace.createColumnFamily(CF_USER_UNIQUE_UUID,  null);
        keyspace.createColumnFamily(CF_EMAIL_UNIQUE_UUID, null);
        keyspace.createColumnFamily(CF_USERS, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "UTF8Type")
                .put("column_metadata", ImmutableMap.<String, Object>builder()
                        .put("firstname",  ImmutableMap.<String, Object>builder()
                                .put("validation_class", "UTF8Type")
                                .put("index_name",       "firstname")
                                .put("index_type",       "KEYS")
                                .build())
                        .put("lastname", ImmutableMap.<String, Object>builder()
                                .put("validation_class", "UTF8Type")
                                .put("index_name",       "lastname")
                                .put("index_type",       "KEYS")
                                .build())
                        .put("age", ImmutableMap.<String, Object>builder()
                                .put("validation_class", "LongType")
                                .put("index_name",       "age")
                                .put("index_type",       "KEYS")
                                .build())
                        .build())
                     .build());
        
        keyspace.createColumnFamily(LOCK_CF_LONG, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "LongType")
                .put("key_validation_class",     "UTF8Type")
                .put("comparator_type",          "UTF8Type")
                .build());
        
        keyspace.createColumnFamily(LOCK_CF_STRING, ImmutableMap.<String, Object>builder()
                .put("default_validation_class", "UTF8Type")
                .put("key_validation_class",     "UTF8Type")
                .put("comparator_type",          "UTF8Type")
                .build());
        
        keyspace.createColumnFamily(UNIQUE_CF, null);
        
        KeyspaceDefinition ki = keyspaceContext.getEntity().describeKeyspace();
        System.out.println("Describe Keyspace: " + ki.getName());

        try {
            //
            // CF_Super :
            // 'A' :
            // 'a' :
            // 1 : 'Aa1',
            // 2 : 'Aa2',
            // 'b' :
            // ...
            // 'z' :
            // ...
            // 'B' :
            // ...
            //
            // CF_Standard :
            // 'A' :
            // 'a' : 1,
            // 'b' : 2,
            // ...
            // 'z' : 26,
            // 'B' :
            // ...
            //

            MutationBatch m;
            OperationResult<Void> result;
            m = keyspace.prepareMutationBatch();

            for (char keyName = 'A'; keyName <= 'Z'; keyName++) {
                String rowKey = Character.toString(keyName);
                ColumnListMutation<String> cfmStandard = m.withRow(
                        CF_STANDARD1, rowKey);
                for (char cName = 'a'; cName <= 'z'; cName++) {
                    cfmStandard.putColumn(Character.toString(cName),
                            (int) (cName - 'a') + 1, null);
                }
                cfmStandard
                        .putColumn("Index1", (int) (keyName - 'A') + 1, null);
                cfmStandard.putColumn("Index2", 42, null);
                m.execute();
            }

            m.withRow(CF_STANDARD1, "Prefixes").putColumn("Prefix1_a", 1, null)
                    .putColumn("Prefix1_b", 2, null)
                    .putColumn("prefix2_a", 3, null);

            result = m.execute();

            String rowKey = "A";
            ColumnListMutation<Long> cfmLong = m.withRow(CF_LONGCOLUMN, rowKey);
            for (Long l = -10L; l < 10L; l++) {
                cfmLong.putEmptyColumn(l, null);
            }
            cfmLong.putEmptyColumn(Long.MAX_VALUE, null);
            result = m.execute();

            m.withRow(CF_USER_INFO, "acct1234")
                .putColumn("firstname", "john", null)
                .putColumn("lastname", "smith", null)
                .putColumn("address", "555 Elm St", null)
                .putColumn("age", 30, null)
                .putEmptyColumn("empty");

            m.execute();

        } catch (Exception e) {
            System.out.println(e.getMessage());
            Assert.fail();
        }
    }

    @Test
    public void testMultiColumnDelete() throws Exception {
        MutationBatch mb = keyspace.prepareMutationBatch();
        mb.withRow(CF_DELETE, 1L)
            .setTimestamp(1).putEmptyColumn(1L, null)
            .setTimestamp(10).putEmptyColumn(2L, null)
            ;
        mb.execute();
        
        ColumnList<Long> result1 = keyspace.prepareQuery(CF_DELETE).getRow(1L).execute().getResult();
        Assert.assertEquals(2, result1.size());
        Assert.assertNotNull(result1.getColumnByName(1L));
        Assert.assertNotNull(result1.getColumnByName(2L));
        
        logColumnList("Insert", result1);
        
        mb = keyspace.prepareMutationBatch();
        mb.withRow(CF_DELETE,  1L)
            .setTimestamp(result1.getColumnByName(1L).getTimestamp()-1)
            .deleteColumn(1L)
            .setTimestamp(result1.getColumnByName(2L).getTimestamp()-1)
            .deleteColumn(2L)
            .putEmptyColumn(3L, null);
        
        mb.execute();
        
        result1 = keyspace.prepareQuery(CF_DELETE).getRow(1L).execute().getResult();
        logColumnList("Delete with older timestamp", result1);
        Assert.assertEquals(3, result1.size());
        
        LOG.info("Delete L2 with TS: " + (result1.getColumnByName(2L).getTimestamp()+1));
        mb.withRow(CF_DELETE,  1L)
            .setTimestamp(result1.getColumnByName(1L).getTimestamp()+1)
            .deleteColumn(1L)
            .setTimestamp(result1.getColumnByName(2L).getTimestamp()+1)
            .deleteColumn(2L);
        mb.execute();
        
        result1 = keyspace.prepareQuery(CF_DELETE).getRow(1L).execute().getResult();
        logColumnList("Delete with newer timestamp", result1);
        Assert.assertEquals(1, result1.size());
    }
    
    <T> void logColumnList(String label, ColumnList<T> cl) {
        LOG.info(">>>>>> " + label);
        for (Column<T> c : cl) {
            LOG.info(c.getName() + " " + c.getTimestamp());
        }
        LOG.info("<<<<<<");
    }
    
    @Test
    public void testCqlComposite() throws Exception {
        CqlStatementResult result = keyspace.prepareCqlStatement()
            .withCql("SELECT * FROM " + CF_COMPOSITE_CSV.getName())
            .execute()
            .getResult();
        
        result.getSchema();
        result.getRows(CF_COMPOSITE_CSV);
    }
    
    @Test
    public void testHasValue() throws Exception {
        ColumnList<String> response = keyspace.prepareQuery(CF_USER_INFO).getRow("acct1234").execute().getResult();
        Assert.assertEquals("firstname", response.getColumnByName("firstname").getName());
        Assert.assertEquals("firstname", response.getColumnByName("firstname").getName());
        Assert.assertEquals("john", response.getColumnByName("firstname").getStringValue());
        Assert.assertEquals("john", response.getColumnByName("firstname").getStringValue());
        Assert.assertEquals(true,  response.getColumnByName("firstname").hasValue());
        Assert.assertEquals(false, response.getColumnByName("empty").hasValue());
        
    }
    
    @Test
    public void getKeyspaceDefinition() throws Exception {
        KeyspaceDefinition def = keyspaceContext.getEntity().describeKeyspace();
        Collection<String> fieldNames = def.getFieldNames();
        LOG.info("Getting field names");
        for (String field : fieldNames) {
            LOG.info(field);
        }
        LOG.info(fieldNames.toString());
        
        System.out.println(fieldNames.toString());
        
        for (FieldMetadata field : def.getFieldsMetadata()) {
            System.out.println(field.getName() + " = " + def.getFieldValue(field.getName()) + " (" + field.getType() + ")");
        }
        
        for (ColumnFamilyDefinition cfDef : def.getColumnFamilyList()) {
            LOG.info("----------" );
            for (FieldMetadata field : cfDef.getFieldsMetadata()) {
                LOG.info(field.getName() + " = " + cfDef.getFieldValue(field.getName()) + " (" + field.getType() + ")");
            }
        }
    }
    
    @Test
    public void testNonExistentKeyspace()  {
        AstyanaxContext<Keyspace> ctx = new AstyanaxContext.Builder()
            .forCluster(TEST_CLUSTER_NAME)
            .forKeyspace(TEST_KEYSPACE_NAME + "_NonExistent")
            .withAstyanaxConfiguration(
                    new AstyanaxConfigurationImpl()
                            .setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE)
                            .setConnectionPoolType(ConnectionPoolType.TOKEN_AWARE)
                            .setDiscoveryDelayInSeconds(60000))
            .withConnectionPoolConfiguration(
                    new ConnectionPoolConfigurationImpl(TEST_CLUSTER_NAME
                            + "_" + TEST_KEYSPACE_NAME)
                            .setSocketTimeout(30000)
                            .setMaxTimeoutWhenExhausted(2000)
                            .setMaxConnsPerHost(20)
                            .setInitConnsPerHost(10)
                            .setSeeds(SEEDS))
            .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
            .buildKeyspace(ThriftFamilyFactory.getInstance());        
        
        ctx.start();
        
        try {
            KeyspaceDefinition keyspaceDef = ctx.getEntity().describeKeyspace();
        } catch (ConnectionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        
    }
    
    @Test
    public void testDescribeRing() throws Exception {
        // [TokenRangeImpl [startToken=0, endToken=0, endpoints=[127.0.0.1]]]
        List<TokenRange> ring = keyspaceContext.getEntity().describeRing();
        LOG.info(ring.toString());
        
        // 127.0.0.1
        RingDescribeHostSupplier ringSupplier = new RingDescribeHostSupplier(keyspaceContext.getEntity(), 9160);
        List<Host> hosts = ringSupplier.get();
        Assert.assertEquals(1, hosts.get(0).getTokenRanges().size());
        LOG.info(hosts.toString());
        
        Supplier<List<Host>> sourceSupplier1 = Suppliers.ofInstance((List<Host>)Lists.newArrayList(new Host("127.0.0.1", 9160)));
        Supplier<List<Host>> sourceSupplier2 = Suppliers.ofInstance((List<Host>)Lists.newArrayList(new Host("127.0.0.2", 9160)));
        
        // 127.0.0.1
        LOG.info(sourceSupplier1.get().toString());
        
        // 127.0.0.2
        LOG.info(sourceSupplier2.get().toString());
        
        hosts = new FilteringHostSupplier(ringSupplier, sourceSupplier1).get();
        LOG.info(hosts.toString());
        
        Assert.assertEquals(1, hosts.size());
        Assert.assertEquals(1, hosts.get(0).getTokenRanges().size());
        hosts = new FilteringHostSupplier(ringSupplier, sourceSupplier2).get();
        LOG.info(hosts.toString());
        Assert.assertEquals(1, hosts.size());
    }
    
    @Test
    public void paginateColumns() {
        String column = "";
        ColumnList<String> columns;
        int pageize = 10;
        try {
            RowQuery<String, String> query = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .getKey("A")
                    .autoPaginate(true)
                    .withColumnRange(
                            new RangeBuilder().setStart(column)
                                    .setLimit(pageize).build());

            while (!(columns = query.execute().getResult()).isEmpty()) {
                for (Column<String> c : columns) {
                }
                // column = Iterables.getLast(columns).getName() + "\u0000";
            }
        } catch (ConnectionException e) {
            System.out.println(e.getMessage());
        }
    }

    @Test
    public void example() {
        AstyanaxContext<Keyspace> context = new AstyanaxContext.Builder()
                .forCluster(TEST_CLUSTER_NAME)
                .forKeyspace(TEST_KEYSPACE_NAME)
                .withAstyanaxConfiguration(
                        new AstyanaxConfigurationImpl()
                                .setDiscoveryType(NodeDiscoveryType.NONE))
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl("MyConnectionPool")
                                .setMaxConnsPerHost(1).setSeeds(
                                        "127.0.0.1:9160"))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
                .buildKeyspace(ThriftFamilyFactory.getInstance());

        context.start();
        Keyspace keyspace = context.getEntity();

        MutationBatch m = keyspace.prepareMutationBatch();

        // m.withRow(CF_USER_STATS, "acct1234")
        // .incrementCounterColumn("loginCount", 1);

        try {
            OperationResult<Void> result = m.execute();
        } catch (ConnectionException e) {
            System.out.println(e);
        }

        try {
            OperationResult<ColumnList<String>> result = keyspace
                    .prepareQuery(CF_USER_INFO).getKey("acct1234").execute();
            ColumnList<String> columns = result.getResult();

            // Lookup columns in response by name
            int age = columns.getColumnByName("age").getIntegerValue();
            String address = columns.getColumnByName("address")
                    .getStringValue();

            // Or, iterate through the columns
            for (Column<String> c : result.getResult()) {
                System.out.println(c.getName());
            }
        } catch (ConnectionException e) {
            System.out.println(e);
        }

    }
    
    @Test
    public void testMultiRowUniqueness() {
        DedicatedMultiRowUniquenessConstraint<UUID> constraint = new DedicatedMultiRowUniquenessConstraint<UUID>
                  (keyspace, TimeUUIDUtils.getUniqueTimeUUIDinMicros())
                  .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                  .withRow(CF_USER_UNIQUE_UUID, "user1")
                  .withRow(CF_EMAIL_UNIQUE_UUID, "user1@domain.com");
        
        DedicatedMultiRowUniquenessConstraint<UUID> constraint2 = new DedicatedMultiRowUniquenessConstraint<UUID>
                  (keyspace, TimeUUIDUtils.getUniqueTimeUUIDinMicros())
                  .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                  .withRow(CF_USER_UNIQUE_UUID, "user1")
                  .withRow(CF_EMAIL_UNIQUE_UUID, "user1@domain.com");
        
        try {
            Column<UUID> c = constraint.getUniqueColumn();
            Assert.fail();
        }
        catch (Exception e) {
            LOG.info(e.getMessage());
        }
        
        try {
            constraint.acquire();
            
            Column<UUID> c = constraint.getUniqueColumn();
            LOG.info("Unique column is " + c.getName());
            
            try {
                constraint2.acquire();
                Assert.fail("Should already be acquired");
            }
            catch (NotUniqueException e) {
                
            }
            catch (Exception e) {
                e.printStackTrace();
                Assert.fail();
            }
            finally {
                try {
                    constraint2.release();
                }
                catch (Exception e) {
                    e.printStackTrace();
                    Assert.fail();
                }
            }
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail();
        }
        finally {
            try {
                constraint.release();
            }
            catch (Exception e) {
                e.printStackTrace();
                Assert.fail();
            }
        }
        
        try {
            constraint2.acquire();
            Column<UUID> c = constraint.getUniqueColumn();
            LOG.info("Unique column is " + c.getName());
        }
        catch (NotUniqueException e) {
            Assert.fail("Should already be unique");
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail();
        }
        finally {
            try {
                constraint2.release();
            }
            catch (Exception e) {
                e.printStackTrace();
                Assert.fail();
            }
        }
        
    }

    @Test
    public void paginateLongColumns() {
        Long column = Long.MIN_VALUE;
        ColumnList<Long> columns;
        int pageize = 10;
        try {
            RowQuery<String, Long> query = keyspace
                    .prepareQuery(CF_LONGCOLUMN)
                    .getKey("A")
                    .autoPaginate(true)
                    .withColumnRange(
                            new RangeBuilder().setStart(column)
                                    .setLimit(pageize).build());

            while (!(columns = query.execute().getResult()).isEmpty()) {
                LOG.info("-----");
                for (Column<Long> c : columns) {
                    LOG.info(Long.toString(c.getName()));
                }
                // column = Iterables.getLast(columns).getName() + "\u0000";
            }
        } catch (ConnectionException e) {
        }
    }

    @Test
    public void getAll() {
        try {
            OperationResult<Rows<String, String>> rows = keyspace
                    .prepareQuery(CF_STANDARD1).getAllRows().setRowLimit(10)
                    .withColumnRange(new RangeBuilder().setLimit(0).build())
                    .setExceptionCallback(new ExceptionCallback() {
                        @Override
                        public boolean onException(ConnectionException e) {
                            Assert.fail(e.getMessage());
                            return true;
                        }
                    }).execute();
            for (Row<String, String> row : rows.getResult()) {
                LOG.info("ROW: " + row.getKey() + " " + row.getColumns().size());
            }
        } catch (ConnectionException e) {
            Assert.fail();
        }
    }
    
    @Test
    public void testAllRowsReader() throws Exception {
        final AtomicLong counter = new AtomicLong(0);
        
        boolean result = new AllRowsReader.Builder<String, String>(keyspace, CF_STANDARD1)
                .forEachRow(new Function<Row<String, String>, Boolean>() {
                    @Override
                    public Boolean apply(@Nullable Row<String, String> row) {
                        counter.incrementAndGet();
                        LOG.info("Got a row: " + row.getKey().toString());
                        return true;
                    }
                })
                .build()
                .call();
        
        Assert.assertTrue(result);
        Assert.assertEquals(28, counter.get());
    }
    
    @Test
    public void testAllRowsReaderWithCancel() throws Exception {
        final AtomicLong counter = new AtomicLong(0);
        
        AllRowsReader<String, String> reader = new AllRowsReader.Builder<String, String>(keyspace, CF_STANDARD1)
                .withPageSize(3)
                .forEachRow(new Function<Row<String, String>, Boolean>() {
                    @Override
                    public Boolean apply(@Nullable Row<String, String> row) {
                        try {
                            Thread.sleep(200);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            throw new RuntimeException(e);
                        }
                        counter.incrementAndGet();
                        LOG.info("Got a row: " + row.getKey().toString());
                        return true;
                    }
                })
                .build();
        
        
        Future<Boolean> future = Executors.newSingleThreadExecutor().submit(reader);        
        
        Thread.sleep(1000);
        
        reader.cancel();
        
        try {
            boolean result = future.get();
            Assert.assertEquals(false, result);
            Assert.fail();
        }
        catch (Exception e) {
            LOG.info("Failed to execute", e);
        }
        LOG.info("Before: " + counter.get());
        Assert.assertNotSame(28, counter.get());
        Thread.sleep(2000);
        LOG.info("After: " + counter.get());
        Assert.assertNotSame(28, counter.get());
    }

    @Test
    public void testAllRowsReaderConcurrency() throws Exception {
        final AtomicLong counter = new AtomicLong(0);
        
        boolean result = new AllRowsReader.Builder<String, String>(keyspace, CF_STANDARD1)
                .withConcurrencyLevel(4)
                .forEachRow(new Function<Row<String, String>, Boolean>() {
                    @Override
                    public Boolean apply(@Nullable Row<String, String> row) {
                        counter.incrementAndGet();
                        LOG.info("Got a row: " + row.getKey().toString());
                        return true;
                    }
                })
                .build()
                .call();
        
        Assert.assertTrue(result);
        Assert.assertEquals(28, counter.get());
    }

    @Test
    public void getAllWithCallback() {
        try {
            final AtomicLong counter = new AtomicLong();

            keyspace.prepareQuery(CF_STANDARD1).getAllRows().setRowLimit(3)
                    .setRepeatLastToken(false)
                    .withColumnRange(new RangeBuilder().setLimit(2).build())
                    .executeWithCallback(new RowCallback<String, String>() {
                        @Override
                        public void success(Rows<String, String> rows) {
                            for (Row<String, String> row : rows) {
                                LOG.info("ROW: " + row.getKey() + " "
                                        + row.getColumns().size());
                                counter.incrementAndGet();
                            }
                        }

                        @Override
                        public boolean failure(ConnectionException e) {
                            LOG.error(e.getMessage(), e);
                            return false;
                        }
                    });
            LOG.info("Read " + counter.get() + " keys");
        } catch (ConnectionException e) {
            Assert.fail();
        }
    }

    static class UserInfo implements Serializable {
        private static final long serialVersionUID = 6366200973810770033L;

        private String firstName;
        private String lastName;

        public UserInfo() {

        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        public String getFirstName() {
            return this.firstName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }

        public String getLastName() {
            return this.lastName;
        }

        public boolean equals(Object other) {
            UserInfo smo = (UserInfo) other;
            return firstName.equals(smo.firstName)
                    && lastName.equals(smo.lastName);
        }
    }

    @Test
    public void testSerializedClassValue() {
        UserInfo smo = new UserInfo();
        smo.setLastName("Landau");
        smo.setFirstName("Eran");

        try {
            ByteBuffer bb = ObjectSerializer.get().toByteBuffer(smo);
            keyspace.prepareColumnMutation(CF_STANDARD1, "Key_SerializeTest",
                    "Column1").putValue(bb, null).execute();

            UserInfo smo2 = (UserInfo) keyspace.prepareQuery(CF_STANDARD1)
                    .getKey("Key_SerializeTest").getColumn("Column1").execute()
                    .getResult().getValue(ObjectSerializer.get());

            Assert.assertEquals(smo, smo2);
        } catch (ConnectionException e) {
            Assert.fail();
        }
    }    
    
    @Test
    public void testSingleOps() throws Exception {
        String key = "SingleOpsTest";
        Random prng = new Random();

        // Set a string value
        {
            String column = "StringColumn";
            String value = RandomStringUtils.randomAlphanumeric(32);
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            String v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getStringValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult()
                        .getStringValue();
                Assert.fail();
            } catch (NotFoundException e) {
            } catch (ConnectionException e) {
                Assert.fail();
            }
        } 

        // Set a byte value
        {
            String column = "ByteColumn";
            byte value = (byte) prng.nextInt(Byte.MAX_VALUE);
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            byte v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getByteValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getByteValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        } 
        
        // Set a short value
        {
            String column = "ShortColumn";
            short value = (short) prng.nextInt(Short.MAX_VALUE);
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            short v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getShortValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getShortValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        } 
        
        // Set a int value
        {
            String column = "IntColumn";
            int value = prng.nextInt();
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            int v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getIntegerValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getIntegerValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        }
        
        // Set a long value
        {
            String column = "LongColumn";
            long value = prng.nextLong();
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            long v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getLongValue();
            Assert.assertEquals(value, v);
         // get as integer should fail
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult()
                        .getIntegerValue();
                Assert.fail();
            } catch (Exception e) {
            	// expected
            }
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getLongValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        }
        
        // Set a float value
        {
            String column = "FloatColumn";
            float value = prng.nextFloat();
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            float v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getFloatValue();
            Assert.assertEquals(value, v);
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            // verify column gone
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult().getFloatValue();
                Assert.fail();
            } catch (NotFoundException e) {
            	// expected
            }
        }

        // Set a double value
        {
            String column = "IntColumn";
            double value = prng.nextDouble();
            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .putValue(value, null).execute();
            // Read
            double v = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult().getDoubleValue();
            Assert.assertEquals(value, v);
            // get as integer should fail
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult()
                        .getIntegerValue();
                Assert.fail();
            } catch (Exception e) {
            	// expected
            }
            // Delete
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .deleteColumn().execute();
            try {
                keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                        .getColumn(column).execute().getResult()
                        .getDoubleValue();
                Assert.fail();
            } catch (NotFoundException e) {
            } catch (ConnectionException e) {
                Assert.fail();
            }
        } 
        
        // Set long column with timestamp
        {
            String column = "TimestampColumn";
            long value = prng.nextLong();

            // Set
            keyspace.prepareColumnMutation(CF_STANDARD1, key, column)
                    .withTimestamp(100)
                    .putValue(value, null)
                    .execute();

            // Read
            Column<String> c = keyspace.prepareQuery(CF_STANDARD1).getKey(key)
                    .getColumn(column).execute().getResult();
            Assert.assertEquals(100,  c.getTimestamp());
        } 
    }

    @Test
    public void testTimeUUIDUnique() {
        long now = System.currentTimeMillis();
        UUID uuid1 = TimeUUIDUtils.getTimeUUID(now);
        UUID uuid2 = TimeUUIDUtils.getTimeUUID(now);
        LOG.info(uuid1.toString());
        LOG.info(uuid2.toString());
        Assert.assertTrue(uuid1.equals(uuid2));
    }

    @Test
    public void testTimeUUID2() {
        MutationBatch m = keyspace.prepareMutationBatch();
        String rowKey = "Key2";
        m.withRow(CF_TIME_UUID, rowKey).delete();
        try {
            m.execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        long now = System.currentTimeMillis();
        long msecPerDay = 86400000;
        for (int i = 0; i < 100; i++) {
            m.withRow(CF_TIME_UUID, rowKey).putColumn(
                    TimeUUIDUtils.getTimeUUID(now - i * msecPerDay), i, null);
        }
        try {
            m.execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        try {
            OperationResult<ColumnList<UUID>> result = keyspace
                    .prepareQuery(CF_TIME_UUID)
                    .getKey(rowKey)
                    .withColumnRange(
                            new RangeBuilder()
                                    .setLimit(100)
                                    .setStart(
                                            TimeUUIDUtils.getTimeUUID(now - 20
                                                    * msecPerDay)).build())
                    .execute();
            for (Column<UUID> column : result.getResult()) {
                System.out.println((now - TimeUUIDUtils.getTimeFromUUID(column
                        .getName())) / msecPerDay);
            }
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }
    }

    @Test
    public void testTimeUUID() {
        MutationBatch m = keyspace.prepareMutationBatch();

        UUID columnName = TimeUUIDUtils.getUniqueTimeUUIDinMillis();
        long columnTime = TimeUUIDUtils.getTimeFromUUID(columnName);
        String rowKey = "Key1";

        m.withRow(CF_TIME_UUID, rowKey).delete();
        try {
            m.execute();
        } catch (ConnectionException e1) {
            Assert.fail();
        }

        int startTime = 100;
        int endTime = 200;

        m.withRow(CF_TIME_UUID, rowKey).putColumn(columnName, 42, null);
        for (int i = startTime; i < endTime; i++) {
            // UUID c = TimeUUIDUtils.getTimeUUID(i);
            LOG.info(TimeUUIDUtils.getTimeUUID(columnTime + i).toString());

            m.withRow(CF_TIME_UUID, rowKey).putColumn(
                    TimeUUIDUtils.getTimeUUID(columnTime + i), i, null);
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            OperationResult<Column<UUID>> result = keyspace
                    .prepareQuery(CF_TIME_UUID).getKey(rowKey)
                    .getColumn(columnName).execute();

            Assert.assertEquals(columnName, result.getResult().getName());
            Assert.assertTrue(result.getResult().getIntegerValue() == 42);

            OperationResult<ColumnList<UUID>> result2 = keyspace
                    .prepareQuery(CF_TIME_UUID).getKey(rowKey).execute();

            result2 = keyspace
                    .prepareQuery(CF_TIME_UUID)
                    .getKey(rowKey)
                    .withColumnRange(
                            new RangeBuilder()
                                    .setLimit(10)
                                    .setStart(TimeUUIDUtils.getTimeUUID(0))
                                    .setEnd(TimeUUIDUtils
                                            .getTimeUUID(Long.MAX_VALUE >> 8))
                                    .build()).execute();
            Assert.assertEquals(10, result2.getResult().size());

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        UUID currentUUID = TimeUUIDUtils.getUniqueTimeUUIDinMicros();

        SerializerPackage pkg = null;
        try {
            pkg = keyspace.getSerializerPackage(CF_TIME_UUID.getName(), false);
        } catch (ConnectionException e) {
            Assert.fail();
            e.printStackTrace();
        } catch (UnknownComparatorException e) {
            Assert.fail();
            e.printStackTrace();
        }
        Serializer<UUID> serializer = (Serializer<UUID>) pkg
                .getColumnNameSerializer();

        ByteBuffer buffer = serializer.toByteBuffer(currentUUID);
        String value = serializer.getString(buffer);
        LOG.info("UUID Time = " + value);

        // Test timeUUID pagination
        RowQuery<String, UUID> query = keyspace
                .prepareQuery(CF_TIME_UUID)
                .getKey(rowKey)
                .withColumnRange(
                        new RangeBuilder()
                                .setLimit(10)
                                .setStart(
                                        TimeUUIDUtils.getTimeUUID(columnTime
                                                + startTime))
                                .setEnd(TimeUUIDUtils.getTimeUUID(columnTime
                                        + endTime)).build()).autoPaginate(true);
        OperationResult<ColumnList<UUID>> result;
        int pageCount = 0;
        int rowCount = 0;
        try {
            LOG.info("starting pagination");
            while (!(result = query.execute()).getResult().isEmpty()) {
                pageCount++;
                rowCount += result.getResult().size();
                LOG.info("==== Block ====");
                for (Column<UUID> column : result.getResult()) {
                    LOG.info("Column is " + column.getName());
                }
            }
            LOG.info("pagination complete");
        } catch (ConnectionException e) {
            Assert.fail();
            LOG.info(e.getMessage());
            e.printStackTrace();
        }

    }

    @Test
    public void testCopy() {
        String keyName = "A";

        try {
            keyspace.prepareQuery(CF_STANDARD1).getKey(keyName)
                    .copyTo(CF_STANDARD2, keyName).execute();

            ColumnList<String> list1 = keyspace.prepareQuery(CF_STANDARD1)
                    .getKey(keyName).execute().getResult();

            ColumnList<String> list2 = keyspace.prepareQuery(CF_STANDARD2)
                    .getKey(keyName).execute().getResult();

            Iterator<Column<String>> iter1 = list1.iterator();
            Iterator<Column<String>> iter2 = list2.iterator();

            while (iter1.hasNext()) {
                Column<String> column1 = iter1.next();
                Column<String> column2 = iter2.next();
                Assert.assertEquals(column1.getName(), column2.getName());
                Assert.assertEquals(column1.getByteBufferValue(),
                        column2.getByteBufferValue());
            }
            Assert.assertFalse(iter2.hasNext());

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail(e.getMessage());
        }
    }

    @Test
    public void testMutationBatchMultipleWithRow() throws Exception {
        MutationBatch mb = keyspace.prepareMutationBatch();
        
        Long key = 9L;
        
        mb.withRow(CF_USERS, key).delete();
        mb.withRow(CF_USERS, key).putEmptyColumn("test", null);
        
        mb.execute();
        
        ColumnList<String> result = keyspace.prepareQuery(CF_USERS).getRow(key).execute().getResult();
        
        Assert.assertEquals(1, result.size());
    }
    
    @Test
    public void testClickStream() {
        MutationBatch m = keyspace.prepareMutationBatch();
        String userId = "UserId";

        long timeCounter = 0;
        for (int i = 0; i < 10; i++) {
            String sessionId = "Session" + i;

            for (int j = 0; j < 10; j++) {
                m.withRow(CF_CLICK_STREAM, userId).putColumn(
                        new SessionEvent(sessionId,
                                TimeUUIDUtils.getTimeUUID(j)),
                        Long.toString(timeCounter), null);
                timeCounter++;
            }
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            OperationResult<ColumnList<SessionEvent>> result;

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER.buildRange()
                                    .greaterThanEquals("Session3")
                                    .lessThanEquals("Session5").build())
                    .execute();
            // Assert.assertEquals(10, result.getResult().size());
            // LOG.info("*********************** INCLUSIVE - INCLUSIVE");
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER.buildRange()
                                    .greaterThanEquals("Session3")
                                    .lessThan("Session5").build()).execute();
            // Assert.assertEquals(10, result.getResult().size());
            // LOG.info("XXXXXXXXXXXXXXXXXXXXXXXX INCLUSIVE - NON_INCLUSIVE");
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER.buildRange().greaterThan("Session3")
                                    .lessThanEquals("Session5").build())
                    .execute();
            // LOG.info("XXXXXXXXXXXXXXXXXXXXXXXX NON_INCLUSIVE - INCLUSIVE");
            // Assert.assertEquals(10, result.getResult().size());
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER.buildRange().greaterThan("Session3")
                                    .lessThan("Session5").build()).execute();
            // LOG.info("XXXXXXXXXXXXXXXXXXXXXXXX NON_INCLUSIVE - NON_INCLUSIVE");
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }

            result = keyspace
                    .prepareQuery(CF_CLICK_STREAM)
                    .getKey(userId)
                    .withColumnRange(
                            SE_SERIALIZER
                                    .buildRange()
                                    .withPrefix("Session3")
                                    .greaterThanEquals(
                                            TimeUUIDUtils.getTimeUUID(2))
                                    .lessThanEquals(
                                            TimeUUIDUtils.getTimeUUID(8))
                                    .build()).execute();

            // Assert.assertEquals(10, result.getResult().size());
            // LOG.info("XXXXXXXXXXXXXXXXXXXXXXXX EQUAL - EQUAL");
            // for (Column<SessionEvent> column : result.getResult()) {
            // LOG.info("####### " + column.getName() + " = " +
            // column.getLongValue());
            // }
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testChangeConsistencyLevel() {
        try {
            keyspace.prepareQuery(CF_STANDARD1)
                    .setConsistencyLevel(ConsistencyLevel.CL_ONE).getKey("A")
                    .execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }
    }

    @Test
    public void testCompositeKey() {
        MockCompositeType key = new MockCompositeType("A", 1, 2, true, "B");
        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF_COMPOSITE_KEY, key).putColumn("Test", "Value", null);
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            ColumnList<String> row = keyspace.prepareQuery(CF_COMPOSITE_KEY)
                    .getKey(key).execute().getResult();
            Assert.assertFalse(row.isEmpty());
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

    }

    @Test
    public void testComposite() {
        String rowKey = "Composite1";

        boolean bool = false;
        MutationBatch m = keyspace.prepareMutationBatch();
        ColumnListMutation<MockCompositeType> mRow = m.withRow(CF_COMPOSITE,
                rowKey);
        int columnCount = 0;
        for (char part1 = 'a'; part1 <= 'b'; part1++) {
            for (int part2 = 0; part2 < 10; part2++) {
                for (int part3 = 10; part3 < 11; part3++) {
                    bool = !bool;
                    columnCount++;
                    mRow.putEmptyColumn(
                            new MockCompositeType(Character.toString(part1),
                                    part2, part3, bool, "UTF"), null);
                }
            }
        }
        LOG.info("Created " + columnCount + " columns");
        
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        OperationResult<ColumnList<MockCompositeType>> result;
        try {
            result = keyspace.prepareQuery(CF_COMPOSITE).getKey(rowKey)
                    .execute();
            Assert.assertEquals(columnCount,  result.getResult().size());
            for (Column<MockCompositeType> col : result.getResult()) {
                LOG.info("COLUMN: " + col.getName().toString());
            }
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            Column<MockCompositeType> column = keyspace
                    .prepareQuery(CF_COMPOSITE).getKey(rowKey)
                    .getColumn(new MockCompositeType("a", 0, 10, true, "UTF"))
                    .execute().getResult();
            LOG.info("Got single column: " + column.getName().toString());
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        LOG.info("Range builder");
        try {
            result = keyspace
                    .prepareQuery(CF_COMPOSITE)
                    .getKey(rowKey)
                    .withColumnRange(
                            M_SERIALIZER
                                    .buildRange()
                                    .withPrefix("a")
                                    .greaterThanEquals(1)
                                    .lessThanEquals(1)
                                    .build()).execute();
            for (Column<MockCompositeType> col : result.getResult()) {
                LOG.info("COLUMN: " + col.getName().toString());
            }
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        
        /*
         * Composite c = new Composite(); c.addComponent("String1",
         * StringSerializer.get()) .addComponent(123, IntegerSerializer.get());
         * 
         * MutationBatch m = keyspace.prepareMutationBatch();
         * m.withRow(CF_COMPOSITE, "Key1") .putColumn(c, 123, null);
         * 
         * try { m.execute(); } catch (ConnectionException e) { Assert.fail(); }
         * 
         * try { OperationResult<Column<Composite>> result =
         * keyspace.prepareQuery(CF_COMPOSITE) .getKey("Key1") .getColumn(c)
         * .execute();
         * 
         * Assert.assertEquals(123, result.getResult().getIntegerValue()); }
         * catch (ConnectionException e) { Assert.fail(); }
         */
    }

    @Test
    public void testCompositeSlice() throws ConnectionException {
        AnnotatedCompositeSerializer<MockCompositeType> ser = new AnnotatedCompositeSerializer<MockCompositeType>(
                MockCompositeType.class);

        keyspace.prepareQuery(CF_COMPOSITE)
                .getKey("Key1")
                .withColumnRange(
                        ser.makeEndpoint("sessionid1", Equality.LESS_THAN)
                                .toBytes(),
                        ser.makeEndpoint("sessionid1", Equality.GREATER_THAN)
                                .toBytes(), false, 100).execute();
    }

    @Test
    public void testIndexQueryWithPagination() {
        OperationResult<Rows<String, String>> result;
        try {
            LOG.info("************************************************** testIndexQueryWithPagination: ");

            int rowCount = 0;
            int pageCount = 0;
            IndexQuery<String, String> query = keyspace
                    .prepareQuery(CF_STANDARD1).searchWithIndex()
                    .setRowLimit(10).autoPaginateRows(true).addExpression()
                    .whereColumn("Index2").equals().value(42);

            while (!(result = query.execute()).getResult().isEmpty()) {
                pageCount++;
                rowCount += result.getResult().size();
                LOG.info("==== Block ====");
                for (Row<String, String> row : result.getResult()) {
                    LOG.info("RowKey is " + row.getKey());
                }
            }

            Assert.assertEquals(pageCount, 3);
            Assert.assertEquals(rowCount, 26);
            LOG.info("************************************************** Index query: "
                    + result.getResult().size());

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        }
    }

    @Test
    public void testIndexQuery() {
        OperationResult<Rows<String, String>> result;
        try {
            LOG.info("************************************************** prepareGetMultiRowIndexQuery: ");

            result = keyspace.prepareQuery(CF_STANDARD1).searchWithIndex()
                    .setStartKey("").addExpression().whereColumn("Index1")
                    .equals().value(26).execute();
            Assert.assertEquals(1, result.getResult().size());
            Assert.assertEquals("Z", result.getResult().getRowByIndex(0)
                    .getKey());
            /*
             * for (Row<String, String> row : result.getResult()) {
             * LOG.info("RowKey is " + row.getKey()); for (Column<String> column
             * : row.getColumns()) { LOG.info("  Column: " + column.getName() +
             * "=" + column.getIntegerValue()); } }
             */

            LOG.info("************************************************** Index query: "
                    + result.getResult().size());

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        }
    }

    @Test
    public void testPreparedIndexQuery() {
        OperationResult<Rows<String, String>> result;
        try {
            LOG.info("************************************************** prepareGetMultiRowIndexQuery: ");

            PreparedIndexExpression<String, String> clause = CF_STANDARD1
                    .newIndexClause().whereColumn("Index1").equals().value(26);

            result = keyspace.prepareQuery(CF_STANDARD1).searchWithIndex()
                    .setStartKey("")
                    .addPreparedExpressions(Arrays.asList(clause)).execute();

            for (Row<String, String> row : result.getResult()) {
                LOG.info("RowKey is " + row.getKey() + " columnCount="
                        + row.getColumns().size());
                for (Column<String> column : row.getColumns()) {
                    LOG.info("  Column: " + column.getName() + "="
                            + column.getIntegerValue());
                }
            }
            Assert.assertEquals(1, result.getResult().size());
            Assert.assertEquals("Z", result.getResult().getRowByIndex(0)
                    .getKey());

            LOG.info("************************************************** Index query: "
                    + result.getResult().size());

        } catch (ConnectionException e) {
            e.printStackTrace();
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (Exception e) {
            e.printStackTrace();
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testIncrementCounter() {
        long baseAmount, incrAmount = 100;
        Column<String> column;

        try {
            column = getColumnValue(CF_COUNTER1, "CounterRow1", "MyCounter");
            baseAmount = column.getLongValue();
        } catch (Exception e) {
            baseAmount = 0;
        }

        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF_COUNTER1, "CounterRow1").incrementCounterColumn(
                "MyCounter", incrAmount);
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        column = getColumnValue(CF_COUNTER1, "CounterRow1", "MyCounter");
        Assert.assertNotNull(column);
        Assert.assertEquals(column.getLongValue(), baseAmount + incrAmount);

        m = keyspace.prepareMutationBatch();
        m.withRow(CF_COUNTER1, "CounterRow1").incrementCounterColumn(
                "MyCounter", incrAmount);
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        column = getColumnValue(CF_COUNTER1, "CounterRow1", "MyCounter");
        Assert.assertNotNull(column);
        Assert.assertEquals(column.getLongValue(), baseAmount + 2 * incrAmount);
    }

    @Test
    public void testDeleteCounter() {
        Column<String> column;
        String rowKey = "CounterRowDelete1";
        String counterName = "MyCounter";

        // Increment the column
        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF_COUNTER1, rowKey).incrementCounterColumn(counterName, 1);
        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        // Read back the value
        column = getColumnValue(CF_COUNTER1, rowKey, counterName);
        Assert.assertNotNull(column);
        Assert.assertEquals(column.getLongValue(), 1);

        // Delete the column
        try {
            // keyspace.prepareColumnMutation(CF_COUNTER1, rowKey, counterName)
            // .deleteCounterColumn().execute();
            keyspace.prepareColumnMutation(CF_COUNTER1, rowKey, counterName)
                    .deleteCounterColumn().execute();
            /*
             * m = keyspace.prepareMutationBatch(); m.withRow(CF_COUNTER1,
             * rowKey) .deleteColumn(counterName); m.execute();
             */
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        // Try to read back
        // This should be non-existent
        column = getColumnValue(CF_COUNTER1, rowKey, counterName);
        if (column != null) {
            LOG.error("Counter has value: " + column.getLongValue());
            Assert.fail();
        }
    }

    @Test
    public void testCql() {
        try {
            System.out.println("testCQL");
            LOG.info("CQL Test");
            OperationResult<CqlResult<String, String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .withCql("SELECT * FROM Standard1;").execute();
            Assert.assertTrue(result.getResult().hasRows());
            Assert.assertEquals(30, result.getResult().getRows().size());
            Assert.assertFalse(result.getResult().hasNumber());
            
            Row<String, String> row;
            
            row = result.getResult().getRows().getRow("A");
            Assert.assertEquals("A", row.getKey());
            
            row = result.getResult().getRows().getRow("B");
            Assert.assertEquals("B", row.getKey());
            
            row = result.getResult().getRows().getRow("NonExistent");
            Assert.assertNull(row);
            
            row = result.getResult().getRows().getRowByIndex(10);
            Assert.assertEquals("I", row.getKey());
            
            for (Row<String, String> row1 : result.getResult().getRows()) {
              LOG.info("KEY***: " + row1.getKey()); 
            }
            
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testCqlCount() {
        try {
            LOG.info("CQL Test");
            OperationResult<CqlResult<String, String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .withCql("SELECT count(*) FROM Standard1 where KEY='A';")
                    .execute();

            long count = result.getResult().getRows().getRowByIndex(0).getColumns().getColumnByName("count").getLongValue();
            LOG.info("CQL Count: " + count);
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testGetSingleColumn() {
        Column<String> column = getColumnValue(CF_STANDARD1, "A", "a");
        Assert.assertNotNull(column);
        Assert.assertEquals(1, column.getIntegerValue());
    }

    @Test
    public void testColumnFamilyDoesntExist() {
        ColumnFamily<String, String> cf = new ColumnFamily<String, String>(
                "DoesntExist", StringSerializer.get(), StringSerializer.get());
        OperationResult<Void> result;
        try {
            MutationBatch m = keyspace.prepareMutationBatch();
            m.withRow(cf, "Key1").putColumn("Column2", "Value2", null);
            result = m.execute();
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.info(e.getMessage());
        }
    }

    @Test
    public void testKeyspaceDoesntExist() {
        AstyanaxContext<Keyspace> keyspaceContext = new AstyanaxContext.Builder()
                .forCluster(TEST_CLUSTER_NAME)
                .forKeyspace(TEST_KEYSPACE_NAME + "_DOESNT_EXIST")
                .withAstyanaxConfiguration(
                        new AstyanaxConfigurationImpl()
                                .setDiscoveryType(NodeDiscoveryType.NONE))
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl(TEST_CLUSTER_NAME
                                + "_" + TEST_KEYSPACE_NAME + "_DOESNT_EXIST")
                                .setMaxConnsPerHost(1).setSeeds(SEEDS))
                .buildKeyspace(ThriftFamilyFactory.getInstance());

        try {
            keyspaceContext.start();

            Keyspace ks = keyspaceContext.getEntity();

            OperationResult<Void> result = null;
            try {
                MutationBatch m = ks.prepareMutationBatch();
                m.withRow(CF_STANDARD1, "Key1").putColumn("Column2", "Value2",
                        null);
                result = m.execute();
                Assert.fail();
            } catch (ConnectionException e) {
                LOG.info(e.getMessage());
            }
        } finally {
            keyspaceContext.shutdown();
        }
    }

    @Test
    public void testGetSingleColumnNotExists() {
        Column<String> column = getColumnValue(CF_STANDARD1, "A",
                "DoesNotExist");
        Assert.assertNull(column);
    }

    @Test
    public void testGetSingleColumnNotExistsAsync() {
        Future<OperationResult<Column<String>>> future = null;
        try {
            future = keyspace.prepareQuery(CF_STANDARD1).getKey("A")
                    .getColumn("DoesNotExist").executeAsync();
            future.get(1000, TimeUnit.MILLISECONDS);
        } catch (ConnectionException e) {
            LOG.info("ConnectionException: " + e.getMessage());
            Assert.fail();
        } catch (InterruptedException e) {
            LOG.info(e.getMessage());
            Assert.fail();
        } catch (ExecutionException e) {
            if (e.getCause() instanceof NotFoundException)
                LOG.info(e.getCause().getMessage());
            else {
                Assert.fail(e.getMessage());
            }
        } catch (TimeoutException e) {
            future.cancel(true);
            LOG.info(e.getMessage());
            Assert.fail();
        }
    }

    @Test
    public void testGetSingleKeyNotExists() {
        Column<String> column = getColumnValue(CF_STANDARD1, "AA", "ab");
        Assert.assertNull(column);
    }

    @Test
    public void testFunctionalQuery() throws ConnectionException {
        OperationResult<ColumnList<String>> r1 = keyspace
                .prepareQuery(CF_STANDARD1).getKey("A").execute();
        Assert.assertEquals(28, r1.getResult().size());

        /*
         * OperationResult<Rows<String, String>> r2 = keyspace.prepareQuery()
         * .fromColumnFamily(CF_STANDARD1) .selectKeyRange("A", "Z", null, null,
         * 5) .execute();
         */
    }
    
    @Test
    public void testNullKeyInMutation() throws ConnectionException {
        try {
            keyspace.prepareMutationBatch()
                .withRow(CF_STANDARD1,  null)
                .putColumn("abc", "def");
            
            Assert.fail();
        }
        catch (NullPointerException e) {
            
        }
    }
    

    @Test
    public void testColumnSlice() throws ConnectionException {
        OperationResult<ColumnList<String>> r1 = keyspace
                .prepareQuery(CF_STANDARD1).getKey("A")
                .withColumnSlice("a", "b").execute();
        Assert.assertEquals(2, r1.getResult().size());
    }

    @Test
    public void testColumnRangeSlice() throws ConnectionException {
        OperationResult<ColumnList<String>> r1 = keyspace
                .prepareQuery(CF_STANDARD1)
                .getKey("A")
                .withColumnRange(
                        new RangeBuilder().setStart("a").setEnd("b")
                                .setLimit(5).build()).execute();
        Assert.assertEquals(2, r1.getResult().size());

        OperationResult<ColumnList<String>> r2 = keyspace
                .prepareQuery(CF_STANDARD1).getKey("A")
                .withColumnRange("a", null, false, 5).execute();
        Assert.assertEquals(5, r2.getResult().size());
        Assert.assertEquals("a", r2.getResult().getColumnByIndex(0).getName());

        ByteBuffer EMPTY_BUFFER = ByteBuffer.wrap(new byte[0]);
        OperationResult<ColumnList<String>> r3 = keyspace
                .prepareQuery(CF_STANDARD1).getKey("A")
                .withColumnRange(EMPTY_BUFFER, EMPTY_BUFFER, true, 5).execute();
        Assert.assertEquals(5, r3.getResult().size());
        Assert.assertEquals("z", r3.getResult().getColumnByIndex(0).getName());
    }

    @Test
    public void testGetColumnsWithPrefix() throws ConnectionException {
        OperationResult<ColumnList<String>> r = keyspace
                .prepareQuery(CF_STANDARD1)
                .getKey("Prefixes")
                .withColumnRange("Prefix1_\u00000", "Prefix1_\uffff", false,
                        Integer.MAX_VALUE).execute();
        Assert.assertEquals(2, r.getResult().size());
        Assert.assertEquals("Prefix1_a", r.getResult().getColumnByIndex(0)
                .getName());
        Assert.assertEquals("Prefix1_b", r.getResult().getColumnByIndex(1)
                .getName());
    }

    @Test
    public void testGetCounters() throws ConnectionException {
        LOG.info("Starting testGetCounters...");

        try {
            OperationResult<Column<String>> result = keyspace
                    .prepareQuery(CF_COUNTER1).getKey("CounterRow1")
                    .getColumn("TestCounter").execute();

            Long count = result.getResult().getLongValue();
            Assert.assertNotNull(count);
            Assert.assertTrue(count > 0);
        } catch (NotFoundException e) {

        }

        LOG.info("... testGetCounters done");
    }

    @Test
    public void testGetSingleKey() {
        try {
            for (char key = 'A'; key <= 'Z'; key++) {
                String keyName = Character.toString(key);
                OperationResult<ColumnList<String>> result = keyspace
                        .prepareQuery(CF_STANDARD1).getKey(keyName).execute();

                Assert.assertNotNull(result.getResult());

                System.out.printf("%s executed on %s in %d msec size=%d\n",
                        keyName, result.getHost(), result.getLatency(), result
                                .getResult().size());
            }
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testGetSingleKeyAsync() {
        try {
            Future<OperationResult<ColumnList<String>>> result = keyspace
                    .prepareQuery(CF_STANDARD1).getKey("A").executeAsync();

            result.get(1000, TimeUnit.MILLISECONDS);

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (InterruptedException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (ExecutionException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        } catch (TimeoutException e) {
            LOG.error(e.getMessage(), e);
            e.printStackTrace();
            Assert.fail();
        }
    }

    @Test
    public void testGetAllKeysRoot() {
        LOG.info("Starting testGetAllKeysRoot...");

        try {
            List<String> keys = new ArrayList<String>();
            for (char key = 'A'; key <= 'Z'; key++) {
                String keyName = Character.toString(key);
                keys.add(keyName);
            }

            OperationResult<Rows<String, String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .getKeySlice(keys.toArray(new String[keys.size()]))
                    .execute();

            Assert.assertEquals(26,  result.getResult().size());
            
            Row<String, String> row;
            
            row = result.getResult().getRow("A");
            Assert.assertEquals("A", row.getKey());
            
            row = result.getResult().getRow("B");
            Assert.assertEquals("B", row.getKey());
            
            row = result.getResult().getRow("NonExistent");
            Assert.assertNull(row);
            
            row = result.getResult().getRowByIndex(10);
            Assert.assertEquals("M", row.getKey());
            /*
             * LOG.info("Get " + result.getResult().size() + " keys"); for
             * (Row<String, String> row : result.getResult()) {
             * LOG.info(String.format("%s executed on %s in %d msec size=%d\n",
             * row.getKey(), result.getHost(), result.getLatency(),
             * row.getColumns().size())); for (Column<String> sc :
             * row.getColumns()) { LOG.info("  " + sc.getName());
             * ColumnList<Integer> subColumns =
             * sc.getSubColumns(IntegerSerializer.get()); for (Column<Integer>
             * sub : subColumns) { LOG.info("    " + sub.getName() + "=" +
             * sub.getStringValue()); } } }
             */

        } catch (ConnectionException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            Assert.fail();
        }

        LOG.info("... testGetAllKeysRoot");
    }

    @Test
    public void testGetColumnSlice() {
        LOG.info("Starting testGetColumnSlice...");
        try {
            OperationResult<ColumnList<String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .getKey("A")
                    .withColumnSlice(
                            new ColumnSlice<String>("c", "h").setLimit(5))
                    .execute();
            Assert.assertNotNull(result.getResult());
            Assert.assertEquals(5, result.getResult().size());
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

    }

    @Test
    public void testGetAllKeysPath() {
        LOG.info("Starting testGetAllKeysPath...");

        try {
            List<String> keys = new ArrayList<String>();
            for (char key = 'A'; key <= 'Z'; key++) {
                String keyName = Character.toString(key);
                keys.add(keyName);
            }

            OperationResult<Rows<String, String>> result = keyspace
                    .prepareQuery(CF_STANDARD1)
                    .getKeySlice(keys.toArray(new String[keys.size()]))
                    .execute();
            /*
             * System.out.printf("%s executed on %s in %d msec size=%d\n",
             * row.getKey(), result.getHost(), result.getLatency(),
             * row.getColumns().size());
             */

            // for (Row<String, String> row : result.getResult()) {
            // for (Column<Integer> column : row.getColumns()) {
            // System.out.println("  Column: " + column.getName());
            // }
            // }
            
            OperationResult<Map<String, Integer>> counts = keyspace
                .prepareQuery(CF_STANDARD1)
                .getKeySlice(keys.toArray(new String[keys.size()]))
                .getColumnCounts()
                .execute();
                        
            Assert.assertEquals(26, counts.getResult().size());
            
            for (Entry<String, Integer> count : counts.getResult().entrySet()) {
                Assert.assertEquals(new Integer(28), count.getValue());
            }
            
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        LOG.info("Starting testGetAllKeysPath...");
    }
    
    @Test
    public void testDeleteMultipleKeys() {
        LOG.info("Starting testDeleteMultipleKeys...");
        LOG.info("... testGetAllKeysPath");

    }

    @Test
    public void testMutationMerge() {
        MutationBatch m1 = keyspace.prepareMutationBatch();
        MutationBatch m2 = keyspace.prepareMutationBatch();
        MutationBatch m3 = keyspace.prepareMutationBatch();
        MutationBatch m4 = keyspace.prepareMutationBatch();
        MutationBatch m5 = keyspace.prepareMutationBatch();

        m1.withRow(CF_STANDARD1, "1").putColumn("1", "X", null);
        m2.withRow(CF_STANDARD1, "2").putColumn("2", "X", null)
                .putColumn("3", "X", null);
        m3.withRow(CF_STANDARD1, "3").putColumn("4", "X", null)
                .putColumn("5", "X", null).putColumn("6", "X", null);
        m4.withRow(CF_STANDARD1, "1").putColumn("7", "X", null)
                .putColumn("8", "X", null).putColumn("9", "X", null)
                .putColumn("10", "X", null);

        MutationBatch merged = keyspace.prepareMutationBatch();
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 0);

        merged.mergeShallow(m1);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 1);

        merged.mergeShallow(m2);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 2);

        merged.mergeShallow(m3);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 3);

        merged.mergeShallow(m4);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 3);

        merged.mergeShallow(m5);
        LOG.info(merged.toString());
        Assert.assertEquals(merged.getRowCount(), 3);
    }

    @Test
    public void testDelete() {
        LOG.info("Starting testDelete...");

        String rowKey = "DeleteMe_testDelete";

        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF_STANDARD1, rowKey).putColumn("Column1", "X", null)
                .putColumn("Column2", "X", null);

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        Assert.assertEquals(getColumnValue(CF_STANDARD1, rowKey, "Column1")
                .getStringValue(), "X");
        Assert.assertTrue(deleteColumn(CF_STANDARD1, rowKey, "Column1"));
        Assert.assertNull(getColumnValue(CF_STANDARD1, rowKey, "Column1"));

        LOG.info("... testDelete");
    }

    @Test
    public void testDeleteLotsOfColumns() {
        LOG.info("Starting testDelete...");

        String rowKey = "DeleteMe_testDeleteLotsOfColumns";

        int nColumns = 100;
        int pageSize = 25;

        // Insert a bunch of rows
        MutationBatch m = keyspace.prepareMutationBatch();
        ColumnListMutation<String> rm = m.withRow(CF_STANDARD1, rowKey);

        for (int i = 0; i < nColumns; i++) {
            rm.putEmptyColumn("" + i, null);
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        // Verify count
        try {
            int count = keyspace.prepareQuery(CF_STANDARD1)
                    .setConsistencyLevel(ConsistencyLevel.CL_QUORUM)
                    .getKey(rowKey).getCount().execute().getResult();
            Assert.assertEquals(nColumns, count);
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        // Delete half of the columns
        m = keyspace.prepareMutationBatch().setConsistencyLevel(
                ConsistencyLevel.CL_QUORUM);
        rm = m.withRow(CF_STANDARD1, rowKey);

        for (int i = 0; i < nColumns / 2; i++) {
            rm.deleteColumn("" + i);
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        // Verify count
        try {
            int count = getRowColumnCount(CF_STANDARD1, rowKey);
            Assert.assertEquals(nColumns / 2, count);

            count = getRowColumnCountWithPagination(CF_STANDARD1, rowKey,
                    pageSize);
            Assert.assertEquals(nColumns / 2, count);

        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        // Delete all of the columns
        m = keyspace.prepareMutationBatch().setConsistencyLevel(
                ConsistencyLevel.CL_QUORUM);
        rm = m.withRow(CF_STANDARD1, rowKey);

        for (int i = 0; i < nColumns; i++) {
            rm.deleteColumn("" + i);
        }

        try {
            m.execute();
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        // Verify count
        try {
            int count = getRowColumnCount(CF_STANDARD1, rowKey);
            Assert.assertEquals(0, count);

            count = getRowColumnCountWithPagination(CF_STANDARD1, rowKey,
                    pageSize);
            Assert.assertEquals(0, count);
        } catch (ConnectionException e) {
            Assert.fail(e.getMessage());
        }

        LOG.info("... testDelete");
    }

    private <K, C> int getRowColumnCount(ColumnFamily<K, C> cf, K rowKey)
            throws ConnectionException {
        int count = keyspace.prepareQuery(cf)
                .setConsistencyLevel(ConsistencyLevel.CL_QUORUM).getKey(rowKey)
                .getCount().execute().getResult();

        return count;
    }

    private <K, C> int getRowColumnCountWithPagination(ColumnFamily<K, C> cf,
            K rowKey, int pageSize) throws ConnectionException {
        RowQuery<K, C> query = keyspace.prepareQuery(cf)
                .setConsistencyLevel(ConsistencyLevel.CL_QUORUM).getKey(rowKey)
                .withColumnRange(new RangeBuilder().setLimit(pageSize).build())
                .autoPaginate(true);

        ColumnList<C> result;
        int count = 0;
        while (!(result = query.execute().getResult()).isEmpty()) {
            count += result.size();
        }

        return count;
    }

    @Test
    public void testCsvLoader() {
        StringBuilder sb = new StringBuilder()
                .append("key, firstname, lastname, age, test\n")
                .append("1, eran, landau, 34, a\n")
                .append("2, netta, landau, 33, b\n")
                .append("3, arielle, landau, 6, c\n")
                .append("4, eyal, landau, 2, d\n");

        RecordReader reader = new CsvRecordReader(new StringReader(
                sb.toString()));
        RecordWriter writer = new ColumnarRecordWriter(keyspace,
                CF_USERS.getName());

        try {
            reader.start();
            writer.start();
            List<Pair<String, String>> record = null;
            while (null != (record = reader.next())) {
                writer.write(record);
            }
        } catch (IOException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } finally {
            reader.shutdown();
            writer.shutdown();
        }

        try {
            Rows<Long, String> rows = keyspace.prepareQuery(CF_USERS)
                    .getAllRows().execute().getResult();
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(false).write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true).setCountName("_count_")
                    .setRowsName("_rows_").setNamesName("_names_").write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true).setDynamicColumnNames(true)
                    .write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true).setIgnoreUndefinedColumns(true)
                    .write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true)
                    .setFixedColumnNames("firstname", "lastname")
                    .setIgnoreUndefinedColumns(true).write(rows);

            LOG.info("******* COLUMNS AS ROWS ********");
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(true).setColumnsAsRows(true).write(rows);

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testCsvLoaderWithCustomSerializers() {
        StringBuilder sb = new StringBuilder()
                .append("key, firstname, lastname, age, test\n")
                .append("1, eran, landau, 34, a\n")
                .append("2, netta, landau, 33, b\n")
                .append("3, arielle, landau, 6, c\n")
                .append("4, eyal, landau, 2, d\n");

        SerializerPackageImpl pkg = null;
        try {
            pkg = new SerializerPackageImpl().setKeyType("LongType")
                    .setColumnNameType("UTF8Type")
                    .setDefaultValueType("UTF8Type")
                    .setValueType("firstname", "UTF8Type")
                    .setValueType("lastname", "UTF8Type")
                    .setValueType("age", "LongType");
        } catch (UnknownComparatorException e) {
            Assert.fail();
        }

        RecordReader reader = new CsvRecordReader(new StringReader(
                sb.toString()));
        RecordWriter writer = new ColumnarRecordWriter(keyspace,
                CF_USERS.getName(), pkg);

        try {
            reader.start();
            writer.start();
            List<Pair<String, String>> record = null;
            while (null != (record = reader.next())) {
                writer.write(record);
            }
        } catch (IOException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } finally {
            reader.shutdown();
            writer.shutdown();
        }

        try {
            Rows<Long, String> rows = keyspace.prepareQuery(CF_USERS)
                    .getAllRows().execute().getResult();
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_USERS.getName(), false))
                    .setRowsAsArray(false).write(rows);
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testCsvLoaderComposite() {
        StringBuilder sb = new StringBuilder().append("key, column, value\n")
                .append("1, a:1, 1a1\n").append("1, b:1, 2b1\n")
                .append("2, a:1, 3a1\n").append("3, a:1, 4a1\n");

        CsvColumnReader reader = new CsvColumnReader(new StringReader(
                sb.toString()));
        RecordWriter writer = new ColumnarRecordWriter(keyspace,
                CF_COMPOSITE_CSV.getName());

        try {
            reader.start();
            writer.start();
            List<Pair<String, String>> record = null;
            while (null != (record = reader.next())) {
                writer.write(record);
            }
        } catch (IOException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } finally {
            reader.shutdown();
            writer.shutdown();
        }

        try {
            Rows<ByteBuffer, ByteBuffer> rows = keyspace
                    .prepareQuery(CF_COMPOSITE_CSV).getAllRows().execute()
                    .getResult();
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(false).write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(true)
                    .setCountName("_count_").setRowsName("_rows_")
                    .setNamesName("_names_").write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(true)
                    .setDynamicColumnNames(true).write(rows);

            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(true)
                    .setIgnoreUndefinedColumns(true).write(rows);

            LOG.info("******* COLUMNS AS ROWS ********");
            new JsonRowsWriter(new PrintWriter(System.out, true),
                    keyspace.getSerializerPackage(CF_COMPOSITE_CSV.getName(),
                            false)).setRowsAsArray(true).setColumnsAsRows(true)
                    .write(rows);

        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }
    }

    @Test
    public void testTtlValues() throws Exception {
        MutationBatch mb = keyspace.prepareMutationBatch();
        mb.withRow(CF_TTL, "row")
          .putColumn("TTL0", "TTL0", 0)
          .putColumn("TTLNULL", "TTLNULL", null)
          .putColumn("TTL1", "TTL1", 1);
        
        mb.execute();
        
        Thread.sleep(2000);
        
        ColumnList<String> result = keyspace.prepareQuery(CF_TTL)
            .getRow("row")
            .execute().getResult();
       
        Assert.assertEquals(2,  result.size());
        Assert.assertNotNull(result.getColumnByName("TTL0"));
        Assert.assertNotNull(result.getColumnByName("TTLNULL"));
    }
    
    @Test
    public void testCluster() {
        AstyanaxContext<Cluster> clusterContext = new AstyanaxContext.Builder()
                .forCluster(TEST_CLUSTER_NAME)
                .withAstyanaxConfiguration(new AstyanaxConfigurationImpl())
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl(TEST_CLUSTER_NAME)
                                .setSeeds(SEEDS).setSocketTimeout(30000)
                                .setMaxTimeoutWhenExhausted(200)
                                .setMaxConnsPerHost(1))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
                .buildCluster(ThriftFamilyFactory.getInstance());

        clusterContext.start();
        Cluster cluster = clusterContext.getEntity();

        try {
            cluster.describeClusterName();
            List<KeyspaceDefinition> keyspaces = cluster.describeKeyspaces();
            LOG.info("Keyspace count:" + keyspaces.size());
            for (KeyspaceDefinition keyspace : keyspaces) {
                LOG.info("Keyspace: " + keyspace.getName());
            }
            Assert.assertNotNull(keyspaces);
            Assert.assertTrue(keyspaces.size() > 0);
        } catch (Exception e) {
            Assert.fail(e.getMessage());
        } finally {
            clusterContext.shutdown();
        }
    }

    @Test
    public void testPrefixedSerializer() {
        ColumnFamily<String, String> cf = new ColumnFamily<String, String>(
                "Standard1", StringSerializer.get(), StringSerializer.get());

        ColumnFamily<String, String> cf1 = new ColumnFamily<String, String>(
                "Standard1", new PrefixedSerializer<String, String>("Prefix1_",
                        StringSerializer.get(), StringSerializer.get()),
                StringSerializer.get());

        ColumnFamily<String, String> cf2 = new ColumnFamily<String, String>(
                "Standard1", new PrefixedSerializer<String, String>("Prefix2_",
                        StringSerializer.get(), StringSerializer.get()),
                StringSerializer.get());

        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(cf1, "A").putColumn("Column1", "Value1", null);
        m.withRow(cf2, "A").putColumn("Column1", "Value2", null);

        try {
            m.execute();
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            OperationResult<ColumnList<String>> result = keyspace
                    .prepareQuery(cf).getKey("Prefix1_A").execute();
            Assert.assertEquals(1, result.getResult().size());
            Column<String> c = result.getResult().getColumnByName("Column1");
            Assert.assertEquals("Value1", c.getStringValue());
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

        try {
            OperationResult<ColumnList<String>> result = keyspace
                    .prepareQuery(cf).getKey("Prefix2_A").execute();
            Assert.assertEquals(1, result.getResult().size());
            Column<String> c = result.getResult().getColumnByName("Column1");
            Assert.assertEquals("Value2", c.getStringValue());
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
        }

    }

    @Test
    public void testWithRetry() {
        String clusterName = TEST_CLUSTER_NAME + "_DOESNT_EXIST";
        AstyanaxContext<Keyspace> keyspaceContext = new AstyanaxContext.Builder()
                .forCluster(clusterName)
                .forKeyspace(TEST_KEYSPACE_NAME)
                .withAstyanaxConfiguration(
                        new AstyanaxConfigurationImpl()
                                .setDiscoveryType(NodeDiscoveryType.NONE))
                .withConnectionPoolConfiguration(
                        new ConnectionPoolConfigurationImpl(clusterName + "_"
                                + TEST_KEYSPACE_NAME).setMaxConnsPerHost(1)
                                .setSeeds(SEEDS))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor())
                .buildKeyspace(ThriftFamilyFactory.getInstance());

        ColumnFamily<String, String> cf = new ColumnFamily<String, String>(
                "DoesntExist", StringSerializer.get(), StringSerializer.get());
        try {
            MutationBatch m = keyspaceContext.getEntity()
                    .prepareMutationBatch()
                    .withRetryPolicy(new ExponentialBackoff(10, 3));
            m.withRow(cf, "Key1").putColumn("Column2", "Value2", null);
            m.execute();
            Assert.fail();
        } catch (ConnectionException e) {
            LOG.info(e.getMessage());
        }
    }
    
    @Test
    public void testTtl() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testTtl")
                .withTtl(2)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1,  TimeUnit.SECONDS);
        
        try {
            lock.acquire();
            Assert.assertEquals(1, lock.readLockColumns().size());
            Thread.sleep(3000);
            Assert.assertEquals(0, lock.readLockColumns().size());
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        finally {
            lock.release();
        }    
        Assert.assertEquals(0, lock.readLockColumns().size());
    }
    
    @Test
    public void testTtlString() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testTtl")
                .withTtl(2)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1,  TimeUnit.SECONDS);
        
        try {
            lock.acquire();
            Assert.assertEquals(1, lock.readLockColumns().size());
            Thread.sleep(3000);
            Assert.assertEquals(0, lock.readLockColumns().size());
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        finally {
            lock.release();
        }    
        Assert.assertEquals(0, lock.readLockColumns().size());
    }
    
    @Test
    public void testStaleLockWithFail() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock1 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1, TimeUnit.SECONDS);
        
        ColumnPrefixDistributedRowLock<String> lock2 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(9,  TimeUnit.SECONDS);
        
        try {
            lock1.acquire();
            Thread.sleep(5000);
            try {
                lock2.acquire();
            }
            catch (Exception e) {
                Assert.fail(e.getMessage());
            }
            finally {
                lock2.release();
            }
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        finally {
            lock1.release();
        }
    }
    
    @Test
    public void testStaleLockWithFail_String() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock1 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1, TimeUnit.SECONDS);
        
        ColumnPrefixDistributedRowLock<String> lock2 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(9,  TimeUnit.SECONDS);
        
        try {
            lock1.acquire();
            Thread.sleep(5000);
            try {
                lock2.acquire();
            }
            catch (Exception e) {
                Assert.fail(e.getMessage());
            }
            finally {
                lock2.release();
            }
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        finally {
            lock1.release();
        }
    }
    
    @Test
    public void testStaleLock() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock1 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1, TimeUnit.SECONDS);
        
        ColumnPrefixDistributedRowLock<String> lock2 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_LONG, "testStaleLock")
                .failOnStaleLock(true)
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(9, TimeUnit.SECONDS);
        
        try {
            lock1.acquire();
            Thread.sleep(2000);
            try {
                lock2.acquire();
                Assert.fail();
            }
            catch (StaleLockException e) {
            }
            catch (Exception e) {
                Assert.fail(e.getMessage());
            }
            finally {
                lock2.release();
            }
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        finally {
            lock1.release();
        }
    }
    
    @Test
    public void testStaleLock_String() throws Exception {
        ColumnPrefixDistributedRowLock<String> lock1 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testStaleLock")
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(1, TimeUnit.SECONDS);
        
        ColumnPrefixDistributedRowLock<String> lock2 = 
            new ColumnPrefixDistributedRowLock<String>(keyspace, LOCK_CF_STRING, "testStaleLock")
                .failOnStaleLock(true)
                .withTtl(TTL)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .expireLockAfter(9, TimeUnit.SECONDS);
        
        try {
            lock1.acquire();
            Thread.sleep(2000);
            try {
                lock2.acquire();
                Assert.fail();
            }
            catch (StaleLockException e) {
            }
            catch (Exception e) {
                Assert.fail(e.getMessage());
            }
            finally {
                lock2.release();
            }
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        finally {
            lock1.release();
        }
    }
    
    @Test
    public void testMultiLock() {
        MultiRowUniquenessConstraint unique = new MultiRowUniquenessConstraint(keyspace)
            .withConsistencyLevel(ConsistencyLevel.CL_ONE)
            .withTtl(60)
            .withLockId("abc")
            .withColumnPrefix("prefix_")
            .withRow(UNIQUE_CF, "testMultiLock_A")
            .withRow(UNIQUE_CF, "testMultiLock_B");
        
        ColumnPrefixUniquenessConstraint<String> singleUnique 
            = new ColumnPrefixUniquenessConstraint<String>(keyspace, UNIQUE_CF, "testMultiLock_A")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .withPrefix("prefix_");
        try {
            unique.acquire();
            String uniqueColumn = singleUnique.readUniqueColumn();
            Assert.assertEquals("abc", uniqueColumn);
            LOG.info("UniqueColumn: " + uniqueColumn);
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        
        MultiRowUniquenessConstraint unique2 = new MultiRowUniquenessConstraint(keyspace)
            .withTtl(60)
            .withConsistencyLevel(ConsistencyLevel.CL_ONE)
            .withColumnPrefix("prefix_")
            .withRow(UNIQUE_CF, "testMultiLock_B");
        try {
            unique2.acquire();
            Assert.fail();
        }
        catch (Exception e) {
            LOG.info(e.getMessage());
        }
        
        try {
            Assert.assertEquals("abc", singleUnique.readUniqueColumn());
            unique.release();
        }
        catch (Exception e) {
            LOG.error(e.getMessage());
            Assert.fail();
        }
        
        try {
            unique2.acquire();
        }
        catch (Exception e) {
            LOG.error(e.getMessage());
            Assert.fail();
        }
        
        try {
            unique2.release();
        } catch (Exception e) {
            LOG.error(e.getMessage());
            Assert.fail();
        }
    }
    
    @Test
    public void testRowUniquenessConstraint() throws Exception {
        RowUniquenessConstraint<String, String> unique = new RowUniquenessConstraint<String, String>
                (keyspace, UNIQUE_CF, "testRowUniquenessConstraint", UUIDStringSupplier.getInstance())
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                ;
        RowUniquenessConstraint<String, String> unique2 = new RowUniquenessConstraint<String, String>
                (keyspace, UNIQUE_CF, "testRowUniquenessConstraint", UUIDStringSupplier.getInstance())
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                ;
        
        try {
            unique.withData("abc").acquire();
            try {
                unique2.acquire();
                Assert.fail();
            }
            catch (Exception e) {
                LOG.info(e.getMessage());
            }
            
            String data = unique.readDataAsString();
            Assert.assertNotNull(data);
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
            LOG.error(e.getMessage());
        }
        finally {
            unique.release();
        }
        
        try {
            String data = unique.readDataAsString();
            Assert.fail();
        }
        catch (Exception e) {
            LOG.info("", e);
        }
    }

    @Test
    public void testPrefixUniquenessConstraint() throws Exception {
        ColumnPrefixUniquenessConstraint<String> unique = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, "testPrefixUniquenessConstraint")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                ;
        ColumnPrefixUniquenessConstraint<String> unique2 = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, "testPrefixUniquenessConstraint")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                ;
        
        try {
            unique.acquire();
            String column = unique.readUniqueColumn();
            LOG.info("Unique Column: " + column);
            
            try {
                unique2.acquire();
                Assert.fail();
            }
            catch (Exception e) {
                
            }
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
            LOG.error(e.getMessage());
        }
        finally {
            unique.release();
        }

        try {
            String column = unique.readUniqueColumn();
            LOG.info(column);
            Assert.fail();
        }
        catch (Exception e) {
            
        }
    }

    @Test
    public void testPrefixUniquenessConstraintWithColumn() throws Exception {
        ColumnPrefixUniquenessConstraint<String> unique = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, "testPrefixUniquenessConstraintWithColumn")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .withUniqueId("abc");
        ColumnPrefixUniquenessConstraint<String> unique2 = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, "testPrefixUniquenessConstraintWithColumn")
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .withUniqueId("def");
        
        try {
            unique.acquire();
            
            String column = unique.readUniqueColumn();
            LOG.info("Unique Column: " + column);
            Assert.assertEquals("abc", column);
            
            try {
                unique2.acquire();
                Assert.fail();
            }
            catch (Exception e) {
                
            }
            
            column = unique.readUniqueColumn();
            LOG.info("Unique Column: " + column);
            Assert.assertEquals("abc", column);
            
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
            LOG.error(e.getMessage());
        }
        finally {
            unique.release();
        }
    }
    
    @Test 
    public void testAcquireAndMutate() throws Exception {
        final String row        = "testAcquireAndMutate";
        final String dataColumn = "data";
        final String value      = "test";
        
        ColumnPrefixUniquenessConstraint<String> unique = new ColumnPrefixUniquenessConstraint<String>(
                keyspace, UNIQUE_CF, row)
                .withConsistencyLevel(ConsistencyLevel.CL_ONE)
                .withUniqueId("def");
        
        try {
            unique.acquireAndApplyMutation(new Function<MutationBatch, Boolean>() {
                @Override
                public Boolean apply(@Nullable MutationBatch m) {
                    m.withRow(UNIQUE_CF, row)
                        .putColumn(dataColumn, value, null);
                    return true;
                }
            });
            String column = unique.readUniqueColumn();
            Assert.assertNotNull(column);
        }
        catch (Exception e) {
            e.printStackTrace();
            LOG.error("", e);
            Assert.fail();
        }
        finally {
        }
        
        ColumnList<String> columns = keyspace.prepareQuery(UNIQUE_CF).getKey(row).execute().getResult();
        Assert.assertEquals(2, columns.size());
        Assert.assertEquals(value, columns.getStringValue(dataColumn, null));
        
        unique.release();
        
        columns = keyspace.prepareQuery(UNIQUE_CF).getKey(row).execute().getResult();
        Assert.assertEquals(1, columns.size());
        Assert.assertEquals(value, columns.getStringValue(dataColumn, null));
    }
    
    // This test confirms the fix for https://github.com/Netflix/astyanax/issues/170
    @Test
    public void columnAutoPaginateTest() throws Exception {
        final ColumnFamily<String, UUID> CF1 = ColumnFamily.newColumnFamily("CF1", StringSerializer.get(),
                TimeUUIDSerializer.get());
        final ColumnFamily<String, String> CF2 = ColumnFamily.newColumnFamily("CF2", StringSerializer.get(),
                StringSerializer.get());
        
        keyspace.createColumnFamily(CF1, null);
        Thread.sleep(3000);
        keyspace.createColumnFamily(CF2, null);
        Thread.sleep(3000);
    
        // query on another column family with different column key type
        // does not seem to work after the first query
        keyspace.prepareQuery(CF2).getKey("anything").execute();

        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(CF1, "test").putColumn(TimeUUIDUtils.getUniqueTimeUUIDinMillis(), "value1", null);
        m.execute();
    
        RowQuery<String, UUID> query = keyspace.prepareQuery(CF1).getKey("test").autoPaginate(true);
    
        // Adding a column range removes the problem
        // query.withColumnRange(new RangeBuilder().build());
    
        ColumnList<UUID> columns = query.execute().getResult();
        
        keyspace.prepareQuery(CF2).getKey("anything").execute();
    }
    
    private boolean deleteColumn(ColumnFamily<String, String> cf,
            String rowKey, String columnName) {
        MutationBatch m = keyspace.prepareMutationBatch();
        m.withRow(cf, rowKey).deleteColumn(columnName);

        try {
            m.execute();
            return true;
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
            return false;
        }
    }

    private Column<String> getColumnValue(ColumnFamily<String, String> cf,
            String rowKey, String columnName) {
        OperationResult<Column<String>> result;
        try {
            result = keyspace.prepareQuery(cf).getKey(rowKey)
                    .getColumn(columnName).execute();
            return result.getResult();
        } catch (NotFoundException e) {
            LOG.info(e.getMessage());
            return null;
        } catch (ConnectionException e) {
            LOG.error(e.getMessage(), e);
            Assert.fail();
            return null;
        }
    }
}=======
>>>>>>> YOURS
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/CompositeRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/AnnotatedCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/AnnotatedCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/AnnotatedCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/AnnotatedCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/AnnotatedCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/AnnotatedCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/serializers/AnnotatedCompositeSerializer.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/query/ColumnFamilyQuery.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/model/ColumnFamily.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/model/ColumnFamily.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/model/ColumnFamily.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/model/ColumnFamily.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/model/ColumnFamily.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/model/ColumnFamily.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/model/ColumnFamily.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/AstyanaxConfiguration.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/MutationBatch.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/MutationBatch.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/MutationBatch.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/AstyanaxContext.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/AstyanaxContext.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/AstyanaxContext.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/AstyanaxContext.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cassandra/src/main/java/com/netflix/astyanax/AstyanaxContext.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-core/src/main/java/com/netflix/astyanax/connectionpool/impl/ConnectionPoolType.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-core/src/main/java/com/netflix/astyanax/connectionpool/ConnectionPoolProxy.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-core/src/main/java/com/netflix/astyanax/retry/RetryPolicy.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-core/src/main/java/com/netflix/astyanax/retry/RunOnceRetryPolicyFactory.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-core/src/main/java/com/netflix/astyanax/Execution.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-core/src/main/java/com/netflix/astyanax/Execution.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/util/AsyncOperationResult.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/util/DataTypeMapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/util/CFQueryContext.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/util/ConsistencyLevelTransform.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/util/CqlTypeMapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlRangeImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlRangeBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlRowListImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlColumnListImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/DirectCqlResult.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlRowSlice.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlRowImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlColumnSlice.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlRowListIterator.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/model/CqlColumnImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CqlRowSliceQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/FlatTableRowSliceQueryGen.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CFColumnQueryGen.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CFRowQueryGen.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CqlColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CFRowRangeQueryGen.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CFRowKeysQueryGen.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CqlRowSliceColumnCountQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/DirectCqlQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CqlColumnQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/QueryGenCache.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CqlRowCopier.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CqlRowQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CqlAllRowsQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CFRowSliceQueryGen.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/FlatTableRowQueryGen.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/reads/CqlColumnCountQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/schema/CqlColumnDefinitionImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/schema/CqlKeyspaceDefinitionImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/schema/CqlColumnFamilyDefinitionImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/CqlStyleMutationQuery.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/BatchedStatements.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/AbstractColumnListMutationImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/StatementCache.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/CqlColumnListMutationImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/MutationQueries.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/CqlColumnMutationImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/CqlMutationBatchImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/AbstractMutationBatchImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/writes/CFMutationQueryGen.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/direct/DirectCqlStatementResultImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/direct/DirectCqlPreparedStatement.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/direct/DirectCqlStatement.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/retrypolicies/ChangeConsistencyLevelRetryPolicy.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/retrypolicies/JavaDriverBasedRetryPolicy.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/CqlClusterImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/JavaDriverConnectionPoolConfigurationImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/ConsistencyLevelMapping.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/CqlOperationResultImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/JavaDriverConfigBuilder.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/CqlAbstractExecutionImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/JavaDriverConnectionPoolMonitorImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/CqlRingDescriber.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/CqlFamilyFactory.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/CqlSchemaVersionReader.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-cql/src/main/java/com/netflix/astyanax/cql/CqlKeyspaceImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/AbstractThriftMutationBatchImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftColumnFamilyQueryImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-thrift/src/main/java/com/netflix/astyanax/thrift/ThriftKeyspaceImpl.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-entity-mapper/src/main/java/com/netflix/astyanax/entitystore/DefaultEntityManager.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-entity-mapper/src/main/java/com/netflix/astyanax/entitystore/DefaultEntityManager.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/utils/TestUtils.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/utils/ReadTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/utils/AstyanaxContextFactory.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/utils/ClusterConfiguration.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/entitymapper/EntityMapperTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/recipes/AllRowsReaderTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/recipes/ColumnPrefixDistributedLockTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/recipes/ChunkedObjectStoreTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/recipes/ColumnPrefixUniquenessConstraintTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/CFStandardTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/CompositeKeyTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/RowSliceRowRangeQueryTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/TimeUUIDTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/SingleColumnMutationTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/LongColumnPaginationTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/PreparedStatementTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/ColumnTimestampAndTTLTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/ColumnCountQueryTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/CounterColumnTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/AllRowsQueryTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/SingleRowColumnPaginationTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/MockCompositeTypeTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/SerializerPackageTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/KeyspaceTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/SingleRowQueryTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/RingDescribeTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/CompositeColumnTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/RowUniquenessConstraintTest.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/RowCopierTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/DirectCqlTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/StaticColumnFamilyTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/ClickStreamTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/SingleRowColumnRangeQueryTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-test/src/main/java/com/netflix/astyanax/cql/test/SchemaTests.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-recipes/src/main/java/com/netflix/astyanax/recipes/storage/ObjectReader.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-recipes/src/main/java/com/netflix/astyanax/recipes/storage/ObjectReader.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-recipes/src/main/java/com/netflix/astyanax/recipes/storage/ObjectReader.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-recipes/src/main/java/com/netflix/astyanax/recipes/storage/ObjectReader.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-recipes/src/main/java/com/netflix/astyanax/recipes/ReverseIndexQuery.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-recipes/src/main/java/com/netflix/astyanax/recipes/ReverseIndexQuery.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_2b15fd9_3de01e3/rev_2b15fd9-3de01e3/astyanax-recipes/src/main/java/com/netflix/astyanax/recipes/ReverseIndexQuery.java;null
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_a20aab8_5afcbce/rev_a20aab8-5afcbce/src/main/java/com/netflix/astyanax/recipes/locks/ColumnPrefixDistributedRowLock.java;<<<<<<< MINE
||||||| BASE
/*******************************************************************************
 * Copyright 2011 Netflix
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package com.netflix.astyanax.recipes.locks;

import java.nio.ByteBuffer;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Preconditions;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.netflix.astyanax.ColumnListMutation;
import com.netflix.astyanax.Keyspace;
import com.netflix.astyanax.MutationBatch;
import com.netflix.astyanax.model.Column;
import com.netflix.astyanax.model.ColumnFamily;
import com.netflix.astyanax.model.ColumnList;
import com.netflix.astyanax.model.ColumnMap;
import com.netflix.astyanax.model.ConsistencyLevel;
import com.netflix.astyanax.model.OrderedColumnMap;
import com.netflix.astyanax.retry.RetryPolicy;
import com.netflix.astyanax.retry.RunOnce;
import com.netflix.astyanax.serializers.ByteBufferSerializer;
import com.netflix.astyanax.serializers.LongSerializer;
import com.netflix.astyanax.util.RangeBuilder;
import com.netflix.astyanax.util.TimeUUIDUtils;

/**
 * Takes a distributed row lock for a single row.  The row lock is accomplished using
 * a sequence of read/write events to Cassandra without the need for something like
 * zookeeper.  
 * 
 * Algorithm 
 * 1. Write a column with name <prefix>_<uuid>. Value is an expiration time. 
 * 2. Read back all columns with <prefix> 
 *      case 1) count==1 Got the lock 
 *      case 2) count> 1 No lock
 * 3. Do something in your code assuming the row is locked
 * 4. Release the lock by deleting the lock columns
 * 
 * Usage considerations
 * 1. Set an expiration time (expireLockAfter) that is long enough for your processing to complete
 * 2. Use this when the probability for contension is very low
 * 3. Optimize by reading all columns (withIncludeAllColumn(true)) and merge the mutation
 *      into the release.  This will save 2 calls to cassandra.
 * 4. If the client fails after Step 1.  A subsequent attempt to lock will automatically 
 *      release these stale locks.  You can turn this auto cleanup off by calling
 *      failOnStaleLock(false), handling a StaleLockException and doing manual cleanup by
 *      calling releaseExpiredLocks()
 * 5. An optional TTL can be set on the lock columns which will ensure abandoned/stale locks
 *      will be cleaned up by compactions at some point.
 * 6. You can customize the 'prefix' used for the lock columns.  This will help with storing
 *      the lock columns with data in the same row.  
 * 7. You can customize the unique part of the lock column to include meaningful data such
 *      as the UUID row key from another column family.  This can have the same effect as 
 *      assigning a foreign key to the lock column and is useful for uniqueness constraint.
 * 8. This recipe is not a transaction.  
 * 
 * Take a lock,
 * <code>
 *      ColumnPrefixDistributedRowLock<String> lock = new ColumnPrefixDistributedRowLock<String>(keyspace, columnFamily, "KeyBeingLocked");
 *      try {
 *          lock.acquire();
 *      }
 *      finally {
 *          lock.release();
 *      }
 * </code>
 * 
 * Read, Modify, Write.  The read, modify, write piggybacks on top of the lock calls.
 * 
 * <code>
 *      ColumnPrefixDistributedRowLock<String> lock = new ColumnPrefixDistributedRowLock<String>(keyspace, columnFamily, "KeyBeingLocked");
 *      MutationBatch m = keyspace.prepareMutationBatch();
 *      try {
 *          ColumnMap<String> columns = lock.acquireLockAndReadRow();
 *          
 *          m.withRow("KeyBeingLocked")
 *              .putColumn("SomeColumnBeingUpdated", );
 *              
 *          lock.releaseWithMutation(m);
 *      }
 *      catch (Exception e) {
 *          lock.release();
 *      }
 * </code>
 * 
 * @author elandau
 * 
 * @param <K>
 */
public class ColumnPrefixDistributedRowLock<K> implements DistributedRowLock {
    public static final int      LOCK_TIMEOUT                    = 60;
    public static final TimeUnit DEFAULT_OPERATION_TIMEOUT_UNITS = TimeUnit.MINUTES;
    public static final String   DEFAULT_LOCK_PREFIX             = "_LOCK_";

    private final ColumnFamily<K, String> columnFamily; // The column family for data and lock
    private final Keyspace   keyspace;                  // The keyspace
    private final K          key;                       // Key being locked

    private long             timeout          = LOCK_TIMEOUT;                   // Timeout after which the lock expires.  Units defined by timeoutUnits.
    private TimeUnit         timeoutUnits     = DEFAULT_OPERATION_TIMEOUT_UNITS;
    private String           prefix           = DEFAULT_LOCK_PREFIX;            // Prefix to identify the lock columns
    private ConsistencyLevel consistencyLevel = ConsistencyLevel.CL_LOCAL_QUORUM;
    private boolean          failOnStaleLock  = false;           
    private String           lockColumn       = null;
    private String           lockId           = null;
    private Set<String>      locksToDelete    = Sets.newHashSet();
    private ColumnMap<String> columns         = null;
    private Integer          ttl              = null;                           // Units in seconds
    private boolean          readDataColumns  = false;
    private RetryPolicy      backoffPolicy    = RunOnce.get();
    private long             acquireTime      = 0;
    private int              retryCount       = 0;

    public ColumnPrefixDistributedRowLock(Keyspace keyspace, ColumnFamily<K, String> columnFamily, K key) {
        this.keyspace     = keyspace;
        this.columnFamily = columnFamily;
        this.key          = key;
        this.lockId       = TimeUUIDUtils.getUniqueTimeUUIDinMicros().toString();
    }

    /**
     * Modify the consistency level being used. Consistency should always be a
     * variant of quorum. The default is CL_QUORUM, which is OK for single
     * region. For multi region the consistency level should be CL_LOCAL_QUORUM.
     * CL_EACH_QUORUM can be used but will Incur substantial latency.
     * 
     * @param consistencyLevel
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withConsistencyLevel(ConsistencyLevel consistencyLevel) {
        this.consistencyLevel = consistencyLevel;
        return this;
    }

    /**
     * Specify the prefix that uniquely distinguishes the lock columns from data
     * column
     * 
     * @param prefix
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withColumnPrefix(String prefix) {
        this.prefix = prefix;
        return this;
    }

    /**
     * If true the first read will also fetch all the columns in the row as 
     * opposed to just the lock columns.
     * @param flag
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withDataColumns(boolean flag) {
        this.readDataColumns = flag;
        return this;
    }
    
    /**
     * Override the autogenerated lock column.
     * 
     * @param lockId
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withLockId(String lockId) {
        this.lockId = lockId;
        return this;
    }

    /**
     * When set to true the operation will fail if a stale lock is detected
     * 
     * @param failOnStaleLock
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> failOnStaleLock(boolean failOnStaleLock) {
        this.failOnStaleLock = failOnStaleLock;
        return this;
    }

    /**
     * Time for failed locks. Under normal circumstances the lock column will be
     * deleted. If not then this lock column will remain and the row will remain
     * locked. The lock will expire after this timeout.
     * 
     * @param timeout
     * @param unit
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> expireLockAfter(long timeout, TimeUnit unit) {
        this.timeout      = timeout;
        this.timeoutUnits = unit;
        return this;
    }

    /**
     * This is the TTL on the lock column being written, as opposed to expireLockAfter which 
     * is written as the lock column value.  Whereas the expireLockAfter can be used to 
     * identify a stale or abandoned lock the TTL will result in the stale or abandoned lock
     * being eventually deleted by cassandra.  Set the TTL to a number that is much greater
     * tan the expireLockAfter time.
     * @param ttl
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withTtl(Integer ttl) {
        this.ttl = ttl;
        return this;
    }
    
    public ColumnPrefixDistributedRowLock<K> withTtl(Integer ttl, TimeUnit units) {
        this.ttl = (int) TimeUnit.SECONDS.convert(ttl,  units);
        return this;
    }
    
    public ColumnPrefixDistributedRowLock<K> withBackoff(RetryPolicy policy) {
        this.backoffPolicy  = policy;
        return this;
    }

    /**
     * Try to take the lock.  The caller must call .release() to properly clean up
     * the lock columns from cassandra
     * 
     * @return
     * @throws Exception
     */
    @Override
    public void acquire() throws Exception {
        
        Preconditions.checkArgument(ttl == null || TimeUnit.SECONDS.convert(timeout, timeoutUnits) < ttl, "Timeout " + timeout + " must be less than TTL " + ttl);
        
        RetryPolicy retry = backoffPolicy.duplicate();
        retryCount = 0;
        while (true) {
            try {
                long curTimeMicros = getCurrentTimeMicros();
                
                MutationBatch m = keyspace.prepareMutationBatch().setConsistencyLevel(consistencyLevel);
                fillLockMutation(m, curTimeMicros, ttl);
                m.execute();
                
                verifyLock(curTimeMicros);
                acquireTime = System.currentTimeMillis();
                return;
            }
            catch (BusyLockException e) {
                release();
                if(!retry.allowRetry())
                    throw e;
                retryCount++;
            }
        }
    }

    /**
     * Take the lock and return the row data columns.  Use this, instead of acquire, when you 
     * want to implement a read-modify-write scenario and want to reduce the number of calls
     * to Cassandra.
     * 
     * @return
     * @throws Exception
     */
    public ColumnMap<String> acquireLockAndReadRow() throws Exception {
        withDataColumns(true);
        acquire();
        return getDataColumns();
    }
    
    /**
     * Verify that the lock was acquired.  This shouldn't be called unless it's part of a recipe
     * built on top of ColumnPrefixDistributedRowLock.  
     * 
     * @param curTimeInMicros
     * @throws BusyLockException
     */
    public void verifyLock(long curTimeInMicros) throws Exception, BusyLockException, StaleLockException {
        if (lockColumn == null) 
            throw new IllegalStateException("verifyLock() called without attempting to take the lock");
        
        // Read back all columns. There should be only 1 if we got the lock
        Map<String, Long> lockResult = readLockColumns(readDataColumns);

        // Cleanup and check that we really got the lock
        for (Entry<String, Long> entry : lockResult.entrySet()) {
            // This is a stale lock that was never cleaned up
            if (entry.getValue() != 0 && curTimeInMicros > entry.getValue()) {
                if (failOnStaleLock) {
                    throw new StaleLockException("Stale lock on row '" + key + "'.  Manual cleanup requried.");
                }
                locksToDelete.add(entry.getKey());
            }
            // Lock already taken, and not by us
            else if (!entry.getKey().equals(lockColumn)) {
                throw new BusyLockException("Lock already acquired for row '" + key + "' with lock column " + entry.getKey());
            }
        }
    }

    /**
     * Release the lock by releasing this and any other stale lock columns
     */
    @Override
    public void release() throws Exception {
        if (!locksToDelete.isEmpty() || lockColumn != null) {
            MutationBatch m = keyspace.prepareMutationBatch().setConsistencyLevel(consistencyLevel);
            fillReleaseMutation(m, false);
            m.execute();
        }
    }

    /**
     * Release using the provided mutation.  Use this when you want to commit actual data
     * when releasing the lock
     * @param m
     * @throws Exception
     */
    public void releaseWithMutation(MutationBatch m) throws Exception {
        releaseWithMutation(m, false);
    }
    
    public boolean releaseWithMutation(MutationBatch m, boolean force) throws Exception {
        long elapsed = System.currentTimeMillis() - acquireTime;
        boolean isStale = false;
        if (timeout > 0 && elapsed > TimeUnit.MILLISECONDS.convert(timeout, this.timeoutUnits)) {
            isStale = true;
            if (!force) {
                throw new StaleLockException("Lock for '" + getKey() + "' became stale");
            }
        }
        
        m.setConsistencyLevel(consistencyLevel);
        fillReleaseMutation(m, false);
        m.execute();
        
        return isStale;
    }
    
    /**
     * Return a mapping of existing lock columns and their expiration times
     * 
     * @return
     * @throws Exception
     */
    public Map<String, Long> readLockColumns() throws Exception {
        return readLockColumns(false);
    }
    
    /**
     * Read all the lock columns.  Will also ready data columns if withDataColumns(true) was called
     * 
     * @param readDataColumns
     * @return
     * @throws Exception
     */
    private Map<String, Long> readLockColumns(boolean readDataColumns) throws Exception {
        Map<String, Long> result = Maps.newLinkedHashMap();
        // Read all the columns
        if (readDataColumns) {
            columns = new OrderedColumnMap<String>();
            ColumnList<String> lockResult = keyspace
                .prepareQuery(columnFamily)
                    .setConsistencyLevel(consistencyLevel)
                    .getKey(key)
                .execute()
                    .getResult();
    
            for (Column<String> c : lockResult) {
                if (c.getName().startsWith(prefix))
                    result.put(c.getName(), readTimeoutValue(c));
                else 
                    columns.add(c);
            }
        }
        // Read only the lock columns
        else {
            ColumnList<String> lockResult = keyspace
                .prepareQuery(columnFamily)
                    .setConsistencyLevel(consistencyLevel)
                    .getKey(key)
                    .withColumnRange(new RangeBuilder().setStart(prefix + "\u0000").setEnd(prefix + "\uFFFF").build())
                .execute()
                    .getResult();

            for (Column<String> c : lockResult) {
                result.put(c.getName(), readTimeoutValue(c));
            }

        }
        return result;    
    }
    
    /**
     * Release all locks. Use this carefully as it could release a lock for a
     * running operation.
     * 
     * @return
     * @throws Exception
     */
    public Map<String, Long> releaseAllLocks() throws Exception {
        return releaseLocks(true);
    }

    /**
     * Release all expired locks for this key.
     * 
     * @return
     * @throws Exception
     */
    public Map<String, Long> releaseExpiredLocks() throws Exception {
        return releaseLocks(false);
    }

    /**
     * Delete locks columns. Set force=true to remove locks that haven't 
     * expired yet.
     * 
     * This operation first issues a read to cassandra and then deletes columns
     * in the response.
     * 
     * @param force - Force delete of non expired locks as well
     * @return
     * @throws Exception
     */
    public Map<String, Long> releaseLocks(boolean force) throws Exception {
        Map<String, Long> locksToDelete = readLockColumns();

        MutationBatch m = keyspace.prepareMutationBatch().setConsistencyLevel(consistencyLevel);
        ColumnListMutation<String> row = m.withRow(columnFamily, key);
        long now = getCurrentTimeMicros();
        for (Entry<String, Long> c : locksToDelete.entrySet()) {
            if (force || (c.getValue() > 0 && c.getValue() < now)) {
                row.deleteColumn(c.getKey());
            }
        }
        m.execute();

        return locksToDelete;
    }

    /**
     * Get the current system time
     * 
     * @return
     */
    private static long getCurrentTimeMicros() {
        return TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);
    }

    /**
     * Fill a mutation with the lock column. This may be used when the mutation
     * is executed externally but should be used with extreme caution to ensure
     * the lock is properly released
     * 
     * @param m
     * @param time
     * @param ttl
     */
    public String fillLockMutation(MutationBatch m, Long time, Integer ttl) {
        if (lockColumn != null) {
            if (!lockColumn.equals(prefix+lockId))
                throw new IllegalStateException("Can't change prefix or lockId after acquiring the lock");
        }
        else {
            lockColumn = prefix + lockId;
        }
        
        Long timeoutValue 
              = (time == null)
              ? new Long(0)
              : time + TimeUnit.MICROSECONDS.convert(timeout, timeoutUnits);
              
        m.withRow(columnFamily, key).putColumn(lockColumn, generateTimeoutValue(timeoutValue), ttl);
        return lockColumn;
    }
    
    /**
     * Generate the expire time value to put in the column value.
     * @param timeout
     * @return
     */
    private ByteBuffer generateTimeoutValue(long timeout) {
        if (columnFamily.getDefaultValueSerializer() == ByteBufferSerializer.get() ||
            columnFamily.getDefaultValueSerializer() == LongSerializer.get()) {
            return LongSerializer.get().toByteBuffer(timeout);
        }
        else {
            return columnFamily.getDefaultValueSerializer().fromString(Long.toString(timeout));
        }
    }
    
    /**
     * Read the expiration time from the column value
     * @param column
     * @return
     */
    public long readTimeoutValue(Column<?> column) {
        if (columnFamily.getDefaultValueSerializer() == ByteBufferSerializer.get() ||
            columnFamily.getDefaultValueSerializer() == LongSerializer.get()) {
            return column.getLongValue();
        }
        else {
            return Long.parseLong(column.getStringValue());
        }
    }

    /**
     * Fill a mutation that will release the locks. This may be used from a
     * separate recipe to release multiple locks.
     * 
     * @param m
     */
    public void fillReleaseMutation(MutationBatch m, boolean excludeCurrentLock) {
        // Add the deletes to the end of the mutation
        ColumnListMutation<String> row = m.withRow(columnFamily, key);
        for (String c : locksToDelete) {
            row.deleteColumn(c);
        }
        if (!excludeCurrentLock && lockColumn != null) 
            row.deleteColumn(lockColumn);
        locksToDelete.clear();
        lockColumn = null;
    }


    public ColumnMap<String> getDataColumns() {
        return columns;
    }
    
    public K getKey() {
        return key;
    }
    
    public Keyspace getKeyspace() {
        return keyspace;
    }

    public ConsistencyLevel getConsistencyLevel() {
        return consistencyLevel;
    }

    public String getLockColumn() {
        return lockColumn;
    }
    
    public String getLockId() {
        return lockId;
    }
    
    public String getPrefix() {
        return prefix;
    }
    
    public int getRetryCount() {
        return retryCount;
    }

}=======
/*******************************************************************************
 * Copyright 2011 Netflix
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package com.netflix.astyanax.recipes.locks;

import java.nio.ByteBuffer;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Preconditions;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.netflix.astyanax.ColumnListMutation;
import com.netflix.astyanax.Keyspace;
import com.netflix.astyanax.MutationBatch;
import com.netflix.astyanax.model.Column;
import com.netflix.astyanax.model.ColumnFamily;
import com.netflix.astyanax.model.ColumnList;
import com.netflix.astyanax.model.ColumnMap;
import com.netflix.astyanax.model.ConsistencyLevel;
import com.netflix.astyanax.model.OrderedColumnMap;
import com.netflix.astyanax.retry.RetryPolicy;
import com.netflix.astyanax.retry.RunOnce;
import com.netflix.astyanax.serializers.ByteBufferSerializer;
import com.netflix.astyanax.serializers.LongSerializer;
import com.netflix.astyanax.util.RangeBuilder;
import com.netflix.astyanax.util.TimeUUIDUtils;

/**
 * Takes a distributed row lock for a single row.  The row lock is accomplished using
 * a sequence of read/write events to Cassandra without the need for something like
 * zookeeper.  
 * 
 * Algorithm 
 * 1. Write a column with name <prefix>_<uuid>. Value is an expiration time. 
 * 2. Read back all columns with <prefix> 
 *      case 1) count==1 Got the lock 
 *      case 2) count> 1 No lock
 * 3. Do something in your code assuming the row is locked
 * 4. Release the lock by deleting the lock columns
 * 
 * Usage considerations
 * 1. Set an expiration time (expireLockAfter) that is long enough for your processing to complete
 * 2. Use this when the probability for contension is very low
 * 3. Optimize by reading all columns (withIncludeAllColumn(true)) and merge the mutation
 *      into the release.  This will save 2 calls to cassandra.
 * 4. If the client fails after Step 1.  A subsequent attempt to lock will automatically 
 *      release these stale locks.  You can turn this auto cleanup off by calling
 *      failOnStaleLock(false), handling a StaleLockException and doing manual cleanup by
 *      calling releaseExpiredLocks()
 * 5. An optional TTL can be set on the lock columns which will ensure abandoned/stale locks
 *      will be cleaned up by compactions at some point.
 * 6. You can customize the 'prefix' used for the lock columns.  This will help with storing
 *      the lock columns with data in the same row.  
 * 7. You can customize the unique part of the lock column to include meaningful data such
 *      as the UUID row key from another column family.  This can have the same effect as 
 *      assigning a foreign key to the lock column and is useful for uniqueness constraint.
 * 8. This recipe is not a transaction.  
 * 
 * Take a lock,
 * <code>
 *      ColumnPrefixDistributedRowLock<String> lock = new ColumnPrefixDistributedRowLock<String>(keyspace, columnFamily, "KeyBeingLocked");
 *      try {
 *          lock.acquire();
 *      }
 *      finally {
 *          lock.release();
 *      }
 * </code>
 * 
 * Read, Modify, Write.  The read, modify, write piggybacks on top of the lock calls.
 * 
 * <code>
 *      ColumnPrefixDistributedRowLock<String> lock = new ColumnPrefixDistributedRowLock<String>(keyspace, columnFamily, "KeyBeingLocked");
 *      MutationBatch m = keyspace.prepareMutationBatch();
 *      try {
 *          ColumnMap<String> columns = lock.acquireLockAndReadRow();
 *          
 *          m.withRow("KeyBeingLocked")
 *              .putColumn("SomeColumnBeingUpdated", );
 *              
 *          lock.releaseWithMutation(m);
 *      }
 *      catch (Exception e) {
 *          lock.release();
 *      }
 * </code>
 * 
 * @author elandau
 * 
 * @param <K>
 */
public class ColumnPrefixDistributedRowLock<K> implements DistributedRowLock {
    public static final int      LOCK_TIMEOUT                    = 60;
    public static final TimeUnit DEFAULT_OPERATION_TIMEOUT_UNITS = TimeUnit.MINUTES;
    public static final String   DEFAULT_LOCK_PREFIX             = "_LOCK_";

    private final ColumnFamily<K, String> columnFamily; // The column family for data and lock
    private final Keyspace   keyspace;                  // The keyspace
    private final K          key;                       // Key being locked

    private long             timeout          = LOCK_TIMEOUT;                   // Timeout after which the lock expires.  Units defined by timeoutUnits.
    private TimeUnit         timeoutUnits     = DEFAULT_OPERATION_TIMEOUT_UNITS;
    private String           prefix           = DEFAULT_LOCK_PREFIX;            // Prefix to identify the lock columns
    private ConsistencyLevel consistencyLevel = ConsistencyLevel.CL_LOCAL_QUORUM;
    private boolean          failOnStaleLock  = false;           
    private String           lockColumn       = null;
    private String           lockId           = null;
    private Set<String>      locksToDelete    = Sets.newHashSet();
    private ColumnMap<String> columns         = null;
    private Integer          ttl              = null;                           // Units in seconds
    private boolean          readDataColumns  = false;
    private RetryPolicy      backoffPolicy    = RunOnce.get();
    private long             acquireTime      = 0;
    private int              retryCount       = 0;

    public ColumnPrefixDistributedRowLock(Keyspace keyspace, ColumnFamily<K, String> columnFamily, K key) {
        this.keyspace     = keyspace;
        this.columnFamily = columnFamily;
        this.key          = key;
        this.lockId       = TimeUUIDUtils.getUniqueTimeUUIDinMicros().toString();
    }

    /**
     * Modify the consistency level being used. Consistency should always be a
     * variant of quorum. The default is CL_QUORUM, which is OK for single
     * region. For multi region the consistency level should be CL_LOCAL_QUORUM.
     * CL_EACH_QUORUM can be used but will Incur substantial latency.
     * 
     * @param consistencyLevel
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withConsistencyLevel(ConsistencyLevel consistencyLevel) {
        this.consistencyLevel = consistencyLevel;
        return this;
    }

    /**
     * Specify the prefix that uniquely distinguishes the lock columns from data
     * column
     * 
     * @param prefix
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withColumnPrefix(String prefix) {
        this.prefix = prefix;
        return this;
    }

    /**
     * If true the first read will also fetch all the columns in the row as 
     * opposed to just the lock columns.
     * @param flag
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withDataColumns(boolean flag) {
        this.readDataColumns = flag;
        return this;
    }
    
    /**
     * Override the autogenerated lock column.
     * 
     * @param lockId
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withLockId(String lockId) {
        this.lockId = lockId;
        return this;
    }

    /**
     * When set to true the operation will fail if a stale lock is detected
     * 
     * @param failOnStaleLock
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> failOnStaleLock(boolean failOnStaleLock) {
        this.failOnStaleLock = failOnStaleLock;
        return this;
    }

    /**
     * Time for failed locks. Under normal circumstances the lock column will be
     * deleted. If not then this lock column will remain and the row will remain
     * locked. The lock will expire after this timeout.
     * 
     * @param timeout
     * @param unit
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> expireLockAfter(long timeout, TimeUnit unit) {
        this.timeout      = timeout;
        this.timeoutUnits = unit;
        return this;
    }

    /**
     * This is the TTL on the lock column being written, as opposed to expireLockAfter which 
     * is written as the lock column value.  Whereas the expireLockAfter can be used to 
     * identify a stale or abandoned lock the TTL will result in the stale or abandoned lock
     * being eventually deleted by cassandra.  Set the TTL to a number that is much greater
     * tan the expireLockAfter time.
     * @param ttl
     * @return
     */
    public ColumnPrefixDistributedRowLock<K> withTtl(Integer ttl) {
        this.ttl = ttl;
        return this;
    }
    
    public ColumnPrefixDistributedRowLock<K> withTtl(Integer ttl, TimeUnit units) {
        this.ttl = (int) TimeUnit.SECONDS.convert(ttl,  units);
        return this;
    }
    
    public ColumnPrefixDistributedRowLock<K> withBackoff(RetryPolicy policy) {
        this.backoffPolicy  = policy;
        return this;
    }

    /**
     * Try to take the lock.  The caller must call .release() to properly clean up
     * the lock columns from cassandra
     * 
     * @return
     * @throws Exception
     */
    @Override
    public void acquire() throws Exception {
        
        Preconditions.checkArgument(ttl == null || TimeUnit.SECONDS.convert(timeout, timeoutUnits) < ttl, "Timeout " + timeout + " must be less than TTL " + ttl);
        
        RetryPolicy retry = backoffPolicy.duplicate();
        retryCount = 0;
        while (true) {
            try {
                long curTimeMicros = getCurrentTimeMicros();
                
                MutationBatch m = keyspace.prepareMutationBatch().setConsistencyLevel(consistencyLevel);
                fillLockMutation(m, curTimeMicros, ttl);
                m.execute();
                
                verifyLock(curTimeMicros);
                acquireTime = System.nanoTime();
                return;
            }
            catch (BusyLockException e) {
                release();
                if(!retry.allowRetry())
                    throw e;
                retryCount++;
            }
        }
    }

    /**
     * Take the lock and return the row data columns.  Use this, instead of acquire, when you 
     * want to implement a read-modify-write scenario and want to reduce the number of calls
     * to Cassandra.
     * 
     * @return
     * @throws Exception
     */
    public ColumnMap<String> acquireLockAndReadRow() throws Exception {
        withDataColumns(true);
        acquire();
        return getDataColumns();
    }
    
    /**
     * Verify that the lock was acquired.  This shouldn't be called unless it's part of a recipe
     * built on top of ColumnPrefixDistributedRowLock.  
     * 
     * @param curTimeInMicros
     * @throws BusyLockException
     */
    public void verifyLock(long curTimeInMicros) throws Exception, BusyLockException, StaleLockException {
        if (lockColumn == null) 
            throw new IllegalStateException("verifyLock() called without attempting to take the lock");
        
        // Read back all columns. There should be only 1 if we got the lock
        Map<String, Long> lockResult = readLockColumns(readDataColumns);

        // Cleanup and check that we really got the lock
        for (Entry<String, Long> entry : lockResult.entrySet()) {
            // This is a stale lock that was never cleaned up
            if (entry.getValue() != 0 && curTimeInMicros > entry.getValue()) {
                if (failOnStaleLock) {
                    throw new StaleLockException("Stale lock on row '" + key + "'.  Manual cleanup requried.");
                }
                locksToDelete.add(entry.getKey());
            }
            // Lock already taken, and not by us
            else if (!entry.getKey().equals(lockColumn)) {
                throw new BusyLockException("Lock already acquired for row '" + key + "' with lock column " + entry.getKey());
            }
        }
    }

    /**
     * Release the lock by releasing this and any other stale lock columns
     */
    @Override
    public void release() throws Exception {
        if (!locksToDelete.isEmpty() || lockColumn != null) {
            MutationBatch m = keyspace.prepareMutationBatch().setConsistencyLevel(consistencyLevel);
            fillReleaseMutation(m, false);
            m.execute();
        }
    }

    /**
     * Release using the provided mutation.  Use this when you want to commit actual data
     * when releasing the lock
     * @param m
     * @throws Exception
     */
    public void releaseWithMutation(MutationBatch m) throws Exception {
        releaseWithMutation(m, false);
    }
    
    public boolean releaseWithMutation(MutationBatch m, boolean force) throws Exception {
        long elapsed = TimeUnit.MILLISECONDS.convert(System.nanoTime() - acquireTime, TimeUnit.NANOSECONDS);
        boolean isStale = false;
        if (timeout > 0 && elapsed > TimeUnit.MILLISECONDS.convert(timeout, this.timeoutUnits)) {
            isStale = true;
            if (!force) {
                throw new StaleLockException("Lock for '" + getKey() + "' became stale");
            }
        }
        
        m.setConsistencyLevel(consistencyLevel);
        fillReleaseMutation(m, false);
        m.execute();
        
        return isStale;
    }
    
    /**
     * Return a mapping of existing lock columns and their expiration times
     * 
     * @return
     * @throws Exception
     */
    public Map<String, Long> readLockColumns() throws Exception {
        return readLockColumns(false);
    }
    
    /**
     * Read all the lock columns.  Will also ready data columns if withDataColumns(true) was called
     * 
     * @param readDataColumns
     * @return
     * @throws Exception
     */
    private Map<String, Long> readLockColumns(boolean readDataColumns) throws Exception {
        Map<String, Long> result = Maps.newLinkedHashMap();
        // Read all the columns
        if (readDataColumns) {
            columns = new OrderedColumnMap<String>();
            ColumnList<String> lockResult = keyspace
                .prepareQuery(columnFamily)
                    .setConsistencyLevel(consistencyLevel)
                    .getKey(key)
                .execute()
                    .getResult();
    
            for (Column<String> c : lockResult) {
                if (c.getName().startsWith(prefix))
                    result.put(c.getName(), readTimeoutValue(c));
                else 
                    columns.add(c);
            }
        }
        // Read only the lock columns
        else {
            ColumnList<String> lockResult = keyspace
                .prepareQuery(columnFamily)
                    .setConsistencyLevel(consistencyLevel)
                    .getKey(key)
                    .withColumnRange(new RangeBuilder().setStart(prefix + "\u0000").setEnd(prefix + "\uFFFF").build())
                .execute()
                    .getResult();

            for (Column<String> c : lockResult) {
                result.put(c.getName(), readTimeoutValue(c));
            }

        }
        return result;    
    }
    
    /**
     * Release all locks. Use this carefully as it could release a lock for a
     * running operation.
     * 
     * @return
     * @throws Exception
     */
    public Map<String, Long> releaseAllLocks() throws Exception {
        return releaseLocks(true);
    }

    /**
     * Release all expired locks for this key.
     * 
     * @return
     * @throws Exception
     */
    public Map<String, Long> releaseExpiredLocks() throws Exception {
        return releaseLocks(false);
    }

    /**
     * Delete locks columns. Set force=true to remove locks that haven't 
     * expired yet.
     * 
     * This operation first issues a read to cassandra and then deletes columns
     * in the response.
     * 
     * @param force - Force delete of non expired locks as well
     * @return
     * @throws Exception
     */
    public Map<String, Long> releaseLocks(boolean force) throws Exception {
        Map<String, Long> locksToDelete = readLockColumns();

        MutationBatch m = keyspace.prepareMutationBatch().setConsistencyLevel(consistencyLevel);
        ColumnListMutation<String> row = m.withRow(columnFamily, key);
        long now = getCurrentTimeMicros();
        for (Entry<String, Long> c : locksToDelete.entrySet()) {
            if (force || (c.getValue() > 0 && c.getValue() < now)) {
                row.deleteColumn(c.getKey());
            }
        }
        m.execute();

        return locksToDelete;
    }

    /**
     * Get the current system time
     * 
     * @return
     */
    private static long getCurrentTimeMicros() {
        return TimeUnit.MICROSECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);
    }

    /**
     * Fill a mutation with the lock column. This may be used when the mutation
     * is executed externally but should be used with extreme caution to ensure
     * the lock is properly released
     * 
     * @param m
     * @param time
     * @param ttl
     */
    public String fillLockMutation(MutationBatch m, Long time, Integer ttl) {
        if (lockColumn != null) {
            if (!lockColumn.equals(prefix+lockId))
                throw new IllegalStateException("Can't change prefix or lockId after acquiring the lock");
        }
        else {
            lockColumn = prefix + lockId;
        }
        
        Long timeoutValue 
              = (time == null)
              ? new Long(0)
              : time + TimeUnit.MICROSECONDS.convert(timeout, timeoutUnits);
              
        m.withRow(columnFamily, key).putColumn(lockColumn, generateTimeoutValue(timeoutValue), ttl);
        return lockColumn;
    }
    
    /**
     * Generate the expire time value to put in the column value.
     * @param timeout
     * @return
     */
    private ByteBuffer generateTimeoutValue(long timeout) {
        if (columnFamily.getDefaultValueSerializer() == ByteBufferSerializer.get() ||
            columnFamily.getDefaultValueSerializer() == LongSerializer.get()) {
            return LongSerializer.get().toByteBuffer(timeout);
        }
        else {
            return columnFamily.getDefaultValueSerializer().fromString(Long.toString(timeout));
        }
    }
    
    /**
     * Read the expiration time from the column value
     * @param column
     * @return
     */
    public long readTimeoutValue(Column<?> column) {
        if (columnFamily.getDefaultValueSerializer() == ByteBufferSerializer.get() ||
            columnFamily.getDefaultValueSerializer() == LongSerializer.get()) {
            return column.getLongValue();
        }
        else {
            return Long.parseLong(column.getStringValue());
        }
    }

    /**
     * Fill a mutation that will release the locks. This may be used from a
     * separate recipe to release multiple locks.
     * 
     * @param m
     */
    public void fillReleaseMutation(MutationBatch m, boolean excludeCurrentLock) {
        // Add the deletes to the end of the mutation
        ColumnListMutation<String> row = m.withRow(columnFamily, key);
        for (String c : locksToDelete) {
            row.deleteColumn(c);
        }
        if (!excludeCurrentLock && lockColumn != null) 
            row.deleteColumn(lockColumn);
        locksToDelete.clear();
        lockColumn = null;
    }


    public ColumnMap<String> getDataColumns() {
        return columns;
    }
    
    public K getKey() {
        return key;
    }
    
    public Keyspace getKeyspace() {
        return keyspace;
    }

    public ConsistencyLevel getConsistencyLevel() {
        return consistencyLevel;
    }

    public String getLockColumn() {
        return lockColumn;
    }
    
    public String getLockId() {
        return lockId;
    }
    
    public String getPrefix() {
        return prefix;
    }
    
    public int getRetryCount() {
        return retryCount;
    }

}>>>>>>> YOURS
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_0ea859d_8e7e118/rev_0ea859d-8e7e118/astyanax-entity-mapper/src/main/java/com/netflix/astyanax/entitystore/DefaultEntityManager.java;<<<<<<< MINE
import com.netflix.astyanax.partitioner.Murmur3Partitioner;
||||||| BASE
=======
import com.netflix.astyanax.partitioner.BigInteger127Partitioner;
import com.netflix.astyanax.partitioner.Partitioner;
>>>>>>> YOURS
/home/ramdisk/experiment3/projects/astyanax/revisions/rev_183d714_75acddc/rev_183d714-75acddc/astyanax-cassandra/src/test/java/com/netflix/astyanax/model/DynamicCompositeTest.java;<<<<<<< MINE
||||||| BASE
package com.netflix.astyanax.model;

import org.junit.Test;

import com.netflix.astyanax.serializers.StringSerializer;

public class DynamicCompositeTest {
    @Test
    public void testComposite() {
        DynamicComposite dc = new DynamicComposite();
        for (char ch = 'A'; ch < 'Z'; ch++) {
            dc.addComponent(Character.toString(ch), StringSerializer.get());
        }

    }
}=======
package com.netflix.astyanax.model;


import java.nio.ByteBuffer;
import java.util.UUID;

import org.junit.Test;

import com.netflix.astyanax.serializers.AbstractSerializer;
import com.netflix.astyanax.serializers.AsciiSerializer;
import com.netflix.astyanax.serializers.BytesArraySerializer;
import com.netflix.astyanax.serializers.IntegerSerializer;
import com.netflix.astyanax.serializers.LongSerializer;
import com.netflix.astyanax.serializers.StringSerializer;
import com.netflix.astyanax.serializers.UUIDSerializer;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;


public class DynamicCompositeTest {


    @Test
    public void testComposite() {
        DynamicComposite dc = new DynamicComposite();
        for ( char ch = 'A'; ch < 'Z'; ch++ ) {
            dc.addComponent( Character.toString( ch ), StringSerializer.get() );
        }
    }


    @Test
    public void testReversedSerialization() {

        AsciiSerializer asciiSerializer = AsciiSerializer.get();
        BytesArraySerializer bytesArraySerializer = BytesArraySerializer.get();

        IntegerSerializer integerSerializer = IntegerSerializer.get();
        LongSerializer longSerializer = LongSerializer.get();

        StringSerializer stringSerializer = StringSerializer.get();

        UUIDSerializer uuidSerializer = UUIDSerializer.get();


        DynamicComposite dc = new DynamicComposite();

        final String string = "test";
        final byte[] bytes = new byte[] { 0x00 };
        final int intValue = 1;
        final long longValue = 1l;
        final UUID uuid = UUID.randomUUID();


        dc.addComponent( string, asciiSerializer, getReversed( asciiSerializer ) );

        dc.addComponent( bytes, bytesArraySerializer, getReversed( bytesArraySerializer ) );

        dc.addComponent( intValue, integerSerializer, getReversed( integerSerializer ) );

        dc.addComponent( longValue, longSerializer, getReversed( longSerializer ) );

        dc.addComponent( string, stringSerializer, getReversed( stringSerializer ) );

        dc.addComponent( uuid, uuidSerializer, getReversed( uuidSerializer ) );

        //serialize to bytes
        ByteBuffer buff = dc.serialize();

        //de-serialize
        DynamicComposite read = DynamicComposite.fromByteBuffer( buff );

        assertEquals(6, read.size());

        assertEquals(string, read.getComponent( 0 ).getValue( asciiSerializer ));

        assertArrayEquals( bytes, ( byte[] ) read.getComponent( 1 ).getValue( bytesArraySerializer ) );

        assertEquals(intValue, read.getComponent( 2 ).getValue( integerSerializer ));

        assertEquals(longValue, read.getComponent( 3 ).getValue( longSerializer ));

        assertEquals(string, read.getComponent( 4 ).getValue( stringSerializer ));

        assertEquals(uuid, read.getComponent( 5 ).getValue( uuidSerializer ));
    }


    private String getReversed( AbstractSerializer serializer ) {
        return serializer.getComparatorType().getTypeName() + "(reversed=true)";
    }
}>>>>>>> YOURS
